/**
 * #flair_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import Long from "long";
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
function createBaseClearFlairTemplatesRequest() {
    return { subreddit: "", flairType: "" };
}
export const ClearFlairTemplatesRequest = {
    $type: "devvit.plugin.redditapi.flair.ClearFlairTemplatesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairType !== "") {
            writer.uint32(18).string(message.flairType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClearFlairTemplatesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.flairType = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            flairType: isSet(object.flairType) ? globalThis.String(object.flairType) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.flairType !== "") {
            obj.flairType = message.flairType;
        }
        return obj;
    },
    create(base) {
        return ClearFlairTemplatesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClearFlairTemplatesRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairType = object.flairType ?? "";
        return message;
    },
};
messageTypeRegistry.set(ClearFlairTemplatesRequest.$type, ClearFlairTemplatesRequest);
function createBaseDeleteFlairRequest() {
    return { subreddit: "", name: "" };
}
export const DeleteFlairRequest = {
    $type: "devvit.plugin.redditapi.flair.DeleteFlairRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteFlairRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return DeleteFlairRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteFlairRequest();
        message.subreddit = object.subreddit ?? "";
        message.name = object.name ?? "";
        return message;
    },
};
messageTypeRegistry.set(DeleteFlairRequest.$type, DeleteFlairRequest);
function createBaseDeleteFlairTemplateRequest() {
    return { subreddit: "", flairTemplateId: "" };
}
export const DeleteFlairTemplateRequest = {
    $type: "devvit.plugin.redditapi.flair.DeleteFlairTemplateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairTemplateId !== "") {
            writer.uint32(18).string(message.flairTemplateId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteFlairTemplateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.flairTemplateId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            flairTemplateId: isSet(object.flairTemplateId) ? globalThis.String(object.flairTemplateId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.flairTemplateId !== "") {
            obj.flairTemplateId = message.flairTemplateId;
        }
        return obj;
    },
    create(base) {
        return DeleteFlairTemplateRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteFlairTemplateRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairTemplateId = object.flairTemplateId ?? "";
        return message;
    },
};
messageTypeRegistry.set(DeleteFlairTemplateRequest.$type, DeleteFlairTemplateRequest);
function createBaseFlairRequest() {
    return { subreddit: "", cssClass: undefined, link: undefined, name: undefined, text: undefined };
}
export const FlairRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.cssClass !== undefined) {
            StringValue.encode({ value: message.cssClass }, writer.uint32(18).fork()).ldelim();
        }
        if (message.link !== undefined) {
            StringValue.encode({ value: message.link }, writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
        }
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.cssClass = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.link = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            cssClass: isSet(object.cssClass) ? String(object.cssClass) : undefined,
            link: isSet(object.link) ? String(object.link) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            text: isSet(object.text) ? String(object.text) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.cssClass !== undefined) {
            obj.cssClass = message.cssClass;
        }
        if (message.link !== undefined) {
            obj.link = message.link;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.text !== undefined) {
            obj.text = message.text;
        }
        return obj;
    },
    create(base) {
        return FlairRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairRequest();
        message.subreddit = object.subreddit ?? "";
        message.cssClass = object.cssClass ?? undefined;
        message.link = object.link ?? undefined;
        message.name = object.name ?? undefined;
        message.text = object.text ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(FlairRequest.$type, FlairRequest);
function createBaseFlairTemplateOrderRequest() {
    return { subreddit: "", flairType: "", order: [] };
}
export const FlairTemplateOrderRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairTemplateOrderRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairType !== "") {
            writer.uint32(18).string(message.flairType);
        }
        for (const v of message.order) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairTemplateOrderRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.flairType = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.order.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            flairType: isSet(object.flairType) ? globalThis.String(object.flairType) : "",
            order: globalThis.Array.isArray(object?.order) ? object.order.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.flairType !== "") {
            obj.flairType = message.flairType;
        }
        if (message.order?.length) {
            obj.order = message.order;
        }
        return obj;
    },
    create(base) {
        return FlairTemplateOrderRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairTemplateOrderRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairType = object.flairType ?? "";
        message.order = object.order?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set(FlairTemplateOrderRequest.$type, FlairTemplateOrderRequest);
function createBaseFlairConfigRequest() {
    return {
        subreddit: "",
        flairEnabled: false,
        flairPosition: "",
        flairSelfAssignEnabled: false,
        linkFlairPosition: "",
        linkFlairSelfAssignEnabled: false,
    };
}
export const FlairConfigRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairConfigRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairEnabled !== false) {
            writer.uint32(16).bool(message.flairEnabled);
        }
        if (message.flairPosition !== "") {
            writer.uint32(26).string(message.flairPosition);
        }
        if (message.flairSelfAssignEnabled !== false) {
            writer.uint32(32).bool(message.flairSelfAssignEnabled);
        }
        if (message.linkFlairPosition !== "") {
            writer.uint32(42).string(message.linkFlairPosition);
        }
        if (message.linkFlairSelfAssignEnabled !== false) {
            writer.uint32(48).bool(message.linkFlairSelfAssignEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairConfigRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.flairEnabled = reader.bool();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.flairPosition = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.flairSelfAssignEnabled = reader.bool();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.linkFlairPosition = reader.string();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.linkFlairSelfAssignEnabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            flairEnabled: isSet(object.flairEnabled) ? globalThis.Boolean(object.flairEnabled) : false,
            flairPosition: isSet(object.flairPosition) ? globalThis.String(object.flairPosition) : "",
            flairSelfAssignEnabled: isSet(object.flairSelfAssignEnabled)
                ? globalThis.Boolean(object.flairSelfAssignEnabled)
                : false,
            linkFlairPosition: isSet(object.linkFlairPosition) ? globalThis.String(object.linkFlairPosition) : "",
            linkFlairSelfAssignEnabled: isSet(object.linkFlairSelfAssignEnabled)
                ? globalThis.Boolean(object.linkFlairSelfAssignEnabled)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.flairEnabled !== false) {
            obj.flairEnabled = message.flairEnabled;
        }
        if (message.flairPosition !== "") {
            obj.flairPosition = message.flairPosition;
        }
        if (message.flairSelfAssignEnabled !== false) {
            obj.flairSelfAssignEnabled = message.flairSelfAssignEnabled;
        }
        if (message.linkFlairPosition !== "") {
            obj.linkFlairPosition = message.linkFlairPosition;
        }
        if (message.linkFlairSelfAssignEnabled !== false) {
            obj.linkFlairSelfAssignEnabled = message.linkFlairSelfAssignEnabled;
        }
        return obj;
    },
    create(base) {
        return FlairConfigRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairConfigRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairEnabled = object.flairEnabled ?? false;
        message.flairPosition = object.flairPosition ?? "";
        message.flairSelfAssignEnabled = object.flairSelfAssignEnabled ?? false;
        message.linkFlairPosition = object.linkFlairPosition ?? "";
        message.linkFlairSelfAssignEnabled = object.linkFlairSelfAssignEnabled ?? false;
        return message;
    },
};
messageTypeRegistry.set(FlairConfigRequest.$type, FlairConfigRequest);
function createBaseFlairCsvRequest() {
    return { subreddit: "", flairCsv: "" };
}
export const FlairCsvRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairCsv !== "") {
            writer.uint32(18).string(message.flairCsv);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.flairCsv = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            flairCsv: isSet(object.flairCsv) ? globalThis.String(object.flairCsv) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.flairCsv !== "") {
            obj.flairCsv = message.flairCsv;
        }
        return obj;
    },
    create(base) {
        return FlairCsvRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairCsvRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairCsv = object.flairCsv ?? "";
        return message;
    },
};
messageTypeRegistry.set(FlairCsvRequest.$type, FlairCsvRequest);
function createBaseFlairListRequest() {
    return {
        subreddit: "",
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        name: undefined,
        show: undefined,
    };
}
export const FlairListRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairListRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(34).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(50).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairListRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        return obj;
    },
    create(base) {
        return FlairListRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairListRequest();
        message.subreddit = object.subreddit ?? "";
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.name = object.name ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(FlairListRequest.$type, FlairListRequest);
function createBaseFlairSelectorRequest() {
    return { subreddit: "", isNewlink: false, link: undefined, name: "" };
}
export const FlairSelectorRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairSelectorRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.isNewlink !== false) {
            writer.uint32(16).bool(message.isNewlink);
        }
        if (message.link !== undefined) {
            StringValue.encode({ value: message.link }, writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== "") {
            writer.uint32(34).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairSelectorRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.isNewlink = reader.bool();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.link = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            isNewlink: isSet(object.isNewlink) ? globalThis.Boolean(object.isNewlink) : false,
            link: isSet(object.link) ? String(object.link) : undefined,
            name: isSet(object.name) ? globalThis.String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.isNewlink !== false) {
            obj.isNewlink = message.isNewlink;
        }
        if (message.link !== undefined) {
            obj.link = message.link;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return FlairSelectorRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairSelectorRequest();
        message.subreddit = object.subreddit ?? "";
        message.isNewlink = object.isNewlink ?? false;
        message.link = object.link ?? undefined;
        message.name = object.name ?? "";
        return message;
    },
};
messageTypeRegistry.set(FlairSelectorRequest.$type, FlairSelectorRequest);
function createBaseFlairTemplateRequest() {
    return {
        subreddit: "",
        allowableContent: "",
        backgroundColor: "",
        cssClass: "",
        flairTemplateId: "",
        flairType: "",
        maxEmojis: 0,
        modOnly: false,
        overrideCss: false,
        text: "",
        textColor: "",
        textEditable: false,
    };
}
export const FlairTemplateRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairTemplateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.allowableContent !== "") {
            writer.uint32(18).string(message.allowableContent);
        }
        if (message.backgroundColor !== "") {
            writer.uint32(26).string(message.backgroundColor);
        }
        if (message.cssClass !== "") {
            writer.uint32(34).string(message.cssClass);
        }
        if (message.flairTemplateId !== "") {
            writer.uint32(42).string(message.flairTemplateId);
        }
        if (message.flairType !== "") {
            writer.uint32(50).string(message.flairType);
        }
        if (message.maxEmojis !== 0) {
            writer.uint32(56).int64(message.maxEmojis);
        }
        if (message.modOnly !== false) {
            writer.uint32(64).bool(message.modOnly);
        }
        if (message.overrideCss !== false) {
            writer.uint32(72).bool(message.overrideCss);
        }
        if (message.text !== "") {
            writer.uint32(82).string(message.text);
        }
        if (message.textColor !== "") {
            writer.uint32(90).string(message.textColor);
        }
        if (message.textEditable !== false) {
            writer.uint32(96).bool(message.textEditable);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairTemplateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.allowableContent = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.backgroundColor = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.cssClass = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.flairTemplateId = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.flairType = reader.string();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.maxEmojis = longToNumber(reader.int64());
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.modOnly = reader.bool();
                    continue;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.overrideCss = reader.bool();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.text = reader.string();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.textColor = reader.string();
                    continue;
                case 12:
                    if (tag !== 96) {
                        break;
                    }
                    message.textEditable = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            allowableContent: isSet(object.allowableContent) ? globalThis.String(object.allowableContent) : "",
            backgroundColor: isSet(object.backgroundColor) ? globalThis.String(object.backgroundColor) : "",
            cssClass: isSet(object.cssClass) ? globalThis.String(object.cssClass) : "",
            flairTemplateId: isSet(object.flairTemplateId) ? globalThis.String(object.flairTemplateId) : "",
            flairType: isSet(object.flairType) ? globalThis.String(object.flairType) : "",
            maxEmojis: isSet(object.maxEmojis) ? globalThis.Number(object.maxEmojis) : 0,
            modOnly: isSet(object.modOnly) ? globalThis.Boolean(object.modOnly) : false,
            overrideCss: isSet(object.overrideCss) ? globalThis.Boolean(object.overrideCss) : false,
            text: isSet(object.text) ? globalThis.String(object.text) : "",
            textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
            textEditable: isSet(object.textEditable) ? globalThis.Boolean(object.textEditable) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.allowableContent !== "") {
            obj.allowableContent = message.allowableContent;
        }
        if (message.backgroundColor !== "") {
            obj.backgroundColor = message.backgroundColor;
        }
        if (message.cssClass !== "") {
            obj.cssClass = message.cssClass;
        }
        if (message.flairTemplateId !== "") {
            obj.flairTemplateId = message.flairTemplateId;
        }
        if (message.flairType !== "") {
            obj.flairType = message.flairType;
        }
        if (message.maxEmojis !== 0) {
            obj.maxEmojis = Math.round(message.maxEmojis);
        }
        if (message.modOnly !== false) {
            obj.modOnly = message.modOnly;
        }
        if (message.overrideCss !== false) {
            obj.overrideCss = message.overrideCss;
        }
        if (message.text !== "") {
            obj.text = message.text;
        }
        if (message.textColor !== "") {
            obj.textColor = message.textColor;
        }
        if (message.textEditable !== false) {
            obj.textEditable = message.textEditable;
        }
        return obj;
    },
    create(base) {
        return FlairTemplateRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairTemplateRequest();
        message.subreddit = object.subreddit ?? "";
        message.allowableContent = object.allowableContent ?? "";
        message.backgroundColor = object.backgroundColor ?? "";
        message.cssClass = object.cssClass ?? "";
        message.flairTemplateId = object.flairTemplateId ?? "";
        message.flairType = object.flairType ?? "";
        message.maxEmojis = object.maxEmojis ?? 0;
        message.modOnly = object.modOnly ?? false;
        message.overrideCss = object.overrideCss ?? false;
        message.text = object.text ?? "";
        message.textColor = object.textColor ?? "";
        message.textEditable = object.textEditable ?? false;
        return message;
    },
};
messageTypeRegistry.set(FlairTemplateRequest.$type, FlairTemplateRequest);
function createBaseLinkFlairRequest() {
    return { subreddit: "" };
}
export const LinkFlairRequest = {
    $type: "devvit.plugin.redditapi.flair.LinkFlairRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLinkFlairRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        return obj;
    },
    create(base) {
        return LinkFlairRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLinkFlairRequest();
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set(LinkFlairRequest.$type, LinkFlairRequest);
function createBaseSelectFlairRequest() {
    return {
        subreddit: "",
        backgroundColor: "",
        cssClass: "",
        flairTemplateId: "",
        link: "",
        name: "",
        returnRtjson: "",
        text: "",
        textColor: "",
    };
}
export const SelectFlairRequest = {
    $type: "devvit.plugin.redditapi.flair.SelectFlairRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.backgroundColor !== "") {
            writer.uint32(18).string(message.backgroundColor);
        }
        if (message.cssClass !== "") {
            writer.uint32(26).string(message.cssClass);
        }
        if (message.flairTemplateId !== "") {
            writer.uint32(34).string(message.flairTemplateId);
        }
        if (message.link !== "") {
            writer.uint32(42).string(message.link);
        }
        if (message.name !== "") {
            writer.uint32(50).string(message.name);
        }
        if (message.returnRtjson !== "") {
            writer.uint32(58).string(message.returnRtjson);
        }
        if (message.text !== "") {
            writer.uint32(66).string(message.text);
        }
        if (message.textColor !== "") {
            writer.uint32(74).string(message.textColor);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelectFlairRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.backgroundColor = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.cssClass = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.flairTemplateId = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.link = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.returnRtjson = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.text = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.textColor = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            backgroundColor: isSet(object.backgroundColor) ? globalThis.String(object.backgroundColor) : "",
            cssClass: isSet(object.cssClass) ? globalThis.String(object.cssClass) : "",
            flairTemplateId: isSet(object.flairTemplateId) ? globalThis.String(object.flairTemplateId) : "",
            link: isSet(object.link) ? globalThis.String(object.link) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            returnRtjson: isSet(object.returnRtjson) ? globalThis.String(object.returnRtjson) : "",
            text: isSet(object.text) ? globalThis.String(object.text) : "",
            textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.backgroundColor !== "") {
            obj.backgroundColor = message.backgroundColor;
        }
        if (message.cssClass !== "") {
            obj.cssClass = message.cssClass;
        }
        if (message.flairTemplateId !== "") {
            obj.flairTemplateId = message.flairTemplateId;
        }
        if (message.link !== "") {
            obj.link = message.link;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.returnRtjson !== "") {
            obj.returnRtjson = message.returnRtjson;
        }
        if (message.text !== "") {
            obj.text = message.text;
        }
        if (message.textColor !== "") {
            obj.textColor = message.textColor;
        }
        return obj;
    },
    create(base) {
        return SelectFlairRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSelectFlairRequest();
        message.subreddit = object.subreddit ?? "";
        message.backgroundColor = object.backgroundColor ?? "";
        message.cssClass = object.cssClass ?? "";
        message.flairTemplateId = object.flairTemplateId ?? "";
        message.link = object.link ?? "";
        message.name = object.name ?? "";
        message.returnRtjson = object.returnRtjson ?? "";
        message.text = object.text ?? "";
        message.textColor = object.textColor ?? "";
        return message;
    },
};
messageTypeRegistry.set(SelectFlairRequest.$type, SelectFlairRequest);
function createBaseSetFlairEnabledRequest() {
    return { subreddit: "", flairEnabled: false };
}
export const SetFlairEnabledRequest = {
    $type: "devvit.plugin.redditapi.flair.SetFlairEnabledRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairEnabled !== false) {
            writer.uint32(16).bool(message.flairEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetFlairEnabledRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.flairEnabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            flairEnabled: isSet(object.flairEnabled) ? globalThis.Boolean(object.flairEnabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.flairEnabled !== false) {
            obj.flairEnabled = message.flairEnabled;
        }
        return obj;
    },
    create(base) {
        return SetFlairEnabledRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetFlairEnabledRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairEnabled = object.flairEnabled ?? false;
        return message;
    },
};
messageTypeRegistry.set(SetFlairEnabledRequest.$type, SetFlairEnabledRequest);
function createBaseFlairObject() {
    return {
        allowableContent: undefined,
        text: undefined,
        textColor: undefined,
        modOnly: false,
        backgroundColor: undefined,
        id: undefined,
        cssClass: undefined,
        maxEmojis: 0,
        richtext: [],
        textEditable: false,
        overrideCss: false,
        type: undefined,
        flairType: undefined,
    };
}
export const FlairObject = {
    $type: "devvit.plugin.redditapi.flair.FlairObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.allowableContent !== undefined) {
            StringValue.encode({ value: message.allowableContent }, writer.uint32(10).fork()).ldelim();
        }
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(18).fork()).ldelim();
        }
        if (message.textColor !== undefined) {
            StringValue.encode({ value: message.textColor }, writer.uint32(26).fork()).ldelim();
        }
        if (message.modOnly !== false) {
            writer.uint32(32).bool(message.modOnly);
        }
        if (message.backgroundColor !== undefined) {
            StringValue.encode({ value: message.backgroundColor }, writer.uint32(42).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(50).fork()).ldelim();
        }
        if (message.cssClass !== undefined) {
            StringValue.encode({ value: message.cssClass }, writer.uint32(58).fork()).ldelim();
        }
        if (message.maxEmojis !== 0) {
            writer.uint32(64).int64(message.maxEmojis);
        }
        for (const v of message.richtext) {
            StringValue.encode({ value: v }, writer.uint32(74).fork()).ldelim();
        }
        if (message.textEditable !== false) {
            writer.uint32(80).bool(message.textEditable);
        }
        if (message.overrideCss !== false) {
            writer.uint32(88).bool(message.overrideCss);
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(98).fork()).ldelim();
        }
        if (message.flairType !== undefined) {
            StringValue.encode({ value: message.flairType }, writer.uint32(106).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.allowableContent = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.textColor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.modOnly = reader.bool();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.backgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.cssClass = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.maxEmojis = longToNumber(reader.int64());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.richtext.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 10:
                    if (tag !== 80) {
                        break;
                    }
                    message.textEditable = reader.bool();
                    continue;
                case 11:
                    if (tag !== 88) {
                        break;
                    }
                    message.overrideCss = reader.bool();
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.flairType = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            allowableContent: isSet(object.allowableContent) ? String(object.allowableContent) : undefined,
            text: isSet(object.text) ? String(object.text) : undefined,
            textColor: isSet(object.textColor) ? String(object.textColor) : undefined,
            modOnly: isSet(object.modOnly) ? globalThis.Boolean(object.modOnly) : false,
            backgroundColor: isSet(object.backgroundColor) ? String(object.backgroundColor) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            cssClass: isSet(object.cssClass) ? String(object.cssClass) : undefined,
            maxEmojis: isSet(object.maxEmojis) ? globalThis.Number(object.maxEmojis) : 0,
            richtext: globalThis.Array.isArray(object?.richtext) ? object.richtext.map((e) => String(e)) : [],
            textEditable: isSet(object.textEditable) ? globalThis.Boolean(object.textEditable) : false,
            overrideCss: isSet(object.overrideCss) ? globalThis.Boolean(object.overrideCss) : false,
            type: isSet(object.type) ? String(object.type) : undefined,
            flairType: isSet(object.flairType) ? String(object.flairType) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.allowableContent !== undefined) {
            obj.allowableContent = message.allowableContent;
        }
        if (message.text !== undefined) {
            obj.text = message.text;
        }
        if (message.textColor !== undefined) {
            obj.textColor = message.textColor;
        }
        if (message.modOnly !== false) {
            obj.modOnly = message.modOnly;
        }
        if (message.backgroundColor !== undefined) {
            obj.backgroundColor = message.backgroundColor;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.cssClass !== undefined) {
            obj.cssClass = message.cssClass;
        }
        if (message.maxEmojis !== 0) {
            obj.maxEmojis = Math.round(message.maxEmojis);
        }
        if (message.richtext?.length) {
            obj.richtext = message.richtext;
        }
        if (message.textEditable !== false) {
            obj.textEditable = message.textEditable;
        }
        if (message.overrideCss !== false) {
            obj.overrideCss = message.overrideCss;
        }
        if (message.type !== undefined) {
            obj.type = message.type;
        }
        if (message.flairType !== undefined) {
            obj.flairType = message.flairType;
        }
        return obj;
    },
    create(base) {
        return FlairObject.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairObject();
        message.allowableContent = object.allowableContent ?? undefined;
        message.text = object.text ?? undefined;
        message.textColor = object.textColor ?? undefined;
        message.modOnly = object.modOnly ?? false;
        message.backgroundColor = object.backgroundColor ?? undefined;
        message.id = object.id ?? undefined;
        message.cssClass = object.cssClass ?? undefined;
        message.maxEmojis = object.maxEmojis ?? 0;
        message.richtext = object.richtext?.map((e) => e) || [];
        message.textEditable = object.textEditable ?? false;
        message.overrideCss = object.overrideCss ?? false;
        message.type = object.type ?? undefined;
        message.flairType = object.flairType ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(FlairObject.$type, FlairObject);
function createBaseFlairArray() {
    return { flair: [] };
}
export const FlairArray = {
    $type: "devvit.plugin.redditapi.flair.FlairArray",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.flair) {
            FlairObject.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairArray();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.flair.push(FlairObject.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            flair: globalThis.Array.isArray(object?.flair) ? object.flair.map((e) => FlairObject.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.flair?.length) {
            obj.flair = message.flair.map((e) => FlairObject.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return FlairArray.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairArray();
        message.flair = object.flair?.map((e) => FlairObject.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(FlairArray.$type, FlairArray);
function createBaseFlairSelectorResponseOption() {
    return {
        flairCssClass: undefined,
        flairTemplateId: undefined,
        flairText: undefined,
        flairTextEditable: undefined,
        flairPosition: undefined,
    };
}
export const FlairSelectorResponseOption = {
    $type: "devvit.plugin.redditapi.flair.FlairSelectorResponseOption",
    encode(message, writer = _m0.Writer.create()) {
        if (message.flairCssClass !== undefined) {
            StringValue.encode({ value: message.flairCssClass }, writer.uint32(10).fork()).ldelim();
        }
        if (message.flairTemplateId !== undefined) {
            StringValue.encode({ value: message.flairTemplateId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.flairText !== undefined) {
            StringValue.encode({ value: message.flairText }, writer.uint32(26).fork()).ldelim();
        }
        if (message.flairTextEditable !== undefined) {
            BoolValue.encode({ value: message.flairTextEditable }, writer.uint32(34).fork()).ldelim();
        }
        if (message.flairPosition !== undefined) {
            StringValue.encode({ value: message.flairPosition }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairSelectorResponseOption();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.flairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.flairTemplateId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.flairText = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.flairTextEditable = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.flairPosition = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            flairCssClass: isSet(object.flairCssClass) ? String(object.flairCssClass) : undefined,
            flairTemplateId: isSet(object.flairTemplateId) ? String(object.flairTemplateId) : undefined,
            flairText: isSet(object.flairText) ? String(object.flairText) : undefined,
            flairTextEditable: isSet(object.flairTextEditable) ? Boolean(object.flairTextEditable) : undefined,
            flairPosition: isSet(object.flairPosition) ? String(object.flairPosition) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.flairCssClass !== undefined) {
            obj.flairCssClass = message.flairCssClass;
        }
        if (message.flairTemplateId !== undefined) {
            obj.flairTemplateId = message.flairTemplateId;
        }
        if (message.flairText !== undefined) {
            obj.flairText = message.flairText;
        }
        if (message.flairTextEditable !== undefined) {
            obj.flairTextEditable = message.flairTextEditable;
        }
        if (message.flairPosition !== undefined) {
            obj.flairPosition = message.flairPosition;
        }
        return obj;
    },
    create(base) {
        return FlairSelectorResponseOption.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairSelectorResponseOption();
        message.flairCssClass = object.flairCssClass ?? undefined;
        message.flairTemplateId = object.flairTemplateId ?? undefined;
        message.flairText = object.flairText ?? undefined;
        message.flairTextEditable = object.flairTextEditable ?? undefined;
        message.flairPosition = object.flairPosition ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(FlairSelectorResponseOption.$type, FlairSelectorResponseOption);
function createBaseFlairSelectorResponse() {
    return { current: undefined, choices: [] };
}
export const FlairSelectorResponse = {
    $type: "devvit.plugin.redditapi.flair.FlairSelectorResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.current !== undefined) {
            FlairSelectorResponseOption.encode(message.current, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.choices) {
            FlairSelectorResponseOption.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairSelectorResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.current = FlairSelectorResponseOption.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.choices.push(FlairSelectorResponseOption.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            current: isSet(object.current) ? FlairSelectorResponseOption.fromJSON(object.current) : undefined,
            choices: globalThis.Array.isArray(object?.choices)
                ? object.choices.map((e) => FlairSelectorResponseOption.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.current !== undefined) {
            obj.current = FlairSelectorResponseOption.toJSON(message.current);
        }
        if (message.choices?.length) {
            obj.choices = message.choices.map((e) => FlairSelectorResponseOption.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return FlairSelectorResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairSelectorResponse();
        message.current = (object.current !== undefined && object.current !== null)
            ? FlairSelectorResponseOption.fromPartial(object.current)
            : undefined;
        message.choices = object.choices?.map((e) => FlairSelectorResponseOption.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(FlairSelectorResponse.$type, FlairSelectorResponse);
function createBaseUserFlair() {
    return { flairCssClass: undefined, user: undefined, flairText: undefined };
}
export const UserFlair = {
    $type: "devvit.plugin.redditapi.flair.UserFlair",
    encode(message, writer = _m0.Writer.create()) {
        if (message.flairCssClass !== undefined) {
            StringValue.encode({ value: message.flairCssClass }, writer.uint32(10).fork()).ldelim();
        }
        if (message.user !== undefined) {
            StringValue.encode({ value: message.user }, writer.uint32(18).fork()).ldelim();
        }
        if (message.flairText !== undefined) {
            StringValue.encode({ value: message.flairText }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserFlair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.flairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.user = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.flairText = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            flairCssClass: isSet(object.flairCssClass) ? String(object.flairCssClass) : undefined,
            user: isSet(object.user) ? String(object.user) : undefined,
            flairText: isSet(object.flairText) ? String(object.flairText) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.flairCssClass !== undefined) {
            obj.flairCssClass = message.flairCssClass;
        }
        if (message.user !== undefined) {
            obj.user = message.user;
        }
        if (message.flairText !== undefined) {
            obj.flairText = message.flairText;
        }
        return obj;
    },
    create(base) {
        return UserFlair.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserFlair();
        message.flairCssClass = object.flairCssClass ?? undefined;
        message.user = object.user ?? undefined;
        message.flairText = object.flairText ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(UserFlair.$type, UserFlair);
function createBaseFlairListResponse() {
    return { users: [], next: undefined, prev: undefined };
}
export const FlairListResponse = {
    $type: "devvit.plugin.redditapi.flair.FlairListResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.users) {
            UserFlair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.next !== undefined) {
            StringValue.encode({ value: message.next }, writer.uint32(18).fork()).ldelim();
        }
        if (message.prev !== undefined) {
            StringValue.encode({ value: message.prev }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairListResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.users.push(UserFlair.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.next = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.prev = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            users: globalThis.Array.isArray(object?.users) ? object.users.map((e) => UserFlair.fromJSON(e)) : [],
            next: isSet(object.next) ? String(object.next) : undefined,
            prev: isSet(object.prev) ? String(object.prev) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.users?.length) {
            obj.users = message.users.map((e) => UserFlair.toJSON(e));
        }
        if (message.next !== undefined) {
            obj.next = message.next;
        }
        if (message.prev !== undefined) {
            obj.prev = message.prev;
        }
        return obj;
    },
    create(base) {
        return FlairListResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairListResponse();
        message.users = object.users?.map((e) => UserFlair.fromPartial(e)) || [];
        message.next = object.next ?? undefined;
        message.prev = object.prev ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(FlairListResponse.$type, FlairListResponse);
function createBaseFlairCsvResultError() {
    return { css: undefined, row: undefined, user: undefined };
}
export const FlairCsvResultError = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResultError",
    encode(message, writer = _m0.Writer.create()) {
        if (message.css !== undefined) {
            StringValue.encode({ value: message.css }, writer.uint32(10).fork()).ldelim();
        }
        if (message.row !== undefined) {
            StringValue.encode({ value: message.row }, writer.uint32(18).fork()).ldelim();
        }
        if (message.user !== undefined) {
            StringValue.encode({ value: message.user }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvResultError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.css = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.row = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.user = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            css: isSet(object.css) ? String(object.css) : undefined,
            row: isSet(object.row) ? String(object.row) : undefined,
            user: isSet(object.user) ? String(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.css !== undefined) {
            obj.css = message.css;
        }
        if (message.row !== undefined) {
            obj.row = message.row;
        }
        if (message.user !== undefined) {
            obj.user = message.user;
        }
        return obj;
    },
    create(base) {
        return FlairCsvResultError.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairCsvResultError();
        message.css = object.css ?? undefined;
        message.row = object.row ?? undefined;
        message.user = object.user ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(FlairCsvResultError.$type, FlairCsvResultError);
function createBaseFlairCsvResultWarning() {
    return { text: undefined };
}
export const FlairCsvResultWarning = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResultWarning",
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvResultWarning();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { text: isSet(object.text) ? String(object.text) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.text !== undefined) {
            obj.text = message.text;
        }
        return obj;
    },
    create(base) {
        return FlairCsvResultWarning.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairCsvResultWarning();
        message.text = object.text ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(FlairCsvResultWarning.$type, FlairCsvResultWarning);
function createBaseFlairCsvResult() {
    return { status: undefined, ok: undefined, errors: undefined, warnings: undefined };
}
export const FlairCsvResult = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResult",
    encode(message, writer = _m0.Writer.create()) {
        if (message.status !== undefined) {
            StringValue.encode({ value: message.status }, writer.uint32(10).fork()).ldelim();
        }
        if (message.ok !== undefined) {
            BoolValue.encode({ value: message.ok }, writer.uint32(18).fork()).ldelim();
        }
        if (message.errors !== undefined) {
            FlairCsvResultError.encode(message.errors, writer.uint32(26).fork()).ldelim();
        }
        if (message.warnings !== undefined) {
            FlairCsvResultWarning.encode(message.warnings, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.status = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ok = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.errors = FlairCsvResultError.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.warnings = FlairCsvResultWarning.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            status: isSet(object.status) ? String(object.status) : undefined,
            ok: isSet(object.ok) ? Boolean(object.ok) : undefined,
            errors: isSet(object.errors) ? FlairCsvResultError.fromJSON(object.errors) : undefined,
            warnings: isSet(object.warnings) ? FlairCsvResultWarning.fromJSON(object.warnings) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.status !== undefined) {
            obj.status = message.status;
        }
        if (message.ok !== undefined) {
            obj.ok = message.ok;
        }
        if (message.errors !== undefined) {
            obj.errors = FlairCsvResultError.toJSON(message.errors);
        }
        if (message.warnings !== undefined) {
            obj.warnings = FlairCsvResultWarning.toJSON(message.warnings);
        }
        return obj;
    },
    create(base) {
        return FlairCsvResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairCsvResult();
        message.status = object.status ?? undefined;
        message.ok = object.ok ?? undefined;
        message.errors = (object.errors !== undefined && object.errors !== null)
            ? FlairCsvResultError.fromPartial(object.errors)
            : undefined;
        message.warnings = (object.warnings !== undefined && object.warnings !== null)
            ? FlairCsvResultWarning.fromPartial(object.warnings)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(FlairCsvResult.$type, FlairCsvResult);
function createBaseFlairCsvResponse() {
    return { result: [] };
}
export const FlairCsvResponse = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.result) {
            FlairCsvResult.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.result.push(FlairCsvResult.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            result: globalThis.Array.isArray(object?.result) ? object.result.map((e) => FlairCsvResult.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.result?.length) {
            obj.result = message.result.map((e) => FlairCsvResult.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return FlairCsvResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlairCsvResponse();
        message.result = object.result?.map((e) => FlairCsvResult.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(FlairCsvResponse.$type, FlairCsvResponse);
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
