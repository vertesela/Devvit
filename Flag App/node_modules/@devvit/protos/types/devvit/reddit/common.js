/**
 * #common.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int32Value, Int64Value, StringValue } from '../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../typeRegistry.js';
export var BanInfo_BanInfoAction;
(function (BanInfo_BanInfoAction) {
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["UNKNOWN"] = 0] = "UNKNOWN";
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["SPAM"] = 1] = "SPAM";
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["FILTER"] = 2] = "FILTER";
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["REMOVE"] = 3] = "REMOVE";
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BanInfo_BanInfoAction || (BanInfo_BanInfoAction = {}));
export function banInfo_BanInfoActionFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return BanInfo_BanInfoAction.UNKNOWN;
        case 1:
        case "SPAM":
            return BanInfo_BanInfoAction.SPAM;
        case 2:
        case "FILTER":
            return BanInfo_BanInfoAction.FILTER;
        case 3:
        case "REMOVE":
            return BanInfo_BanInfoAction.REMOVE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BanInfo_BanInfoAction.UNRECOGNIZED;
    }
}
export function banInfo_BanInfoActionToJSON(object) {
    switch (object) {
        case BanInfo_BanInfoAction.UNKNOWN:
            return 0;
        case BanInfo_BanInfoAction.SPAM:
            return 1;
        case BanInfo_BanInfoAction.FILTER:
            return 2;
        case BanInfo_BanInfoAction.REMOVE:
            return 3;
        case BanInfo_BanInfoAction.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseAuthorFlairRichText() {
    return { e: undefined, t: undefined };
}
export const AuthorFlairRichText = {
    $type: "devvit.reddit.AuthorFlairRichText",
    encode(message, writer = _m0.Writer.create()) {
        if (message.e !== undefined) {
            StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
        }
        if (message.t !== undefined) {
            StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthorFlairRichText();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.e = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.t = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { e: isSet(object.e) ? String(object.e) : undefined, t: isSet(object.t) ? String(object.t) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.e !== undefined) {
            obj.e = message.e;
        }
        if (message.t !== undefined) {
            obj.t = message.t;
        }
        return obj;
    },
    create(base) {
        return AuthorFlairRichText.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuthorFlairRichText();
        message.e = object.e ?? undefined;
        message.t = object.t ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(AuthorFlairRichText.$type, AuthorFlairRichText);
function createBaseAwarding() {
    return {
        awardSubType: undefined,
        awardType: undefined,
        awardingsRequiredToGrantBenefits: undefined,
        coinPrice: undefined,
        coinReward: undefined,
        count: undefined,
        daysOfDripExtension: undefined,
        daysOfPremium: undefined,
        description: undefined,
        endDate: undefined,
        giverCoinReward: undefined,
        iconFormat: undefined,
        iconHeight: undefined,
        iconUrl: undefined,
        iconWidth: undefined,
        id: undefined,
        isEnabled: undefined,
        isNew: undefined,
        name: undefined,
        pennyDonate: undefined,
        pennyPrice: undefined,
        resizedIcons: [],
        resizedStaticIcons: [],
        startDate: undefined,
        staticIconHeight: undefined,
        staticIconUrl: undefined,
        staticIconWidth: undefined,
        stickyDurationSeconds: undefined,
        subredditCoinReward: undefined,
        subredditId: undefined,
        tiersByRequiredAwardings: undefined,
    };
}
export const Awarding = {
    $type: "devvit.reddit.Awarding",
    encode(message, writer = _m0.Writer.create()) {
        if (message.awardSubType !== undefined) {
            StringValue.encode({ value: message.awardSubType }, writer.uint32(10).fork()).ldelim();
        }
        if (message.awardType !== undefined) {
            StringValue.encode({ value: message.awardType }, writer.uint32(18).fork()).ldelim();
        }
        if (message.awardingsRequiredToGrantBenefits !== undefined) {
            Int32Value.encode({ value: message.awardingsRequiredToGrantBenefits }, writer.uint32(26).fork()).ldelim();
        }
        if (message.coinPrice !== undefined) {
            Int64Value.encode({ value: message.coinPrice }, writer.uint32(34).fork()).ldelim();
        }
        if (message.coinReward !== undefined) {
            Int64Value.encode({ value: message.coinReward }, writer.uint32(42).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int32Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
        }
        if (message.daysOfDripExtension !== undefined) {
            Int32Value.encode({ value: message.daysOfDripExtension }, writer.uint32(58).fork()).ldelim();
        }
        if (message.daysOfPremium !== undefined) {
            Int32Value.encode({ value: message.daysOfPremium }, writer.uint32(66).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(74).fork()).ldelim();
        }
        if (message.endDate !== undefined) {
            StringValue.encode({ value: message.endDate }, writer.uint32(82).fork()).ldelim();
        }
        if (message.giverCoinReward !== undefined) {
            Int32Value.encode({ value: message.giverCoinReward }, writer.uint32(90).fork()).ldelim();
        }
        if (message.iconFormat !== undefined) {
            StringValue.encode({ value: message.iconFormat }, writer.uint32(98).fork()).ldelim();
        }
        if (message.iconHeight !== undefined) {
            Int32Value.encode({ value: message.iconHeight }, writer.uint32(106).fork()).ldelim();
        }
        if (message.iconUrl !== undefined) {
            StringValue.encode({ value: message.iconUrl }, writer.uint32(114).fork()).ldelim();
        }
        if (message.iconWidth !== undefined) {
            Int32Value.encode({ value: message.iconWidth }, writer.uint32(122).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(130).fork()).ldelim();
        }
        if (message.isEnabled !== undefined) {
            BoolValue.encode({ value: message.isEnabled }, writer.uint32(138).fork()).ldelim();
        }
        if (message.isNew !== undefined) {
            BoolValue.encode({ value: message.isNew }, writer.uint32(146).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(154).fork()).ldelim();
        }
        if (message.pennyDonate !== undefined) {
            Int32Value.encode({ value: message.pennyDonate }, writer.uint32(162).fork()).ldelim();
        }
        if (message.pennyPrice !== undefined) {
            Int32Value.encode({ value: message.pennyPrice }, writer.uint32(170).fork()).ldelim();
        }
        for (const v of message.resizedIcons) {
            Awarding_Icon.encode(v, writer.uint32(178).fork()).ldelim();
        }
        for (const v of message.resizedStaticIcons) {
            Awarding_Icon.encode(v, writer.uint32(186).fork()).ldelim();
        }
        if (message.startDate !== undefined) {
            StringValue.encode({ value: message.startDate }, writer.uint32(194).fork()).ldelim();
        }
        if (message.staticIconHeight !== undefined) {
            Int32Value.encode({ value: message.staticIconHeight }, writer.uint32(202).fork()).ldelim();
        }
        if (message.staticIconUrl !== undefined) {
            StringValue.encode({ value: message.staticIconUrl }, writer.uint32(210).fork()).ldelim();
        }
        if (message.staticIconWidth !== undefined) {
            Int32Value.encode({ value: message.staticIconWidth }, writer.uint32(218).fork()).ldelim();
        }
        if (message.stickyDurationSeconds !== undefined) {
            Int64Value.encode({ value: message.stickyDurationSeconds }, writer.uint32(226).fork()).ldelim();
        }
        if (message.subredditCoinReward !== undefined) {
            Int64Value.encode({ value: message.subredditCoinReward }, writer.uint32(234).fork()).ldelim();
        }
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(242).fork()).ldelim();
        }
        if (message.tiersByRequiredAwardings !== undefined) {
            StringValue.encode({ value: message.tiersByRequiredAwardings }, writer.uint32(250).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAwarding();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.awardSubType = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.awardType = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.awardingsRequiredToGrantBenefits = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.coinPrice = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.coinReward = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.count = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.daysOfDripExtension = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.daysOfPremium = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.endDate = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.giverCoinReward = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.iconFormat = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.iconHeight = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.iconUrl = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.iconWidth = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 16:
                    if (tag !== 130) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 17:
                    if (tag !== 138) {
                        break;
                    }
                    message.isEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 18:
                    if (tag !== 146) {
                        break;
                    }
                    message.isNew = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 19:
                    if (tag !== 154) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 20:
                    if (tag !== 162) {
                        break;
                    }
                    message.pennyDonate = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 21:
                    if (tag !== 170) {
                        break;
                    }
                    message.pennyPrice = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 22:
                    if (tag !== 178) {
                        break;
                    }
                    message.resizedIcons.push(Awarding_Icon.decode(reader, reader.uint32()));
                    continue;
                case 23:
                    if (tag !== 186) {
                        break;
                    }
                    message.resizedStaticIcons.push(Awarding_Icon.decode(reader, reader.uint32()));
                    continue;
                case 24:
                    if (tag !== 194) {
                        break;
                    }
                    message.startDate = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 25:
                    if (tag !== 202) {
                        break;
                    }
                    message.staticIconHeight = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 26:
                    if (tag !== 210) {
                        break;
                    }
                    message.staticIconUrl = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 27:
                    if (tag !== 218) {
                        break;
                    }
                    message.staticIconWidth = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 28:
                    if (tag !== 226) {
                        break;
                    }
                    message.stickyDurationSeconds = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 29:
                    if (tag !== 234) {
                        break;
                    }
                    message.subredditCoinReward = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 30:
                    if (tag !== 242) {
                        break;
                    }
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 31:
                    if (tag !== 250) {
                        break;
                    }
                    message.tiersByRequiredAwardings = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            awardSubType: isSet(object.awardSubType) ? String(object.awardSubType) : undefined,
            awardType: isSet(object.awardType) ? String(object.awardType) : undefined,
            awardingsRequiredToGrantBenefits: isSet(object.awardingsRequiredToGrantBenefits)
                ? Number(object.awardingsRequiredToGrantBenefits)
                : undefined,
            coinPrice: isSet(object.coinPrice) ? Number(object.coinPrice) : undefined,
            coinReward: isSet(object.coinReward) ? Number(object.coinReward) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            daysOfDripExtension: isSet(object.daysOfDripExtension) ? Number(object.daysOfDripExtension) : undefined,
            daysOfPremium: isSet(object.daysOfPremium) ? Number(object.daysOfPremium) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            endDate: isSet(object.endDate) ? String(object.endDate) : undefined,
            giverCoinReward: isSet(object.giverCoinReward) ? Number(object.giverCoinReward) : undefined,
            iconFormat: isSet(object.iconFormat) ? String(object.iconFormat) : undefined,
            iconHeight: isSet(object.iconHeight) ? Number(object.iconHeight) : undefined,
            iconUrl: isSet(object.iconUrl) ? String(object.iconUrl) : undefined,
            iconWidth: isSet(object.iconWidth) ? Number(object.iconWidth) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            isEnabled: isSet(object.isEnabled) ? Boolean(object.isEnabled) : undefined,
            isNew: isSet(object.isNew) ? Boolean(object.isNew) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            pennyDonate: isSet(object.pennyDonate) ? Number(object.pennyDonate) : undefined,
            pennyPrice: isSet(object.pennyPrice) ? Number(object.pennyPrice) : undefined,
            resizedIcons: globalThis.Array.isArray(object?.resizedIcons)
                ? object.resizedIcons.map((e) => Awarding_Icon.fromJSON(e))
                : [],
            resizedStaticIcons: globalThis.Array.isArray(object?.resizedStaticIcons)
                ? object.resizedStaticIcons.map((e) => Awarding_Icon.fromJSON(e))
                : [],
            startDate: isSet(object.startDate) ? String(object.startDate) : undefined,
            staticIconHeight: isSet(object.staticIconHeight) ? Number(object.staticIconHeight) : undefined,
            staticIconUrl: isSet(object.staticIconUrl) ? String(object.staticIconUrl) : undefined,
            staticIconWidth: isSet(object.staticIconWidth) ? Number(object.staticIconWidth) : undefined,
            stickyDurationSeconds: isSet(object.stickyDurationSeconds) ? Number(object.stickyDurationSeconds) : undefined,
            subredditCoinReward: isSet(object.subredditCoinReward) ? Number(object.subredditCoinReward) : undefined,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            tiersByRequiredAwardings: isSet(object.tiersByRequiredAwardings)
                ? String(object.tiersByRequiredAwardings)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.awardSubType !== undefined) {
            obj.awardSubType = message.awardSubType;
        }
        if (message.awardType !== undefined) {
            obj.awardType = message.awardType;
        }
        if (message.awardingsRequiredToGrantBenefits !== undefined) {
            obj.awardingsRequiredToGrantBenefits = message.awardingsRequiredToGrantBenefits;
        }
        if (message.coinPrice !== undefined) {
            obj.coinPrice = message.coinPrice;
        }
        if (message.coinReward !== undefined) {
            obj.coinReward = message.coinReward;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.daysOfDripExtension !== undefined) {
            obj.daysOfDripExtension = message.daysOfDripExtension;
        }
        if (message.daysOfPremium !== undefined) {
            obj.daysOfPremium = message.daysOfPremium;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.endDate !== undefined) {
            obj.endDate = message.endDate;
        }
        if (message.giverCoinReward !== undefined) {
            obj.giverCoinReward = message.giverCoinReward;
        }
        if (message.iconFormat !== undefined) {
            obj.iconFormat = message.iconFormat;
        }
        if (message.iconHeight !== undefined) {
            obj.iconHeight = message.iconHeight;
        }
        if (message.iconUrl !== undefined) {
            obj.iconUrl = message.iconUrl;
        }
        if (message.iconWidth !== undefined) {
            obj.iconWidth = message.iconWidth;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.isEnabled !== undefined) {
            obj.isEnabled = message.isEnabled;
        }
        if (message.isNew !== undefined) {
            obj.isNew = message.isNew;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.pennyDonate !== undefined) {
            obj.pennyDonate = message.pennyDonate;
        }
        if (message.pennyPrice !== undefined) {
            obj.pennyPrice = message.pennyPrice;
        }
        if (message.resizedIcons?.length) {
            obj.resizedIcons = message.resizedIcons.map((e) => Awarding_Icon.toJSON(e));
        }
        if (message.resizedStaticIcons?.length) {
            obj.resizedStaticIcons = message.resizedStaticIcons.map((e) => Awarding_Icon.toJSON(e));
        }
        if (message.startDate !== undefined) {
            obj.startDate = message.startDate;
        }
        if (message.staticIconHeight !== undefined) {
            obj.staticIconHeight = message.staticIconHeight;
        }
        if (message.staticIconUrl !== undefined) {
            obj.staticIconUrl = message.staticIconUrl;
        }
        if (message.staticIconWidth !== undefined) {
            obj.staticIconWidth = message.staticIconWidth;
        }
        if (message.stickyDurationSeconds !== undefined) {
            obj.stickyDurationSeconds = message.stickyDurationSeconds;
        }
        if (message.subredditCoinReward !== undefined) {
            obj.subredditCoinReward = message.subredditCoinReward;
        }
        if (message.subredditId !== undefined) {
            obj.subredditId = message.subredditId;
        }
        if (message.tiersByRequiredAwardings !== undefined) {
            obj.tiersByRequiredAwardings = message.tiersByRequiredAwardings;
        }
        return obj;
    },
    create(base) {
        return Awarding.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAwarding();
        message.awardSubType = object.awardSubType ?? undefined;
        message.awardType = object.awardType ?? undefined;
        message.awardingsRequiredToGrantBenefits = object.awardingsRequiredToGrantBenefits ?? undefined;
        message.coinPrice = object.coinPrice ?? undefined;
        message.coinReward = object.coinReward ?? undefined;
        message.count = object.count ?? undefined;
        message.daysOfDripExtension = object.daysOfDripExtension ?? undefined;
        message.daysOfPremium = object.daysOfPremium ?? undefined;
        message.description = object.description ?? undefined;
        message.endDate = object.endDate ?? undefined;
        message.giverCoinReward = object.giverCoinReward ?? undefined;
        message.iconFormat = object.iconFormat ?? undefined;
        message.iconHeight = object.iconHeight ?? undefined;
        message.iconUrl = object.iconUrl ?? undefined;
        message.iconWidth = object.iconWidth ?? undefined;
        message.id = object.id ?? undefined;
        message.isEnabled = object.isEnabled ?? undefined;
        message.isNew = object.isNew ?? undefined;
        message.name = object.name ?? undefined;
        message.pennyDonate = object.pennyDonate ?? undefined;
        message.pennyPrice = object.pennyPrice ?? undefined;
        message.resizedIcons = object.resizedIcons?.map((e) => Awarding_Icon.fromPartial(e)) || [];
        message.resizedStaticIcons = object.resizedStaticIcons?.map((e) => Awarding_Icon.fromPartial(e)) || [];
        message.startDate = object.startDate ?? undefined;
        message.staticIconHeight = object.staticIconHeight ?? undefined;
        message.staticIconUrl = object.staticIconUrl ?? undefined;
        message.staticIconWidth = object.staticIconWidth ?? undefined;
        message.stickyDurationSeconds = object.stickyDurationSeconds ?? undefined;
        message.subredditCoinReward = object.subredditCoinReward ?? undefined;
        message.subredditId = object.subredditId ?? undefined;
        message.tiersByRequiredAwardings = object.tiersByRequiredAwardings ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(Awarding.$type, Awarding);
function createBaseAwarding_Icon() {
    return { height: undefined, url: undefined, width: undefined };
}
export const Awarding_Icon = {
    $type: "devvit.reddit.Awarding.Icon",
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(10).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAwarding_Icon();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet(object.height) ? Number(object.height) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== undefined) {
            obj.height = message.height;
        }
        if (message.url !== undefined) {
            obj.url = message.url;
        }
        if (message.width !== undefined) {
            obj.width = message.width;
        }
        return obj;
    },
    create(base) {
        return Awarding_Icon.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAwarding_Icon();
        message.height = object.height ?? undefined;
        message.url = object.url ?? undefined;
        message.width = object.width ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(Awarding_Icon.$type, Awarding_Icon);
function createBaseCommentContributionSettings() {
    return { allowedMediaTypes: [] };
}
export const CommentContributionSettings = {
    $type: "devvit.reddit.CommentContributionSettings",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.allowedMediaTypes) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommentContributionSettings();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.allowedMediaTypes.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            allowedMediaTypes: globalThis.Array.isArray(object?.allowedMediaTypes)
                ? object.allowedMediaTypes.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.allowedMediaTypes?.length) {
            obj.allowedMediaTypes = message.allowedMediaTypes;
        }
        return obj;
    },
    create(base) {
        return CommentContributionSettings.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommentContributionSettings();
        message.allowedMediaTypes = object.allowedMediaTypes?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set(CommentContributionSettings.$type, CommentContributionSettings);
function createBaseGildings() {
    return { gid1: undefined, gid2: undefined, gid3: undefined };
}
export const Gildings = {
    $type: "devvit.reddit.Gildings",
    encode(message, writer = _m0.Writer.create()) {
        if (message.gid1 !== undefined) {
            Int32Value.encode({ value: message.gid1 }, writer.uint32(10).fork()).ldelim();
        }
        if (message.gid2 !== undefined) {
            Int32Value.encode({ value: message.gid2 }, writer.uint32(18).fork()).ldelim();
        }
        if (message.gid3 !== undefined) {
            Int32Value.encode({ value: message.gid3 }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGildings();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.gid1 = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.gid2 = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.gid3 = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            gid1: isSet(object.gid1) ? Number(object.gid1) : undefined,
            gid2: isSet(object.gid2) ? Number(object.gid2) : undefined,
            gid3: isSet(object.gid3) ? Number(object.gid3) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.gid1 !== undefined) {
            obj.gid1 = message.gid1;
        }
        if (message.gid2 !== undefined) {
            obj.gid2 = message.gid2;
        }
        if (message.gid3 !== undefined) {
            obj.gid3 = message.gid3;
        }
        return obj;
    },
    create(base) {
        return Gildings.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGildings();
        message.gid1 = object.gid1 ?? undefined;
        message.gid2 = object.gid2 ?? undefined;
        message.gid3 = object.gid3 ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(Gildings.$type, Gildings);
function createBaseMediaEmbed() {
    return {
        content: undefined,
        width: undefined,
        height: undefined,
        sandbox: undefined,
        scrolling: undefined,
        publicThumbnailUrl: undefined,
    };
}
export const MediaEmbed = {
    $type: "devvit.reddit.MediaEmbed",
    encode(message, writer = _m0.Writer.create()) {
        if (message.content !== undefined) {
            StringValue.encode({ value: message.content }, writer.uint32(10).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(26).fork()).ldelim();
        }
        if (message.sandbox !== undefined) {
            BoolValue.encode({ value: message.sandbox }, writer.uint32(34).fork()).ldelim();
        }
        if (message.scrolling !== undefined) {
            BoolValue.encode({ value: message.scrolling }, writer.uint32(42).fork()).ldelim();
        }
        if (message.publicThumbnailUrl !== undefined) {
            StringValue.encode({ value: message.publicThumbnailUrl }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMediaEmbed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.content = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.sandbox = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.scrolling = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.publicThumbnailUrl = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            content: isSet(object.content) ? String(object.content) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
            sandbox: isSet(object.sandbox) ? Boolean(object.sandbox) : undefined,
            scrolling: isSet(object.scrolling) ? Boolean(object.scrolling) : undefined,
            publicThumbnailUrl: isSet(object.publicThumbnailUrl) ? String(object.publicThumbnailUrl) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.content !== undefined) {
            obj.content = message.content;
        }
        if (message.width !== undefined) {
            obj.width = message.width;
        }
        if (message.height !== undefined) {
            obj.height = message.height;
        }
        if (message.sandbox !== undefined) {
            obj.sandbox = message.sandbox;
        }
        if (message.scrolling !== undefined) {
            obj.scrolling = message.scrolling;
        }
        if (message.publicThumbnailUrl !== undefined) {
            obj.publicThumbnailUrl = message.publicThumbnailUrl;
        }
        return obj;
    },
    create(base) {
        return MediaEmbed.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMediaEmbed();
        message.content = object.content ?? undefined;
        message.width = object.width ?? undefined;
        message.height = object.height ?? undefined;
        message.sandbox = object.sandbox ?? undefined;
        message.scrolling = object.scrolling ?? undefined;
        message.publicThumbnailUrl = object.publicThumbnailUrl ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(MediaEmbed.$type, MediaEmbed);
function createBaseUserFlairRichtext() {
    return { e: undefined, t: undefined };
}
export const UserFlairRichtext = {
    $type: "devvit.reddit.UserFlairRichtext",
    encode(message, writer = _m0.Writer.create()) {
        if (message.e !== undefined) {
            StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
        }
        if (message.t !== undefined) {
            StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserFlairRichtext();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.e = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.t = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { e: isSet(object.e) ? String(object.e) : undefined, t: isSet(object.t) ? String(object.t) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.e !== undefined) {
            obj.e = message.e;
        }
        if (message.t !== undefined) {
            obj.t = message.t;
        }
        return obj;
    },
    create(base) {
        return UserFlairRichtext.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserFlairRichtext();
        message.e = object.e ?? undefined;
        message.t = object.t ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(UserFlairRichtext.$type, UserFlairRichtext);
function createBaseBanInfo() {
    return {
        auto: undefined,
        bannedAt: undefined,
        banner: undefined,
        moderatorBanned: undefined,
        note: undefined,
        unbanner: undefined,
        unbannedAt: undefined,
        resetUsed: undefined,
        reasonId: undefined,
        reasonTitle: undefined,
        reasonMessage: undefined,
        reasonBy: undefined,
        modNote: undefined,
        banAllTriggered: undefined,
        subredditMessage: undefined,
        removeAction: 0,
    };
}
export const BanInfo = {
    $type: "devvit.reddit.BanInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.auto !== undefined) {
            BoolValue.encode({ value: message.auto }, writer.uint32(10).fork()).ldelim();
        }
        if (message.bannedAt !== undefined) {
            Int32Value.encode({ value: message.bannedAt }, writer.uint32(18).fork()).ldelim();
        }
        if (message.banner !== undefined) {
            StringValue.encode({ value: message.banner }, writer.uint32(26).fork()).ldelim();
        }
        if (message.moderatorBanned !== undefined) {
            BoolValue.encode({ value: message.moderatorBanned }, writer.uint32(34).fork()).ldelim();
        }
        if (message.note !== undefined) {
            StringValue.encode({ value: message.note }, writer.uint32(42).fork()).ldelim();
        }
        if (message.unbanner !== undefined) {
            StringValue.encode({ value: message.unbanner }, writer.uint32(50).fork()).ldelim();
        }
        if (message.unbannedAt !== undefined) {
            Int32Value.encode({ value: message.unbannedAt }, writer.uint32(58).fork()).ldelim();
        }
        if (message.resetUsed !== undefined) {
            BoolValue.encode({ value: message.resetUsed }, writer.uint32(66).fork()).ldelim();
        }
        if (message.reasonId !== undefined) {
            StringValue.encode({ value: message.reasonId }, writer.uint32(74).fork()).ldelim();
        }
        if (message.reasonTitle !== undefined) {
            StringValue.encode({ value: message.reasonTitle }, writer.uint32(82).fork()).ldelim();
        }
        if (message.reasonMessage !== undefined) {
            StringValue.encode({ value: message.reasonMessage }, writer.uint32(90).fork()).ldelim();
        }
        if (message.reasonBy !== undefined) {
            StringValue.encode({ value: message.reasonBy }, writer.uint32(98).fork()).ldelim();
        }
        if (message.modNote !== undefined) {
            StringValue.encode({ value: message.modNote }, writer.uint32(106).fork()).ldelim();
        }
        if (message.banAllTriggered !== undefined) {
            BoolValue.encode({ value: message.banAllTriggered }, writer.uint32(114).fork()).ldelim();
        }
        if (message.subredditMessage !== undefined) {
            StringValue.encode({ value: message.subredditMessage }, writer.uint32(122).fork()).ldelim();
        }
        if (message.removeAction !== 0) {
            writer.uint32(128).int32(message.removeAction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBanInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.auto = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bannedAt = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.banner = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.moderatorBanned = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.note = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.unbanner = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.unbannedAt = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.resetUsed = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.reasonId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.reasonTitle = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.reasonMessage = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.reasonBy = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.modNote = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.banAllTriggered = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.subredditMessage = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 16:
                    if (tag !== 128) {
                        break;
                    }
                    message.removeAction = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            auto: isSet(object.auto) ? Boolean(object.auto) : undefined,
            bannedAt: isSet(object.bannedAt) ? Number(object.bannedAt) : undefined,
            banner: isSet(object.banner) ? String(object.banner) : undefined,
            moderatorBanned: isSet(object.moderatorBanned) ? Boolean(object.moderatorBanned) : undefined,
            note: isSet(object.note) ? String(object.note) : undefined,
            unbanner: isSet(object.unbanner) ? String(object.unbanner) : undefined,
            unbannedAt: isSet(object.unbannedAt) ? Number(object.unbannedAt) : undefined,
            resetUsed: isSet(object.resetUsed) ? Boolean(object.resetUsed) : undefined,
            reasonId: isSet(object.reasonId) ? String(object.reasonId) : undefined,
            reasonTitle: isSet(object.reasonTitle) ? String(object.reasonTitle) : undefined,
            reasonMessage: isSet(object.reasonMessage) ? String(object.reasonMessage) : undefined,
            reasonBy: isSet(object.reasonBy) ? String(object.reasonBy) : undefined,
            modNote: isSet(object.modNote) ? String(object.modNote) : undefined,
            banAllTriggered: isSet(object.banAllTriggered) ? Boolean(object.banAllTriggered) : undefined,
            subredditMessage: isSet(object.subredditMessage) ? String(object.subredditMessage) : undefined,
            removeAction: isSet(object.removeAction) ? banInfo_BanInfoActionFromJSON(object.removeAction) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.auto !== undefined) {
            obj.auto = message.auto;
        }
        if (message.bannedAt !== undefined) {
            obj.bannedAt = message.bannedAt;
        }
        if (message.banner !== undefined) {
            obj.banner = message.banner;
        }
        if (message.moderatorBanned !== undefined) {
            obj.moderatorBanned = message.moderatorBanned;
        }
        if (message.note !== undefined) {
            obj.note = message.note;
        }
        if (message.unbanner !== undefined) {
            obj.unbanner = message.unbanner;
        }
        if (message.unbannedAt !== undefined) {
            obj.unbannedAt = message.unbannedAt;
        }
        if (message.resetUsed !== undefined) {
            obj.resetUsed = message.resetUsed;
        }
        if (message.reasonId !== undefined) {
            obj.reasonId = message.reasonId;
        }
        if (message.reasonTitle !== undefined) {
            obj.reasonTitle = message.reasonTitle;
        }
        if (message.reasonMessage !== undefined) {
            obj.reasonMessage = message.reasonMessage;
        }
        if (message.reasonBy !== undefined) {
            obj.reasonBy = message.reasonBy;
        }
        if (message.modNote !== undefined) {
            obj.modNote = message.modNote;
        }
        if (message.banAllTriggered !== undefined) {
            obj.banAllTriggered = message.banAllTriggered;
        }
        if (message.subredditMessage !== undefined) {
            obj.subredditMessage = message.subredditMessage;
        }
        if (message.removeAction !== 0) {
            obj.removeAction = banInfo_BanInfoActionToJSON(message.removeAction);
        }
        return obj;
    },
    create(base) {
        return BanInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBanInfo();
        message.auto = object.auto ?? undefined;
        message.bannedAt = object.bannedAt ?? undefined;
        message.banner = object.banner ?? undefined;
        message.moderatorBanned = object.moderatorBanned ?? undefined;
        message.note = object.note ?? undefined;
        message.unbanner = object.unbanner ?? undefined;
        message.unbannedAt = object.unbannedAt ?? undefined;
        message.resetUsed = object.resetUsed ?? undefined;
        message.reasonId = object.reasonId ?? undefined;
        message.reasonTitle = object.reasonTitle ?? undefined;
        message.reasonMessage = object.reasonMessage ?? undefined;
        message.reasonBy = object.reasonBy ?? undefined;
        message.modNote = object.modNote ?? undefined;
        message.banAllTriggered = object.banAllTriggered ?? undefined;
        message.subredditMessage = object.subredditMessage ?? undefined;
        message.removeAction = object.removeAction ?? 0;
        return message;
    },
};
messageTypeRegistry.set(BanInfo.$type, BanInfo);
function isSet(value) {
    return value !== null && value !== undefined;
}
