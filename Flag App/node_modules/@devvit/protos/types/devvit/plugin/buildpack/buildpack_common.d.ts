/**
 * #buildpack_common.ts
 *
 * @packageDocumentation
 */
import _m0 from 'protobufjs/minimal.js';
import { ActorSpec, BuildInfo, DependencySpec } from '../../runtime/bundle.js';
import { FileSystem } from './filesystem.js';
export declare enum Minify {
    /** NONE - Disable minification. The default. */
    NONE = 0,
    /** ALL - Minify everything. */
    ALL = 1,
    UNRECOGNIZED = -1
}
export declare function minifyFromJSON(object: any): Minify;
export declare function minifyToJSON(object: Minify): number;
/** Actor program and configuration. */
export interface Bundle {
    /** See LinkedBundle.code. */
    code: string;
    /**
     * This is the the detail on the bundle itself **and** its dependendencies.
     *
     * to-do: Can we can rename to "spec" or something like that. This is really
     *   confusing because if you want the Bundle's exported actor name (ie,
     *   `Devvit.init(name, ...)`), you have to ask for it form the dependencies
     *   which doesn't make sense.
     */
    dependencies?: DependencySpec | undefined;
    /**
     * Optional information about the environment the code was built in. Outdated
     * dependencies may indicate an invalid build.
     */
    buildInfo?: BuildInfo | undefined;
    /**
     * Contents of the ./assets directory, rooted at the ./assets directory.
     *
     * @deprecated
     */
    assets?: FileSystem | undefined;
    /**
     * This map contains the contents of the assets directory, rooted at the
     * assets directory. The keys are the relative paths of the files, and the
     * values are the devvit asset ids used to look up the asset during upload
     *  e.g. "images/en/banner.jpg": "30d509ee-208d-4b45-86b8-b48ef48cc524",
     */
    assetIds: {
        [key: string]: string;
    };
}
export interface Bundle_AssetIdsEntry {
    key: string;
    value: string;
}
export interface CompileParams {
    /**
     * This is the stateless version, where the entire information needed to be
     * bundled is included with the request.  This **MUST** be supported for all
     * languages/implementations.
     */
    virtualFileSystem?: FileSystem | undefined;
    /**
     * Path to a directory with a file named BuildPack.DevvitModuleEntryPoint.
     *
     * Here we assume that we've transferred the repo to the build server using
     * rsync, git, or some other efficient protocol with e.g. deltas and
     * compression.
     *
     * This **MAY** be supported for various languages/implementations, and the
     * rsync-like protocol is left as an exercise for the build pack
     * implementor.
     */
    filename?: string | undefined;
    minify: Minify;
    info?: ActorSpec | undefined;
    includeAssets: boolean;
}
export interface CompileLog {
    detail?: CompileLogLineDetail | undefined;
    text: string;
}
export interface CompileLogLineDetail {
    /** 0-based. */
    column: number;
    filename: string;
    /** 1-based. */
    line: number;
    suggestion: string;
    text: string;
}
export interface CompileResponse {
    /** This bundle may be present even when the build was erroneous. */
    bundle?: Bundle | undefined;
    errors: CompileLog[];
    warnings: CompileLog[];
}
export declare const Bundle: {
    $type: "devvit.plugin.buildpack.Bundle";
    encode(message: Bundle, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Bundle;
    fromJSON(object: any): Bundle;
    toJSON(message: Bundle): unknown;
    create(base?: DeepPartial<Bundle>): Bundle;
    fromPartial(object: DeepPartial<Bundle>): Bundle;
};
export declare const Bundle_AssetIdsEntry: {
    $type: "devvit.plugin.buildpack.Bundle.AssetIdsEntry";
    encode(message: Bundle_AssetIdsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Bundle_AssetIdsEntry;
    fromJSON(object: any): Bundle_AssetIdsEntry;
    toJSON(message: Bundle_AssetIdsEntry): unknown;
    create(base?: DeepPartial<Bundle_AssetIdsEntry>): Bundle_AssetIdsEntry;
    fromPartial(object: DeepPartial<Bundle_AssetIdsEntry>): Bundle_AssetIdsEntry;
};
export declare const CompileParams: {
    $type: "devvit.plugin.buildpack.CompileParams";
    encode(message: CompileParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileParams;
    fromJSON(object: any): CompileParams;
    toJSON(message: CompileParams): unknown;
    create(base?: DeepPartial<CompileParams>): CompileParams;
    fromPartial(object: DeepPartial<CompileParams>): CompileParams;
};
export declare const CompileLog: {
    $type: "devvit.plugin.buildpack.CompileLog";
    encode(message: CompileLog, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileLog;
    fromJSON(object: any): CompileLog;
    toJSON(message: CompileLog): unknown;
    create(base?: DeepPartial<CompileLog>): CompileLog;
    fromPartial(object: DeepPartial<CompileLog>): CompileLog;
};
export declare const CompileLogLineDetail: {
    $type: "devvit.plugin.buildpack.CompileLogLineDetail";
    encode(message: CompileLogLineDetail, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileLogLineDetail;
    fromJSON(object: any): CompileLogLineDetail;
    toJSON(message: CompileLogLineDetail): unknown;
    create(base?: DeepPartial<CompileLogLineDetail>): CompileLogLineDetail;
    fromPartial(object: DeepPartial<CompileLogLineDetail>): CompileLogLineDetail;
};
export declare const CompileResponse: {
    $type: "devvit.plugin.buildpack.CompileResponse";
    encode(message: CompileResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileResponse;
    fromJSON(object: any): CompileResponse;
    toJSON(message: CompileResponse): unknown;
    create(base?: DeepPartial<CompileResponse>): CompileResponse;
    fromPartial(object: DeepPartial<CompileResponse>): CompileResponse;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=buildpack_common.d.ts.map