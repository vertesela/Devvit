/**
 * #users_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int32Value, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { User } from '../../../reddit/user.js';
function createBaseGenericUsersRequest() {
    return { id: undefined, username: "" };
}
export const GenericUsersRequest = {
    $type: "devvit.plugin.redditapi.users.GenericUsersRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
        }
        if (message.username !== "") {
            writer.uint32(18).string(message.username);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenericUsersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : undefined,
            username: isSet(object.username) ? globalThis.String(object.username) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.username !== "") {
            obj.username = message.username;
        }
        return obj;
    },
    create(base) {
        return GenericUsersRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGenericUsersRequest();
        message.id = object.id ?? undefined;
        message.username = object.username ?? "";
        return message;
    },
};
messageTypeRegistry.set(GenericUsersRequest.$type, GenericUsersRequest);
function createBaseBlockUserRequest() {
    return { accountId: undefined, name: undefined };
}
export const BlockUserRequest = {
    $type: "devvit.plugin.redditapi.users.BlockUserRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.accountId !== undefined) {
            StringValue.encode({ value: message.accountId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockUserRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.accountId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            accountId: isSet(object.accountId) ? String(object.accountId) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.accountId !== undefined) {
            obj.accountId = message.accountId;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return BlockUserRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockUserRequest();
        message.accountId = object.accountId ?? undefined;
        message.name = object.name ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(BlockUserRequest.$type, BlockUserRequest);
function createBaseFriendRequest() {
    return {
        banContext: undefined,
        banMessage: undefined,
        banReason: undefined,
        duration: undefined,
        name: "",
        note: undefined,
        permissions: undefined,
        type: "",
        subreddit: undefined,
    };
}
export const FriendRequest = {
    $type: "devvit.plugin.redditapi.users.FriendRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.banContext !== undefined) {
            StringValue.encode({ value: message.banContext }, writer.uint32(10).fork()).ldelim();
        }
        if (message.banMessage !== undefined) {
            StringValue.encode({ value: message.banMessage }, writer.uint32(18).fork()).ldelim();
        }
        if (message.banReason !== undefined) {
            StringValue.encode({ value: message.banReason }, writer.uint32(26).fork()).ldelim();
        }
        if (message.duration !== undefined) {
            Int32Value.encode({ value: message.duration }, writer.uint32(34).fork()).ldelim();
        }
        if (message.name !== "") {
            writer.uint32(42).string(message.name);
        }
        if (message.note !== undefined) {
            StringValue.encode({ value: message.note }, writer.uint32(50).fork()).ldelim();
        }
        if (message.permissions !== undefined) {
            StringValue.encode({ value: message.permissions }, writer.uint32(58).fork()).ldelim();
        }
        if (message.type !== "") {
            writer.uint32(66).string(message.type);
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFriendRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.banContext = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.banMessage = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.banReason = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.duration = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.note = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.permissions = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            banContext: isSet(object.banContext) ? String(object.banContext) : undefined,
            banMessage: isSet(object.banMessage) ? String(object.banMessage) : undefined,
            banReason: isSet(object.banReason) ? String(object.banReason) : undefined,
            duration: isSet(object.duration) ? Number(object.duration) : undefined,
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            note: isSet(object.note) ? String(object.note) : undefined,
            permissions: isSet(object.permissions) ? String(object.permissions) : undefined,
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.banContext !== undefined) {
            obj.banContext = message.banContext;
        }
        if (message.banMessage !== undefined) {
            obj.banMessage = message.banMessage;
        }
        if (message.banReason !== undefined) {
            obj.banReason = message.banReason;
        }
        if (message.duration !== undefined) {
            obj.duration = message.duration;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.note !== undefined) {
            obj.note = message.note;
        }
        if (message.permissions !== undefined) {
            obj.permissions = message.permissions;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        return obj;
    },
    create(base) {
        return FriendRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFriendRequest();
        message.banContext = object.banContext ?? undefined;
        message.banMessage = object.banMessage ?? undefined;
        message.banReason = object.banReason ?? undefined;
        message.duration = object.duration ?? undefined;
        message.name = object.name ?? "";
        message.note = object.note ?? undefined;
        message.permissions = object.permissions ?? undefined;
        message.type = object.type ?? "";
        message.subreddit = object.subreddit ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(FriendRequest.$type, FriendRequest);
function createBaseReportUserRequest() {
    return { details: "", reason: "", user: "" };
}
export const ReportUserRequest = {
    $type: "devvit.plugin.redditapi.users.ReportUserRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.details !== "") {
            writer.uint32(10).string(message.details);
        }
        if (message.reason !== "") {
            writer.uint32(18).string(message.reason);
        }
        if (message.user !== "") {
            writer.uint32(26).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReportUserRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.details = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.reason = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.user = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: isSet(object.details) ? globalThis.String(object.details) : "",
            reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
            user: isSet(object.user) ? globalThis.String(object.user) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.details !== "") {
            obj.details = message.details;
        }
        if (message.reason !== "") {
            obj.reason = message.reason;
        }
        if (message.user !== "") {
            obj.user = message.user;
        }
        return obj;
    },
    create(base) {
        return ReportUserRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseReportUserRequest();
        message.details = object.details ?? "";
        message.reason = object.reason ?? "";
        message.user = object.user ?? "";
        return message;
    },
};
messageTypeRegistry.set(ReportUserRequest.$type, ReportUserRequest);
function createBaseSetPermissionsRequest() {
    return { name: "", subreddit: "", permissions: "", type: "" };
}
export const SetPermissionsRequest = {
    $type: "devvit.plugin.redditapi.users.SetPermissionsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.subreddit !== "") {
            writer.uint32(18).string(message.subreddit);
        }
        if (message.permissions !== "") {
            writer.uint32(26).string(message.permissions);
        }
        if (message.type !== "") {
            writer.uint32(34).string(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetPermissionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.permissions = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            permissions: isSet(object.permissions) ? globalThis.String(object.permissions) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.permissions !== "") {
            obj.permissions = message.permissions;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        return obj;
    },
    create(base) {
        return SetPermissionsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetPermissionsRequest();
        message.name = object.name ?? "";
        message.subreddit = object.subreddit ?? "";
        message.permissions = object.permissions ?? "";
        message.type = object.type ?? "";
        return message;
    },
};
messageTypeRegistry.set(SetPermissionsRequest.$type, SetPermissionsRequest);
function createBaseUnfriendRequest() {
    return { id: undefined, name: undefined, type: "", subreddit: undefined };
}
export const UnfriendRequest = {
    $type: "devvit.plugin.redditapi.users.UnfriendRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(18).fork()).ldelim();
        }
        if (message.type !== "") {
            writer.uint32(26).string(message.type);
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnfriendRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        return obj;
    },
    create(base) {
        return UnfriendRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUnfriendRequest();
        message.id = object.id ?? undefined;
        message.name = object.name ?? undefined;
        message.type = object.type ?? "";
        message.subreddit = object.subreddit ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(UnfriendRequest.$type, UnfriendRequest);
function createBaseUserDataByAccountIdsRequest() {
    return { ids: "" };
}
export const UserDataByAccountIdsRequest = {
    $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.ids !== "") {
            writer.uint32(10).string(message.ids);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserDataByAccountIdsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.ids = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { ids: isSet(object.ids) ? globalThis.String(object.ids) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids !== "") {
            obj.ids = message.ids;
        }
        return obj;
    },
    create(base) {
        return UserDataByAccountIdsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserDataByAccountIdsRequest();
        message.ids = object.ids ?? "";
        return message;
    },
};
messageTypeRegistry.set(UserDataByAccountIdsRequest.$type, UserDataByAccountIdsRequest);
function createBaseUsernameAvailableRequest() {
    return { user: "" };
}
export const UsernameAvailableRequest = {
    $type: "devvit.plugin.redditapi.users.UsernameAvailableRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.user !== "") {
            writer.uint32(10).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUsernameAvailableRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.user = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { user: isSet(object.user) ? globalThis.String(object.user) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.user !== "") {
            obj.user = message.user;
        }
        return obj;
    },
    create(base) {
        return UsernameAvailableRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUsernameAvailableRequest();
        message.user = object.user ?? "";
        return message;
    },
};
messageTypeRegistry.set(UsernameAvailableRequest.$type, UsernameAvailableRequest);
function createBaseUpdateFriendRelationshipRequest() {
    return { name: "", note: "" };
}
export const UpdateFriendRelationshipRequest = {
    $type: "devvit.plugin.redditapi.users.UpdateFriendRelationshipRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.note !== "") {
            writer.uint32(18).string(message.note);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateFriendRelationshipRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.note = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            note: isSet(object.note) ? globalThis.String(object.note) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.note !== "") {
            obj.note = message.note;
        }
        return obj;
    },
    create(base) {
        return UpdateFriendRelationshipRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateFriendRelationshipRequest();
        message.name = object.name ?? "";
        message.note = object.note ?? "";
        return message;
    },
};
messageTypeRegistry.set(UpdateFriendRelationshipRequest.$type, UpdateFriendRelationshipRequest);
function createBaseUserAboutRequest() {
    return { username: "" };
}
export const UserAboutRequest = {
    $type: "devvit.plugin.redditapi.users.UserAboutRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.username !== "") {
            writer.uint32(10).string(message.username);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserAboutRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.username !== "") {
            obj.username = message.username;
        }
        return obj;
    },
    create(base) {
        return UserAboutRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserAboutRequest();
        message.username = object.username ?? "";
        return message;
    },
};
messageTypeRegistry.set(UserAboutRequest.$type, UserAboutRequest);
function createBaseUserWhereRequest() {
    return {
        context: undefined,
        show: undefined,
        sort: undefined,
        t: undefined,
        type: undefined,
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        username: undefined,
        where: "",
    };
}
export const UserWhereRequest = {
    $type: "devvit.plugin.redditapi.users.UserWhereRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.context !== undefined) {
            Int32Value.encode({ value: message.context }, writer.uint32(10).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(18).fork()).ldelim();
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(26).fork()).ldelim();
        }
        if (message.t !== undefined) {
            StringValue.encode({ value: message.t }, writer.uint32(34).fork()).ldelim();
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(42).fork()).ldelim();
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(50).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(58).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(66).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int32Value.encode({ value: message.limit }, writer.uint32(74).fork()).ldelim();
        }
        if (message.username !== undefined) {
            StringValue.encode({ value: message.username }, writer.uint32(90).fork()).ldelim();
        }
        if (message.where !== "") {
            writer.uint32(98).string(message.where);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserWhereRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.context = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.t = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.limit = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.username = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.where = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            context: isSet(object.context) ? Number(object.context) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            t: isSet(object.t) ? String(object.t) : undefined,
            type: isSet(object.type) ? String(object.type) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            username: isSet(object.username) ? String(object.username) : undefined,
            where: isSet(object.where) ? globalThis.String(object.where) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.context !== undefined) {
            obj.context = message.context;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        if (message.sort !== undefined) {
            obj.sort = message.sort;
        }
        if (message.t !== undefined) {
            obj.t = message.t;
        }
        if (message.type !== undefined) {
            obj.type = message.type;
        }
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.username !== undefined) {
            obj.username = message.username;
        }
        if (message.where !== "") {
            obj.where = message.where;
        }
        return obj;
    },
    create(base) {
        return UserWhereRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserWhereRequest();
        message.context = object.context ?? undefined;
        message.show = object.show ?? undefined;
        message.sort = object.sort ?? undefined;
        message.t = object.t ?? undefined;
        message.type = object.type ?? undefined;
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.username = object.username ?? undefined;
        message.where = object.where ?? "";
        return message;
    },
};
messageTypeRegistry.set(UserWhereRequest.$type, UserWhereRequest);
function createBaseGeneralFriendResponse() {
    return {
        date: undefined,
        relId: undefined,
        name: undefined,
        id: undefined,
        fields: [],
        explanation: undefined,
        message: undefined,
        reason: undefined,
    };
}
export const GeneralFriendResponse = {
    $type: "devvit.plugin.redditapi.users.GeneralFriendResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.date !== undefined) {
            Int64Value.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
        }
        if (message.relId !== undefined) {
            StringValue.encode({ value: message.relId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.fields) {
            StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
        }
        if (message.explanation !== undefined) {
            StringValue.encode({ value: message.explanation }, writer.uint32(50).fork()).ldelim();
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGeneralFriendResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.date = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.relId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.fields.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.explanation = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            date: isSet(object.date) ? Number(object.date) : undefined,
            relId: isSet(object.relId) ? String(object.relId) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
            explanation: isSet(object.explanation) ? String(object.explanation) : undefined,
            message: isSet(object.message) ? String(object.message) : undefined,
            reason: isSet(object.reason) ? String(object.reason) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.date !== undefined) {
            obj.date = message.date;
        }
        if (message.relId !== undefined) {
            obj.relId = message.relId;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.fields?.length) {
            obj.fields = message.fields;
        }
        if (message.explanation !== undefined) {
            obj.explanation = message.explanation;
        }
        if (message.message !== undefined) {
            obj.message = message.message;
        }
        if (message.reason !== undefined) {
            obj.reason = message.reason;
        }
        return obj;
    },
    create(base) {
        return GeneralFriendResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGeneralFriendResponse();
        message.date = object.date ?? undefined;
        message.relId = object.relId ?? undefined;
        message.name = object.name ?? undefined;
        message.id = object.id ?? undefined;
        message.fields = object.fields?.map((e) => e) || [];
        message.explanation = object.explanation ?? undefined;
        message.message = object.message ?? undefined;
        message.reason = object.reason ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(GeneralFriendResponse.$type, GeneralFriendResponse);
function createBaseBlockUserResponse() {
    return { date: undefined, iconImg: undefined, id: undefined, name: undefined };
}
export const BlockUserResponse = {
    $type: "devvit.plugin.redditapi.users.BlockUserResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.date !== undefined) {
            Int64Value.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
        }
        if (message.iconImg !== undefined) {
            StringValue.encode({ value: message.iconImg }, writer.uint32(18).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockUserResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.date = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.iconImg = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            date: isSet(object.date) ? Number(object.date) : undefined,
            iconImg: isSet(object.iconImg) ? String(object.iconImg) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.date !== undefined) {
            obj.date = message.date;
        }
        if (message.iconImg !== undefined) {
            obj.iconImg = message.iconImg;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return BlockUserResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockUserResponse();
        message.date = object.date ?? undefined;
        message.iconImg = object.iconImg ?? undefined;
        message.id = object.id ?? undefined;
        message.name = object.name ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(BlockUserResponse.$type, BlockUserResponse);
function createBaseUserDataByAccountIdsResponse() {
    return { users: {} };
}
export const UserDataByAccountIdsResponse = {
    $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.users).forEach(([key, value]) => {
            UserDataByAccountIdsResponse_UsersEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserDataByAccountIdsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = UserDataByAccountIdsResponse_UsersEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.users[entry1.key] = entry1.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            users: isObject(object.users)
                ? Object.entries(object.users).reduce((acc, [key, value]) => {
                    acc[key] = UserDataByAccountIdsResponse_UserAccountData.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.users) {
            const entries = Object.entries(message.users);
            if (entries.length > 0) {
                obj.users = {};
                entries.forEach(([k, v]) => {
                    obj.users[k] = UserDataByAccountIdsResponse_UserAccountData.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return UserDataByAccountIdsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserDataByAccountIdsResponse();
        message.users = Object.entries(object.users ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = UserDataByAccountIdsResponse_UserAccountData.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(UserDataByAccountIdsResponse.$type, UserDataByAccountIdsResponse);
function createBaseUserDataByAccountIdsResponse_UserAccountData() {
    return {
        name: undefined,
        createdUtc: undefined,
        linkKarma: undefined,
        commentKarma: undefined,
        profileImg: undefined,
        profileColor: undefined,
        profileOver18: undefined,
    };
}
export const UserDataByAccountIdsResponse_UserAccountData = {
    $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UserAccountData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(10).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(18).fork()).ldelim();
        }
        if (message.linkKarma !== undefined) {
            Int64Value.encode({ value: message.linkKarma }, writer.uint32(26).fork()).ldelim();
        }
        if (message.commentKarma !== undefined) {
            Int64Value.encode({ value: message.commentKarma }, writer.uint32(34).fork()).ldelim();
        }
        if (message.profileImg !== undefined) {
            StringValue.encode({ value: message.profileImg }, writer.uint32(42).fork()).ldelim();
        }
        if (message.profileColor !== undefined) {
            StringValue.encode({ value: message.profileColor }, writer.uint32(50).fork()).ldelim();
        }
        if (message.profileOver18 !== undefined) {
            BoolValue.encode({ value: message.profileOver18 }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserDataByAccountIdsResponse_UserAccountData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.linkKarma = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.commentKarma = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.profileImg = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.profileColor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.profileOver18 = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            linkKarma: isSet(object.linkKarma) ? Number(object.linkKarma) : undefined,
            commentKarma: isSet(object.commentKarma) ? Number(object.commentKarma) : undefined,
            profileImg: isSet(object.profileImg) ? String(object.profileImg) : undefined,
            profileColor: isSet(object.profileColor) ? String(object.profileColor) : undefined,
            profileOver18: isSet(object.profileOver18) ? Boolean(object.profileOver18) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.createdUtc !== undefined) {
            obj.createdUtc = message.createdUtc;
        }
        if (message.linkKarma !== undefined) {
            obj.linkKarma = message.linkKarma;
        }
        if (message.commentKarma !== undefined) {
            obj.commentKarma = message.commentKarma;
        }
        if (message.profileImg !== undefined) {
            obj.profileImg = message.profileImg;
        }
        if (message.profileColor !== undefined) {
            obj.profileColor = message.profileColor;
        }
        if (message.profileOver18 !== undefined) {
            obj.profileOver18 = message.profileOver18;
        }
        return obj;
    },
    create(base) {
        return UserDataByAccountIdsResponse_UserAccountData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserDataByAccountIdsResponse_UserAccountData();
        message.name = object.name ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.linkKarma = object.linkKarma ?? undefined;
        message.commentKarma = object.commentKarma ?? undefined;
        message.profileImg = object.profileImg ?? undefined;
        message.profileColor = object.profileColor ?? undefined;
        message.profileOver18 = object.profileOver18 ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(UserDataByAccountIdsResponse_UserAccountData.$type, UserDataByAccountIdsResponse_UserAccountData);
function createBaseUserDataByAccountIdsResponse_UsersEntry() {
    return { key: "", value: undefined };
}
export const UserDataByAccountIdsResponse_UsersEntry = {
    $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UsersEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            UserDataByAccountIdsResponse_UserAccountData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserDataByAccountIdsResponse_UsersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = UserDataByAccountIdsResponse_UserAccountData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? UserDataByAccountIdsResponse_UserAccountData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = UserDataByAccountIdsResponse_UserAccountData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return UserDataByAccountIdsResponse_UsersEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserDataByAccountIdsResponse_UsersEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? UserDataByAccountIdsResponse_UserAccountData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(UserDataByAccountIdsResponse_UsersEntry.$type, UserDataByAccountIdsResponse_UsersEntry);
function createBaseUserTrophiesResponse() {
    return { kind: undefined, data: undefined };
}
export const UserTrophiesResponse = {
    $type: "devvit.plugin.redditapi.users.UserTrophiesResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            UserTrophiesResponse_UserTrophiesData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserTrophiesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = UserTrophiesResponse_UserTrophiesData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? UserTrophiesResponse_UserTrophiesData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.kind !== undefined) {
            obj.kind = message.kind;
        }
        if (message.data !== undefined) {
            obj.data = UserTrophiesResponse_UserTrophiesData.toJSON(message.data);
        }
        return obj;
    },
    create(base) {
        return UserTrophiesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserTrophiesResponse();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? UserTrophiesResponse_UserTrophiesData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(UserTrophiesResponse.$type, UserTrophiesResponse);
function createBaseUserTrophiesResponse_TrophiesData() {
    return {
        icon70: undefined,
        grantedAt: undefined,
        url: undefined,
        icon40: undefined,
        name: undefined,
        awardId: undefined,
        id: undefined,
        description: undefined,
    };
}
export const UserTrophiesResponse_TrophiesData = {
    $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.icon70 !== undefined) {
            StringValue.encode({ value: message.icon70 }, writer.uint32(10).fork()).ldelim();
        }
        if (message.grantedAt !== undefined) {
            Int64Value.encode({ value: message.grantedAt }, writer.uint32(18).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
        }
        if (message.icon40 !== undefined) {
            StringValue.encode({ value: message.icon40 }, writer.uint32(34).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(42).fork()).ldelim();
        }
        if (message.awardId !== undefined) {
            StringValue.encode({ value: message.awardId }, writer.uint32(50).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserTrophiesResponse_TrophiesData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.icon70 = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.grantedAt = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.icon40 = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.awardId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            icon70: isSet(object.icon70) ? String(object.icon70) : undefined,
            grantedAt: isSet(object.grantedAt) ? Number(object.grantedAt) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            icon40: isSet(object.icon40) ? String(object.icon40) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            awardId: isSet(object.awardId) ? String(object.awardId) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.icon70 !== undefined) {
            obj.icon70 = message.icon70;
        }
        if (message.grantedAt !== undefined) {
            obj.grantedAt = message.grantedAt;
        }
        if (message.url !== undefined) {
            obj.url = message.url;
        }
        if (message.icon40 !== undefined) {
            obj.icon40 = message.icon40;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.awardId !== undefined) {
            obj.awardId = message.awardId;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return UserTrophiesResponse_TrophiesData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserTrophiesResponse_TrophiesData();
        message.icon70 = object.icon70 ?? undefined;
        message.grantedAt = object.grantedAt ?? undefined;
        message.url = object.url ?? undefined;
        message.icon40 = object.icon40 ?? undefined;
        message.name = object.name ?? undefined;
        message.awardId = object.awardId ?? undefined;
        message.id = object.id ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(UserTrophiesResponse_TrophiesData.$type, UserTrophiesResponse_TrophiesData);
function createBaseUserTrophiesResponse_TrophiesType() {
    return { kind: undefined, data: undefined };
}
export const UserTrophiesResponse_TrophiesType = {
    $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesType",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            UserTrophiesResponse_TrophiesData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserTrophiesResponse_TrophiesType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = UserTrophiesResponse_TrophiesData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? UserTrophiesResponse_TrophiesData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.kind !== undefined) {
            obj.kind = message.kind;
        }
        if (message.data !== undefined) {
            obj.data = UserTrophiesResponse_TrophiesData.toJSON(message.data);
        }
        return obj;
    },
    create(base) {
        return UserTrophiesResponse_TrophiesType.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserTrophiesResponse_TrophiesType();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? UserTrophiesResponse_TrophiesData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(UserTrophiesResponse_TrophiesType.$type, UserTrophiesResponse_TrophiesType);
function createBaseUserTrophiesResponse_UserTrophiesData() {
    return { trophies: [] };
}
export const UserTrophiesResponse_UserTrophiesData = {
    $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.UserTrophiesData",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.trophies) {
            UserTrophiesResponse_TrophiesType.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserTrophiesResponse_UserTrophiesData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.trophies.push(UserTrophiesResponse_TrophiesType.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            trophies: globalThis.Array.isArray(object?.trophies)
                ? object.trophies.map((e) => UserTrophiesResponse_TrophiesType.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.trophies?.length) {
            obj.trophies = message.trophies.map((e) => UserTrophiesResponse_TrophiesType.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UserTrophiesResponse_UserTrophiesData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserTrophiesResponse_UserTrophiesData();
        message.trophies = object.trophies?.map((e) => UserTrophiesResponse_TrophiesType.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(UserTrophiesResponse_UserTrophiesData.$type, UserTrophiesResponse_UserTrophiesData);
function createBaseUserAboutResponse() {
    return { kind: undefined, data: undefined };
}
export const UserAboutResponse = {
    $type: "devvit.plugin.redditapi.users.UserAboutResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            User.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserAboutResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = User.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? User.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.kind !== undefined) {
            obj.kind = message.kind;
        }
        if (message.data !== undefined) {
            obj.data = User.toJSON(message.data);
        }
        return obj;
    },
    create(base) {
        return UserAboutResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserAboutResponse();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null) ? User.fromPartial(object.data) : undefined;
        return message;
    },
};
messageTypeRegistry.set(UserAboutResponse.$type, UserAboutResponse);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
