syntax = "proto3";

package devvit.ui.effects.v1alpha;

import "devvit/ui/events/v1alpha/event.proto";
import "google/protobuf/wrappers.proto";

option go_package = "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/generated/protos/types/devvit/ui/events/v1alpha";
option java_package = "com.reddit.devvit.ui.effects.v1alpha";

/**
 * This is a low level effect that allows the client or server to send events
 * directly, typically to the other runtime.  It's not intended to be used by
 * app code directly, but rather by hooks that start to bring concurrency features
 * into the platform.
 *
 * An example might be a useFetchHook.  An app developer would use the hook to
 * fetch a remote api, making the request from the server runtime, but without
 * blocking the client runtime.  The lifecycle would be something like:
 *
 *    const {data, loading, error} = useFetch("https://api.example.com");
 *
 * The useFetch hook on the client runtime would emit a
 * SendEventEffect(AsyncRequest({id: "hook-id-xyz"})).  When this event hits the client
 * runtime, it would instantly circuit-break, causing the runtime to send the event to the
 * server runtime.  The server runtime would then look up the hook by id, actually make the
 * request, and then emit a SendEventEffect(AsyncResponse(id: "hook-id-xyz", data: "..."), Target.CLIENT)
 * which would get routed back into the client.
 *
 * This request lifecycle would be orthogonal to the normal event lifecycle, and therefore you
 * couldn't/wouldn't do any setStates inside of the hook.  But the benefit would be that
 * there would be no state conflicts, so the async request/response could be handled concurrently.
 *
 */
message SendEventEffect {
  devvit.ui.events.v1alpha.UIEvent event = 1;

  // If true, the event will be sent to the front of the queue.  The reason to do this is
  // for event replay in e.g. circuit breaking.
  google.protobuf.BoolValue jumps_queue = 2;
}
