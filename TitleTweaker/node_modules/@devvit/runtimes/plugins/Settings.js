var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Settings_dispatcher;
import { SettingsResponse, SettingsValues } from '@devvit/protos';
import { fetch } from 'undici';
import { Header } from '@devvit/shared-types/Header.js';
import { getFromMetadata } from '../common/envelope/EnvelopeUtil.js';
const headerContentType = 'content-type';
const contentTypeProtobuf = 'application/protobuf';
const contentTypeJSON = 'application/json';
/**
 * SettingsPlugin loads settings from an HTTP endpoint that is specified in metadata as `devvit-sec-settings-uri`
 * Unlike the go runtime which implements a caching for scalability, this implementation will reload the
 * settings from the remote host whenever it is called.
 */
class Settings {
    constructor(dispatcher) {
        // this dispatcher is used for mocking in unit tests
        _Settings_dispatcher.set(this, void 0);
        __classPrivateFieldSet(this, _Settings_dispatcher, dispatcher, "f");
    }
    async GetSettings(_request, metadata) {
        const settingsUri = getFromMetadata(Header.SettingsUri, metadata);
        let installationSettings;
        if (settingsUri) {
            const opts = {};
            if (__classPrivateFieldGet(this, _Settings_dispatcher, "f")) {
                opts.dispatcher = __classPrivateFieldGet(this, _Settings_dispatcher, "f");
            }
            const response = await fetch(settingsUri, opts);
            if (!response.ok) {
                throw new Error(`unable to load settings: status code ${response.status}`);
            }
            const contentTypeHeader = response.headers.get(headerContentType);
            if (!contentTypeHeader) {
                throw new Error('unable to load settings: unknown content type');
            }
            // parse the content-type to just the media type dropping charset/boundary after the ;
            const idx = contentTypeHeader.indexOf(';');
            const contentType = contentTypeHeader
                .toLowerCase()
                .slice(0, idx > 0 ? idx : undefined)
                .trim();
            switch (contentType) {
                case contentTypeProtobuf:
                    installationSettings = SettingsValues.decode(new Uint8Array(await response.arrayBuffer()));
                    break;
                case contentTypeJSON:
                    installationSettings = SettingsValues.fromJSON(await response.json());
                    break;
                default:
                    throw new Error('unable to load settings: unknown content type');
            }
        }
        return SettingsResponse.fromPartial({
            installationSettings: installationSettings,
            instanceSettings: {},
        });
    }
}
_Settings_dispatcher = new WeakMap();
export default Settings;
