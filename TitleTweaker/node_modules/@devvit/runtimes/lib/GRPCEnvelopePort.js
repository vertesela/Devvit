var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GRPCEnvelopePort_instances, _GRPCEnvelopePort_remoteUrl, _GRPCEnvelopePort_client, _GRPCEnvelopePort_providesByServiceName, _GRPCEnvelopePort_extraOutgoingMetadata, _GRPCEnvelopePort_postMessageAsync, _GRPCEnvelopePort_onMessage, _GRPCEnvelopePort_newMethodDescriptor;
import { Envelope } from '@devvit/protos';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import * as grpcWeb from 'grpc-web';
import { v4 as UUIDv4 } from 'uuid';
import { Header } from '@devvit/shared-types/Header.js';
import { envelopeMethodToName, envelopeMethodToServiceName, } from '../common/envelope/EnvelopeUtil.js';
import { Buffer } from './Buffer.js';
import { Log } from './loggers/Log.js';
export class GRPCEnvelopePort {
    constructor(remoteUrl, definitions, extraOutgoingMetadata, client) {
        _GRPCEnvelopePort_instances.add(this);
        _GRPCEnvelopePort_remoteUrl.set(this, void 0);
        _GRPCEnvelopePort_client.set(this, void 0);
        _GRPCEnvelopePort_providesByServiceName.set(this, void 0);
        _GRPCEnvelopePort_extraOutgoingMetadata.set(this, void 0);
        this.onmessage = null;
        __classPrivateFieldSet(this, _GRPCEnvelopePort_remoteUrl, remoteUrl, "f");
        __classPrivateFieldSet(this, _GRPCEnvelopePort_client, client ?? new grpcWeb.GrpcWebClientBase({ format: 'binary', withCredentials: true }), "f");
        // TODO: see if there is a way we can look up this def by name in postMessage
        // NOTE: we won't always have the full list if/when we allow devs to provide their own
        //       service definitions
        __classPrivateFieldSet(this, _GRPCEnvelopePort_providesByServiceName, definitions.reduce((obj, def) => Object.assign(obj, { [def.fullName]: def }), {}), "f");
        __classPrivateFieldSet(this, _GRPCEnvelopePort_extraOutgoingMetadata, extraOutgoingMetadata, "f");
    }
    postMessage(envelope) {
        // Can't await and don't want to. We post to the GRPC "port" but there's no
        // addEventListener for it. Instead, the port later responds and that's the
        // port message event.
        void __classPrivateFieldGet(this, _GRPCEnvelopePort_instances, "m", _GRPCEnvelopePort_postMessageAsync).call(this, envelope);
    }
    terminate() {
        this.onmessage = null;
    }
}
_GRPCEnvelopePort_remoteUrl = new WeakMap(), _GRPCEnvelopePort_client = new WeakMap(), _GRPCEnvelopePort_providesByServiceName = new WeakMap(), _GRPCEnvelopePort_extraOutgoingMetadata = new WeakMap(), _GRPCEnvelopePort_instances = new WeakSet(), _GRPCEnvelopePort_postMessageAsync = async function _GRPCEnvelopePort_postMessageAsync(envelope) {
    const metadata = metadataToObject(envelope.metadata);
    if (__classPrivateFieldGet(this, _GRPCEnvelopePort_extraOutgoingMetadata, "f")) {
        const extraMetadata = metadataToObject(__classPrivateFieldGet(this, _GRPCEnvelopePort_extraOutgoingMetadata, "f"));
        Object.assign(metadata, extraMetadata);
    }
    const descriptor = __classPrivateFieldGet(this, _GRPCEnvelopePort_instances, "m", _GRPCEnvelopePort_newMethodDescriptor).call(this, envelope);
    // Every request must have a response.
    let message;
    let error;
    try {
        message = await __classPrivateFieldGet(this, _GRPCEnvelopePort_client, "f").thenableCall(`${__classPrivateFieldGet(this, _GRPCEnvelopePort_remoteUrl, "f")}${envelope.method}`, envelope.message, metadata, descriptor);
    }
    catch (err) {
        error = err;
        Log.error(StringUtil.caughtToString(err));
    }
    // Always resolve the promise that initiated the call,
    // whether it was successful or not.
    __classPrivateFieldGet(this, _GRPCEnvelopePort_instances, "m", _GRPCEnvelopePort_onMessage).call(this, envelope, message, error);
}, _GRPCEnvelopePort_onMessage = function _GRPCEnvelopePort_onMessage(envelope, message, error) {
    const errorMessage = {};
    if (error) {
        errorMessage['name'] = error.name;
        errorMessage['message'] = error.message;
        errorMessage['cause'] = JSON.stringify(error.cause);
        errorMessage['stack'] = error.stack ?? '';
    }
    const response = Envelope.fromPartial({
        id: UUIDv4(),
        method: envelope.method,
        request: false,
        message: message ?? errorMessage,
        metadata: envelope.metadata,
        src: envelope.dst,
        dst: envelope.src,
        streamId: envelope.streamId,
        traceId: envelope.traceId,
        complete: true, // to-do: allow streams.
        success: message != null,
    });
    this.onmessage?.(new MessageEvent('message', { data: response }));
}, _GRPCEnvelopePort_newMethodDescriptor = function _GRPCEnvelopePort_newMethodDescriptor(envelope) {
    const serviceName = envelopeMethodToServiceName(envelope);
    const methodName = envelopeMethodToName(envelope);
    const method = __classPrivateFieldGet(this, _GRPCEnvelopePort_providesByServiceName, "f")[serviceName].methods[methodName];
    if (method == null)
        throw Error(`Unknown method: ${methodName}.`);
    if (method.requestType == null || method.responseType == null) {
        throw new Error('Envelope must contain a valid `requestType` and `responseType`.');
    }
    // Best guess: https://github.com/grpc/grpc-web/blob/f1fe57473f15aa995bdf7935ebe714ed8c3bf05b/javascript/net/grpc/web/grpcwebclientbase_test.js#L204
    class Request {
        constructor(message) {
            Object.assign(this, method.requestType.fromPartial(message));
        }
    }
    class Response {
        constructor(message) {
            Object.assign(this, method.responseType.fromPartial(message));
        }
    }
    return new grpcWeb.MethodDescriptor(envelope.method, method.requestStream ? grpcWeb.MethodType.SERVER_STREAMING : grpcWeb.MethodType.UNARY, Request, Response, (request) => {
        if (typeof request === 'string') {
            return Buffer.from(request, 'base64');
        }
        return method.requestType.encode(request).finish();
    }, method.responseType.decode.bind(method.responseType));
};
function metadataToObject(metadata) {
    // These are the only dev platform headers allowed by CORS:
    const allowedKeys = [
        Header.Installation,
        Header.Version,
        Header.App,
        Header.Actor,
        Header.Canary,
    ];
    return Object.entries(metadata)
        .filter(([key]) => allowedKeys.includes(key))
        .reduce((out, [key, { values }]) => ({ ...out, [key]: values.join(',') }), {});
}
