/**
 * #moderation_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Int32Value, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
function createBaseAboutLogRequest() {
    return {
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        show: undefined,
        mod: undefined,
        type: undefined,
        subreddit: undefined,
    };
}
export const AboutLogRequest = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
        }
        if (message.mod !== undefined) {
            StringValue.encode({ value: message.mod }, writer.uint32(50).fork()).ldelim();
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(66).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.mod = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            mod: isSet(object.mod) ? String(object.mod) : undefined,
            type: isSet(object.type) ? String(object.type) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        if (message.mod !== undefined) {
            obj.mod = message.mod;
        }
        if (message.type !== undefined) {
            obj.type = message.type;
        }
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        return obj;
    },
    create(base) {
        return AboutLogRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAboutLogRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.show = object.show ?? undefined;
        message.mod = object.mod ?? undefined;
        message.type = object.type ?? undefined;
        message.subreddit = object.subreddit ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(AboutLogRequest.$type, AboutLogRequest);
function createBaseAboutLocationRequest() {
    return {
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        location: "",
        only: undefined,
        show: undefined,
        subreddit: "",
    };
}
export const AboutLocationRequest = {
    $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.location !== "") {
            writer.uint32(42).string(message.location);
        }
        if (message.only !== undefined) {
            StringValue.encode({ value: message.only }, writer.uint32(50).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
        }
        if (message.subreddit !== "") {
            writer.uint32(66).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLocationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.location = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.only = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            location: isSet(object.location) ? globalThis.String(object.location) : "",
            only: isSet(object.only) ? String(object.only) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.location !== "") {
            obj.location = message.location;
        }
        if (message.only !== undefined) {
            obj.only = message.only;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        return obj;
    },
    create(base) {
        return AboutLocationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAboutLocationRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.location = object.location ?? "";
        message.only = object.only ?? undefined;
        message.show = object.show ?? undefined;
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set(AboutLocationRequest.$type, AboutLocationRequest);
function createBaseAcceptModeratorInviteRequest() {
    return { subreddit: "" };
}
export const AcceptModeratorInviteRequest = {
    $type: "devvit.plugin.redditapi.moderation.AcceptModeratorInviteRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAcceptModeratorInviteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        return obj;
    },
    create(base) {
        return AcceptModeratorInviteRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAcceptModeratorInviteRequest();
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set(AcceptModeratorInviteRequest.$type, AcceptModeratorInviteRequest);
function createBaseBasicModerationIdRequest() {
    return { id: "" };
}
export const BasicModerationIdRequest = {
    $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicModerationIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return BasicModerationIdRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBasicModerationIdRequest();
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set(BasicModerationIdRequest.$type, BasicModerationIdRequest);
function createBaseDistinguishRequest() {
    return { how: "", id: "", sticky: false };
}
export const DistinguishRequest = {
    $type: "devvit.plugin.redditapi.moderation.DistinguishRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.how !== "") {
            writer.uint32(10).string(message.how);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.sticky !== false) {
            writer.uint32(24).bool(message.sticky);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDistinguishRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.how = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.sticky = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            how: isSet(object.how) ? globalThis.String(object.how) : "",
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            sticky: isSet(object.sticky) ? globalThis.Boolean(object.sticky) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.how !== "") {
            obj.how = message.how;
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.sticky !== false) {
            obj.sticky = message.sticky;
        }
        return obj;
    },
    create(base) {
        return DistinguishRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDistinguishRequest();
        message.how = object.how ?? "";
        message.id = object.id ?? "";
        message.sticky = object.sticky ?? false;
        return message;
    },
};
messageTypeRegistry.set(DistinguishRequest.$type, DistinguishRequest);
function createBaseRemoveRequest() {
    return { id: "", spam: false };
}
export const RemoveRequest = {
    $type: "devvit.plugin.redditapi.moderation.RemoveRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.spam !== false) {
            writer.uint32(16).bool(message.spam);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoveRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.spam = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            spam: isSet(object.spam) ? globalThis.Boolean(object.spam) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.spam !== false) {
            obj.spam = message.spam;
        }
        return obj;
    },
    create(base) {
        return RemoveRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRemoveRequest();
        message.id = object.id ?? "";
        message.spam = object.spam ?? false;
        return message;
    },
};
messageTypeRegistry.set(RemoveRequest.$type, RemoveRequest);
function createBaseSnoozeReportsRequest() {
    return { id: "", reason: "" };
}
export const SnoozeReportsRequest = {
    $type: "devvit.plugin.redditapi.moderation.SnoozeReportsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.reason !== "") {
            writer.uint32(18).string(message.reason);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSnoozeReportsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.reason = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.reason !== "") {
            obj.reason = message.reason;
        }
        return obj;
    },
    create(base) {
        return SnoozeReportsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSnoozeReportsRequest();
        message.id = object.id ?? "";
        message.reason = object.reason ?? "";
        return message;
    },
};
messageTypeRegistry.set(SnoozeReportsRequest.$type, SnoozeReportsRequest);
function createBaseUpdateCrowdControlLevelRequest() {
    return { id: "", level: 0 };
}
export const UpdateCrowdControlLevelRequest = {
    $type: "devvit.plugin.redditapi.moderation.UpdateCrowdControlLevelRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.level !== 0) {
            writer.uint32(16).int32(message.level);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCrowdControlLevelRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.level = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            level: isSet(object.level) ? globalThis.Number(object.level) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.level !== 0) {
            obj.level = Math.round(message.level);
        }
        return obj;
    },
    create(base) {
        return UpdateCrowdControlLevelRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateCrowdControlLevelRequest();
        message.id = object.id ?? "";
        message.level = object.level ?? 0;
        return message;
    },
};
messageTypeRegistry.set(UpdateCrowdControlLevelRequest.$type, UpdateCrowdControlLevelRequest);
function createBaseStylesheetRequest() {
    return { subreddit: "" };
}
export const StylesheetRequest = {
    $type: "devvit.plugin.redditapi.moderation.StylesheetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStylesheetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        return obj;
    },
    create(base) {
        return StylesheetRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStylesheetRequest();
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set(StylesheetRequest.$type, StylesheetRequest);
function createBaseAboutLogResponse() {
    return { kind: "", data: undefined };
}
export const AboutLogResponse = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            AboutLogResponse_AboutLogListing.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.kind = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = AboutLogResponse_AboutLogListing.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
            data: isSet(object.data) ? AboutLogResponse_AboutLogListing.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.kind !== "") {
            obj.kind = message.kind;
        }
        if (message.data !== undefined) {
            obj.data = AboutLogResponse_AboutLogListing.toJSON(message.data);
        }
        return obj;
    },
    create(base) {
        return AboutLogResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAboutLogResponse();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? AboutLogResponse_AboutLogListing.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(AboutLogResponse.$type, AboutLogResponse);
function createBaseAboutLogResponse_LogObject() {
    return {
        description: undefined,
        targetBody: undefined,
        modId36: undefined,
        createdUtc: undefined,
        subreddit: undefined,
        targetTitle: undefined,
        targetPermalink: undefined,
        subredditNamePrefixed: undefined,
        details: undefined,
        action: undefined,
        targetAuthor: undefined,
        targetFullname: undefined,
        srId36: undefined,
        id: undefined,
        mod: undefined,
    };
}
export const AboutLogResponse_LogObject = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.LogObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(10).fork()).ldelim();
        }
        if (message.targetBody !== undefined) {
            StringValue.encode({ value: message.targetBody }, writer.uint32(18).fork()).ldelim();
        }
        if (message.modId36 !== undefined) {
            StringValue.encode({ value: message.modId36 }, writer.uint32(26).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(34).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.targetTitle !== undefined) {
            StringValue.encode({ value: message.targetTitle }, writer.uint32(50).fork()).ldelim();
        }
        if (message.targetPermalink !== undefined) {
            StringValue.encode({ value: message.targetPermalink }, writer.uint32(58).fork()).ldelim();
        }
        if (message.subredditNamePrefixed !== undefined) {
            StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(66).fork()).ldelim();
        }
        if (message.details !== undefined) {
            StringValue.encode({ value: message.details }, writer.uint32(74).fork()).ldelim();
        }
        if (message.action !== undefined) {
            StringValue.encode({ value: message.action }, writer.uint32(82).fork()).ldelim();
        }
        if (message.targetAuthor !== undefined) {
            StringValue.encode({ value: message.targetAuthor }, writer.uint32(90).fork()).ldelim();
        }
        if (message.targetFullname !== undefined) {
            StringValue.encode({ value: message.targetFullname }, writer.uint32(98).fork()).ldelim();
        }
        if (message.srId36 !== undefined) {
            StringValue.encode({ value: message.srId36 }, writer.uint32(106).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(114).fork()).ldelim();
        }
        if (message.mod !== undefined) {
            StringValue.encode({ value: message.mod }, writer.uint32(122).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogResponse_LogObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.targetBody = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.modId36 = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.targetTitle = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.targetPermalink = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.details = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.action = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.targetAuthor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.targetFullname = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.srId36 = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.mod = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet(object.description) ? String(object.description) : undefined,
            targetBody: isSet(object.targetBody) ? String(object.targetBody) : undefined,
            modId36: isSet(object.modId36) ? String(object.modId36) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            targetTitle: isSet(object.targetTitle) ? String(object.targetTitle) : undefined,
            targetPermalink: isSet(object.targetPermalink) ? String(object.targetPermalink) : undefined,
            subredditNamePrefixed: isSet(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : undefined,
            details: isSet(object.details) ? String(object.details) : undefined,
            action: isSet(object.action) ? String(object.action) : undefined,
            targetAuthor: isSet(object.targetAuthor) ? String(object.targetAuthor) : undefined,
            targetFullname: isSet(object.targetFullname) ? String(object.targetFullname) : undefined,
            srId36: isSet(object.srId36) ? String(object.srId36) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            mod: isSet(object.mod) ? String(object.mod) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.targetBody !== undefined) {
            obj.targetBody = message.targetBody;
        }
        if (message.modId36 !== undefined) {
            obj.modId36 = message.modId36;
        }
        if (message.createdUtc !== undefined) {
            obj.createdUtc = message.createdUtc;
        }
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        if (message.targetTitle !== undefined) {
            obj.targetTitle = message.targetTitle;
        }
        if (message.targetPermalink !== undefined) {
            obj.targetPermalink = message.targetPermalink;
        }
        if (message.subredditNamePrefixed !== undefined) {
            obj.subredditNamePrefixed = message.subredditNamePrefixed;
        }
        if (message.details !== undefined) {
            obj.details = message.details;
        }
        if (message.action !== undefined) {
            obj.action = message.action;
        }
        if (message.targetAuthor !== undefined) {
            obj.targetAuthor = message.targetAuthor;
        }
        if (message.targetFullname !== undefined) {
            obj.targetFullname = message.targetFullname;
        }
        if (message.srId36 !== undefined) {
            obj.srId36 = message.srId36;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.mod !== undefined) {
            obj.mod = message.mod;
        }
        return obj;
    },
    create(base) {
        return AboutLogResponse_LogObject.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAboutLogResponse_LogObject();
        message.description = object.description ?? undefined;
        message.targetBody = object.targetBody ?? undefined;
        message.modId36 = object.modId36 ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.subreddit = object.subreddit ?? undefined;
        message.targetTitle = object.targetTitle ?? undefined;
        message.targetPermalink = object.targetPermalink ?? undefined;
        message.subredditNamePrefixed = object.subredditNamePrefixed ?? undefined;
        message.details = object.details ?? undefined;
        message.action = object.action ?? undefined;
        message.targetAuthor = object.targetAuthor ?? undefined;
        message.targetFullname = object.targetFullname ?? undefined;
        message.srId36 = object.srId36 ?? undefined;
        message.id = object.id ?? undefined;
        message.mod = object.mod ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(AboutLogResponse_LogObject.$type, AboutLogResponse_LogObject);
function createBaseAboutLogResponse_AboutLogListing() {
    return { after: undefined, before: undefined, children: [], dist: undefined };
}
export const AboutLogResponse_AboutLogListing = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.children) {
            AboutLogResponse_AboutLogListing_WrappedLogObject.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.dist !== undefined) {
            Int32Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogResponse_AboutLogListing();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.children.push(AboutLogResponse_AboutLogListing_WrappedLogObject.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.dist = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            children: globalThis.Array.isArray(object?.children)
                ? object.children.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.fromJSON(e))
                : [],
            dist: isSet(object.dist) ? Number(object.dist) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.children?.length) {
            obj.children = message.children.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.toJSON(e));
        }
        if (message.dist !== undefined) {
            obj.dist = message.dist;
        }
        return obj;
    },
    create(base) {
        return AboutLogResponse_AboutLogListing.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAboutLogResponse_AboutLogListing();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.children = object.children?.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.fromPartial(e)) ||
            [];
        message.dist = object.dist ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(AboutLogResponse_AboutLogListing.$type, AboutLogResponse_AboutLogListing);
function createBaseAboutLogResponse_AboutLogListing_WrappedLogObject() {
    return { kind: "", data: undefined };
}
export const AboutLogResponse_AboutLogListing_WrappedLogObject = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing.WrappedLogObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            AboutLogResponse_LogObject.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogResponse_AboutLogListing_WrappedLogObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.kind = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = AboutLogResponse_LogObject.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
            data: isSet(object.data) ? AboutLogResponse_LogObject.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.kind !== "") {
            obj.kind = message.kind;
        }
        if (message.data !== undefined) {
            obj.data = AboutLogResponse_LogObject.toJSON(message.data);
        }
        return obj;
    },
    create(base) {
        return AboutLogResponse_AboutLogListing_WrappedLogObject.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAboutLogResponse_AboutLogListing_WrappedLogObject();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? AboutLogResponse_LogObject.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(AboutLogResponse_AboutLogListing_WrappedLogObject.$type, AboutLogResponse_AboutLogListing_WrappedLogObject);
function isSet(value) {
    return value !== null && value !== undefined;
}
