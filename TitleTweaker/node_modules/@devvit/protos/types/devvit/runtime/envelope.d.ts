/**
 * #envelope.ts
 *
 * @packageDocumentation
 */
import _m0 from 'protobufjs/minimal.js';
import { Strings } from './runtime_common.js';
export interface Envelope {
    /**
     * Should be unique per-envelope. May remain the same for
     * envelopes that are mutated and forwarded along because
     * they are considered logically the same envelope.
     * Populated when the Envelope first gets post()ed to a central dispatcher.
     * Only to be used for debugging and repeat dispatch suppression.
     */
    id: string;
    src: string;
    dst: string;
    /**
     * The method has this format:
     *
     *   /<Definition.fullName>/<MethodDefinition.name>
     *
     * See EnvelopeUtil.envelopeMethod().
     */
    method: string;
    streamId: string;
    traceId: string;
    /**
     * When success is true and message is present, message adheres to the method
     * request / response type. When success is false, message's type is unknown.
     * In TypeScript only, messages are usually of type UnknownMessage.
     */
    success: boolean;
    message?: any | undefined;
    request: boolean;
    complete: boolean;
    /**
     * Must be consistent per streamId.  Can be omitted from subsequent
     * messages.
     */
    metadata: {
        [key: string]: Strings;
    };
}
export interface Envelope_MetadataEntry {
    key: string;
    value?: Strings | undefined;
}
export declare const Envelope: {
    $type: "devvit.runtime.Envelope";
    encode(message: Envelope, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Envelope;
    fromJSON(object: any): Envelope;
    toJSON(message: Envelope): unknown;
    create(base?: DeepPartial<Envelope>): Envelope;
    fromPartial(object: DeepPartial<Envelope>): Envelope;
};
export declare const Envelope_MetadataEntry: {
    $type: "devvit.runtime.Envelope.MetadataEntry";
    encode(message: Envelope_MetadataEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Envelope_MetadataEntry;
    fromJSON(object: any): Envelope_MetadataEntry;
    toJSON(message: Envelope_MetadataEntry): unknown;
    create(base?: DeepPartial<Envelope_MetadataEntry>): Envelope_MetadataEntry;
    fromPartial(object: DeepPartial<Envelope_MetadataEntry>): Envelope_MetadataEntry;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=envelope.d.ts.map