import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { AppCreationRequest, AppSearchRequest, AppSearchResponse, GetAppBySlugRequest, FullAppInfo, GetAllWithOwnerRequest, GetPopularAppsRequest, CheckIfMediaExistsRequest, CheckIfMediaExistsResponse, UploadNewMediaRequest, UploadNewMediaResponse, AppUpdateRequest, UnpublishAppRequest, AppExistsRequest, AppExistsResponse, AppAccountExistsRequest, AppAccountExistsResponse, CreateAppAccountRequest, CreateAppAccountResponse, } from './app/app.js';
import { AppInfo, MultipleAppInfos } from './app/info/app_info.js';
import { UUID } from '../uuid.js';
import { GetAllWithInstallLocationRequest, GetAllWithInstallerRequest, InstallationCreationRequest, FullInstallationInfo, GetByAppNameAndInstallLocationRequest, MultipleInstallationsResponse, GetAllWithAppResponse, GetInstallationHistoryRequest, GetInstallationHistoryResponse, InstallationUpgradeRequest, InstallationUpgradeManyRequest, InstallationUpgradeManyResponse, InstallationUpdateRequest, } from './installation/installation.js';
import { Empty } from '../../google/protobuf/empty.js';
import { AppVersionCreationRequest, FullAppVersionInfo, AppSlugAndVersion, AppVersionUpdateRequest, ValidInstallLocationsRequest, ValidInstallLocationsResponse, GetAppVersionBundleResponse, } from './app_version/app_version.js';
import { AppVersionInfo } from './app_version/info/app_version_info.js';
import { GetNutritionByNameVersionRequest, MultipleNutritionCategories, } from './nutrition/nutrition.js';
import { CreateFeedbackRequest } from './feedback/feedback.js';
import { CreateDataTokenRequest, CreateDataTokenResponse, GetDataTokenByIdRequest, GetDataTokenByIdResponse, GetDataTokensByOrganizationNameRequest, GetDataTokensByOrganizationNameResponse, RevokeDataTokenByIdRequest, RevokeDataTokenByIdResponse, } from './data_api/admin/auth/auth.js';
import { CreateDataSubscriptionRequest, CreateDataSubscriptionResponse, GetDataSubscriptionByIdRequest, GetDataSubscriptionByIdResponse, GetDataSubscriptionsByOrganizationNameRequest, GetDataSubscriptionsByOrganizationNameResponse, UpdateDataSubscriptionRequest, UpdateDataSubscriptionResponse, DeleteDataSubscriptionRequest, DeleteDataSubscriptionResponse, } from './data_api/admin/subscription/subscription.js';
import { CreateOrganizationRequest, CreateOrganizationResponse, GetOrganizationByNameRequest, GetOrganizationByNameResponse, GetOrganizationsRequest, GetOrganizationsResponse, } from './data_api/admin/organization/organization.js';
import { GetAuditLogEventsRequest, GetAuditLogEventsResponse, } from './data_api/admin/audit/audit.js';
import { Value } from '../../google/protobuf/struct.js';
import { GetInstallationSettingsFormRequest, GetInstallationSettingsFormResponse, ValidateInstallationSettingsFormRequest, ValidateInstallationSettingsFormResponse, GetInstallationSettingsRequest, GetInstallationSettingsResponse, UpdateInstallationSettingsRequest, UpdateInstallationSettingsResponse, } from './installation_settings/installation_settings.js';
import { GetAppSettingsFormRequest, GetAppSettingsFormResponse, ValidateAppSettingsFormRequest, ValidateAppSettingsFormResponse, GetAppSettingsRequest, GetAppSettingsResponse, UpdateAppSettingsRequest, UpdateAppSettingsResponse, } from './app_settings/app_settings.js';
export var AppMethod;
(function (AppMethod) {
    AppMethod["Create"] = "Create";
    AppMethod["Search"] = "Search";
    AppMethod["GetBySlug"] = "GetBySlug";
    AppMethod["GetByUUID"] = "GetByUUID";
    AppMethod["GetAllWithLocation"] = "GetAllWithLocation";
    AppMethod["GetAllWithInstaller"] = "GetAllWithInstaller";
    AppMethod["GetAllWithOwner"] = "GetAllWithOwner";
    AppMethod["GetPopularApps"] = "GetPopularApps";
    AppMethod["CheckIfMediaExists"] = "CheckIfMediaExists";
    AppMethod["UploadNewMedia"] = "UploadNewMedia";
    AppMethod["Update"] = "Update";
    AppMethod["Unpublish"] = "Unpublish";
    AppMethod["Exists"] = "Exists";
    AppMethod["AppAccountExists"] = "AppAccountExists";
    AppMethod["CreateAppAccount"] = "CreateAppAccount";
})(AppMethod || (AppMethod = {}));
export const AppMethodList = [
    AppMethod.Create,
    AppMethod.Search,
    AppMethod.GetBySlug,
    AppMethod.GetByUUID,
    AppMethod.GetAllWithLocation,
    AppMethod.GetAllWithInstaller,
    AppMethod.GetAllWithOwner,
    AppMethod.GetPopularApps,
    AppMethod.CheckIfMediaExists,
    AppMethod.UploadNewMedia,
    AppMethod.Update,
    AppMethod.Unpublish,
    AppMethod.Exists,
    AppMethod.AppAccountExists,
    AppMethod.CreateAppAccount,
];
export function createAppServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'App',
        methodList: AppMethodList,
        matchRoute: matchAppRoute,
    });
}
function matchAppRoute(method, events) {
    switch (method) {
        case 'Create':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Create' };
                await events.onMatch(ctx);
                return handleAppCreateRequest(ctx, service, data, interceptors);
            };
        case 'Search':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Search' };
                await events.onMatch(ctx);
                return handleAppSearchRequest(ctx, service, data, interceptors);
            };
        case 'GetBySlug':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetBySlug' };
                await events.onMatch(ctx);
                return handleAppGetBySlugRequest(ctx, service, data, interceptors);
            };
        case 'GetByUUID':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetByUUID' };
                await events.onMatch(ctx);
                return handleAppGetByUUIDRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithLocation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithLocation' };
                await events.onMatch(ctx);
                return handleAppGetAllWithLocationRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithInstaller':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithInstaller' };
                await events.onMatch(ctx);
                return handleAppGetAllWithInstallerRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithOwner':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithOwner' };
                await events.onMatch(ctx);
                return handleAppGetAllWithOwnerRequest(ctx, service, data, interceptors);
            };
        case 'GetPopularApps':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetPopularApps' };
                await events.onMatch(ctx);
                return handleAppGetPopularAppsRequest(ctx, service, data, interceptors);
            };
        case 'CheckIfMediaExists':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'CheckIfMediaExists' };
                await events.onMatch(ctx);
                return handleAppCheckIfMediaExistsRequest(ctx, service, data, interceptors);
            };
        case 'UploadNewMedia':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UploadNewMedia' };
                await events.onMatch(ctx);
                return handleAppUploadNewMediaRequest(ctx, service, data, interceptors);
            };
        case 'Update':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Update' };
                await events.onMatch(ctx);
                return handleAppUpdateRequest(ctx, service, data, interceptors);
            };
        case 'Unpublish':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unpublish' };
                await events.onMatch(ctx);
                return handleAppUnpublishRequest(ctx, service, data, interceptors);
            };
        case 'Exists':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Exists' };
                await events.onMatch(ctx);
                return handleAppExistsRequest(ctx, service, data, interceptors);
            };
        case 'AppAccountExists':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AppAccountExists' };
                await events.onMatch(ctx);
                return handleAppAppAccountExistsRequest(ctx, service, data, interceptors);
            };
        case 'CreateAppAccount':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'CreateAppAccount' };
                await events.onMatch(ctx);
                return handleAppCreateAppAccountRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppSearchRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppSearchJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppSearchProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetBySlugRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetBySlugJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetBySlugProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetByUUIDRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetByUUIDJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetByUUIDProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetAllWithLocationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetAllWithLocationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetAllWithLocationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetAllWithInstallerRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetAllWithInstallerJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetAllWithInstallerProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetAllWithOwnerRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetAllWithOwnerJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetAllWithOwnerProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetPopularAppsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetPopularAppsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetPopularAppsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppCheckIfMediaExistsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppCheckIfMediaExistsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppCheckIfMediaExistsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppUploadNewMediaRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppUploadNewMediaJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppUploadNewMediaProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppUnpublishRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppUnpublishJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppUnpublishProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppExistsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppExistsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppExistsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppAppAccountExistsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppAppAccountExistsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppAppAccountExistsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppCreateAppAccountRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppCreateAppAccountJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppCreateAppAccountProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleAppCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppCreationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return JSON.stringify(AppInfo.toJSON(response));
}
async function handleAppSearchJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppSearchRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Search(ctx, inputReq);
        });
    }
    else {
        response = await service.Search(ctx, request);
    }
    return JSON.stringify(AppSearchResponse.toJSON(response));
}
async function handleAppGetBySlugJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAppBySlugRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetBySlug(ctx, inputReq);
        });
    }
    else {
        response = await service.GetBySlug(ctx, request);
    }
    return JSON.stringify(FullAppInfo.toJSON(response));
}
async function handleAppGetByUUIDJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByUUID(ctx, request);
    }
    return JSON.stringify(FullAppInfo.toJSON(response));
}
async function handleAppGetAllWithLocationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithInstallLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithLocation(ctx, request);
    }
    return JSON.stringify(MultipleAppInfos.toJSON(response));
}
async function handleAppGetAllWithInstallerJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithInstallerRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstaller(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstaller(ctx, request);
    }
    return JSON.stringify(MultipleAppInfos.toJSON(response));
}
async function handleAppGetAllWithOwnerJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithOwnerRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithOwner(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithOwner(ctx, request);
    }
    return JSON.stringify(MultipleAppInfos.toJSON(response));
}
async function handleAppGetPopularAppsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetPopularAppsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetPopularApps(ctx, inputReq);
        });
    }
    else {
        response = await service.GetPopularApps(ctx, request);
    }
    return JSON.stringify(MultipleAppInfos.toJSON(response));
}
async function handleAppCheckIfMediaExistsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CheckIfMediaExistsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CheckIfMediaExists(ctx, inputReq);
        });
    }
    else {
        response = await service.CheckIfMediaExists(ctx, request);
    }
    return JSON.stringify(CheckIfMediaExistsResponse.toJSON(response));
}
async function handleAppUploadNewMediaJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UploadNewMediaRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UploadNewMedia(ctx, inputReq);
        });
    }
    else {
        response = await service.UploadNewMedia(ctx, request);
    }
    return JSON.stringify(UploadNewMediaResponse.toJSON(response));
}
async function handleAppUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppUpdateRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return JSON.stringify(FullAppInfo.toJSON(response));
}
async function handleAppUnpublishJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UnpublishAppRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unpublish(ctx, inputReq);
        });
    }
    else {
        response = await service.Unpublish(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleAppExistsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppExistsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Exists(ctx, inputReq);
        });
    }
    else {
        response = await service.Exists(ctx, request);
    }
    return JSON.stringify(AppExistsResponse.toJSON(response));
}
async function handleAppAppAccountExistsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppAccountExistsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AppAccountExists(ctx, inputReq);
        });
    }
    else {
        response = await service.AppAccountExists(ctx, request);
    }
    return JSON.stringify(AppAccountExistsResponse.toJSON(response));
}
async function handleAppCreateAppAccountJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CreateAppAccountRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateAppAccount(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateAppAccount(ctx, request);
    }
    return JSON.stringify(CreateAppAccountResponse.toJSON(response));
}
async function handleAppCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppCreationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return Buffer.from(AppInfo.encode(response).finish());
}
async function handleAppSearchProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppSearchRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Search(ctx, inputReq);
        });
    }
    else {
        response = await service.Search(ctx, request);
    }
    return Buffer.from(AppSearchResponse.encode(response).finish());
}
async function handleAppGetBySlugProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAppBySlugRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetBySlug(ctx, inputReq);
        });
    }
    else {
        response = await service.GetBySlug(ctx, request);
    }
    return Buffer.from(FullAppInfo.encode(response).finish());
}
async function handleAppGetByUUIDProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByUUID(ctx, request);
    }
    return Buffer.from(FullAppInfo.encode(response).finish());
}
async function handleAppGetAllWithLocationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithInstallLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithLocation(ctx, request);
    }
    return Buffer.from(MultipleAppInfos.encode(response).finish());
}
async function handleAppGetAllWithInstallerProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithInstallerRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstaller(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstaller(ctx, request);
    }
    return Buffer.from(MultipleAppInfos.encode(response).finish());
}
async function handleAppGetAllWithOwnerProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithOwnerRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithOwner(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithOwner(ctx, request);
    }
    return Buffer.from(MultipleAppInfos.encode(response).finish());
}
async function handleAppGetPopularAppsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetPopularAppsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetPopularApps(ctx, inputReq);
        });
    }
    else {
        response = await service.GetPopularApps(ctx, request);
    }
    return Buffer.from(MultipleAppInfos.encode(response).finish());
}
async function handleAppCheckIfMediaExistsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CheckIfMediaExistsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CheckIfMediaExists(ctx, inputReq);
        });
    }
    else {
        response = await service.CheckIfMediaExists(ctx, request);
    }
    return Buffer.from(CheckIfMediaExistsResponse.encode(response).finish());
}
async function handleAppUploadNewMediaProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UploadNewMediaRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UploadNewMedia(ctx, inputReq);
        });
    }
    else {
        response = await service.UploadNewMedia(ctx, request);
    }
    return Buffer.from(UploadNewMediaResponse.encode(response).finish());
}
async function handleAppUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppUpdateRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return Buffer.from(FullAppInfo.encode(response).finish());
}
async function handleAppUnpublishProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UnpublishAppRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unpublish(ctx, inputReq);
        });
    }
    else {
        response = await service.Unpublish(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleAppExistsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppExistsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Exists(ctx, inputReq);
        });
    }
    else {
        response = await service.Exists(ctx, request);
    }
    return Buffer.from(AppExistsResponse.encode(response).finish());
}
async function handleAppAppAccountExistsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppAccountExistsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AppAccountExists(ctx, inputReq);
        });
    }
    else {
        response = await service.AppAccountExists(ctx, request);
    }
    return Buffer.from(AppAccountExistsResponse.encode(response).finish());
}
async function handleAppCreateAppAccountProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CreateAppAccountRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateAppAccount(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateAppAccount(ctx, request);
    }
    return Buffer.from(CreateAppAccountResponse.encode(response).finish());
}
export var AppVersionMethod;
(function (AppVersionMethod) {
    AppVersionMethod["Create"] = "Create";
    AppVersionMethod["Get"] = "Get";
    AppVersionMethod["GetBySlugAndVersionNumber"] = "GetBySlugAndVersionNumber";
    AppVersionMethod["Update"] = "Update";
    AppVersionMethod["GetValidInstallLocations"] = "GetValidInstallLocations";
    AppVersionMethod["GetAppVersionBundle"] = "GetAppVersionBundle";
    AppVersionMethod["GetNutritionByNameVersion"] = "GetNutritionByNameVersion";
    AppVersionMethod["GetNutritionByAppVersionId"] = "GetNutritionByAppVersionId";
})(AppVersionMethod || (AppVersionMethod = {}));
export const AppVersionMethodList = [
    AppVersionMethod.Create,
    AppVersionMethod.Get,
    AppVersionMethod.GetBySlugAndVersionNumber,
    AppVersionMethod.Update,
    AppVersionMethod.GetValidInstallLocations,
    AppVersionMethod.GetAppVersionBundle,
    AppVersionMethod.GetNutritionByNameVersion,
    AppVersionMethod.GetNutritionByAppVersionId,
];
export function createAppVersionServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'AppVersion',
        methodList: AppVersionMethodList,
        matchRoute: matchAppVersionRoute,
    });
}
function matchAppVersionRoute(method, events) {
    switch (method) {
        case 'Create':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Create' };
                await events.onMatch(ctx);
                return handleAppVersionCreateRequest(ctx, service, data, interceptors);
            };
        case 'Get':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Get' };
                await events.onMatch(ctx);
                return handleAppVersionGetRequest(ctx, service, data, interceptors);
            };
        case 'GetBySlugAndVersionNumber':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetBySlugAndVersionNumber' };
                await events.onMatch(ctx);
                return handleAppVersionGetBySlugAndVersionNumberRequest(ctx, service, data, interceptors);
            };
        case 'Update':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Update' };
                await events.onMatch(ctx);
                return handleAppVersionUpdateRequest(ctx, service, data, interceptors);
            };
        case 'GetValidInstallLocations':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetValidInstallLocations' };
                await events.onMatch(ctx);
                return handleAppVersionGetValidInstallLocationsRequest(ctx, service, data, interceptors);
            };
        case 'GetAppVersionBundle':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAppVersionBundle' };
                await events.onMatch(ctx);
                return handleAppVersionGetAppVersionBundleRequest(ctx, service, data, interceptors);
            };
        case 'GetNutritionByNameVersion':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetNutritionByNameVersion' };
                await events.onMatch(ctx);
                return handleAppVersionGetNutritionByNameVersionRequest(ctx, service, data, interceptors);
            };
        case 'GetNutritionByAppVersionId':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetNutritionByAppVersionId' };
                await events.onMatch(ctx);
                return handleAppVersionGetNutritionByAppVersionIdRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionGetRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionGetJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionGetProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionGetBySlugAndVersionNumberRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionGetBySlugAndVersionNumberJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionGetBySlugAndVersionNumberProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionGetValidInstallLocationsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionGetValidInstallLocationsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionGetValidInstallLocationsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionGetAppVersionBundleRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionGetAppVersionBundleJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionGetAppVersionBundleProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionGetNutritionByNameVersionRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionGetNutritionByNameVersionJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionGetNutritionByNameVersionProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionGetNutritionByAppVersionIdRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionGetNutritionByAppVersionIdJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionGetNutritionByAppVersionIdProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleAppVersionCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppVersionCreationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return JSON.stringify(AppVersionInfo.toJSON(response));
}
async function handleAppVersionGetJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Get(ctx, inputReq);
        });
    }
    else {
        response = await service.Get(ctx, request);
    }
    return JSON.stringify(FullAppVersionInfo.toJSON(response));
}
async function handleAppVersionGetBySlugAndVersionNumberJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppSlugAndVersion.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetBySlugAndVersionNumber(ctx, inputReq);
        });
    }
    else {
        response = await service.GetBySlugAndVersionNumber(ctx, request);
    }
    return JSON.stringify(FullAppVersionInfo.toJSON(response));
}
async function handleAppVersionUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppVersionUpdateRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return JSON.stringify(FullAppVersionInfo.toJSON(response));
}
async function handleAppVersionGetValidInstallLocationsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ValidInstallLocationsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetValidInstallLocations(ctx, inputReq);
        });
    }
    else {
        response = await service.GetValidInstallLocations(ctx, request);
    }
    return JSON.stringify(ValidInstallLocationsResponse.toJSON(response));
}
async function handleAppVersionGetAppVersionBundleJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAppVersionBundle(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAppVersionBundle(ctx, request);
    }
    return JSON.stringify(GetAppVersionBundleResponse.toJSON(response));
}
async function handleAppVersionGetNutritionByNameVersionJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetNutritionByNameVersionRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetNutritionByNameVersion(ctx, inputReq);
        });
    }
    else {
        response = await service.GetNutritionByNameVersion(ctx, request);
    }
    return JSON.stringify(MultipleNutritionCategories.toJSON(response));
}
async function handleAppVersionGetNutritionByAppVersionIdJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetNutritionByAppVersionId(ctx, inputReq);
        });
    }
    else {
        response = await service.GetNutritionByAppVersionId(ctx, request);
    }
    return JSON.stringify(MultipleNutritionCategories.toJSON(response));
}
async function handleAppVersionCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppVersionCreationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return Buffer.from(AppVersionInfo.encode(response).finish());
}
async function handleAppVersionGetProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Get(ctx, inputReq);
        });
    }
    else {
        response = await service.Get(ctx, request);
    }
    return Buffer.from(FullAppVersionInfo.encode(response).finish());
}
async function handleAppVersionGetBySlugAndVersionNumberProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppSlugAndVersion.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetBySlugAndVersionNumber(ctx, inputReq);
        });
    }
    else {
        response = await service.GetBySlugAndVersionNumber(ctx, request);
    }
    return Buffer.from(FullAppVersionInfo.encode(response).finish());
}
async function handleAppVersionUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppVersionUpdateRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return Buffer.from(FullAppVersionInfo.encode(response).finish());
}
async function handleAppVersionGetValidInstallLocationsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ValidInstallLocationsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetValidInstallLocations(ctx, inputReq);
        });
    }
    else {
        response = await service.GetValidInstallLocations(ctx, request);
    }
    return Buffer.from(ValidInstallLocationsResponse.encode(response).finish());
}
async function handleAppVersionGetAppVersionBundleProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAppVersionBundle(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAppVersionBundle(ctx, request);
    }
    return Buffer.from(GetAppVersionBundleResponse.encode(response).finish());
}
async function handleAppVersionGetNutritionByNameVersionProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetNutritionByNameVersionRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetNutritionByNameVersion(ctx, inputReq);
        });
    }
    else {
        response = await service.GetNutritionByNameVersion(ctx, request);
    }
    return Buffer.from(MultipleNutritionCategories.encode(response).finish());
}
async function handleAppVersionGetNutritionByAppVersionIdProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetNutritionByAppVersionId(ctx, inputReq);
        });
    }
    else {
        response = await service.GetNutritionByAppVersionId(ctx, request);
    }
    return Buffer.from(MultipleNutritionCategories.encode(response).finish());
}
export var InstallationsMethod;
(function (InstallationsMethod) {
    InstallationsMethod["Create"] = "Create";
    InstallationsMethod["GetByUUID"] = "GetByUUID";
    InstallationsMethod["GetByAppNameAndInstallLocation"] = "GetByAppNameAndInstallLocation";
    InstallationsMethod["GetAllWithInstallLocation"] = "GetAllWithInstallLocation";
    InstallationsMethod["GetAllWithInstaller"] = "GetAllWithInstaller";
    InstallationsMethod["GetAllWithVersionUUID"] = "GetAllWithVersionUUID";
    InstallationsMethod["GetAllWithApp"] = "GetAllWithApp";
    InstallationsMethod["GetInstallationHistory"] = "GetInstallationHistory";
    InstallationsMethod["Upgrade"] = "Upgrade";
    InstallationsMethod["UpgradeMany"] = "UpgradeMany";
    InstallationsMethod["Update"] = "Update";
    InstallationsMethod["Remove"] = "Remove";
})(InstallationsMethod || (InstallationsMethod = {}));
export const InstallationsMethodList = [
    InstallationsMethod.Create,
    InstallationsMethod.GetByUUID,
    InstallationsMethod.GetByAppNameAndInstallLocation,
    InstallationsMethod.GetAllWithInstallLocation,
    InstallationsMethod.GetAllWithInstaller,
    InstallationsMethod.GetAllWithVersionUUID,
    InstallationsMethod.GetAllWithApp,
    InstallationsMethod.GetInstallationHistory,
    InstallationsMethod.Upgrade,
    InstallationsMethod.UpgradeMany,
    InstallationsMethod.Update,
    InstallationsMethod.Remove,
];
export function createInstallationsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'Installations',
        methodList: InstallationsMethodList,
        matchRoute: matchInstallationsRoute,
    });
}
function matchInstallationsRoute(method, events) {
    switch (method) {
        case 'Create':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Create' };
                await events.onMatch(ctx);
                return handleInstallationsCreateRequest(ctx, service, data, interceptors);
            };
        case 'GetByUUID':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetByUUID' };
                await events.onMatch(ctx);
                return handleInstallationsGetByUUIDRequest(ctx, service, data, interceptors);
            };
        case 'GetByAppNameAndInstallLocation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetByAppNameAndInstallLocation' };
                await events.onMatch(ctx);
                return handleInstallationsGetByAppNameAndInstallLocationRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithInstallLocation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithInstallLocation' };
                await events.onMatch(ctx);
                return handleInstallationsGetAllWithInstallLocationRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithInstaller':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithInstaller' };
                await events.onMatch(ctx);
                return handleInstallationsGetAllWithInstallerRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithVersionUUID':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithVersionUUID' };
                await events.onMatch(ctx);
                return handleInstallationsGetAllWithVersionUUIDRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithApp':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithApp' };
                await events.onMatch(ctx);
                return handleInstallationsGetAllWithAppRequest(ctx, service, data, interceptors);
            };
        case 'GetInstallationHistory':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetInstallationHistory' };
                await events.onMatch(ctx);
                return handleInstallationsGetInstallationHistoryRequest(ctx, service, data, interceptors);
            };
        case 'Upgrade':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Upgrade' };
                await events.onMatch(ctx);
                return handleInstallationsUpgradeRequest(ctx, service, data, interceptors);
            };
        case 'UpgradeMany':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpgradeMany' };
                await events.onMatch(ctx);
                return handleInstallationsUpgradeManyRequest(ctx, service, data, interceptors);
            };
        case 'Update':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Update' };
                await events.onMatch(ctx);
                return handleInstallationsUpdateRequest(ctx, service, data, interceptors);
            };
        case 'Remove':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Remove' };
                await events.onMatch(ctx);
                return handleInstallationsRemoveRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetByUUIDRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetByUUIDJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetByUUIDProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetByAppNameAndInstallLocationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetByAppNameAndInstallLocationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetByAppNameAndInstallLocationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetAllWithInstallLocationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetAllWithInstallLocationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetAllWithInstallLocationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetAllWithInstallerRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetAllWithInstallerJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetAllWithInstallerProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetAllWithVersionUUIDRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetAllWithVersionUUIDJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetAllWithVersionUUIDProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetAllWithAppRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetAllWithAppJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetAllWithAppProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetInstallationHistoryRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetInstallationHistoryJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetInstallationHistoryProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsUpgradeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsUpgradeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsUpgradeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsUpgradeManyRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsUpgradeManyJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsUpgradeManyProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsRemoveRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsRemoveJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsRemoveProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleInstallationsCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationCreationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsGetByUUIDJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByUUID(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsGetByAppNameAndInstallLocationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetByAppNameAndInstallLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByAppNameAndInstallLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByAppNameAndInstallLocation(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsGetAllWithInstallLocationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithInstallLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstallLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstallLocation(ctx, request);
    }
    return JSON.stringify(MultipleInstallationsResponse.toJSON(response));
}
async function handleInstallationsGetAllWithInstallerJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithInstallerRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstaller(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstaller(ctx, request);
    }
    return JSON.stringify(MultipleInstallationsResponse.toJSON(response));
}
async function handleInstallationsGetAllWithVersionUUIDJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithVersionUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithVersionUUID(ctx, request);
    }
    return JSON.stringify(MultipleInstallationsResponse.toJSON(response));
}
async function handleInstallationsGetAllWithAppJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithApp(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithApp(ctx, request);
    }
    return JSON.stringify(GetAllWithAppResponse.toJSON(response));
}
async function handleInstallationsGetInstallationHistoryJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetInstallationHistoryRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetInstallationHistory(ctx, inputReq);
        });
    }
    else {
        response = await service.GetInstallationHistory(ctx, request);
    }
    return JSON.stringify(GetInstallationHistoryResponse.toJSON(response));
}
async function handleInstallationsUpgradeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationUpgradeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Upgrade(ctx, inputReq);
        });
    }
    else {
        response = await service.Upgrade(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsUpgradeManyJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationUpgradeManyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpgradeMany(ctx, inputReq);
        });
    }
    else {
        response = await service.UpgradeMany(ctx, request);
    }
    return JSON.stringify(InstallationUpgradeManyResponse.toJSON(response));
}
async function handleInstallationsUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationUpdateRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsRemoveJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Remove(ctx, inputReq);
        });
    }
    else {
        response = await service.Remove(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleInstallationsCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationCreationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsGetByUUIDProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByUUID(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsGetByAppNameAndInstallLocationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetByAppNameAndInstallLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByAppNameAndInstallLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByAppNameAndInstallLocation(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsGetAllWithInstallLocationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithInstallLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstallLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstallLocation(ctx, request);
    }
    return Buffer.from(MultipleInstallationsResponse.encode(response).finish());
}
async function handleInstallationsGetAllWithInstallerProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithInstallerRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstaller(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstaller(ctx, request);
    }
    return Buffer.from(MultipleInstallationsResponse.encode(response).finish());
}
async function handleInstallationsGetAllWithVersionUUIDProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithVersionUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithVersionUUID(ctx, request);
    }
    return Buffer.from(MultipleInstallationsResponse.encode(response).finish());
}
async function handleInstallationsGetAllWithAppProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithApp(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithApp(ctx, request);
    }
    return Buffer.from(GetAllWithAppResponse.encode(response).finish());
}
async function handleInstallationsGetInstallationHistoryProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetInstallationHistoryRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetInstallationHistory(ctx, inputReq);
        });
    }
    else {
        response = await service.GetInstallationHistory(ctx, request);
    }
    return Buffer.from(GetInstallationHistoryResponse.encode(response).finish());
}
async function handleInstallationsUpgradeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationUpgradeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Upgrade(ctx, inputReq);
        });
    }
    else {
        response = await service.Upgrade(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsUpgradeManyProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationUpgradeManyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpgradeMany(ctx, inputReq);
        });
    }
    else {
        response = await service.UpgradeMany(ctx, request);
    }
    return Buffer.from(InstallationUpgradeManyResponse.encode(response).finish());
}
async function handleInstallationsUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationUpdateRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsRemoveProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Remove(ctx, inputReq);
        });
    }
    else {
        response = await service.Remove(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
export var FeedbackMethod;
(function (FeedbackMethod) {
    FeedbackMethod["Create"] = "Create";
})(FeedbackMethod || (FeedbackMethod = {}));
export const FeedbackMethodList = [FeedbackMethod.Create];
export function createFeedbackServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'Feedback',
        methodList: FeedbackMethodList,
        matchRoute: matchFeedbackRoute,
    });
}
function matchFeedbackRoute(method, events) {
    switch (method) {
        case 'Create':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Create' };
                await events.onMatch(ctx);
                return handleFeedbackCreateRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFeedbackCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFeedbackCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFeedbackCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleFeedbackCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CreateFeedbackRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleFeedbackCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CreateFeedbackRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
export var DataApiAdminMethod;
(function (DataApiAdminMethod) {
    DataApiAdminMethod["CreateDataToken"] = "CreateDataToken";
    DataApiAdminMethod["GetDataTokenById"] = "GetDataTokenById";
    DataApiAdminMethod["GetDataTokensByOrganizationName"] = "GetDataTokensByOrganizationName";
    DataApiAdminMethod["RevokeDataTokenById"] = "RevokeDataTokenById";
    DataApiAdminMethod["CreateDataSubscription"] = "CreateDataSubscription";
    DataApiAdminMethod["GetDataSubscriptionById"] = "GetDataSubscriptionById";
    DataApiAdminMethod["GetDataSubscriptionsByOrganizationName"] = "GetDataSubscriptionsByOrganizationName";
    DataApiAdminMethod["UpdateDataSubscription"] = "UpdateDataSubscription";
    DataApiAdminMethod["DeleteDataSubscription"] = "DeleteDataSubscription";
    DataApiAdminMethod["CreateOrganization"] = "CreateOrganization";
    DataApiAdminMethod["GetOrganizationByName"] = "GetOrganizationByName";
    DataApiAdminMethod["GetOrganizations"] = "GetOrganizations";
    DataApiAdminMethod["GetAuditLogEvents"] = "GetAuditLogEvents";
})(DataApiAdminMethod || (DataApiAdminMethod = {}));
export const DataApiAdminMethodList = [
    DataApiAdminMethod.CreateDataToken,
    DataApiAdminMethod.GetDataTokenById,
    DataApiAdminMethod.GetDataTokensByOrganizationName,
    DataApiAdminMethod.RevokeDataTokenById,
    DataApiAdminMethod.CreateDataSubscription,
    DataApiAdminMethod.GetDataSubscriptionById,
    DataApiAdminMethod.GetDataSubscriptionsByOrganizationName,
    DataApiAdminMethod.UpdateDataSubscription,
    DataApiAdminMethod.DeleteDataSubscription,
    DataApiAdminMethod.CreateOrganization,
    DataApiAdminMethod.GetOrganizationByName,
    DataApiAdminMethod.GetOrganizations,
    DataApiAdminMethod.GetAuditLogEvents,
];
export function createDataApiAdminServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'DataApiAdmin',
        methodList: DataApiAdminMethodList,
        matchRoute: matchDataApiAdminRoute,
    });
}
function matchDataApiAdminRoute(method, events) {
    switch (method) {
        case 'CreateDataToken':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'CreateDataToken' };
                await events.onMatch(ctx);
                return handleDataApiAdminCreateDataTokenRequest(ctx, service, data, interceptors);
            };
        case 'GetDataTokenById':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetDataTokenById' };
                await events.onMatch(ctx);
                return handleDataApiAdminGetDataTokenByIdRequest(ctx, service, data, interceptors);
            };
        case 'GetDataTokensByOrganizationName':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetDataTokensByOrganizationName' };
                await events.onMatch(ctx);
                return handleDataApiAdminGetDataTokensByOrganizationNameRequest(ctx, service, data, interceptors);
            };
        case 'RevokeDataTokenById':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'RevokeDataTokenById' };
                await events.onMatch(ctx);
                return handleDataApiAdminRevokeDataTokenByIdRequest(ctx, service, data, interceptors);
            };
        case 'CreateDataSubscription':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'CreateDataSubscription' };
                await events.onMatch(ctx);
                return handleDataApiAdminCreateDataSubscriptionRequest(ctx, service, data, interceptors);
            };
        case 'GetDataSubscriptionById':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetDataSubscriptionById' };
                await events.onMatch(ctx);
                return handleDataApiAdminGetDataSubscriptionByIdRequest(ctx, service, data, interceptors);
            };
        case 'GetDataSubscriptionsByOrganizationName':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetDataSubscriptionsByOrganizationName' };
                await events.onMatch(ctx);
                return handleDataApiAdminGetDataSubscriptionsByOrganizationNameRequest(ctx, service, data, interceptors);
            };
        case 'UpdateDataSubscription':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpdateDataSubscription' };
                await events.onMatch(ctx);
                return handleDataApiAdminUpdateDataSubscriptionRequest(ctx, service, data, interceptors);
            };
        case 'DeleteDataSubscription':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'DeleteDataSubscription' };
                await events.onMatch(ctx);
                return handleDataApiAdminDeleteDataSubscriptionRequest(ctx, service, data, interceptors);
            };
        case 'CreateOrganization':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'CreateOrganization' };
                await events.onMatch(ctx);
                return handleDataApiAdminCreateOrganizationRequest(ctx, service, data, interceptors);
            };
        case 'GetOrganizationByName':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetOrganizationByName' };
                await events.onMatch(ctx);
                return handleDataApiAdminGetOrganizationByNameRequest(ctx, service, data, interceptors);
            };
        case 'GetOrganizations':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetOrganizations' };
                await events.onMatch(ctx);
                return handleDataApiAdminGetOrganizationsRequest(ctx, service, data, interceptors);
            };
        case 'GetAuditLogEvents':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAuditLogEvents' };
                await events.onMatch(ctx);
                return handleDataApiAdminGetAuditLogEventsRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminCreateDataTokenRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminCreateDataTokenJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminCreateDataTokenProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminGetDataTokenByIdRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminGetDataTokenByIdJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminGetDataTokenByIdProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminGetDataTokensByOrganizationNameRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminGetDataTokensByOrganizationNameJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminGetDataTokensByOrganizationNameProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminRevokeDataTokenByIdRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminRevokeDataTokenByIdJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminRevokeDataTokenByIdProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminCreateDataSubscriptionRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminCreateDataSubscriptionJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminCreateDataSubscriptionProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminGetDataSubscriptionByIdRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminGetDataSubscriptionByIdJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminGetDataSubscriptionByIdProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminGetDataSubscriptionsByOrganizationNameRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminGetDataSubscriptionsByOrganizationNameJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminGetDataSubscriptionsByOrganizationNameProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminUpdateDataSubscriptionRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminUpdateDataSubscriptionJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminUpdateDataSubscriptionProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminDeleteDataSubscriptionRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminDeleteDataSubscriptionJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminDeleteDataSubscriptionProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminCreateOrganizationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminCreateOrganizationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminCreateOrganizationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminGetOrganizationByNameRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminGetOrganizationByNameJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminGetOrganizationByNameProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminGetOrganizationsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminGetOrganizationsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminGetOrganizationsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDataApiAdminGetAuditLogEventsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDataApiAdminGetAuditLogEventsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDataApiAdminGetAuditLogEventsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleDataApiAdminCreateDataTokenJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CreateDataTokenRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateDataToken(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateDataToken(ctx, request);
    }
    return JSON.stringify(CreateDataTokenResponse.toJSON(response));
}
async function handleDataApiAdminGetDataTokenByIdJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetDataTokenByIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetDataTokenById(ctx, inputReq);
        });
    }
    else {
        response = await service.GetDataTokenById(ctx, request);
    }
    return JSON.stringify(GetDataTokenByIdResponse.toJSON(response));
}
async function handleDataApiAdminGetDataTokensByOrganizationNameJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetDataTokensByOrganizationNameRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetDataTokensByOrganizationName(ctx, inputReq);
        });
    }
    else {
        response = await service.GetDataTokensByOrganizationName(ctx, request);
    }
    return JSON.stringify(GetDataTokensByOrganizationNameResponse.toJSON(response));
}
async function handleDataApiAdminRevokeDataTokenByIdJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = RevokeDataTokenByIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RevokeDataTokenById(ctx, inputReq);
        });
    }
    else {
        response = await service.RevokeDataTokenById(ctx, request);
    }
    return JSON.stringify(RevokeDataTokenByIdResponse.toJSON(response));
}
async function handleDataApiAdminCreateDataSubscriptionJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CreateDataSubscriptionRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateDataSubscription(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateDataSubscription(ctx, request);
    }
    return JSON.stringify(CreateDataSubscriptionResponse.toJSON(response));
}
async function handleDataApiAdminGetDataSubscriptionByIdJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetDataSubscriptionByIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetDataSubscriptionById(ctx, inputReq);
        });
    }
    else {
        response = await service.GetDataSubscriptionById(ctx, request);
    }
    return JSON.stringify(GetDataSubscriptionByIdResponse.toJSON(response));
}
async function handleDataApiAdminGetDataSubscriptionsByOrganizationNameJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetDataSubscriptionsByOrganizationNameRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetDataSubscriptionsByOrganizationName(ctx, inputReq);
        });
    }
    else {
        response = await service.GetDataSubscriptionsByOrganizationName(ctx, request);
    }
    return JSON.stringify(GetDataSubscriptionsByOrganizationNameResponse.toJSON(response));
}
async function handleDataApiAdminUpdateDataSubscriptionJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UpdateDataSubscriptionRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateDataSubscription(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateDataSubscription(ctx, request);
    }
    return JSON.stringify(UpdateDataSubscriptionResponse.toJSON(response));
}
async function handleDataApiAdminDeleteDataSubscriptionJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = DeleteDataSubscriptionRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DeleteDataSubscription(ctx, inputReq);
        });
    }
    else {
        response = await service.DeleteDataSubscription(ctx, request);
    }
    return JSON.stringify(DeleteDataSubscriptionResponse.toJSON(response));
}
async function handleDataApiAdminCreateOrganizationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CreateOrganizationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateOrganization(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateOrganization(ctx, request);
    }
    return JSON.stringify(CreateOrganizationResponse.toJSON(response));
}
async function handleDataApiAdminGetOrganizationByNameJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetOrganizationByNameRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetOrganizationByName(ctx, inputReq);
        });
    }
    else {
        response = await service.GetOrganizationByName(ctx, request);
    }
    return JSON.stringify(GetOrganizationByNameResponse.toJSON(response));
}
async function handleDataApiAdminGetOrganizationsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetOrganizationsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetOrganizations(ctx, inputReq);
        });
    }
    else {
        response = await service.GetOrganizations(ctx, request);
    }
    return JSON.stringify(GetOrganizationsResponse.toJSON(response));
}
async function handleDataApiAdminGetAuditLogEventsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAuditLogEventsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAuditLogEvents(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAuditLogEvents(ctx, request);
    }
    return JSON.stringify(GetAuditLogEventsResponse.toJSON(response));
}
async function handleDataApiAdminCreateDataTokenProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CreateDataTokenRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateDataToken(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateDataToken(ctx, request);
    }
    return Buffer.from(CreateDataTokenResponse.encode(response).finish());
}
async function handleDataApiAdminGetDataTokenByIdProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetDataTokenByIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetDataTokenById(ctx, inputReq);
        });
    }
    else {
        response = await service.GetDataTokenById(ctx, request);
    }
    return Buffer.from(GetDataTokenByIdResponse.encode(response).finish());
}
async function handleDataApiAdminGetDataTokensByOrganizationNameProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetDataTokensByOrganizationNameRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetDataTokensByOrganizationName(ctx, inputReq);
        });
    }
    else {
        response = await service.GetDataTokensByOrganizationName(ctx, request);
    }
    return Buffer.from(GetDataTokensByOrganizationNameResponse.encode(response).finish());
}
async function handleDataApiAdminRevokeDataTokenByIdProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = RevokeDataTokenByIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RevokeDataTokenById(ctx, inputReq);
        });
    }
    else {
        response = await service.RevokeDataTokenById(ctx, request);
    }
    return Buffer.from(RevokeDataTokenByIdResponse.encode(response).finish());
}
async function handleDataApiAdminCreateDataSubscriptionProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CreateDataSubscriptionRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateDataSubscription(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateDataSubscription(ctx, request);
    }
    return Buffer.from(CreateDataSubscriptionResponse.encode(response).finish());
}
async function handleDataApiAdminGetDataSubscriptionByIdProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetDataSubscriptionByIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetDataSubscriptionById(ctx, inputReq);
        });
    }
    else {
        response = await service.GetDataSubscriptionById(ctx, request);
    }
    return Buffer.from(GetDataSubscriptionByIdResponse.encode(response).finish());
}
async function handleDataApiAdminGetDataSubscriptionsByOrganizationNameProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetDataSubscriptionsByOrganizationNameRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetDataSubscriptionsByOrganizationName(ctx, inputReq);
        });
    }
    else {
        response = await service.GetDataSubscriptionsByOrganizationName(ctx, request);
    }
    return Buffer.from(GetDataSubscriptionsByOrganizationNameResponse.encode(response).finish());
}
async function handleDataApiAdminUpdateDataSubscriptionProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UpdateDataSubscriptionRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateDataSubscription(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateDataSubscription(ctx, request);
    }
    return Buffer.from(UpdateDataSubscriptionResponse.encode(response).finish());
}
async function handleDataApiAdminDeleteDataSubscriptionProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = DeleteDataSubscriptionRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DeleteDataSubscription(ctx, inputReq);
        });
    }
    else {
        response = await service.DeleteDataSubscription(ctx, request);
    }
    return Buffer.from(DeleteDataSubscriptionResponse.encode(response).finish());
}
async function handleDataApiAdminCreateOrganizationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CreateOrganizationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateOrganization(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateOrganization(ctx, request);
    }
    return Buffer.from(CreateOrganizationResponse.encode(response).finish());
}
async function handleDataApiAdminGetOrganizationByNameProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetOrganizationByNameRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetOrganizationByName(ctx, inputReq);
        });
    }
    else {
        response = await service.GetOrganizationByName(ctx, request);
    }
    return Buffer.from(GetOrganizationByNameResponse.encode(response).finish());
}
async function handleDataApiAdminGetOrganizationsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetOrganizationsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetOrganizations(ctx, inputReq);
        });
    }
    else {
        response = await service.GetOrganizations(ctx, request);
    }
    return Buffer.from(GetOrganizationsResponse.encode(response).finish());
}
async function handleDataApiAdminGetAuditLogEventsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAuditLogEventsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAuditLogEvents(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAuditLogEvents(ctx, request);
    }
    return Buffer.from(GetAuditLogEventsResponse.encode(response).finish());
}
export var EventsMethod;
(function (EventsMethod) {
    EventsMethod["SendEvent"] = "SendEvent";
})(EventsMethod || (EventsMethod = {}));
export const EventsMethodList = [EventsMethod.SendEvent];
export function createEventsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'Events',
        methodList: EventsMethodList,
        matchRoute: matchEventsRoute,
    });
}
function matchEventsRoute(method, events) {
    switch (method) {
        case 'SendEvent':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SendEvent' };
                await events.onMatch(ctx);
                return handleEventsSendEventRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleEventsSendEventRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleEventsSendEventJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleEventsSendEventProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleEventsSendEventJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Value.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SendEvent(ctx, inputReq);
        });
    }
    else {
        response = await service.SendEvent(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleEventsSendEventProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Value.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SendEvent(ctx, inputReq);
        });
    }
    else {
        response = await service.SendEvent(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
export var DevPortalInstallationSettingsMethod;
(function (DevPortalInstallationSettingsMethod) {
    DevPortalInstallationSettingsMethod["GetForm"] = "GetForm";
    DevPortalInstallationSettingsMethod["ValidateForm"] = "ValidateForm";
    DevPortalInstallationSettingsMethod["GetSettings"] = "GetSettings";
    DevPortalInstallationSettingsMethod["UpdateSettings"] = "UpdateSettings";
})(DevPortalInstallationSettingsMethod || (DevPortalInstallationSettingsMethod = {}));
export const DevPortalInstallationSettingsMethodList = [
    DevPortalInstallationSettingsMethod.GetForm,
    DevPortalInstallationSettingsMethod.ValidateForm,
    DevPortalInstallationSettingsMethod.GetSettings,
    DevPortalInstallationSettingsMethod.UpdateSettings,
];
export function createDevPortalInstallationSettingsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'DevPortalInstallationSettings',
        methodList: DevPortalInstallationSettingsMethodList,
        matchRoute: matchDevPortalInstallationSettingsRoute,
    });
}
function matchDevPortalInstallationSettingsRoute(method, events) {
    switch (method) {
        case 'GetForm':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetForm' };
                await events.onMatch(ctx);
                return handleDevPortalInstallationSettingsGetFormRequest(ctx, service, data, interceptors);
            };
        case 'ValidateForm':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ValidateForm' };
                await events.onMatch(ctx);
                return handleDevPortalInstallationSettingsValidateFormRequest(ctx, service, data, interceptors);
            };
        case 'GetSettings':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetSettings' };
                await events.onMatch(ctx);
                return handleDevPortalInstallationSettingsGetSettingsRequest(ctx, service, data, interceptors);
            };
        case 'UpdateSettings':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpdateSettings' };
                await events.onMatch(ctx);
                return handleDevPortalInstallationSettingsUpdateSettingsRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalInstallationSettingsGetFormRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalInstallationSettingsGetFormJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalInstallationSettingsGetFormProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalInstallationSettingsValidateFormRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalInstallationSettingsValidateFormJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalInstallationSettingsValidateFormProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalInstallationSettingsGetSettingsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalInstallationSettingsGetSettingsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalInstallationSettingsGetSettingsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalInstallationSettingsUpdateSettingsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalInstallationSettingsUpdateSettingsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalInstallationSettingsUpdateSettingsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleDevPortalInstallationSettingsGetFormJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetInstallationSettingsFormRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetForm(ctx, inputReq);
        });
    }
    else {
        response = await service.GetForm(ctx, request);
    }
    return JSON.stringify(GetInstallationSettingsFormResponse.toJSON(response));
}
async function handleDevPortalInstallationSettingsValidateFormJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ValidateInstallationSettingsFormRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ValidateForm(ctx, inputReq);
        });
    }
    else {
        response = await service.ValidateForm(ctx, request);
    }
    return JSON.stringify(ValidateInstallationSettingsFormResponse.toJSON(response));
}
async function handleDevPortalInstallationSettingsGetSettingsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetInstallationSettingsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.GetSettings(ctx, request);
    }
    return JSON.stringify(GetInstallationSettingsResponse.toJSON(response));
}
async function handleDevPortalInstallationSettingsUpdateSettingsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UpdateInstallationSettingsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateSettings(ctx, request);
    }
    return JSON.stringify(UpdateInstallationSettingsResponse.toJSON(response));
}
async function handleDevPortalInstallationSettingsGetFormProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetInstallationSettingsFormRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetForm(ctx, inputReq);
        });
    }
    else {
        response = await service.GetForm(ctx, request);
    }
    return Buffer.from(GetInstallationSettingsFormResponse.encode(response).finish());
}
async function handleDevPortalInstallationSettingsValidateFormProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ValidateInstallationSettingsFormRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ValidateForm(ctx, inputReq);
        });
    }
    else {
        response = await service.ValidateForm(ctx, request);
    }
    return Buffer.from(ValidateInstallationSettingsFormResponse.encode(response).finish());
}
async function handleDevPortalInstallationSettingsGetSettingsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetInstallationSettingsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.GetSettings(ctx, request);
    }
    return Buffer.from(GetInstallationSettingsResponse.encode(response).finish());
}
async function handleDevPortalInstallationSettingsUpdateSettingsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UpdateInstallationSettingsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateSettings(ctx, request);
    }
    return Buffer.from(UpdateInstallationSettingsResponse.encode(response).finish());
}
export var DevPortalAppSettingsMethod;
(function (DevPortalAppSettingsMethod) {
    DevPortalAppSettingsMethod["GetForm"] = "GetForm";
    DevPortalAppSettingsMethod["ValidateForm"] = "ValidateForm";
    DevPortalAppSettingsMethod["GetSettings"] = "GetSettings";
    DevPortalAppSettingsMethod["UpdateSettings"] = "UpdateSettings";
})(DevPortalAppSettingsMethod || (DevPortalAppSettingsMethod = {}));
export const DevPortalAppSettingsMethodList = [
    DevPortalAppSettingsMethod.GetForm,
    DevPortalAppSettingsMethod.ValidateForm,
    DevPortalAppSettingsMethod.GetSettings,
    DevPortalAppSettingsMethod.UpdateSettings,
];
export function createDevPortalAppSettingsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'DevPortalAppSettings',
        methodList: DevPortalAppSettingsMethodList,
        matchRoute: matchDevPortalAppSettingsRoute,
    });
}
function matchDevPortalAppSettingsRoute(method, events) {
    switch (method) {
        case 'GetForm':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetForm' };
                await events.onMatch(ctx);
                return handleDevPortalAppSettingsGetFormRequest(ctx, service, data, interceptors);
            };
        case 'ValidateForm':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ValidateForm' };
                await events.onMatch(ctx);
                return handleDevPortalAppSettingsValidateFormRequest(ctx, service, data, interceptors);
            };
        case 'GetSettings':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetSettings' };
                await events.onMatch(ctx);
                return handleDevPortalAppSettingsGetSettingsRequest(ctx, service, data, interceptors);
            };
        case 'UpdateSettings':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpdateSettings' };
                await events.onMatch(ctx);
                return handleDevPortalAppSettingsUpdateSettingsRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalAppSettingsGetFormRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalAppSettingsGetFormJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalAppSettingsGetFormProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalAppSettingsValidateFormRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalAppSettingsValidateFormJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalAppSettingsValidateFormProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalAppSettingsGetSettingsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalAppSettingsGetSettingsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalAppSettingsGetSettingsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalAppSettingsUpdateSettingsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalAppSettingsUpdateSettingsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalAppSettingsUpdateSettingsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleDevPortalAppSettingsGetFormJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAppSettingsFormRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetForm(ctx, inputReq);
        });
    }
    else {
        response = await service.GetForm(ctx, request);
    }
    return JSON.stringify(GetAppSettingsFormResponse.toJSON(response));
}
async function handleDevPortalAppSettingsValidateFormJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ValidateAppSettingsFormRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ValidateForm(ctx, inputReq);
        });
    }
    else {
        response = await service.ValidateForm(ctx, request);
    }
    return JSON.stringify(ValidateAppSettingsFormResponse.toJSON(response));
}
async function handleDevPortalAppSettingsGetSettingsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAppSettingsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.GetSettings(ctx, request);
    }
    return JSON.stringify(GetAppSettingsResponse.toJSON(response));
}
async function handleDevPortalAppSettingsUpdateSettingsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UpdateAppSettingsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateSettings(ctx, request);
    }
    return JSON.stringify(UpdateAppSettingsResponse.toJSON(response));
}
async function handleDevPortalAppSettingsGetFormProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAppSettingsFormRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetForm(ctx, inputReq);
        });
    }
    else {
        response = await service.GetForm(ctx, request);
    }
    return Buffer.from(GetAppSettingsFormResponse.encode(response).finish());
}
async function handleDevPortalAppSettingsValidateFormProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ValidateAppSettingsFormRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ValidateForm(ctx, inputReq);
        });
    }
    else {
        response = await service.ValidateForm(ctx, request);
    }
    return Buffer.from(ValidateAppSettingsFormResponse.encode(response).finish());
}
async function handleDevPortalAppSettingsGetSettingsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAppSettingsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.GetSettings(ctx, request);
    }
    return Buffer.from(GetAppSettingsResponse.encode(response).finish());
}
async function handleDevPortalAppSettingsUpdateSettingsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UpdateAppSettingsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateSettings(ctx, request);
    }
    return Buffer.from(UpdateAppSettingsResponse.encode(response).finish());
}
