export interface SubredditData {
    id?: string;
    name?: string;
    displayName?: string;
    communityIcon?: string;
    keyColor?: string;
    subscribers?: number;
    primaryColor?: string;
    lastUpdated?: string;
    icon?: string;
}
export type GetConversationsRequest = {
    /** modmail conversation id */
    after?: string;
    /** array of subreddit names */
    subreddits?: string[];
    /** an integer between 1 and 100 (default: 25) */
    limit?: number;
    /**
     * Sort by:
     * - `recent` - Order by whenever anyone last updated the conversation, mod or participant
     * - `mod` - Order by the last time a mod updated the conversation
     * - `user` - Order by the last time a participant user updated the conversation
     * - `unread` - Order by the most recent unread message in the conversation for this mod
     */
    sort?: 'recent' | 'mod' | 'user' | 'unread';
    /**
     * Filter by conversation state
     *
     * A conversation can be in more than one state.
     * For example, a conversation may be both 'highlighted' and 'inprogress'.
     */
    state?: ConversationStateFilter;
};
/**
 * A Conversation State is a way in which conversations may be filtered within the UI.
 *
 * A conversation can be in more than one state.
 * For example, a conversation may be both 'highlighted' and 'inprogress'.
 */
export type ConversationStateFilter = 'all' | 'new' | 'inprogress' | 'archived' | 'appeals' | 'join_requests' | 'highlighted' | 'mod' | 'notifications' | 'inbox' | 'filtered' | 'default';
/**
 * Conversation participant
 */
export interface Participant {
    isMod?: boolean;
    isAdmin?: boolean;
    name?: string;
    isOp?: boolean;
    isParticipant?: boolean;
    isApproved?: boolean;
    isHidden?: boolean;
    id?: number;
    isDeleted?: boolean;
}
export interface ConversationUserData {
    /** User ID*/
    id?: string;
    /** Username */
    name?: string;
    /** Recent comments */
    recentComments: {
        [id: string]: {
            comment?: string;
            date?: string;
            permalink?: string;
            title?: string;
        };
    };
    /** Recent posts */
    recentPosts: {
        [id: string]: {
            date?: string;
            permalink?: string;
            title?: string;
        };
    };
    /** Recent conversations */
    recentConvos: {
        [id: string]: {
            date?: string;
            permalink?: string;
            id?: string;
            subject?: string;
        };
    };
    isSuspended?: boolean;
    isShadowBanned?: boolean;
    muteStatus?: {
        isMuted?: boolean;
        muteCount?: number;
        endDate?: string;
        reason?: string;
    };
    banStatus?: {
        isBanned?: boolean;
        isPermanent?: boolean;
        endDate?: string;
        reason?: string;
    };
    approveStatus?: {
        isApproved?: boolean;
    };
    /** When was created */
    created?: string;
}
export declare enum ModMailConversationState {
    New = "New",
    InProgress = "InProgress",
    Archived = "Archived",
    Appeals = "Appeals",
    JoinRequests = "JoinRequests",
    Filtered = "Filtered"
}
/**
 * An ActionType describes a particular logged action within a conversation. For example,
 * if a mod highlights a conversation, a ModerationAction record with the type `Highlighted`
 * would be created.
 */
export declare enum ModMailActionType {
    Highlighted = "Highlighted",
    Unhighlighted = "Unhighlighted",
    Archived = "Archived",
    Unarchived = "Unarchived",
    ReportedToAdmins = "ReportedToAdmins",
    Muted = "Muted",
    Unmuted = "Unmuted",
    Banned = "Banned",
    Unbanned = "Unbanned",
    Approved = "Approved",
    Disapproved = "Disapproved",
    Filtered = "Filtered",
    Unfiltered = "Unfiltered"
}
export interface ConversationData {
    /** Conversation ID */
    id?: string;
    /** Suject of the conversation */
    subject?: string;
    /**
     * Subreddit owning the modmail conversation
     */
    subreddit?: {
        displayName?: string;
        id?: string;
    };
    /**
     * A ConversationType specifies whether a conversation is with a subreddit
     * itself, with another user, or with another subreddit entirely.
     * - `internal` - This is a conversation with another user outside of the subreddit. The participant ID is that user's ID.
     * - `sr_user` - This is a Mod Discussion, internal to the subreddit. There is no other participant.
     * - `sr_sr` - This is a conversation is with another subreddit. The participant will have a subreddit ID.
     */
    conversationType?: string;
    /** Is the conversation automatically generated e.g. from automod, u/reddit */
    isAuto?: boolean;
    /** Participant. Is absent for mod discussions */
    participant?: Participant;
    /** The last datetime a user made any interaction with the conversation */
    lastUserUpdate?: string;
    /** Is the conversation internal (i.e. mod only) */
    isInternal?: boolean;
    /**
     * The last datetime a mod from the owning subreddit made any interaction
     * with the conversation.
     *
     * (Note that if this is a subreddit to subreddit conversation, the mods of
     * the participant subreddit are irrelevant and do not affect this field.)
     */
    lastModUpdate?: string;
    /** The authors of each message in the modmail conversation. */
    authors: Participant[];
    /** The datetime of the last time the conversation was update. */
    lastUpdated?: string;
    /** State of the conversation */
    state?: ModMailConversationState;
    /** The datetime of the last unread message within this conversation for the current viewer. */
    lastUnread?: string;
    /** Is the conversation highlighted */
    isHighlighted?: boolean;
    /** Number of messages (not actions) in the conversation */
    numMessages?: number;
    /**
     * Conversation messages
     *
     * @example
     * ```ts
     * const arrayOfMessages = Object.values(conversation.messages);
     * const messageById = conversation.messages[messageId];
     * ```
     */
    messages: {
        [id: string]: MessageData;
    };
    /**
     * Conversation mod actions
     *
     * @example
     * ```ts
     * const arrayOfModActions = Object.values(conversation.modActions);
     * const modActionById = conversation.modActions[modActionId];
     * ```
     */
    modActions: {
        [id: string]: ModActionData;
    };
}
export interface ModActionData {
    /** Action id */
    id?: string;
    /** Type of the action */
    actionType: ModMailActionType;
    /** When the action happened */
    date?: string;
    /** Action author */
    author?: {
        /** User id  */
        id?: number;
        /** User name */
        name?: string;
        isMod?: boolean;
        isAdmin?: boolean;
        isHidden?: boolean;
        isDeleted?: boolean;
    };
}
export interface MessageData {
    /** Message ID */
    id?: string;
    /** Message body */
    body?: string;
    /** When was created */
    date?: string;
    author?: Participant;
    isInternal?: boolean;
    bodyMarkdown?: string;
    participatingAs?: string;
}
export interface ConversationResponse {
    conversation: ConversationData;
}
export interface WithUserData {
    user?: ConversationUserData;
}
export interface UnreadCountResponse {
    archived?: number;
    appeals?: number;
    highlighted?: number;
    notifications?: number;
    joinRequests?: number;
    filtered?: number;
    new?: number;
    inprogress?: number;
    mod?: number;
}
type ParticipantSubreddit = {
    id: string;
    name: string;
};
export type GetConversationResponse = {
    conversation?: ConversationData;
    /** If the conversation is with another subreddit, what subreddit we are communicating with. */
    participantSubreddit?: ParticipantSubreddit;
} & WithUserData;
export interface GetConversationsResponse {
    /**
     * Conversations key-value map
     */
    conversations: {
        [id: string]: ConversationData;
    };
    viewerId?: string;
}
/**
 * Class providing the methods for working with Mod Mail
 */
export declare class ModMailService {
    #private;
    /**
     * Marks all conversations read for a particular conversation state within the passed list of subreddits.
     *
     * @param subreddits Array of subreddit names
     * @param state One of the possible conversation states ('all' to read all conversations)
     *
     * @returns conversationIds
     *
     * @example
     * ```ts
     * const conversationIds = await reddit.modMail.bulkReadConversations(
     *   ['askReddit', 'myAwesomeSubreddit'],
     *   'filtered'
     * );
     * ```
     */
    bulkReadConversations(subreddits: string[], state: ConversationStateFilter): Promise<string[]>;
    /**
     * Get conversations for a logged in user or subreddits
     *
     * @param params.after id of a modmail
     * @param params.subreddits array of subreddit names
     * @param params.limit an integer between 1 and 100 (default: 25)
     * @param params.sort one of (recent, mod, user, unread)
     * @param params.state One of the possible conversation states ('all' to read all conversations)
     *
     * @example
     * ```ts
     * const {viewerId, conversations} = await reddit.modMail.getConversations({
     *   after: 'abcdef',
     *   limit: 42
     * });
     *
     * const arrayOfConversations = Object.values(conversations);
     * ```
     */
    getConversations(params: GetConversationsRequest): Promise<GetConversationsResponse>;
    /**
     * Returns all messages, mod actions and conversation metadata for a given conversation id
     *
     * @param params.conversationId id of a modmail conversation
     * @param params.markRead should be marked as read (default: false)
     *
     * @example
     * ```ts
     * const { conversation, messages, modActions, user } = await reddit.modMail.getConversation({ conversationId: 'abcdef', markRead: true });
     * ```
     */
    getConversation(params: {
        /** a modmail conversation id */
        conversationId: string;
        /** mark read? */
        markRead?: boolean;
    }): Promise<GetConversationResponse>;
    /**
     * Returns a list of Subreddits that the user moderates with mail permission
     *
     * @example
     * ```ts
     * const subredditsData = await reddit.modMail.getSubreddits();
     *
     * for (const subreddit of Object.values(subreddits)) {
     *   console.log(subreddit.id);
     *   console.log(subreddit.name);
     * }
     * ```
     */
    getSubreddits(): Promise<{
        [key: string]: SubredditData;
    }>;
    /**
     * Creates a new conversation for a particular SR.
     *
     * This endpoint will create a ModmailConversation object
     * as well as the first ModmailMessage within the ModmailConversation object.
     *
     * @note
     * Note on {param.to}:
     * The to field for this endpoint is somewhat confusing. It can be:
     * - A User, passed like "username" or "u/username"
     * - A Subreddit, passed like "r/subreddit"
     * - null, meaning an internal moderator discussion
     *
     * In this way to is a bit of a misnomer in modmail conversations.
     * What it really means is the participant of the conversation who is not a mod of the subreddit.
     *
     * @param params.body markdown text
     * @param params.isAuthorHidden is author hidden? (default: false)
     * @param params.subredditName subreddit name
     * @param params.subject subject of the conversation. max 100 characters
     * @param params.to a user (e.g. u/username), a subreddit (e.g. r/subreddit) or null
     *
     * @example
     * ```ts
     * const { conversation, messages, modActions } = await reddit.modMail.createConversation({
     *   subredditName: 'askReddit',
     *   subject: 'Test conversation',
     *   body: 'Lorem ipsum sit amet',
     *   to: null,
     * });
     * ```
     */
    createConversation(params: {
        body: string;
        isAuthorHidden?: boolean;
        subredditName: string;
        subject: string;
        to?: string | null;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Creates a new message for a particular conversation.
     *
     * @param params.conversationId Id of a modmail conversation
     * @param params.body markdown text
     * @param params.isInternal is internal message? (default: false)
     * @param params.isAuthorHidden is author hidden? (default: false)
     *
     * @example
     * ```ts
     * await reddit.modMail.reply({
     *   body: 'Lorem ipsum sit amet',
     *   conversationId: 'abcdef',
     * });
     * ```
     */
    reply(params: {
        body: string;
        isAuthorHidden?: boolean;
        isInternal?: boolean;
        conversationId: string;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Marks a conversation as highlighted.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.highlightConversation('abcdef');
     * ```
     */
    highlightConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Removes a highlight from a conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unhighlightConversation('abcdef');
     * ```
     */
    unhighlightConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Marks a conversation as archived
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.archive('abcdef');
     * ```
     */
    archiveConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Marks conversation as unarchived.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unarchiveConversation('abcdef');
     * ```
     */
    unarchiveConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Marks a conversation as read for the user.
     *
     * @param params.conversationId Id of a modmail conversation
     * @param params.numHours For how many hous the conversation needs to be muted
     *
     * @example
     * ```ts
     * await reddit.modMail.muteConversation({ conversationId: 'abcdef', numHours: 2 });
     * ```
     */
    muteConversation(params: {
        conversationId: string;
        numHours: number;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Unmutes the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unmuteConversation('abcdef');
     * ```
     */
    unmuteConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Marks a conversations as read for the user.
     *
     * @param conversationIds An array of ids
     *
     * @example
     * ```ts
     * await reddit.modMail.readConversations(['abcdef', 'qwerty']);
     * ```
     */
    readConversations(conversationIds: string[]): Promise<void>;
    /**
     * Marks conversations as unread for the user.
     *
     * @param conversationIds An array of ids
     *
     * @example
     * ```ts
     * await reddit.modMail.unreadConversations(['abcdef', 'qwerty']);
     * ```
     */
    unreadConversations(conversationIds: string[]): Promise<void>;
    /**
     * Approve the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.approveConversation('abcdef');
     * ```
     */
    approveConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Disapprove the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.disapproveConversation('abcdef');
     * ```
     */
    disapproveConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Temporary ban (switch from permanent to temporary ban) the non mod user associated with a particular conversation.
     *
     * @param params.conversationId a modmail conversation id
     * @param params.duration duration in days, max 999
     *
     * @example
     * ```ts
     * await reddit.modMail.tempBanConversation({ conversationId: 'abcdef', duration: 42 });
     * ```
     */
    tempBanConversation(params: {
        conversationId: string;
        duration: number;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Unban the non mod user associated with a particular conversation.
     *
     * @param conversationId a modmail conversation id
     *
     * @example
     * ```ts
     * await reddit.modMail.unbanConversation('abcdef');
     * ```
     */
    unbanConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Endpoint to retrieve the unread conversation count by conversation state.
     *
     * @example
     * ```ts
     * const response = await reddit.modMail.getUnreadCount();
     *
     * console.log(response.highlighted);
     * console.log(response.new);
     * ```
     */
    getUnreadCount(): Promise<UnreadCountResponse>;
    /**
     * Returns recent posts, comments and modmail conversations for a given user.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * const data = await reddit.modMail.getUserConversations('abcdef');
     *
     * console.log(data.recentComments);
     * console.log(data.recentPosts);
     * ```
     */
    getUserConversations(conversationId: string): Promise<ConversationUserData>;
}
export {};
//# sourceMappingURL=ModMail.d.ts.map