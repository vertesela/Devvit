import { Hook, } from '../../../types/hooks.js';
import { ChannelStatus } from '../../../types/realtime.js';
import { RealtimeSubscriptionStatus } from '@devvit/protos';
export function makeUseChannelHook(reconciler) {
    function useChannel(options) {
        const hookIndex = reconciler.currentHookIndex;
        const currentState = reconciler.getCurrentComponentState();
        const previousState = reconciler.getPreviousComponentState();
        let hookState = {
            channel: options.name,
            active: false,
            connected: false,
            preventCallback: false,
            type: Hook.CHANNEL,
        };
        if (hookIndex in currentState) {
            hookState = currentState[hookIndex];
        }
        else if (hookIndex in previousState) {
            hookState = previousState[hookIndex];
        }
        async function send(data) {
            const name = currentState[hookIndex].channel;
            if (currentState[hookIndex].active) {
                if (currentState[hookIndex].connected) {
                    await reconciler.realtime.send(name, data);
                }
                else {
                    throw Error(`Failed to send to channel '${name}'; it is active but not yet connected`);
                }
            }
            else {
                throw Error(`Cannot send a message over inactive channel: ${name}`);
            }
        }
        function subscribe() {
            if (!currentState[hookIndex].active) {
                const name = currentState[hookIndex].channel;
                currentState[hookIndex].active = true;
                reconciler.addRealtimeChannel(name);
            }
        }
        function unsubscribe() {
            if (currentState[hookIndex].active) {
                const name = currentState[hookIndex].channel;
                currentState[hookIndex].active = false;
                reconciler.removeRealtimeChannel(name);
            }
        }
        const event = reconciler.realtimeEvent;
        if (reconciler.isInitialRender) {
            hookState.active = false;
        }
        else if (event && hookState.active && event.event.channel === hookState.channel) {
            if (!hookState.preventCallback) {
                reconciler.runHook(async () => {
                    let result;
                    switch (event.status) {
                        case RealtimeSubscriptionStatus.REALTIME_SUBSCRIBED:
                            hookState.connected = true;
                            result = options.onSubscribed?.();
                            break;
                        case RealtimeSubscriptionStatus.REALTIME_UNSUBSCRIBED:
                            hookState.connected = false;
                            result = options.onUnsubscribed?.();
                            break;
                        default:
                            result = options.onMessage(event.event?.data ?? {});
                            break;
                    }
                    await result;
                });
            }
            reconciler.rerenderIn(0);
        }
        currentState[hookIndex] = hookState;
        reconciler.currentHookIndex++;
        let status = ChannelStatus.Unknown;
        if (hookState.active && hookState.connected) {
            status = ChannelStatus.Connected;
        }
        else if (hookState.active && !hookState.connected) {
            status = ChannelStatus.Connecting;
        }
        else if (!hookState.active && hookState.connected) {
            status = ChannelStatus.Disconnecting;
        }
        else if (!hookState.active && !hookState.connected) {
            status = ChannelStatus.Disconnected;
        }
        return {
            subscribe,
            unsubscribe,
            send,
            status,
        };
    }
    return useChannel;
}
