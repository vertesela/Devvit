var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ListInstalls_instances, _ListInstalls_installationsClient, _ListInstalls_fetchInstalls, _ListInstalls_formatAndLogInstallations, _ListInstalls_formatAndLogInstallationsOfMyApps, _ListInstalls_formatAndLogInstallationsInSubreddit;
import { GetAllWithInstallerRequest, GetAllWithInstallLocationRequest, InstallationType, UUID, } from '@devvit/protos';
import { Args, ux } from '@oclif/core';
import { DevvitCommand, toLowerCaseArgParser } from '../../util/commands/DevvitCommand.js';
import { createInstallationsClient } from '../../util/clientGenerators.js';
import { DevvitVersion } from '@devvit/shared-types/Version.js';
var SearchType;
(function (SearchType) {
    SearchType[SearchType["MINE"] = 0] = "MINE";
    SearchType[SearchType["BY_SUB"] = 1] = "BY_SUB";
})(SearchType || (SearchType = {}));
class ListInstalls extends DevvitCommand {
    constructor() {
        super(...arguments);
        _ListInstalls_instances.add(this);
        _ListInstalls_installationsClient.set(this, createInstallationsClient(this));
    }
    async run() {
        const { args } = await this.parse(ListInstalls);
        ux.action.start('loading');
        const results = await __classPrivateFieldGet(this, _ListInstalls_instances, "m", _ListInstalls_fetchInstalls).call(this, args.subreddit);
        ux.action.stop();
        this.log(); // newline
        let searchType = SearchType.MINE;
        if (args.subreddit) {
            searchType = SearchType.BY_SUB;
        }
        await __classPrivateFieldGet(this, _ListInstalls_instances, "m", _ListInstalls_formatAndLogInstallations).call(this, results.installations, searchType);
    }
}
_ListInstalls_installationsClient = new WeakMap(), _ListInstalls_instances = new WeakSet(), _ListInstalls_fetchInstalls = async function _ListInstalls_fetchInstalls(subreddit) {
    const token = await this.getAccessTokenAndLoginIfNeeded();
    if (subreddit != null) {
        // ask about installations in given subreddit
        return await __classPrivateFieldGet(this, _ListInstalls_installationsClient, "f").GetAllWithInstallLocation(GetAllWithInstallLocationRequest.fromPartial({
            type: InstallationType.SUBREDDIT,
            location: subreddit,
        }));
    }
    // Not getting subreddit app installs, get all apps installed by the logged in user
    const myId = await this.getUserT2Id(token);
    return await __classPrivateFieldGet(this, _ListInstalls_installationsClient, "f").GetAllWithInstaller(GetAllWithInstallerRequest.fromPartial({
        installedBy: myId,
    }));
}, _ListInstalls_formatAndLogInstallations = async function _ListInstalls_formatAndLogInstallations(installations, searchType) {
    const fullInstallationsInfo = await Promise.all(installations.map((i) => __classPrivateFieldGet(this, _ListInstalls_installationsClient, "f").GetByUUID(UUID.fromPartial({ id: i.id }))));
    if (searchType === SearchType.BY_SUB) {
        __classPrivateFieldGet(this, _ListInstalls_instances, "m", _ListInstalls_formatAndLogInstallationsInSubreddit).call(this, fullInstallationsInfo);
        return;
    }
    __classPrivateFieldGet(this, _ListInstalls_instances, "m", _ListInstalls_formatAndLogInstallationsOfMyApps).call(this, fullInstallationsInfo);
}, _ListInstalls_formatAndLogInstallationsOfMyApps = function _ListInstalls_formatAndLogInstallationsOfMyApps(installations) {
    const installationsIndexedByAppName = new Map();
    // index installations by app name
    installations.forEach((installationInfo) => {
        if (installationInfo.app == null)
            return;
        const appName = installationInfo.app.name;
        installationsIndexedByAppName.set(appName, installationsIndexedByAppName.get(appName) ?? []);
        installationsIndexedByAppName.get(appName).push(installationInfo);
    });
    const data = [];
    installationsIndexedByAppName.forEach((installations, appName) => {
        data.push({
            appName,
            installations: installations.map((i) => ({
                appVersion: DevvitVersion.fromProtoAppVersionInfo(i.appVersion).toString(),
                location: i.installation.location.name,
            })),
        });
    });
    const appNameColumn = {
        header: 'App Name',
        get: (entry) => entry.appName,
        minWidth: 18,
    };
    const installedSubredditsColumn = {
        header: 'Installed Subreddits',
        get: (row) => row.installations
            .map((installation) => `${installation.location} (v${installation.appVersion})`)
            .join(`\n`) + '\n',
    };
    ux.table(data, {
        appNameColumn,
        installedSubredditsColumn,
    });
}, _ListInstalls_formatAndLogInstallationsInSubreddit = function _ListInstalls_formatAndLogInstallationsInSubreddit(installationsInSubreddit) {
    const data = installationsInSubreddit.map((installation) => {
        const versionStr = DevvitVersion.fromProtoAppVersionInfo(installation.appVersion).toString();
        const appName = installation.app.name;
        return {
            version: versionStr,
            appName,
        };
    });
    // we can assume the list of installations is specific to a subreddit
    const appsColumn = {
        header: 'Apps Installed In Subreddit',
        get: (row) => `${row.appName} (v${row.version})`,
        minWidth: 18,
    };
    ux.table(data, { appsColumn });
};
ListInstalls.description = 'List all apps currently installed in the specified subreddit. If no subreddit is given, defaults to listing all apps installed by you';
ListInstalls.args = {
    subreddit: Args.string({
        required: false,
        description: 'Provide the name of the subreddit in which to search for app installs. The "r/" prefix is optional',
        parse: toLowerCaseArgParser,
    }),
};
export default ListInstalls;
