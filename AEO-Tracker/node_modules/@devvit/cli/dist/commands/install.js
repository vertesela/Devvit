var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Install_instances, _Install_appClient, _Install_appVersionClient, _Install_installationsClient, _Install_findExistingInstallation;
import { GetAllWithInstallLocationRequest, InstallationCreationRequest, InstallationType, InstallationUpgradeRequest, NutritionCategory, UUID, } from '@devvit/protos';
import { DevvitVersion } from '@devvit/shared-types/Version.js';
import { Args, ux } from '@oclif/core';
import os from 'node:os';
import { createAppClient, createAppVersionClient, createInstallationsClient, } from '../util/clientGenerators.js';
import { DevvitCommand, toLowerCaseArgParser } from '../util/commands/DevvitCommand.js';
import { getInfoForSlugString } from '../util/common-actions/slugVersionStringToUUID.js';
class Install extends DevvitCommand {
    constructor() {
        super(...arguments);
        _Install_instances.add(this);
        _Install_appClient.set(this, createAppClient(this));
        _Install_appVersionClient.set(this, createAppVersionClient(this));
        _Install_installationsClient.set(this, createInstallationsClient(this));
    }
    async run() {
        const { args } = await this.parse(Install);
        const { subreddit } = args;
        const appWithVersion = await this.inferAppNameAndVersion(args.appWithVersion);
        await this.checkIfUserLoggedIn();
        await this.checkDevvitTermsAndConditions();
        const token = await this.getAccessTokenAndLoginIfNeeded();
        const userT2Id = await this.getUserT2Id(token);
        const { appInfo, appVersion } = await getInfoForSlugString(appWithVersion, __classPrivateFieldGet(this, _Install_appClient, "f"));
        const name = appInfo.app.slug;
        const version = DevvitVersion.fromProtoAppVersionInfo(appVersion).toString();
        ux.action.start(`Requesting installation details on ${name}`);
        const [existingInstallInfo, nutrition] = await Promise.all([
            __classPrivateFieldGet(this, _Install_instances, "m", _Install_findExistingInstallation).call(this, {
                subreddit: subreddit,
                appId: appInfo.app.id,
            }),
            __classPrivateFieldGet(this, _Install_appVersionClient, "f").GetNutritionByNameVersion({ name, version }),
        ]);
        if (existingInstallInfo) {
            ux.action.stop(`Currently on version ${DevvitVersion.fromProtoAppVersionInfo(existingInstallInfo.appVersion).toString()} ✅`);
        }
        this.log(nutritionCategoriesToString(name, nutrition.categories));
        const r = subreddit.startsWith('r/') ? '' : 'r/';
        ux.action.start(`Installing ${name} to ${r}${subreddit}`);
        let installationInfo;
        try {
            if (existingInstallInfo) {
                if (existingInstallInfo.appVersion && appVersion.id === existingInstallInfo.appVersion.id) {
                    // exit gracefully if the current app version is already installed
                    ux.action.stop(`Version ${DevvitVersion.fromProtoAppVersionInfo(existingInstallInfo.appVersion).toString()} has already been installed ✅`);
                    return;
                }
                else {
                    installationInfo = await __classPrivateFieldGet(this, _Install_installationsClient, "f").Upgrade(InstallationUpgradeRequest.fromPartial({
                        id: existingInstallInfo.installation?.id,
                        appVersionId: appVersion.id,
                    }));
                }
            }
            else {
                installationInfo = await __classPrivateFieldGet(this, _Install_installationsClient, "f").Create(InstallationCreationRequest.fromPartial({
                    appVersionId: appVersion.id,
                    runAs: userT2Id,
                    type: InstallationType.SUBREDDIT,
                    location: subreddit,
                }));
            }
            ux.action.stop(`Successfully installed version ${DevvitVersion.fromProtoAppVersionInfo(installationInfo.appVersion).toString()} ✅`);
        }
        catch {
            this.error('There was an error installing your app. Please try again later.');
        }
    }
}
_Install_appClient = new WeakMap(), _Install_appVersionClient = new WeakMap(), _Install_installationsClient = new WeakMap(), _Install_instances = new WeakSet(), _Install_findExistingInstallation = async function _Install_findExistingInstallation({ subreddit, appId, }) {
    const existingInstalls = await __classPrivateFieldGet(this, _Install_installationsClient, "f").GetAllWithInstallLocation(GetAllWithInstallLocationRequest.fromPartial({
        type: InstallationType.SUBREDDIT,
        location: subreddit,
    }));
    const fullInstallInfoList = await Promise.all(existingInstalls.installations.map((install) => {
        // TODO I'm not a fan of having to re-fetch these installs to get the app IDs
        // TODO we should update the protobuf to include the app and app version IDs
        return __classPrivateFieldGet(this, _Install_installationsClient, "f").GetByUUID(UUID.fromPartial({ id: install.id }));
    }));
    return fullInstallInfoList.find((install) => {
        return install.app?.id === appId;
    });
};
Install.description = 'Install an app from the App Directory to a subreddit that you moderate. Specify the version you want to install, or default to @latest';
Install.examples = [
    '$ devvit install <subreddit> [app-name][@version]',
    '$ devvit install r/MyTestSubreddit',
    '$ devvit install MyOtherTestSubreddit my-app',
    '$ devvit install r/SomeOtherSubreddit my-app@1.2.3',
    '$ devvit install r/AnotherSubreddit @1.2.3',
];
Install.args = {
    subreddit: Args.string({
        description: 'Provide the name of the subreddit where you want to install. The "r/" prefix is optional',
        required: true,
        parse: toLowerCaseArgParser,
    }),
    appWithVersion: Args.string({
        description: 'Provide the name of the app you want to install (defaults to working directory app) and version (defaults to latest)',
        required: false,
        parse: toLowerCaseArgParser,
    }),
};
export default Install;
function nutritionCategoriesToString(name, cats) {
    if (!cats.length)
        return `${name} requires no permissions!`;
    return `${name} may:\n${cats
        .map((cat) => ` • ${nutritionCategoryToString[cat] ??
        nutritionCategoryToString[NutritionCategory.UNRECOGNIZED]}`)
        .join(os.EOL)}`;
}
const nutritionCategoryToString = {
    [NutritionCategory.UNCATEGORIZED]: 'Use uncategorized permissions.',
    [NutritionCategory.APP_TRIGGERS]: 'Execute when installed or upgraded.',
    [NutritionCategory.ASSETS]: 'Present predefined audio-visual media.',
    [NutritionCategory.DATA]: 'Read and write _app_ data to Reddit servers.',
    [NutritionCategory.HTTP]: 'Read and write _any_ data to and from the internet.',
    [NutritionCategory.MODERATOR]: "Appear and act as a moderator on subreddits where it's installed.",
    [NutritionCategory.MODLOG]: 'Read and write to Reddit moderator logs.',
    [NutritionCategory.REDDIT_API]: 'Read and write _any_ Reddit data.',
    [NutritionCategory.REDDIT_TRIGGERS]: 'Observe Reddit events such as post creation, comment deletion, and more.',
    [NutritionCategory.SCHEDULER]: 'Schedule itself for later execution.',
    [NutritionCategory.UI]: 'Appear in subreddit, post, and comment menu entries, and custom posts.',
    [NutritionCategory.UNRECOGNIZED]: 'Use unknown permissions.',
};
