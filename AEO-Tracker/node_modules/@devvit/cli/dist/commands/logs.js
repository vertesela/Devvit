var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Logs_instances, _a, _Logs_appLogSub, _Logs_playtest, _Logs_getTailFilter, _Logs_newAppLogSub, _Logs_onExit;
import { GetByAppNameAndInstallLocationRequest, InstallationType, RemoteLogQuery, RemoteLogSubredditAppNameFilter, RemoteLogType, Severity, } from '@devvit/protos';
import { Args, Flags } from '@oclif/core';
import { sub } from 'date-fns';
import { filter, merge, retry } from 'rxjs';
import { PlaytestServer } from '../lib/playtest-server.js';
import { AppLogObserver } from '../util/app-logs/app-log-observer.js';
import { defaultAppLogDateFormat, formatAppLogDivider, parseAppLogDuration, supportedDurationFormats, } from '../util/app-logs/app-log-util.js';
import { createInstallationsClient, createRemoteLoggerClient } from '../util/clientGenerators.js';
import { DevvitCommand, toLowerCaseArgParser } from '../util/commands/DevvitCommand.js';
const durationFlag = Flags.custom({
    default: async () => new Date(),
    defaultHelp: async () => '0m',
    parse: async (str) => sub(new Date(), parseAppLogDuration(str)),
});
class Logs extends DevvitCommand {
    constructor() {
        super(...arguments);
        _Logs_instances.add(this);
        _Logs_appLogSub.set(this, void 0);
        _Logs_playtest.set(this, void 0);
    }
    async run() {
        // Despite the name, finally() is only invoked on successful termination.
        process.on('SIGINT', () => void __classPrivateFieldGet(this, _Logs_instances, "m", _Logs_onExit).call(this));
        await this.checkIfUserLoggedIn();
        await this.checkDevvitTermsAndConditions();
        const { args, flags } = await this.parse(_a);
        __classPrivateFieldSet(this, _Logs_playtest, new PlaytestServer(flags.dateformat, this), "f");
        if (flags.connect)
            __classPrivateFieldGet(this, _Logs_playtest, "f").open();
        const appName = args.app || (await this.inferAppNameFromProject());
        const subredditAppName = await __classPrivateFieldGet(this, _Logs_instances, "m", _Logs_getTailFilter).call(this, args.subreddit, appName);
        if (!flags.json) {
            this.log(formatAppLogDivider(`streaming logs for ${appName} on ${args.subreddit}`));
        }
        __classPrivateFieldSet(this, _Logs_appLogSub, __classPrivateFieldGet(this, _Logs_instances, "m", _Logs_newAppLogSub).call(this, subredditAppName, flags), "f");
    }
}
_a = Logs, _Logs_appLogSub = new WeakMap(), _Logs_playtest = new WeakMap(), _Logs_instances = new WeakSet(), _Logs_getTailFilter = async function _Logs_getTailFilter(subreddit, appName) {
    // if the dummy-logger is asked for don't worry about doing any lookup, the dummy logger works
    // for every subreddit regardless of user. It's designed to test that logs are flowing through
    // the system. Long term, this will likely be removed as we build confidence in our logger.
    if (appName === 'dummy-logger') {
        return RemoteLogSubredditAppNameFilter.fromPartial({
            subreddit,
            appName,
        });
    }
    // Call DevPortal to ensure the installation is valid and to convert
    // the subreddit name to a t5_ id.
    // TODO: move this conversion/check into Gateway
    const installationClient = createInstallationsClient(this);
    const result = await installationClient.GetByAppNameAndInstallLocation(GetByAppNameAndInstallLocationRequest.fromPartial({
        slug: appName,
        location: subreddit,
        type: InstallationType.SUBREDDIT,
    }));
    return RemoteLogSubredditAppNameFilter.fromPartial({
        subreddit: result.installation?.location?.id,
        appName,
    });
}, _Logs_newAppLogSub = function _Logs_newAppLogSub(subredditAppName, flags) {
    const client = createRemoteLoggerClient(this);
    const logs = client.Tail(RemoteLogQuery.fromPartial({
        type: RemoteLogType.LOG,
        since: flags.since,
        subredditAppName,
    }));
    const errors = client.Tail(RemoteLogQuery.fromPartial({
        type: RemoteLogType.ERROR,
        since: flags.since,
        subredditAppName,
    }));
    return merge(logs, errors)
        .pipe(retry({ count: 3, delay: 1000, resetOnSuccess: true }))
        .pipe(filter((log) => flags.verbose || log.log?.severity !== Severity.VERBOSE))
        .subscribe(new AppLogObserver(flags, this));
}, _Logs_onExit = function _Logs_onExit() {
    __classPrivateFieldGet(this, _Logs_appLogSub, "f")?.unsubscribe();
    __classPrivateFieldGet(this, _Logs_playtest, "f")?.close();
};
Logs.description = 'Streams logs for an installation within a specified subreddit';
Logs.examples = [
    '$ devvit logs <subreddit> [app]',
    '$ devvit logs r/myTestSubreddit',
    '$ devvit logs myOtherTestSubreddit my-app',
];
Logs.args = {
    subreddit: Args.string({
        description: 'Provide the subreddit name. The "r/" prefix is optional',
        required: true,
        parse: toLowerCaseArgParser,
    }),
    app: Args.string({
        description: 'Provide the app name (defaults to working directory app)',
        required: false,
        parse: toLowerCaseArgParser,
    }),
};
Logs.flags = {
    // to-do: DX-4706 delete.
    connect: Flags.boolean({ description: 'Connect to local runtime.', hidden: true }),
    dateformat: Flags.string({
        char: 'd',
        description: 'Format for rendering dates. See https://date-fns.org/v2.29.3/docs/format for format options',
        default: defaultAppLogDateFormat,
    }),
    json: Flags.boolean({
        char: 'j',
        description: 'output JSON for each log line',
        default: false,
    }),
    showKeepAlive: Flags.boolean({
        default: false,
        hidden: true,
    }),
    since: durationFlag({
        char: 's',
        description: `when to start the logs from. example "15s", "2w1d" "30m"\n${supportedDurationFormats}`,
    }),
    verbose: Flags.boolean({ default: false }),
};
export default Logs;
