var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BundleActor_instances, _BundleActor_getOwnerUsername, _BundleActor_getActorRelativePath;
import { ActorSpec, Bundle } from '@devvit/protos';
import { ACTORS_DIR_LEGACY, ACTOR_SRC_DIR, ACTOR_SRC_PRIMARY_NAME, } from '@devvit/shared-types/constants.js';
import { Args } from '@oclif/core';
import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { Bundler } from '../../util/Bundler.js';
import { toLowerCaseArgParser } from '../../util/commands/DevvitCommand.js';
import { ProjectCommand } from '../../util/commands/ProjectCommand.js';
import { distDirFilename } from '../../util/config.js';
import { readDevvitConfig } from '../../util/devvitConfig.js';
import { dirExists } from '../../util/files.js';
class BundleActor extends ProjectCommand {
    constructor() {
        super(...arguments);
        _BundleActor_instances.add(this);
    }
    async run() {
        const { args } = await this.parse(BundleActor);
        const username = await __classPrivateFieldGet(this, _BundleActor_instances, "m", _BundleActor_getOwnerUsername).call(this);
        const config = await readDevvitConfig(this.projectRoot);
        const actorName = args.name;
        const actorPath = await __classPrivateFieldGet(this, _BundleActor_instances, "m", _BundleActor_getActorRelativePath).call(this, actorName);
        const actorBundler = new Bundler();
        const bundle = await actorBundler.bundle(actorPath, ActorSpec.fromPartial({
            name: actorName,
            owner: username,
            version: config.version,
        }));
        await mkdir(path.join(this.projectRoot, distDirFilename), { recursive: true });
        await writeFile(path.join(this.projectRoot, distDirFilename, `${actorName}.bundle.json`), JSON.stringify(Bundle.toJSON(bundle)));
        this.log(`Successfully bundled actor: ${actorName}`);
    }
}
_BundleActor_instances = new WeakSet(), _BundleActor_getOwnerUsername = async function _BundleActor_getOwnerUsername() {
    let username = '';
    try {
        const token = await this.getAccessToken();
        if (token) {
            username = await this.getUserDisplayName(token);
        }
    }
    catch (e) {
        // Username is unavailable.
    }
    if (!username) {
        this.warn(`You are not logged in: setting "username" as empty`);
    }
    return username;
}, _BundleActor_getActorRelativePath = 
/**
 * @description checks that the specified actor name exists as a folder in project
 */
async function _BundleActor_getActorRelativePath(actorName) {
    const actorRelativePath = actorName === ACTOR_SRC_PRIMARY_NAME
        ? ACTOR_SRC_DIR
        : path.join(ACTORS_DIR_LEGACY, actorName);
    const fullPath = path.join(this.projectRoot, actorRelativePath);
    const actorFolderExists = await dirExists(fullPath);
    if (!actorFolderExists) {
        this.error(`Actor: ${actorName} does not exist in your project. Please make sure that the correct folder exists under /actors`);
    }
    return actorRelativePath;
};
BundleActor.description = 'Bundle an actor into bundle.json';
BundleActor.examples = ['$ devvit bundle actor my-actor'];
BundleActor.args = {
    name: Args.string({
        description: 'The name of of the actor to bundle',
        required: false,
        parse: toLowerCaseArgParser,
        default: 'main',
    }),
};
BundleActor.hidden = true;
export default BundleActor;
