var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Playtest_instances, _a, _Playtest_installationsClient, _Playtest_appLogSub, _Playtest_bundler, _Playtest_existingInstallInfo, _Playtest_appInfo, _Playtest_version, _Playtest_lastQueuedBundle, _Playtest_isOnWatchExecuting, _Playtest_server, _Playtest_flags, _Playtest_getExistingInstallInfo, _Playtest_newAppLogSub, _Playtest_onWatch, _Playtest_onWatchError, _Playtest_onExit;
import { MY_PORTAL_ENABLED, REDDIT_DESKTOP } from '@devvit/dev-server/server/config.js';
import { ActorSpec, BuildStatus, DependencySpec, GetAllWithInstallLocationRequest, InstallationCreationRequest, InstallationType, InstallationUpgradeRequest, RemoteLogType, Severity, UUID, VersionVisibility, } from '@devvit/protos';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { DevvitVersion, VersionBumpType } from '@devvit/shared-types/Version.js';
import { ACTOR_SRC_DIR, ACTOR_SRC_PRIMARY_NAME, MAX_ALLOWED_SUBSCRIBER_COUNT, } from '@devvit/shared-types/constants.js';
import { Args, Flags, ux } from '@oclif/core';
import chalk from 'chalk';
import path from 'path';
import { filter, map, merge, retry } from 'rxjs';
import Upload from '../commands/upload.js';
import { gqlQuery } from '../lib/http/gql.js';
import { PlaytestServer } from '../lib/playtest-server.js';
import { Bundler } from '../util/Bundler.js';
import { AppLogObserver } from '../util/app-logs/app-log-observer.js';
import { createInstallationsClient, createRemoteLoggerClient } from '../util/clientGenerators.js';
import { toLowerCaseArgParser } from '../util/commands/DevvitCommand.js';
import { slugVersionStringToUUID } from '../util/common-actions/slugVersionStringToUUID.js';
import { updateDevvitConfig } from '../util/devvitConfig.js';
class Playtest extends Upload {
    constructor() {
        super(...arguments);
        _Playtest_instances.add(this);
        _Playtest_installationsClient.set(this, createInstallationsClient(this));
        _Playtest_appLogSub.set(this, void 0);
        _Playtest_bundler.set(this, new Bundler(true));
        _Playtest_existingInstallInfo.set(this, void 0);
        _Playtest_appInfo.set(this, void 0);
        _Playtest_version.set(this, void 0);
        _Playtest_lastQueuedBundle.set(this, void 0);
        _Playtest_isOnWatchExecuting.set(this, false);
        _Playtest_server.set(this, new PlaytestServer(undefined, this));
        _Playtest_flags.set(this, void 0);
        _Playtest_onWatch.set(this, async (bundle, subreddit) => {
            /* We have to do this here because none of the rxjs functions fit this use case perfectly. What
             * we need is something that serializes this whole pipeline, but also discards all but the most
             * recent value once we resume processing. We would love to use one of these, but...
             * - concatMap(): Serializes the pipeline correctly but doesn't discard intermediate values. We
             *    only care about the latest bundle, not a queue of bundles.
             * - exhaustMap(): Serializes the pipeline correctly but won't enqueue the latest value.
             * - switchMap(): Takes the latest value correctly but doesn't serialize the pipeline, and we
             *    don't support cancel.
             * There is probably a way to do this using pure RxJS, but it seems substantially more difficult
             * than just doing it ourselves here.
             */
            if (__classPrivateFieldGet(this, _Playtest_isOnWatchExecuting, "f")) {
                // if we're already executing, queue this watch to be executed after we're done
                __classPrivateFieldSet(this, _Playtest_lastQueuedBundle, bundle, "f");
                return;
            }
            if (!bundle) {
                return;
            }
            if (!__classPrivateFieldGet(this, _Playtest_version, "f")) {
                this.error('Something went wrong: no version of this app exists.');
            }
            __classPrivateFieldSet(this, _Playtest_isOnWatchExecuting, true, "f");
            // 1. bump playtest version:
            __classPrivateFieldGet(this, _Playtest_version, "f").bumpVersion(VersionBumpType.Prerelease);
            // 2. update devvit yaml:
            await updateDevvitConfig(this.projectRoot, {
                version: __classPrivateFieldGet(this, _Playtest_version, "f").toString(),
            });
            // 3. update bundle version:
            modifyBundleVersion(bundle, __classPrivateFieldGet(this, _Playtest_version, "f").toString());
            // 4. create new playtest version:
            const appVersionInfo = await this.createVersion(__classPrivateFieldGet(this, _Playtest_appInfo, "f"), __classPrivateFieldGet(this, _Playtest_version, "f"), [bundle], VersionVisibility.PRIVATE);
            // 5. confirm new version has finished building:
            if (!(await this.checkVersionBuildStatus(appVersionInfo))) {
                this.error('App version did not build successfully.');
            }
            // 6. install playtest version to specified subreddit:
            const appWithVersion = `${__classPrivateFieldGet(this, _Playtest_appInfo, "f").app.slug}@${__classPrivateFieldGet(this, _Playtest_version, "f")}`;
            const appVersionId = await slugVersionStringToUUID(appWithVersion, this.appClient);
            const playtestUrl = chalk.bold.green(`${REDDIT_DESKTOP}/r/${subreddit}${__classPrivateFieldGet(this, _Playtest_flags, "f")?.connect ? `?playtest=${__classPrivateFieldGet(this, _Playtest_appInfo, "f").app.slug}` : ''}`);
            ux.action.start(`Installing playtest version ${__classPrivateFieldGet(this, _Playtest_version, "f")}...`);
            await __classPrivateFieldGet(this, _Playtest_installationsClient, "f").Upgrade(InstallationUpgradeRequest.fromPartial({
                id: __classPrivateFieldGet(this, _Playtest_existingInstallInfo, "f").installation.id,
                appVersionId,
            }));
            if (__classPrivateFieldGet(this, _Playtest_flags, "f")?.connect && !__classPrivateFieldGet(this, _Playtest_flags, "f")['no-live-reload'])
                __classPrivateFieldGet(this, _Playtest_server, "f").send({ appInstalled: {} });
            ux.action.stop(`✅\nSuccess! Please visit your test subreddit and refresh to see your latest changes:\n✨ ${playtestUrl}\n`);
            __classPrivateFieldSet(this, _Playtest_isOnWatchExecuting, false, "f");
            // If there's a queued watch, execute it now.
            if (__classPrivateFieldGet(this, _Playtest_lastQueuedBundle, "f")) {
                const newerBundle = __classPrivateFieldGet(this, _Playtest_lastQueuedBundle, "f");
                __classPrivateFieldSet(this, _Playtest_lastQueuedBundle, undefined, "f");
                await __classPrivateFieldGet(this, _Playtest_onWatch, "f").call(this, newerBundle, subreddit); // subreddit won't change between calls!
            }
        });
        _Playtest_onWatchError.set(this, (err) => {
            this.error(`watch error: ${StringUtil.caughtToString(err)}`);
        });
    }
    static get flags() {
        return {
            // to-do: DX-4706 delete.
            connect: Flags.boolean({ description: 'Connect to local runtime.', hidden: true }),
            // to-do: delete. This only exists in case users dislike live-reload.
            'no-live-reload': Flags.boolean({
                description: 'Attempt to reload the subreddit being browsed automatically.',
                // to-do: DX-4706 delete.
                hidden: true,
            }),
            verbose: Flags.boolean({ default: false }),
        };
    }
    async checkVersionBuildStatus(appVersionInfo) {
        ux.action.start('App is building remotely...');
        for (let i = 0; i < 5 && appVersionInfo.buildStatus === BuildStatus.BUILDING; i++) {
            // version is still building: wait and try again
            await sleep(1000);
            const info = await this.appVersionClient.Get(appVersionInfo);
            if (!info.appVersion) {
                this.error('Something went wrong, no app version available.');
            }
            appVersionInfo = info.appVersion;
        }
        if (appVersionInfo.buildStatus === BuildStatus.READY) {
            ux.action.stop(`✅`);
        }
        else {
            this.warn('Something went wrong: the previous version did not build successfully.');
        }
        return appVersionInfo.buildStatus === BuildStatus.READY;
    }
    async run() {
        // Despite the name, finally() is only invoked on successful termination.
        process.on('SIGINT', () => void __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_onExit).call(this));
        const { args, flags } = await this.parse(_a);
        __classPrivateFieldSet(this, _Playtest_flags, flags, "f");
        if (flags.connect)
            __classPrivateFieldGet(this, _Playtest_server, "f").open();
        const token = await this.getAccessTokenAndLoginIfNeeded();
        const username = await this.getUserDisplayName(token);
        await this.checkDevvitTermsAndConditions();
        const projectConfig = await this.getProjectConfig();
        const appName = projectConfig.slug ?? projectConfig.name;
        const subreddit = args.subreddit.startsWith('r/')
            ? args.subreddit.substring(2)
            : args.subreddit;
        __classPrivateFieldSet(this, _Playtest_appInfo, await this.getAppBySlug(appName), "f");
        if (!__classPrivateFieldGet(this, _Playtest_appInfo, "f")) {
            this.error(`Your app doesn't exist yet - you'll need to run 'devvit upload' before you can playtest your app.`);
        }
        // alert user if they're about to run playtest in a large subreddit
        const subscriberCount = await fetchSubredditSubscriberCount(subreddit, token);
        if (subscriberCount > MAX_ALLOWED_SUBSCRIBER_COUNT) {
            this.error('Playtest can only be used in a small test subreddit. Please try again in a community with less than 50 members.');
        }
        const v = __classPrivateFieldGet(this, _Playtest_appInfo, "f").versions[0];
        __classPrivateFieldSet(this, _Playtest_version, new DevvitVersion(v.majorVersion, v.minorVersion, v.patchVersion, v.prereleaseVersion), "f");
        const srcDir = path.join(this.projectRoot, ACTOR_SRC_DIR);
        const watch = __classPrivateFieldGet(this, _Playtest_bundler, "f").watch(srcDir, {
            name: ACTOR_SRC_PRIMARY_NAME,
            owner: username,
            version: projectConfig.version,
        });
        // before starting playtest session, make sure app has been installed to the test subreddit:
        const appWithVersion = `${appName}@${__classPrivateFieldGet(this, _Playtest_version, "f")}`;
        const appVersionId = await slugVersionStringToUUID(appWithVersion, this.appClient);
        ux.action.start(`Checking for existing installation...`);
        __classPrivateFieldSet(this, _Playtest_existingInstallInfo, await __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_getExistingInstallInfo).call(this, subreddit), "f");
        if (!__classPrivateFieldGet(this, _Playtest_existingInstallInfo, "f")) {
            const userT2Id = await this.getUserT2Id(token);
            ux.action.start(`Installing...`);
            try {
                __classPrivateFieldSet(this, _Playtest_existingInstallInfo, await __classPrivateFieldGet(this, _Playtest_installationsClient, "f").Create(InstallationCreationRequest.fromPartial({
                    appVersionId,
                    runAs: userT2Id,
                    type: InstallationType.SUBREDDIT,
                    location: subreddit,
                })), "f");
            }
            catch {
                this.error('There was an error installing your app. Please try again later.');
            }
        }
        __classPrivateFieldSet(this, _Playtest_appLogSub, __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_newAppLogSub).call(this, appName, __classPrivateFieldGet(this, _Playtest_existingInstallInfo, "f").installation.location.id, flags.verbose), "f");
        // Async subscribers are
        // unsupported (https://github.com/ReactiveX/rxjs/issues/2827). Pipe all
        // bundles through an asynchronous observable and only open a subscription
        // for errors. We just dispose the source (bundler) to unsubscribe.
        watch
            .pipe(map((bundle) => __classPrivateFieldGet(this, _Playtest_onWatch, "f").call(this, bundle, subreddit)))
            .subscribe({ error: __classPrivateFieldGet(this, _Playtest_onWatchError, "f") });
        // We don't know when the user is done. If connected to a terminal, end when
        // stdin is closed. Otherwise, close immediately to avoid the chance that
        // forever processes are created. This is the approach taken by esbuild,
        // https://github.com/evanw/esbuild/commit/77194c8.
        if (process.stdin.isTTY) {
            await new Promise((resolve) => process.stdin.once('close', resolve));
        }
    }
}
_a = Playtest, _Playtest_installationsClient = new WeakMap(), _Playtest_appLogSub = new WeakMap(), _Playtest_bundler = new WeakMap(), _Playtest_existingInstallInfo = new WeakMap(), _Playtest_appInfo = new WeakMap(), _Playtest_version = new WeakMap(), _Playtest_lastQueuedBundle = new WeakMap(), _Playtest_isOnWatchExecuting = new WeakMap(), _Playtest_server = new WeakMap(), _Playtest_flags = new WeakMap(), _Playtest_onWatch = new WeakMap(), _Playtest_onWatchError = new WeakMap(), _Playtest_instances = new WeakSet(), _Playtest_getExistingInstallInfo = async function _Playtest_getExistingInstallInfo(subreddit) {
    const existingInstalls = await __classPrivateFieldGet(this, _Playtest_installationsClient, "f").GetAllWithInstallLocation(GetAllWithInstallLocationRequest.fromPartial({
        type: InstallationType.SUBREDDIT,
        location: subreddit,
    }));
    const fullInstallInfoList = await Promise.all(existingInstalls.installations.map((install) => {
        // TODO I'm not a fan of having to re-fetch these installs to get the app IDs
        // TODO we should update the protobuf to include the app and app version IDs
        return __classPrivateFieldGet(this, _Playtest_installationsClient, "f").GetByUUID(UUID.fromPartial({ id: install.id }));
    }));
    return fullInstallInfoList.find((install) => {
        return install.app?.id === __classPrivateFieldGet(this, _Playtest_appInfo, "f")?.app?.id;
    });
}, _Playtest_newAppLogSub = function _Playtest_newAppLogSub(appName, subreddit, verbose) {
    const client = createRemoteLoggerClient(this);
    const subredditAppName = { appName, subreddit };
    const now = new Date();
    const logs = client.Tail({
        type: RemoteLogType.LOG,
        subredditAppName,
        since: now,
    });
    const errors = client.Tail({
        type: RemoteLogType.ERROR,
        subredditAppName,
        since: now,
    });
    return merge(logs, errors)
        .pipe(retry({ count: 5, delay: 1000, resetOnSuccess: true }))
        .pipe(filter((log) => verbose || log.log?.severity !== Severity.VERBOSE))
        .subscribe(new AppLogObserver({}, this));
}, _Playtest_onExit = async function _Playtest_onExit() {
    const revertCommand = chalk.blue(`devvit install ${__classPrivateFieldGet(this, _Playtest_existingInstallInfo, "f").installation.location.name} ${__classPrivateFieldGet(this, _Playtest_appInfo, "f").app.slug}@latest`);
    __classPrivateFieldGet(this, _Playtest_appLogSub, "f")?.unsubscribe();
    await __classPrivateFieldGet(this, _Playtest_bundler, "f").dispose();
    __classPrivateFieldGet(this, _Playtest_server, "f").close();
    this.log(`\nYour playtest session has ended, but your playtest version is still installed. To revert back to the latest non-playtest version of the app, run: \n${revertCommand}`);
};
Playtest.description = 'Installs your app to your test subreddit and starts a playtest session where a new version is installed whenever you save changes to your app code, and logs are continuously streamed';
Playtest.examples = [
    '$ devvit playtest <subreddit>',
    '$ devvit playtest r/myTestSubreddit',
    '$ devvit playtest myOtherTestSubreddit',
];
Playtest.args = {
    subreddit: Args.string({
        description: 'Provide the name of a small test subreddit with <50 members. The "r/" prefix is optional',
        required: true,
        parse: toLowerCaseArgParser,
    }),
};
export default Playtest;
export function modifyBundleVersion(bundle, version) {
    var _b;
    bundle.dependencies ?? (bundle.dependencies = DependencySpec.fromPartial({}));
    (_b = bundle.dependencies).actor ?? (_b.actor = ActorSpec.fromPartial({}));
    bundle.dependencies.actor.version = version.toString();
}
export async function fetchSubredditSubscriberCount(subreddit, token) {
    // Hack: GQL is failing below on snoodev.
    if (MY_PORTAL_ENABLED)
        return 0;
    const GET_SUBREDDIT_INFO_BY_NAME_QUERY_HASH = 'f1d2d2ac1ef6e39f9c4a103960d5b07d83665073a376c7852655fae2f1ad5159';
    // TODO: figure out how to get proper types from graphql.ts in portal
    const subredditInfo = await gqlQuery({
        accessToken: token.accessToken,
        hash: GET_SUBREDDIT_INFO_BY_NAME_QUERY_HASH,
        name: 'GetSubredditInfoByName',
        variables: { name: subreddit },
    });
    return subredditInfo.data.subredditInfoByName.subscribersCount;
}
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
