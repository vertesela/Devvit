var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _New_instances, _New_createAppParams, _New_createAppFlags, _New_appNameValidator, _New_slug_get, _New_projectPath_get, _New_gitInit, _New_initCreateAppParams, _New_promptAppName, _New_promptChooseTemplate, _New_copyProjectTemplate, _New_installAppDependencies, _New_syncDependenciesToCurrentCliVersion, _New_logWelcomeMessage;
import { penFromHash } from '@devvit/play';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { DevvitVersion } from '@devvit/shared-types/Version.js';
import { APP_SLUG_BASE_MAX_LENGTH, makeSlug, sluggable } from '@devvit/shared-types/slug.js';
import { Args, Flags } from '@oclif/core';
import chalk from 'chalk';
import inquirer from 'inquirer';
import { readdirSync } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
import { createRequire } from 'node:module';
import path from 'node:path';
import { URL } from 'node:url';
import semver from 'semver';
import Cutter from '../util/Cutter.js';
import { Git } from '../util/Git.js';
import { DevvitCommand, toLowerCaseArgParser } from '../util/commands/DevvitCommand.js';
import { generateDevvitConfig } from '../util/devvitConfig.js';
import { ProjectTemplateResolver } from '../util/template-resolvers/ProjectTemplateResolver.js';
import { logInBox } from '../util/ui.js';
import { exec as _exec } from 'node:child_process';
import util from 'node:util';
const exec = util.promisify(_exec);
const templateResolver = new ProjectTemplateResolver();
const require = createRequire(import.meta.url);
// eslint-disable-next-line security/detect-non-literal-require
const cliPackageJSON = require(require.resolve(`@devvit/cli/package.json`));
const CLI_VERSION = semver.parse(cliPackageJSON.version);
class New extends DevvitCommand {
    constructor() {
        super(...arguments);
        _New_instances.add(this);
        _New_createAppParams.set(this, null);
        _New_createAppFlags.set(this, null);
        _New_appNameValidator.set(this, async (rawAppName) => {
            const existingDirNames = new Set(readdirSync(process.cwd(), { withFileTypes: true })
                .filter((d) => d.isDirectory())
                .map((d) => d.name));
            if (existingDirNames.has(rawAppName)) {
                return `The directory "${rawAppName}" already exists. Use a new directory name!`;
            }
            if (!sluggable(rawAppName)) {
                return `The app name is invalid. An app name must:\n\t1. be between 3~${APP_SLUG_BASE_MAX_LENGTH} characters long\n\t2. contain only the following characters: [0-9], [a-z], [A-Z], spaces, and dashes\n\t3. begin with a letter\n\t`;
            }
            return true;
        });
    }
    async run() {
        const { args, flags } = await this.parse(New);
        __classPrivateFieldSet(this, _New_createAppFlags, flags, "f");
        if (flags.yes) {
            this.warn('You are running this command using the --yes flag. This means that the app will be created using default settings');
            if (args.appName == null) {
                this.error('The app name must be provided when running the command with the --yes flag. Otherwise, there is no context as to where the new app should be created and how it should be identified when published to the App Store');
            }
        }
        // do the necessary prompts to get information required for setting up a new project
        await __classPrivateFieldGet(this, _New_instances, "m", _New_initCreateAppParams).call(this, args, flags);
        assertNonNull(__classPrivateFieldGet(this, _New_createAppParams, "f"), 'Expected params to be initialized at this point for app creation');
        // Copy project template
        await __classPrivateFieldGet(this, _New_instances, "m", _New_copyProjectTemplate).call(this);
        // Make devvit.yaml (we put in the app name as is without a unique suffix)
        await generateDevvitConfig(__classPrivateFieldGet(this, _New_instances, "a", _New_projectPath_get), {
            name: __classPrivateFieldGet(this, _New_createAppParams, "f").appName,
            version: DevvitVersion.fromString('0.0.0').toString(),
        });
        // git init
        await __classPrivateFieldGet(this, _New_instances, "m", _New_gitInit).call(this);
        // make package.json
        const pkgJsonPath = path.join(__classPrivateFieldGet(this, _New_instances, "a", _New_projectPath_get), 'package.json');
        const templatePkgJson = JSON.parse(await readFile(pkgJsonPath, 'utf8'));
        const pkgJson = {
            ...templatePkgJson,
            name: __classPrivateFieldGet(this, _New_instances, "a", _New_slug_get),
            version: '0.0.0',
            type: 'module',
            private: true,
            license: 'BSD-3-Clause',
        };
        __classPrivateFieldGet(this, _New_instances, "m", _New_syncDependenciesToCurrentCliVersion).call(this, pkgJson.dependencies ?? {});
        __classPrivateFieldGet(this, _New_instances, "m", _New_syncDependenciesToCurrentCliVersion).call(this, pkgJson.devDependencies ?? {});
        await writeFile(pkgJsonPath, JSON.stringify(pkgJson, null, 2));
        // skip dependency installation if 'yes' is set to avoid unexpected changes in CI
        const dependenciesInstalled = flags.yes || flags.noDependencies ? false : (await __classPrivateFieldGet(this, _New_instances, "m", _New_installAppDependencies).call(this)).success;
        __classPrivateFieldGet(this, _New_instances, "m", _New_logWelcomeMessage).call(this, path.relative(process.cwd(), __classPrivateFieldGet(this, _New_instances, "a", _New_projectPath_get)), {
            dependenciesInstalled,
        });
    }
}
_New_createAppParams = new WeakMap(), _New_createAppFlags = new WeakMap(), _New_appNameValidator = new WeakMap(), _New_instances = new WeakSet(), _New_slug_get = function _New_slug_get() {
    if (__classPrivateFieldGet(this, _New_createAppParams, "f")?.appName == null) {
        this.error('The project was not properly initialized. Aborting');
    }
    return makeSlug(__classPrivateFieldGet(this, _New_createAppParams, "f").appName);
}, _New_projectPath_get = function _New_projectPath_get() {
    if (__classPrivateFieldGet(this, _New_createAppParams, "f")?.appName == null) {
        this.error('The project was not properly initialized. Aborting');
    }
    // if we were told to make it here, then make it here
    if (__classPrivateFieldGet(this, _New_createAppFlags, "f")?.here) {
        return process.cwd();
    }
    // else, we're using the app slug (without the unique suffix) as the dir name
    return path.join(process.cwd(), __classPrivateFieldGet(this, _New_instances, "a", _New_slug_get));
}, _New_gitInit = async function _New_gitInit() {
    const git = new Git(__classPrivateFieldGet(this, _New_instances, "a", _New_projectPath_get));
    await git.init();
    await git.initDotGitIgnore();
}, _New_initCreateAppParams = async function _New_initCreateAppParams(args, flags) {
    // If the template is a URL, unpack it as a pen. This code does not throw.
    let pen;
    if (flags.template) {
        // to-do: use URL.canParse(). penFromHash() doesn't throw.
        try {
            pen = penFromHash(new URL(flags.template).hash);
        }
        catch { } // eslint-disable-line no-empty
    }
    // Favor explicit appName to pen name default.
    const name = args.appName || pen?.name;
    if (name) {
        const validationResult = await __classPrivateFieldGet(this, _New_appNameValidator, "f").call(this, name);
        if (typeof validationResult === 'string') {
            this.error(validationResult);
        }
    }
    const appName = name || (await __classPrivateFieldGet(this, _New_instances, "m", _New_promptAppName).call(this));
    // If the template is not a pen, and the user did not enter a template flag, prompt them to choose
    const templateName = pen
        ? // Pens alway use the pen template.
            'pen'
        : flags.template ?? (await __classPrivateFieldGet(this, _New_instances, "m", _New_promptChooseTemplate).call(this));
    __classPrivateFieldSet(this, _New_createAppParams, {
        appName: appName.toLowerCase(),
        templateName,
        pen,
    }, "f");
}, _New_promptAppName = async function _New_promptAppName() {
    const res = await inquirer.prompt([
        {
            name: 'appName',
            message: 'Project name:',
            type: 'input',
            validate: __classPrivateFieldGet(this, _New_appNameValidator, "f"),
            filter: (input) => {
                return String(input).trim().toLowerCase();
            },
        },
    ]);
    return res.appName;
}, _New_promptChooseTemplate = async function _New_promptChooseTemplate() {
    const choices = templateResolver.options.filter((name) => name !== 'pen');
    const res = await inquirer.prompt([
        {
            name: 'templateName',
            message: 'Choose a template:',
            type: 'list',
            choices,
        },
    ]);
    return res.templateName;
}, _New_copyProjectTemplate = async function _New_copyProjectTemplate() {
    const templatePath = templateResolver.resolve({
        name: __classPrivateFieldGet(this, _New_createAppParams, "f").templateName,
    });
    const cutter = new Cutter(templatePath);
    await cutter.cut(__classPrivateFieldGet(this, _New_instances, "a", _New_projectPath_get), {
        name: __classPrivateFieldGet(this, _New_createAppParams, "f").appName,
        // Specify pen source Mustache template, if any.
        mainSrc: __classPrivateFieldGet(this, _New_createAppParams, "f")?.pen?.src ?? '',
    });
}, _New_installAppDependencies = async function _New_installAppDependencies() {
    this.log(`${chalk.bold.yellow(' 🔧 Installing dependencies...')}`);
    const npmInstallationOutput = await exec(`npm i --loglevel=error --no-fund`, {
        cwd: __classPrivateFieldGet(this, _New_instances, "a", _New_projectPath_get),
    });
    return { success: npmInstallationOutput.stderr === '' };
}, _New_syncDependenciesToCurrentCliVersion = function _New_syncDependenciesToCurrentCliVersion(deps) {
    for (const dep of Object.keys(deps)) {
        if (dep.startsWith('@devvit')) {
            deps[dep] = `${CLI_VERSION}`;
        }
    }
}, _New_logWelcomeMessage = function _New_logWelcomeMessage(newProjectPath, props) {
    if (__classPrivateFieldGet(this, _New_createAppFlags, "f")?.here) {
        return;
    }
    this.log(`${chalk.bold.green(' 🚀🚀🚀 Devvit app successfully created! ')}`);
    const welcomeInstructions = [];
    const cdInstructions = `• ${chalk.cyan(`\`cd ${newProjectPath}\``)} to open your project directory`;
    welcomeInstructions.push(cdInstructions);
    if (!props.dependenciesInstalled) {
        const installInstructions = `• ${chalk.cyan(`\`npm install\``)} to install dependencies`;
        welcomeInstructions.push(installInstructions);
    }
    const playtestInstructions = `• ${chalk.cyan(`\`devvit playtest\``)} to develop in your test community`;
    welcomeInstructions.push(playtestInstructions);
    const msg = welcomeInstructions.join('\n');
    logInBox(msg, { style: 'SINGLE', color: chalk.magenta });
};
New.description = 'Create a new app';
New.examples = ['$ devvit new'];
New.flags = {
    yes: Flags.boolean({
        required: false,
        default: false,
        description: 'Flag to skip all prompts and use defaults',
        hidden: true, // this is mainly for our CI, no need to expose in help for end users
    }),
    here: Flags.boolean({
        required: false,
        default: false,
        description: 'Flag to generate the project here, and not in a subdirectory',
    }),
    template: Flags.string({
        description: 'Template name or pen URL. Available templates are: ' +
            // The pen template is only for use internally to scaffold a project from
            // a pen URL.
            `${templateResolver.options.filter((name) => name !== 'pen').join(', ')}.`,
        required: false,
        char: 't',
    }),
    noDependencies: Flags.boolean({
        required: false,
        default: false,
        description: 'Flag to skip dependency installation step',
    }),
};
New.args = {
    appName: Args.string({
        description: 'Name of the app. A new directory with the provided app name will be created. If no name is entered, you will be prompted to choose one in the next step.',
        required: false,
        parse: toLowerCaseArgParser,
    }),
};
export default New;
