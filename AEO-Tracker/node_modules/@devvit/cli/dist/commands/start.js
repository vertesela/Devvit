var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Start_instances, _Start_devvitServer, _Start_getPidLockfilePath, _Start_createPidLockfileIfNotExists, _Start_readPidLockfile, _Start_getRunningNodeProcessPids, _Start_beforeDevServerStartup, _Start_afterDevServerStartup, _Start_openDevStudio, _Start_promptOpenBrowser;
import { startServer as startDevvitServer } from '@devvit/dev-server/server/index.js';
import { Flags } from '@oclif/core';
import getPort, { portNumbers } from 'get-port';
import inquirer from 'inquirer';
import fs from 'node:fs';
import fsp from 'node:fs/promises';
import path from 'node:path';
import open from 'open';
import ps from 'ps-node';
import { DOT_DEVVIT_DIR_FILENAME } from '@devvit/dev-server/server/config.js';
import { readLine } from '@devvit/dev-server/server/io/input-util.js';
import chalk from 'chalk';
import { AUTH_CONFIG } from '../util/auth.js';
import { ProjectCommand } from '../util/commands/ProjectCommand.js';
import { DEVVIT_DISABLE_EXTERN_DEVVIT_PROTOS } from '../util/config.js';
import { logInBox } from '../util/ui.js';
const PORT_RANGE = {
    LOWER_BOUND: 3000,
    UPPER_BOUND: 3100,
};
class Start extends ProjectCommand {
    constructor() {
        super(...arguments);
        _Start_instances.add(this);
        _Start_devvitServer.set(this, void 0);
    }
    async run() {
        await this.checkIfUserLoggedIn();
        await this.checkDevvitTermsAndConditions();
        process.chdir(this.projectRoot);
        const { flags } = await this.parse(Start);
        const preferredPorts = flags.port ? [flags.port] : [];
        const portNumber = await getPort({
            port: [...preferredPorts, ...portNumbers(PORT_RANGE.LOWER_BOUND, PORT_RANGE.UPPER_BOUND)],
        });
        // when user-specified port is unavailable, prompt to make sure that user is
        // okay with the port we find for them
        if (flags.port != null && flags.port !== portNumber) {
            const { confirmUsePort } = await inquirer.prompt([
                {
                    name: 'confirmUsePort',
                    message: `Port ${flags.port} is already in use. Use next available port ${portNumber}?`,
                    type: 'confirm',
                },
            ]);
            if (!confirmUsePort) {
                this.error('Aborting...');
            }
        }
        await __classPrivateFieldGet(this, _Start_instances, "m", _Start_beforeDevServerStartup).call(this, this.projectRoot);
        __classPrivateFieldSet(this, _Start_devvitServer, await startDevvitServer({
            disableExternDevvitProtos: DEVVIT_DISABLE_EXTERN_DEVVIT_PROTOS,
            projectDir: this.projectRoot,
            port: portNumber,
            authPluginConfig: {
                dotDevvitDir: DOT_DEVVIT_DIR_FILENAME,
                auth: AUTH_CONFIG,
            },
        }), "f");
        await __classPrivateFieldGet(this, _Start_instances, "m", _Start_afterDevServerStartup).call(this, this.projectRoot, portNumber);
        if (!__classPrivateFieldGet(this, _Start_devvitServer, "f")) {
            this.error('An error occurred when starting the dev server');
        }
        const msg = `Dev Studio listening on: ${chalk.cyan.bold(`http://localhost:${portNumber}`)} ...but you should use Playtest instead!`;
        await __classPrivateFieldGet(this, _Start_instances, "m", _Start_promptOpenBrowser).call(this, msg);
    }
}
_Start_devvitServer = new WeakMap(), _Start_instances = new WeakSet(), _Start_getPidLockfilePath = function _Start_getPidLockfilePath() {
    return path.join(DOT_DEVVIT_DIR_FILENAME, 'pid.lockfile.json');
}, _Start_createPidLockfileIfNotExists = async function _Start_createPidLockfileIfNotExists() {
    const lockfilePath = __classPrivateFieldGet(this, _Start_instances, "m", _Start_getPidLockfilePath).call(this);
    const devvitConfigDir = path.dirname(lockfilePath);
    if (!fs.existsSync(devvitConfigDir)) {
        await fsp.mkdir(devvitConfigDir, { recursive: true });
    }
    if (!fs.existsSync(lockfilePath)) {
        await fsp.open(lockfilePath, 'w');
    }
}, _Start_readPidLockfile = async function _Start_readPidLockfile() {
    return JSON.parse((await fsp.readFile(__classPrivateFieldGet(this, _Start_instances, "m", _Start_getPidLockfilePath).call(this), { encoding: 'utf8' })) || '{}');
}, _Start_getRunningNodeProcessPids = async function _Start_getRunningNodeProcessPids() {
    return new Promise((resolve, reject) => {
        ps.lookup({ command: 'node' }, (err, resultList) => {
            if (err) {
                reject(err);
                return;
            }
            resolve(new Set(resultList.map((p) => Number(p.pid))));
        });
    });
}, _Start_beforeDevServerStartup = async function _Start_beforeDevServerStartup(projectDir) {
    await __classPrivateFieldGet(this, _Start_instances, "m", _Start_createPidLockfileIfNotExists).call(this);
    const currentNodeProcesses = await __classPrivateFieldGet(this, _Start_instances, "m", _Start_getRunningNodeProcessPids).call(this);
    const staleLockfile = await __classPrivateFieldGet(this, _Start_instances, "m", _Start_readPidLockfile).call(this);
    const updatedLockfile = {};
    Object.entries(staleLockfile).forEach(([pid, pInfo]) => {
        if (currentNodeProcesses.has(parseInt(pid))) {
            // don't wipe entries of proceses that are still running
            updatedLockfile[pid] = pInfo;
            // only one dev-server per project
            if (pInfo.projectDir === projectDir) {
                this.error(`There is already a dev-server running for this project listening at http://localhost:${pInfo.port}`);
            }
        }
    });
    await fsp.writeFile(__classPrivateFieldGet(this, _Start_instances, "m", _Start_getPidLockfilePath).call(this), JSON.stringify(updatedLockfile, null, 2));
}, _Start_afterDevServerStartup = async function _Start_afterDevServerStartup(projectDir, port) {
    const lockfile = await __classPrivateFieldGet(this, _Start_instances, "m", _Start_readPidLockfile).call(this);
    // lockfile should not have my pid if I'm just starting up
    if (lockfile[process.pid] != null) {
        this.warn('pid.lockfile.json is malformed. Stopping all dev-server processes');
        const currentNodeProcesses = await __classPrivateFieldGet(this, _Start_instances, "m", _Start_getRunningNodeProcessPids).call(this);
        Object.keys(lockfile).forEach((pid) => {
            // don't kill ourself yet
            if (parseInt(pid) === process.pid)
                return;
            if (currentNodeProcesses.has(parseInt(pid))) {
                ps.kill(pid);
            }
        });
        await fsp.rm(__classPrivateFieldGet(this, _Start_instances, "m", _Start_getPidLockfilePath).call(this), { force: true });
        this.exit(1);
    }
    // append my pid to lockfile
    lockfile[process.pid] = {
        port,
        projectDir,
    };
    await fsp.writeFile(__classPrivateFieldGet(this, _Start_instances, "m", _Start_getPidLockfilePath).call(this), JSON.stringify(lockfile, null, 2));
}, _Start_openDevStudio = async function _Start_openDevStudio() {
    if (__classPrivateFieldGet(this, _Start_devvitServer, "f") == null) {
        this.error('There was an error starting the dev server');
    }
    const devServerAddress = __classPrivateFieldGet(this, _Start_devvitServer, "f").address();
    if (devServerAddress) {
        const addr = typeof devServerAddress === 'string'
            ? `http://${devServerAddress}`
            : `http://localhost:${devServerAddress.port}`;
        await open(addr, { wait: false });
    }
}, _Start_promptOpenBrowser = async function _Start_promptOpenBrowser(msg) {
    logInBox(`${msg}\n\nPress enter to open, control-c to quit.`, {
        color: chalk.magenta,
        padding: {
            x: 2,
            y: 0,
        },
    });
    if (await readLine())
        void __classPrivateFieldGet(this, _Start_instances, "m", _Start_openDevStudio).call(this);
};
Start.description = 'DEPRECATED. **Please switch to `devvit playtest`**';
Start.examples = ['$ devvit start -p 3000'];
Start.flags = {
    port: Flags.integer({
        char: 'p',
        description: 'Specify the port number on localhost to serve the Dev Studio',
    }),
};
export default Start;
