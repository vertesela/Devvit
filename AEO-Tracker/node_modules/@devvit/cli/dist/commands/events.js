var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Events_instances, _Events_onStreamNext, _Events_onStreamError;
import { LogEventMessage, RemoteLogQuery, RemoteLogType } from '@devvit/protos';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { Args, Flags } from '@oclif/core';
import chalk from 'chalk';
import { sub } from 'date-fns';
import { createRemoteLoggerClient } from '../util/clientGenerators.js';
import { DevvitCommand, toLowerCaseArgParser } from '../util/commands/DevvitCommand.js';
import { formatAppLogDivider, supportedDurationFormats } from '../util/app-logs/app-log-util.js';
const durations = {
    w: 'weeks',
    d: 'days',
    h: 'hours',
    m: 'minutes',
    s: 'seconds',
};
const durationFlag = Flags.custom({
    default: async () => new Date(),
    defaultHelp: async () => '0m',
    parse: async (str) => {
        // eslint-disable-next-line security/detect-non-literal-regexp
        const pattern = new RegExp(`(?<quantity>\\d+)(?<unit>[${Object.values(durations).join('')}])`, 'g');
        const matches = str.matchAll(pattern);
        const duration = {};
        for (const match of matches) {
            if (match.groups) {
                const { quantity, unit } = match.groups;
                const key = durations[unit];
                duration[key] = parseInt(quantity);
                str = str.replace(match[0], '');
            }
        }
        if (str.length > 0) {
            throw new Error(`Unable to parse duration: ${str}. ${supportedDurationFormats}`);
        }
        return sub(new Date(), duration);
    },
});
class Events extends DevvitCommand {
    constructor() {
        super(...arguments);
        _Events_instances.add(this);
    }
    async run() {
        await this.checkIfUserLoggedIn();
        const { args, flags } = await this.parse(Events);
        const loggerClient = createRemoteLoggerClient(this);
        const appName = args.app || (await this.inferAppNameFromProject());
        this.log(formatAppLogDivider(`streaming event logs for ${appName}`));
        loggerClient
            .Tail(RemoteLogQuery.fromPartial({
            type: RemoteLogType.EVENT,
            since: flags.since,
            subredditAppName: { appName },
        }))
            .subscribe({
            complete: () => { },
            error: (err) => __classPrivateFieldGet(this, _Events_instances, "m", _Events_onStreamError).call(this, err),
            next: (msg) => __classPrivateFieldGet(this, _Events_instances, "m", _Events_onStreamNext).call(this, msg),
        });
    }
}
_Events_instances = new WeakSet(), _Events_onStreamNext = function _Events_onStreamNext(msg) {
    if (msg.keepalive != null)
        return;
    if (msg.event != null) {
        this.log(JSON.stringify(LogEventMessage.toJSON(msg.event)));
    }
    else {
        this.warn(chalk.yellow(`unknown message: ${JSON.stringify(msg)}`));
    }
}, _Events_onStreamError = function _Events_onStreamError(err) {
    this.error(chalk.red(`error while fetching logs: ${StringUtil.caughtToString(err)}`));
};
Events.description = 'Streams event logs for an installation';
Events.hidden = true;
Events.args = {
    app: Args.string({
        description: 'app name',
        required: false,
        parse: toLowerCaseArgParser,
    }),
};
Events.flags = {
    since: durationFlag({
        char: 's',
        description: `when to start the logs from. example "15s", "2w1d" "30m"\n${supportedDurationFormats}`,
    }),
};
export default Events;
