var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Publish_instances, _Publish_appClient, _Publish_appVersionClient, _Publish_updateVersion, _Publish_checkIfAppCreatesCustomPost, _Publish_checkIfAppUsesFetch;
import { AppVersionUpdateRequest, GetAppBySlugRequest, InstallationType, VersionVisibility, } from '@devvit/protos';
import { Args, ux } from '@oclif/core';
import chalk from 'chalk';
import { DEVVIT_PORTAL_URL } from '../util/config.js';
import { DevvitVersion } from '@devvit/shared-types/Version.js';
import { createAppClient, createAppVersionClient } from '../util/clientGenerators.js';
import { ProjectCommand } from '../util/commands/ProjectCommand.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { handleTwirpError } from '../util/twirp-error-handler.js';
import { getInfoForSlugString } from '../util/common-actions/slugVersionStringToUUID.js';
import { readLine } from '@devvit/dev-server/server/io/input-util.js';
import open from 'open';
class Publish extends ProjectCommand {
    constructor() {
        super(...arguments);
        _Publish_instances.add(this);
        _Publish_appClient.set(this, createAppClient(this));
        _Publish_appVersionClient.set(this, createAppVersionClient(this));
        this.checkAppVersionTermsAndConditions = async (app, appDetailsUrl) => {
            const { termsAndConditions, privacyPolicy } = app;
            if (!termsAndConditions || !privacyPolicy) {
                this.log('Apps that use the http plugin must have terms & conditions and a privacy policy linked before publishing. Add these links on the app details page and run `devvit publish` again.');
                this.log(`${appDetailsUrl} \n(press enter to open, control-c to quit)`);
                if (await readLine()) {
                    try {
                        await open(appDetailsUrl);
                    }
                    catch (_err) {
                        this.error('An error occurred when opening the app details page');
                    }
                }
                process.exit();
            }
        };
    }
    async run() {
        const { args } = await this.parse(Publish);
        const appWithVersion = await this.inferAppNameAndVersion(args.appWithVersion);
        await this.checkIfUserLoggedIn();
        await this.checkDevvitTermsAndConditions();
        ux.action.start(`Finding ${appWithVersion}...`);
        const { appInfo, appVersion } = await getInfoForSlugString(appWithVersion, __classPrivateFieldGet(this, _Publish_appClient, "f"));
        ux.action.stop(`✅`);
        if (!appInfo.app) {
            this.error('There was an error retrieving the app info.');
        }
        const resp = await __classPrivateFieldGet(this, _Publish_appVersionClient, "f").GetAppVersionBundle({
            id: appVersion.id,
        });
        const bundle = resp.actorBundles[0].bundle;
        if (!bundle) {
            this.error(`There was an error getting the bundles for that app version.`);
        }
        const appCreatesCustomPost = await __classPrivateFieldGet(this, _Publish_instances, "m", _Publish_checkIfAppCreatesCustomPost).call(this, bundle);
        if (appCreatesCustomPost) {
            this.error('Custom post apps need to be approved before they can be published. Please use the app review form to submit your app.');
        }
        const appUsesFetch = await __classPrivateFieldGet(this, _Publish_instances, "m", _Publish_checkIfAppUsesFetch).call(this, bundle);
        const appDetailsUrl = `${DEVVIT_PORTAL_URL}/apps/${appInfo.app.slug}`;
        if (appUsesFetch) {
            await this.checkAppVersionTermsAndConditions(appInfo.app, appDetailsUrl);
        }
        const devvitVersion = new DevvitVersion(appVersion.majorVersion, appVersion.minorVersion, appVersion.patchVersion, appVersion.prereleaseVersion);
        if (appVersion.visibility === VersionVisibility.UNLISTED) {
            this.log(`Version "${devvitVersion}" has already been published.\n\n✨ Visit ${chalk.cyan.bold(`${appDetailsUrl}`)} to view your app!`);
            return;
        }
        await __classPrivateFieldGet(this, _Publish_instances, "m", _Publish_updateVersion).call(this, appVersion.id, devvitVersion);
        this.log(`\n✨ Visit ${chalk.cyan.bold(`${appDetailsUrl}`)} to view your app!`);
    }
    /**
     * throws error if the app is not found, or if the user doesn't have permission to view the app
     */
    async getAppBySlug(slug) {
        try {
            return await __classPrivateFieldGet(this, _Publish_appClient, "f").GetBySlug(GetAppBySlugRequest.fromPartial({ slug }));
        }
        catch (err) {
            this.error(StringUtil.caughtToString(err));
        }
    }
}
_Publish_appClient = new WeakMap(), _Publish_appVersionClient = new WeakMap(), _Publish_instances = new WeakSet(), _Publish_updateVersion = async function _Publish_updateVersion(appVersionId, devvitVersion) {
    const visibility = {
        value: VersionVisibility.UNLISTED,
    };
    const appVersionUpdateRequest = AppVersionUpdateRequest.fromPartial({
        id: appVersionId,
        visibility,
        validInstallTypes: [InstallationType.SUBREDDIT],
    });
    ux.action.start(`Publishing version "${devvitVersion.toString()}" to Reddit...`);
    try {
        const appVersionInfo = await __classPrivateFieldGet(this, _Publish_appVersionClient, "f").Update(appVersionUpdateRequest);
        ux.action.stop(`Success! ✅`);
        return appVersionInfo;
    }
    catch (error) {
        return handleTwirpError(error, (message) => this.error(message));
    }
}, _Publish_checkIfAppCreatesCustomPost = async function _Publish_checkIfAppCreatesCustomPost(bundle) {
    return !!bundle.provides.find((provision) => provision.name === 'CustomPost');
}, _Publish_checkIfAppUsesFetch = async function _Publish_checkIfAppUsesFetch(bundle) {
    return !!bundle.uses.find((use) => use.hostname === 'http.plugins.local');
};
Publish.description = 'Publish any previously uploaded version of an app. In this state, only the app owner can find or install the app to a subreddit which they moderate.';
Publish.examples = [
    '$ devvit publish',
    '$ devvit publish [app-name][@version]',
    '$ devvit publish my-app',
    '$ devvit publish my-app@1.2.3',
];
Publish.args = {
    appWithVersion: Args.string({
        description: 'App to install (defaults to working directory app) and version (defaults to latest)',
        required: false,
    }),
};
export default Publish;
