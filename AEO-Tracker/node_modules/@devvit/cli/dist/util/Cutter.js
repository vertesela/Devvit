var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Cutter_instances, _Cutter_cut;
import { fileTypeFromFile } from 'file-type';
import Mustache from 'mustache';
import { exec as _exec } from 'node:child_process';
import fs from 'node:fs';
import fsp from 'node:fs/promises';
import path from 'node:path';
import util from 'node:util';
const exec = util.promisify(_exec);
const RAW_FILE_MIME_TYPES = [
    'image/',
    'video/',
    'application/',
    'video/',
    'audio/',
    'font/',
    'model/',
];
function m(template, mustacheContext) {
    return Mustache.render(template, mustacheContext);
}
/** Render a template directly to the filesystem. */
class Cutter {
    constructor(source) {
        _Cutter_instances.add(this);
        this.source = source;
    }
    async cut(target, mustacheContext) {
        await fsp.mkdir(target, { recursive: true });
        await __classPrivateFieldGet(this, _Cutter_instances, "m", _Cutter_cut).call(this, this.source, target, mustacheContext);
        const cmd = path.join(target, 'init.sh');
        if (fs.existsSync(cmd)) {
            const { stderr } = await exec(`bash ${cmd}`);
            if (stderr.length) {
                throw new Error(stderr);
            }
            fs.rmSync(cmd);
        }
    }
}
_Cutter_instances = new WeakSet(), _Cutter_cut = async function _Cutter_cut(source, target, mustacheContext) {
    for await (const entry of await fsp.opendir(source)) {
        const newName = m(entry.name, mustacheContext);
        const newTarget = path.join(target, newName);
        const newSource = path.join(source, entry.name);
        if (entry.isDirectory()) {
            if (entry.name === 'node_modules') {
                continue;
            }
            await fsp.mkdir(newTarget);
            await __classPrivateFieldGet(this, _Cutter_instances, "m", _Cutter_cut).call(this, newSource, newTarget, mustacheContext);
        }
        else if (entry.isFile()) {
            const type = await fileTypeFromFile(newSource);
            // If we could determine the file type, and it starts with a raw mime type indicator
            if (type && RAW_FILE_MIME_TYPES.some((mime) => type.mime.startsWith(mime))) {
                // Copy the file directly, no Mustache
                await fsp.copyFile(newSource, newTarget);
                continue;
            }
            // Else, run Mustache against the file contents & write the output
            const content = await fsp.readFile(newSource, 'utf8');
            const newContent = m(content, mustacheContext);
            await fsp.writeFile(newTarget, newContent);
        }
        else {
            throw new Error(`Unknown file type: ${entry.name}`);
        }
    }
};
export default Cutter;
