var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Git_baseDir;
import git, { Errors as GitErrors, TREE } from 'isomorphic-git';
import fs from 'node:fs';
import fsp from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
const __dirname = fileURLToPath(path.join(import.meta.url, '..'));
// implementation using isomorphic-git
export class Git {
    constructor(baseDir) {
        _Git_baseDir.set(this, void 0);
        __classPrivateFieldSet(this, _Git_baseDir, baseDir, "f");
    }
    async init() {
        await git.init({
            fs,
            dir: __classPrivateFieldGet(this, _Git_baseDir, "f"),
            defaultBranch: 'main',
        });
    }
    get rootDir() {
        return __classPrivateFieldGet(this, _Git_baseDir, "f");
    }
    async assertIsInsideGitRepo() {
        try {
            await git.findRoot({ fs, filepath: __classPrivateFieldGet(this, _Git_baseDir, "f") });
        }
        catch (error) {
            if (error instanceof GitErrors.NotFoundError) {
                throw new Error(`Your current working directory is not in a git repo. Try running \`git init\` in the project root, or see https://git-scm.com/docs/git-init for instructions on initializing a git repo`);
            }
            throw error;
        }
    }
    async assertWorktreeHasCommit() {
        try {
            await git.log({ fs, dir: __classPrivateFieldGet(this, _Git_baseDir, "f") });
        }
        catch (error) {
            if (error instanceof GitErrors.NotFoundError) {
                throw new Error('Devvit uses HEAD for publishing. Make sure that there is at least one commit in the project before publishing');
            }
            throw error;
        }
    }
    async listFiles() {
        return git.walk({
            fs,
            dir: __classPrivateFieldGet(this, _Git_baseDir, "f"),
            trees: [TREE({ ref: 'HEAD' })],
            map: async (filepath, _) => filepath, // some isomorphic-git magic here. See https://isomorphic-git.org/docs/en/walk#mapstring-array-walkerentry-null-promise-any
        });
    }
    async initDotGitIgnore() {
        const src = path.join(__dirname, './templates/gitignore');
        const dest = path.join(this.rootDir, '.gitignore');
        await fsp.copyFile(src, dest);
    }
}
_Git_baseDir = new WeakMap();
