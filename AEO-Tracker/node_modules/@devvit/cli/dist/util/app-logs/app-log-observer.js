var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AppLogObserver_instances, _AppLogObserver_config, _AppLogObserver_logger, _AppLogObserver_logError, _AppLogObserver_logEvent;
import { LogErrorMessage, LogEventMessage, LogMessage, Severity } from '@devvit/protos';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import chalk from 'chalk';
import { formatAppLogDate, formatAppLogDivider, formatAppLogMessage, severities, } from './app-log-util.js';
/**
 * RemoteLogMessage Rxjs Observer that logs messages to stdout / stderr for
 * users.
 */
export class AppLogObserver {
    constructor(config, logger) {
        _AppLogObserver_instances.add(this);
        /** Often CLI flags. */
        _AppLogObserver_config.set(this, void 0);
        /** Often a DevvitCommand. */
        _AppLogObserver_logger.set(this, void 0);
        __classPrivateFieldSet(this, _AppLogObserver_config, config, "f");
        __classPrivateFieldSet(this, _AppLogObserver_logger, logger, "f");
    }
    complete() {
        if (!__classPrivateFieldGet(this, _AppLogObserver_config, "f").json) {
            __classPrivateFieldGet(this, _AppLogObserver_logger, "f").log(formatAppLogDivider(`log stream complete (${formatAppLogDate(new Date(), __classPrivateFieldGet(this, _AppLogObserver_config, "f").dateformat)})`));
        }
    }
    next(msg) {
        if (msg.error != null) {
            if (__classPrivateFieldGet(this, _AppLogObserver_config, "f").json)
                __classPrivateFieldGet(this, _AppLogObserver_logger, "f").log(JSON.stringify(LogErrorMessage.toJSON(msg.error)));
            else
                __classPrivateFieldGet(this, _AppLogObserver_instances, "m", _AppLogObserver_logError).call(this, msg.error);
        }
        else if (msg.event != null) {
            if (__classPrivateFieldGet(this, _AppLogObserver_config, "f").json)
                __classPrivateFieldGet(this, _AppLogObserver_logger, "f").log(JSON.stringify(LogEventMessage.toJSON(msg.event)));
            else
                __classPrivateFieldGet(this, _AppLogObserver_instances, "m", _AppLogObserver_logEvent).call(this, msg.event);
        }
        else if (msg.log != null) {
            if (__classPrivateFieldGet(this, _AppLogObserver_config, "f").json)
                __classPrivateFieldGet(this, _AppLogObserver_logger, "f").log(JSON.stringify(LogMessage.toJSON(msg.log)));
            else
                __classPrivateFieldGet(this, _AppLogObserver_logger, "f").log(formatAppLogMessage(msg.log, __classPrivateFieldGet(this, _AppLogObserver_config, "f").dateformat));
        }
        else if (msg.keepalive && __classPrivateFieldGet(this, _AppLogObserver_config, "f").showKeepAlive) {
            __classPrivateFieldGet(this, _AppLogObserver_logger, "f").log(chalk.dim(formatAppLogDivider('keep alive')));
        }
    }
    error(err) {
        __classPrivateFieldGet(this, _AppLogObserver_logger, "f").error(chalk.red(`error while fetching logs: ${StringUtil.caughtToString(err)}`));
    }
}
_AppLogObserver_config = new WeakMap(), _AppLogObserver_logger = new WeakMap(), _AppLogObserver_instances = new WeakSet(), _AppLogObserver_logError = function _AppLogObserver_logError(error) {
    const level = severities[Severity.ERROR];
    const timestamp = error.timestamp
        ? chalk.dim(formatAppLogDate(error.timestamp, __classPrivateFieldGet(this, _AppLogObserver_config, "f").dateformat))
        : '';
    // at a minimum show the timestamp and error message
    let errLine = `${level.color(`[${level.label}]`)} ${timestamp} ${level.color(error.message)}`;
    // next if we have a stack show it
    if (error.stack) {
        errLine += `\n${chalk.dim(error.stack)}`;
    }
    // if we have the file name show that and the line/column number if provided
    if (error.fileName) {
        errLine += `\n${error.fileName}`;
        if (error.lineNumber != null) {
            errLine += `:${error.lineNumber}`;
            if (error.columnNumber != null)
                errLine += `:${error.columnNumber}`;
        }
    }
    __classPrivateFieldGet(this, _AppLogObserver_logger, "f").log(errLine);
}, _AppLogObserver_logEvent = function _AppLogObserver_logEvent(log) {
    const level = severities[Severity.VERBOSE];
    const timestamp = log.timestamp
        ? chalk.dim(formatAppLogDate(log.timestamp, __classPrivateFieldGet(this, _AppLogObserver_config, "f").dateformat))
        : '';
    __classPrivateFieldGet(this, _AppLogObserver_logger, "f").log(`${level.color(`[EVENT]`)} ${timestamp} ${log.type} labels=${JSON.stringify(log.labels)}`);
};
