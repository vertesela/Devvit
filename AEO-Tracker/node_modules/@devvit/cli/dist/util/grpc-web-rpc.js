var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GRPCMessageFactory_message, _GrpcWebRpc_baseUrl, _GrpcWebRpc_headers, _GrpcWebRpc_getToken;
import { NodeHttpTransport } from '@improbable-eng/grpc-web-node-http-transport';
import { defer, mergeMap, Observable } from 'rxjs';
// TODO: figure out why this import is so funky
import pkg from '@improbable-eng/grpc-web';
const { grpc } = pkg;
import { HEADER_AUTHORIZATION } from '../constants/Headers.js';
class GRPCMessageFactory {
    static deserializeBinary(bytes) {
        return newProtobufMessage(bytes);
    }
    constructor(bytes = new Uint8Array()) {
        _GRPCMessageFactory_message.set(this, void 0);
        __classPrivateFieldSet(this, _GRPCMessageFactory_message, newProtobufMessage(bytes), "f");
    }
    serializeBinary() {
        return __classPrivateFieldGet(this, _GRPCMessageFactory_message, "f").serializeBinary();
    }
    toObject() {
        return __classPrivateFieldGet(this, _GRPCMessageFactory_message, "f").toObject();
    }
}
_GRPCMessageFactory_message = new WeakMap();
function newProtobufMessage(bytes) {
    return {
        serializeBinary() {
            return bytes;
        },
        toObject() {
            throw Error('gRPC-web ProtobufMessage.toObject() unsupported. This grpc-web ' +
                'client relies on ts-proto to serialize to bytes. This method should ' +
                'never be called.');
        },
    };
}
export class GrpcWebRpc {
    constructor({ baseUrl, headers, getToken }) {
        _GrpcWebRpc_baseUrl.set(this, void 0);
        _GrpcWebRpc_headers.set(this, void 0);
        _GrpcWebRpc_getToken.set(this, void 0);
        __classPrivateFieldSet(this, _GrpcWebRpc_baseUrl, baseUrl, "f");
        __classPrivateFieldSet(this, _GrpcWebRpc_headers, headers, "f");
        __classPrivateFieldSet(this, _GrpcWebRpc_getToken, getToken, "f");
    }
    request(_service, _method, _data) {
        throw new Error('Method not implemented.');
    }
    serverStreamingRequest(serviceName, methodName, data) {
        const def = {
            methodName,
            service: { serviceName },
            requestStream: false,
            requestType: GRPCMessageFactory,
            responseStream: true,
            responseType: GRPCMessageFactory,
        };
        const observable = defer(() => __classPrivateFieldGet(this, _GrpcWebRpc_getToken, "f").call(this));
        return observable.pipe(mergeMap((token) => {
            return new Observable((subscriber) => {
                // convert our headers to grpc metadata and include our auth token
                const metadata = new grpc.Metadata();
                if (token) {
                    metadata.set(...HEADER_AUTHORIZATION(token.accessToken));
                }
                __classPrivateFieldGet(this, _GrpcWebRpc_headers, "f").forEach((val, key) => metadata.set(key, val));
                const invocation = grpc.invoke(def, {
                    request: newProtobufMessage(data),
                    host: __classPrivateFieldGet(this, _GrpcWebRpc_baseUrl, "f"),
                    transport: NodeHttpTransport(),
                    metadata,
                    onMessage(msg) {
                        subscriber.next(msg.serializeBinary());
                    },
                    onEnd(code, msg) {
                        if (code === grpc.Code.OK)
                            subscriber.complete();
                        else
                            subscriber.error(Error(`gRPC-web code ${code} (${grpc.Code[code]}); ${msg}`));
                    },
                });
                return () => invocation.close();
            });
        }));
    }
    clientStreamingRequest(_service, _method, _data) {
        throw new Error('Method not implemented.');
    }
    bidirectionalStreamingRequest(_service, _method, _data) {
        throw new Error('Method not implemented.');
    }
}
_GrpcWebRpc_baseUrl = new WeakMap(), _GrpcWebRpc_headers = new WeakMap(), _GrpcWebRpc_getToken = new WeakMap();
