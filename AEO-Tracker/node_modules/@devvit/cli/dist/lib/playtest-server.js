var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PlaytestServer_instances, _PlaytestServer_connections, _PlaytestServer_dateFormat, _PlaytestServer_logger, _PlaytestServer_server, _PlaytestServer_timer, _PlaytestServer_checkLiveness, _PlaytestServer_onSockClosed, _PlaytestServer_onSockMsg, _PlaytestServer_onSockOpened;
import { PlaytestProviderMessage } from '@devvit/protos';
import { WebSocketServer } from 'ws';
import { formatAppLogDivider, formatAppLogMessage } from '../util/app-logs/app-log-util.js';
const port = 5678;
const livenessInterval = 15000;
/**
 * Playtest development mode server. Connects PlaytestClients for bidirectional
 * messaging. See PlaytestClient.
 */
export class PlaytestServer {
    constructor(dateFormat, logger) {
        _PlaytestServer_instances.add(this);
        /** Connection by Connection.id. */
        _PlaytestServer_connections.set(this, []);
        _PlaytestServer_dateFormat.set(this, void 0);
        _PlaytestServer_logger.set(this, void 0);
        _PlaytestServer_server.set(this, void 0);
        _PlaytestServer_timer.set(this, void 0);
        _PlaytestServer_checkLiveness.set(this, () => {
            const now = Date.now();
            for (const con of __classPrivateFieldGet(this, _PlaytestServer_connections, "f")) {
                if (now - con.active > 2 * livenessInterval) {
                    // The socket cannot be closed gracefully. Terminate the socket to
                    // trigger close.
                    con.sock.terminate();
                    continue;
                }
                con.sock.ping(); // There's no web API for ping data.
            }
        });
        _PlaytestServer_onSockMsg.set(this, (con, ev) => {
            if (typeof ev.data !== 'string') {
                __classPrivateFieldGet(this, _PlaytestServer_logger, "f").warn(`omitting unsupported ${typeof ev.data} message`);
                return;
            }
            let json;
            try {
                json = JSON.parse(ev.data);
            }
            catch {
                __classPrivateFieldGet(this, _PlaytestServer_logger, "f").warn(`omitting unparseable message "${ev.data}"`);
                return;
            }
            const msg = PlaytestProviderMessage.fromJSON(json);
            if (msg.callState)
                for (const log of msg.callState.logs)
                    __classPrivateFieldGet(this, _PlaytestServer_logger, "f").log(formatAppLogMessage(log, __classPrivateFieldGet(this, _PlaytestServer_dateFormat, "f")));
            if (msg.connect) {
                // Technically, the connection happens in #onSockOpened() but presenting
                // the tab URL as the entity is more sensible to users.
                con.url = msg.connect.url;
                __classPrivateFieldGet(this, _PlaytestServer_logger, "f").log(formatAppLogDivider(`${con.url} connected`, 'TruncStart'));
            }
        });
        _PlaytestServer_onSockOpened.set(this, (sock) => {
            const con = { active: Date.now(), sock };
            __classPrivateFieldSet(this, _PlaytestServer_connections, [...__classPrivateFieldGet(this, _PlaytestServer_connections, "f"), con], "f");
            sock.onclose = () => __classPrivateFieldGet(this, _PlaytestServer_instances, "m", _PlaytestServer_onSockClosed).call(this, con);
            sock.onmessage = (ev) => __classPrivateFieldGet(this, _PlaytestServer_onSockMsg, "f").call(this, con, ev);
            sock.on('pong', () => {
                con.active = Date.now();
            });
        });
        __classPrivateFieldSet(this, _PlaytestServer_dateFormat, dateFormat, "f");
        __classPrivateFieldSet(this, _PlaytestServer_logger, logger, "f");
    }
    close() {
        if (__classPrivateFieldGet(this, _PlaytestServer_timer, "f") != null)
            clearInterval(__classPrivateFieldGet(this, _PlaytestServer_timer, "f"));
        __classPrivateFieldSet(this, _PlaytestServer_timer, undefined, "f");
        for (const con of __classPrivateFieldGet(this, _PlaytestServer_connections, "f"))
            con.sock.terminate();
        __classPrivateFieldSet(this, _PlaytestServer_connections, [], "f");
        __classPrivateFieldGet(this, _PlaytestServer_server, "f")?.close();
        __classPrivateFieldSet(this, _PlaytestServer_server, undefined, "f");
    }
    open() {
        if (__classPrivateFieldGet(this, _PlaytestServer_server, "f"))
            return;
        __classPrivateFieldSet(this, _PlaytestServer_timer, setInterval(__classPrivateFieldGet(this, _PlaytestServer_checkLiveness, "f"), livenessInterval), "f");
        __classPrivateFieldSet(this, _PlaytestServer_server, new WebSocketServer({ port, verifyClient }), "f");
        __classPrivateFieldGet(this, _PlaytestServer_server, "f").on('connection', __classPrivateFieldGet(this, _PlaytestServer_onSockOpened, "f"));
    }
    /** Send to all connections. */
    send(msg) {
        for (const con of __classPrivateFieldGet(this, _PlaytestServer_connections, "f"))
            con.sock.send(JSON.stringify(msg));
    }
}
_PlaytestServer_connections = new WeakMap(), _PlaytestServer_dateFormat = new WeakMap(), _PlaytestServer_logger = new WeakMap(), _PlaytestServer_server = new WeakMap(), _PlaytestServer_timer = new WeakMap(), _PlaytestServer_checkLiveness = new WeakMap(), _PlaytestServer_onSockMsg = new WeakMap(), _PlaytestServer_onSockOpened = new WeakMap(), _PlaytestServer_instances = new WeakSet(), _PlaytestServer_onSockClosed = function _PlaytestServer_onSockClosed(con) {
    if (con.url)
        __classPrivateFieldGet(this, _PlaytestServer_logger, "f").log(formatAppLogDivider(`${con.url} disconnected`, 'TruncStart'));
    __classPrivateFieldSet(this, _PlaytestServer_connections, __classPrivateFieldGet(this, _PlaytestServer_connections, "f").filter((connection) => connection !== con), "f");
};
// The recommended approach is convoluted. See
// https://github.com/websockets/ws/issues/377#issuecomment-462152231.
const verifyClient = (info) => {
    // Verify the origin of the document opening the websocket connection.
    if (!info.origin)
        return false;
    // Get just the domain portion of the Origin header, ignoring protocol and
    // port.
    const domain = new URL(info.origin).hostname;
    return ['localhost', '127.0.0.1', '0.0.0.0', '[::1]'].includes(domain);
};
