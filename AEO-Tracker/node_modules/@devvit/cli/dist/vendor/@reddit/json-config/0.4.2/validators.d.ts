import type { Validator } from './index.js';
import type { JSONValue } from './index.js';
import type { ConfigSpec } from './index.js';
import type { ValidatedConfig } from './index.js';
import type { UnwrappedValidators } from './index.js';
import type { Unpacked } from './index.js';
import type { Literal } from './index.js';
import type { UnvalidatedJSONValue } from './index.js';
/**
 * A Validator that just validates that any value is defined.
 */
export declare const required: Validator<JSONValue & UnvalidatedJSONValue>;
/**
 * A Validator for raw strings
 *
 * If a non-string value is configured, it will be cast as a string.
 */
export declare const string: Validator<string>;
/**
 * A Validator for floating-point numbers
 *
 * If a non-numeric value is configured, it will be cast to a string, then
 * parsed as a number using parseFloat.
 */
export declare const float: Validator<number>;
/**
 * A Validator for integers
 *
 * Allows configuring numbers as strings, as longs as they parse as integers.
 *
 * Configured values that parse to a non-integer number will throw a RangeError,
 * and other configurued value types will throw a TypeError.
 */
export declare const integer: Validator<number>;
/**
 * A Validator for boolean values
 *
 * Allows any falsey value in addition to the string literal "false"
 */
export declare const boolean: Validator<boolean>;
/**
 * A Validator for spans of time
 *
 * This takes a string of the form '1 second' or '3 days' and returns an
 * integer representing that span of time in milliseconds.
 *
 * Throws a TypeError if a non-string value is configured, or if a value is
 * configured in the wrong format, or if the value references an unknown unit
 * of time.
 */
export declare const timespan: Validator<number>;
/**
 * A Validator for a percentage
 *
 * This takes a string in fhe form of '37.2%' or '44%' and returns a float in
 * the range [0.0, 1.0].
 *
 * Throws a TypeError if a non-string value is configured, or if the value is
 * configured in the wrong format.  Throws a RangeError if the parsed value
 * is outside of the valid range.
 */
export declare const percent: Validator<number>;
/**
 * A ValidatorFactory for validating one of several choices.
 *
 * Values are validated exactly against the given options.  If values should be converted in the
 * parsed configuration, use `oneOfRecord` or `oneOfEnum` instead.
 *
 * ```typescript
 * validators.oneOf('foo', 'bar', 'baz');
 * ```
 */
export declare function oneOf<T>(...options: T[]): Validator<T>;
/**
 * A ValidatorFactory for validating one of several choices
 *
 * For each option, the key is what should be in the configuration file and
 * the value is what it is mapped to.
 *
 * E.g.
 *
 * ```typescript
 * validators.oneOfRecord({ hearts: 'H', spades: 'S' })
 * ```
 *
 * would parse `"hearts"` into `'H'`.
 *
 * Throws a TypeError if a non-string value is configured.  Throws a RangeError
 * if an invalid option is configured.
 */
export declare function oneOfRecord<T extends any>(options: Record<string, T>): Validator<T>;
/**
 * A ValidatorFactory for validationg a member of an enum
 */
export declare function oneOfEnum<T extends any>(options: T): Validator<T[keyof T]>;
/**
 * A ValidatorFactory for an array of values specified by another validator
 *
 * At least one value must be provided. If you want an empty list to be a valid
 * choice, wrap with [optional](#optional).
 *
 * Throws a TypeError if a non-array value is configured.  Throws a RangeError
 * if the configured array is empty.
 */
export declare function array<T>(validator: Validator<T>): Validator<T[]>;
/**
 * An option of type T1, or if that fails to parse, of type T2.
 *
 * This is useful for backwards-compatible configuration changes.  Catches any
 * errors thrown by the primary validator, but will throw any errors thrown by
 * the fallback validator.
 */
export declare function fallback<T1, T2>(validator: Validator<T1>, backup: Validator<T2>): Validator<T1 | T2>;
/**
 * An option of type T, or the given default value if not configured.
 */
export declare function optional<T>(validator: Validator<T>, defaultVal: T): Validator<T>;
/**
 * An object of type T, which should be a config spec.
 *
 * Normally you can just use objects directly in your config spec without needing to wrap them,
 * but this can be used to compose an object validator with other validators, e.g.
 *
 * ```typescript
 * const spec = {
 *   foo: {
 *     value: number,
 *   },
 *   bar: validators.optional(
 *    validators.object({
 *      value: string,
 *    }
 *   ),
 * }
 * ```
 */
export declare function object<T extends ConfigSpec>(configSpec: T): Validator<ValidatedConfig<T>>;
/**
 * An object of type T, which should be a config spec.  Valid values must not contain any additional
 * keys not defined in the config spec.
 *
 * ```typescript
 * const spec = {
 *   foo: validators.object({
 *     value: number,
 *   }),
 *   bar: validators.shape({
 *     value: number,
 *   }),
 * }
 * ```
 *
 * The `foo` key can be given any object as long as it contains a `value` key with a number value,
 * whereas the `bar` key will only validate with an object that _only_ has the `value` key.
 */
export declare function shape<T extends ConfigSpec>(configSpec: T): Validator<ValidatedConfig<T>>;
/**
 * Use to validate an object as a Record<string, T>.  This is useful when your configuration object
 * can accept any arbitrary keys, but requires validation on their assigned values.
 *
 * ```typescript
 * const spec = {
 *   overrides: record(
 *     object({ name: string, value: required })
 *   ),
 * };
 * ```
 */
export declare function record<T>(validator: Validator<T>): Validator<Record<string, T | undefined>>;
/**
 * A ValidatorFactory for a tuple of values of a specific length and type, defined by the
 * input validators.
 *
 * The tuple validator can be used for arrays with small, fixed sizes and varying types.  If you
 * need an array of a uniform type, use the `array` validator instead.
 *
 * ```typescript
 * const spec = {
 *   // "ALL" will be validated as an array with 2 values, a string and a boolean
 *   ALL: validators.tuple(string, boolean),
 * }
 * ```
 */
export declare function tuple<T extends any[]>(...validators: T): Validator<UnwrappedValidators<T>>;
/**
 * A ValidatorFactory for validating against any number of validators.
 *
 * The result of the first validator that matches a value is returned.
 *
 * ```typescript
 * validators.any(
 *   validators.boolean,
 *   validators.number,
 *   validators.object({ value: validators.number }),
 * )
 * ```
 */
export declare function any<T extends any[]>(...validators: T): Validator<Unpacked<UnwrappedValidators<T>>>;
/**
 * A ValidatorFactory for validating that simple values match an exact expected value.
 *
 * For typescript to type this correctly, you will usually need to also pass the value as the type
 * argument.
 *
 * ```typescript
 * validators.identity<'foo'>('foo');
 * ```
 */
export declare function identity<T extends Literal>(match: Literal): Validator<T>;
//# sourceMappingURL=validators.d.ts.map