/**
 * Config validation utility
 *
 * This module provides configuration value parsing and validation.
 *
 * This module can be used to validate the structure of parsed JSON or plain JS object structure
 * against a specified validation schema.  The `validateConfig` method will return a valid, typed
 * object given an input object, or throw an error if validation fails.
 *
 * All of the validator methods are also exported as members of the exported `validators` object
 * for convenience, so you can just `import { validators } from '@reddit/faceplate/lib/config';`.
 *
 * Example JSON config file:
 *
 * ```json
 * {
 *   "simple": true,
 *   "cards": ["clubs", "spades", "diamonds"],
 *   "nested": {
 *     "once": 1,
 *     "really": {
 *       "deep": "3 seconds"
 *     }
 *   },
 *   "sampleRate": "37.1%",
 *   "interval": "30 seconds"
 * }
 * ```
 *
 * Then:
 *
 * ```typescript
 * import { validateConfig} from '@reddit/json-config.js';
 * import * as v from '@reddit/json-config/validators.js';
 *
 * import rawConfig from "./example/config.json"
 *
 * const config = validateConfig(rawConfig, {
 *   simple: v.boolean,
 *   cards: v.array(v.oneOfRecord({
 *     clubs: 1,
 *     spades: 2,
 *     diamonds: 3,
 *     hearts: 4,
 *    })),
 *   nested: {
 *     once: v.integer,
 *     really: {
 *       deep: v.timespan,
 *     },
 *   },
 *   optional: v.optional(v.integer, 9001),
 *   sampleRate: v.percent,
 *   interval: v.fallback(v.timespan, v.integer),
 * });
 * ```
 *
 * @packageDocumentation
 */
const RequiredSymbol = Symbol('json');
/**
 * @ignore
 */
function isSpecValueAValidator(val) {
    return typeof val === 'function';
}
/**
 * @ignore
 */
function isConfigValueAJSONObject(val) {
    return !!val && typeof val === 'object' && !Array.isArray(val);
}
function _validateConfig(unvalidatedConfig, configSpec, keyPath) {
    const validated = {};
    if (!unvalidatedConfig ||
        typeof unvalidatedConfig !== 'object' ||
        Array.isArray(unvalidatedConfig)) {
        throw new TypeError('not an object');
    }
    for (const key in configSpec) {
        keyPath.push(key);
        const specValue = configSpec[key];
        if (isSpecValueAValidator(specValue)) {
            validated[key] = specValue(unvalidatedConfig[key]);
        }
        else if (Object.prototype.hasOwnProperty.call(unvalidatedConfig, key)) {
            const subConfig = unvalidatedConfig[key];
            if (typeof subConfig === 'string' ||
                typeof subConfig === 'number' ||
                typeof subConfig === 'boolean') {
                validated[key] = subConfig;
            }
            else if (isConfigValueAJSONObject(subConfig)) {
                const res = _validateConfig(subConfig, specValue, keyPath);
                validated[key] = res; // TODO not sure how to type this
            }
            else {
                throw new TypeError(`invalid config for ${key}`);
            }
        }
        else {
            throw new TypeError(`expected config section ${key} not found`);
        }
        keyPath.pop();
    }
    return validated;
}
/**
 * Parse and validate a raw JSON config object.
 *
 * Passes an object parsed from raw JSON through additional parsers/validators
 * specific to part of the application.  The returned object should retain
 * type information based on the interface of the passed `configSpec`.
 *
 * @param unvalidatedConfig An object parsed from valid JSON.
 * @param configSpec An object specifying the shape of the expected config.
 */
export function validateConfig(unvalidatedConfig, configSpec) {
    const keyPath = [];
    try {
        return _validateConfig(unvalidatedConfig, configSpec, keyPath);
    }
    catch (err) {
        if (err instanceof Error && keyPath.length) {
            err.message = `Error in key path "${keyPath.join('.')}": ${err.message}`;
        }
        throw err;
    }
}
