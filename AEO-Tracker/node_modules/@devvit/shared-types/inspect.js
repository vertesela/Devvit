const indentPerLevel = '  '; // 2 spaces
const smallThreshold = 55;
const defaultOptions = {
    depth: 2,
};
/**
 * Similar to node's standard util.inspect, with the following differences:
 * - Strings are not escaped (for example, when they have quote marks in them)
 *   and not enclosed in quotes
 * - Symbol keys in objects are dropped and not printed
 * - Prints arrays with more items per line sometimes
 * - Errors may include a stacktrace
 * - Promises are terse
 * - There's no color output
 */
export function inspect(val, options) {
    const indent = '';
    const refs = {
        visited: new Map(),
        currentNumber: 0,
    };
    const completeOptions = {
        ...defaultOptions,
        ...(options ?? {}),
    };
    return inspectRoot(val, completeOptions, refs, indent);
}
function inspectRoot(val, args, refs, indent) {
    switch (typeof val) {
        case 'object':
            if (val === null) {
                return 'null';
            }
            if (val instanceof Date) {
                return val.toISOString();
            }
            if (val instanceof Error) {
                return val.stack || `${val.name}: ${val.message}`;
            }
            if (val instanceof Promise) {
                return `[Promise]`;
            }
            return inspectObject(val, args, refs, indent);
        case 'undefined':
            return 'undefined';
        case 'function':
            return `[Function: ${val.name}]`;
        case 'string': // fallthrough
        case 'number': // fallthrough
        case 'bigint': // fallthrough
        case 'boolean': // fallthrough
        case 'symbol': // fallthrough
            return val.toString();
        default:
            return ''; // this should never happen
    }
}
function inspectObject(obj, args, refs, indent) {
    let refConfig = refs.visited.get(obj);
    if (refConfig === undefined) {
        refConfig = { isBeingPrinted: false };
        refs.visited.set(obj, refConfig);
    }
    if (refConfig.isBeingPrinted) {
        if (refConfig.refNumber === undefined) {
            refConfig.refNumber = ++refs.currentNumber;
        }
        return `[Circular *${refConfig.refNumber}]`;
    }
    refConfig.isBeingPrinted = true;
    let depthRemaining = args.depth;
    if (depthRemaining !== null && depthRemaining < 0) {
        refConfig.isBeingPrinted = false;
        return Array.isArray(obj) ? '[Array]' : '[Object]';
    }
    if (depthRemaining !== null) {
        depthRemaining -= 1;
    }
    const entries = [];
    let totalLength = 0;
    const subObjArgs = {
        ...args,
        depth: depthRemaining,
    };
    // collect all of the entries of the object or array
    if (Array.isArray(obj)) {
        for (const val of obj) {
            const valString = inspectRoot(val, subObjArgs, refs, indent + indentPerLevel);
            entries.push(valString);
            totalLength += valString.length;
        }
    }
    else {
        for (const key in obj) {
            const valString = inspectRoot(obj[key], subObjArgs, refs, indent + indentPerLevel);
            entries.push([key, valString]);
            totalLength += key.length;
            totalLength += valString.length;
            totalLength += ': '.length;
        }
    }
    // now that we've visited all the children, it's safe to mark as not being printed
    refConfig.isBeingPrinted = false;
    // if any children referenced this node, we've got to add a ref label
    const refLabel = refConfig.refNumber ? `⟨ref *${refConfig.refNumber}⟩ ` : '';
    // handle small objects in a single line
    if (totalLength < smallThreshold) {
        if (Array.isArray(obj)) {
            return `${refLabel}[ ${entries.join(', ')} ]`;
        }
        return `${refLabel}{${entries.map(([key, val]) => `${key}: ${val}`).join(', ')}}`;
    }
    // handle large objects by indenting/formatting
    let result = `${refLabel}${Array.isArray(obj) ? '[' : '{'}`;
    for (let i = 0; i < entries.length; i++) {
        const isLast = i === entries.length - 1;
        const entry = entries[i];
        if (Array.isArray(obj)) {
            result += `\n${indent}${indentPerLevel}${entry}`;
        }
        else {
            const [key, val] = entry;
            result += `\n${indent}${indentPerLevel}${key}: ${val}`;
        }
        if (!isLast) {
            result += ',';
        }
    }
    result += `\n${indent}${Array.isArray(obj) ? ']' : '}'}`;
    return result;
}
