var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InMemoryResolver_instances, _InMemoryResolver_pluginsByFullName, _InMemoryResolver_bundlesByApp, _InMemoryResolver_registerPluginsSync, _InMemoryResolver_formatListOfItems;
import { Resolution } from '@devvit/protos';
import { InspectorQuery } from '@devvit/protos';
import { Empty } from '@devvit/protos';
import { NonNull } from '@devvit/shared-types/NonNull.js';
import { PLUGIN_NAME } from '@devvit/runtimes/lib/HostnameUtil.js';
import { Log } from '@devvit/runtimes/lib/loggers/Log.js';
/**
 * This keeps track of all of the bundles you've made, so that it can give them back to the Linker.
 */
export class InMemoryResolver {
    static async new(runtime) {
        const inspector = runtime.getInspector();
        const inspectorDescriptions = await inspector.ListActors(InspectorQuery.fromPartial({}));
        return new InMemoryResolver(inspectorDescriptions);
    }
    constructor(inspectorDescriptions) {
        _InMemoryResolver_instances.add(this);
        _InMemoryResolver_pluginsByFullName.set(this, new Map());
        // Last bundle wins!  Probably hard to query over the long haul.
        _InMemoryResolver_bundlesByApp.set(this, new Map());
        __classPrivateFieldGet(this, _InMemoryResolver_instances, "m", _InMemoryResolver_registerPluginsSync).call(this, inspectorDescriptions);
    }
    async RegisterBundle(bundle, _metadata) {
        const app = NonNull(bundle.dependencies?.actor?.name);
        __classPrivateFieldGet(this, _InMemoryResolver_bundlesByApp, "f").set(app, bundle);
        return Empty.fromPartial({});
    }
    async RegisterPlugins(inspectorDescriptions, _metadata) {
        __classPrivateFieldGet(this, _InMemoryResolver_instances, "m", _InMemoryResolver_registerPluginsSync).call(this, inspectorDescriptions);
        return Empty.fromPartial({});
    }
    async Resolve(query, _metadata) {
        if (query.versions) {
            Log.warn("narrowing the query by version query e.g. '>=2' is not yet supported");
        }
        if (query.owner) {
            Log.warn('narrowing the query by owner is not yet supported');
        }
        if (query.name == null || query.name === PLUGIN_NAME) {
            const plugin = __classPrivateFieldGet(this, _InMemoryResolver_pluginsByFullName, "f").get(query.typeName);
            if (plugin == null)
                return Resolution.fromPartial({
                    error: {
                        query,
                        text: `No plugin typed "${query.typeName}". Plugins available are: ${__classPrivateFieldGet(this, _InMemoryResolver_instances, "m", _InMemoryResolver_formatListOfItems).call(this, __classPrivateFieldGet(this, _InMemoryResolver_pluginsByFullName, "f").keys())}`,
                    },
                });
            return Resolution.fromPartial({ plugin });
        }
        const bundle = __classPrivateFieldGet(this, _InMemoryResolver_bundlesByApp, "f").get(query.name);
        if (bundle == null)
            return Resolution.fromPartial({
                error: {
                    query,
                    text: `No app named "${query.name}". Available are: ${__classPrivateFieldGet(this, _InMemoryResolver_instances, "m", _InMemoryResolver_formatListOfItems).call(this, __classPrivateFieldGet(this, _InMemoryResolver_bundlesByApp, "f").keys())}`,
                },
            });
        if (query.typeName != null &&
            !bundle.dependencies?.provides.some((provide) => provide.definition?.fullName === query.typeName))
            return Resolution.fromPartial({
                error: {
                    query,
                    text: `App named "${query.name}" exists but does not provide type "${query.typeName}".`,
                },
            });
        return Resolution.fromPartial({ bundle });
    }
}
_InMemoryResolver_pluginsByFullName = new WeakMap(), _InMemoryResolver_bundlesByApp = new WeakMap(), _InMemoryResolver_instances = new WeakSet(), _InMemoryResolver_registerPluginsSync = function _InMemoryResolver_registerPluginsSync(inspectorDescriptions) {
    inspectorDescriptions.descriptions.forEach((description) => {
        description.provides.forEach((provided) => {
            // to-do: Report error to caller instead of throwing.
            if (__classPrivateFieldGet(this, _InMemoryResolver_pluginsByFullName, "f").has(provided.fullName))
                throw Error(`Plugin type "${provided.fullName}" already registered.`);
            __classPrivateFieldGet(this, _InMemoryResolver_pluginsByFullName, "f").set(provided.fullName, description);
        });
    });
}, _InMemoryResolver_formatListOfItems = function _InMemoryResolver_formatListOfItems(items) {
    return `${[...items].map((name) => `"${name}"`).join(', ')}`;
};
