var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DefaultLinker_instances, _DefaultLinker_resolver, _DefaultLinker_permissions, _DefaultLinker_link, _DefaultLinker_linkQuery;
import { LinkedBundle, LinkerResponse, ResolutionError } from '@devvit/protos';
import { LOCAL_HOSTNAME, NODE_HOSTNAME, PLUGIN_NAME, PLUGIN_OWNER, REDDIT_API_CNAME, } from '@devvit/runtimes/lib/HostnameUtil.js';
import { assertNonNull, NonNull } from '@devvit/shared-types/NonNull.js';
export class DefaultLinker {
    constructor(resolver, permissions) {
        _DefaultLinker_instances.add(this);
        _DefaultLinker_resolver.set(this, void 0);
        _DefaultLinker_permissions.set(this, void 0);
        __classPrivateFieldSet(this, _DefaultLinker_resolver, resolver, "f");
        __classPrivateFieldSet(this, _DefaultLinker_permissions, permissions, "f");
    }
    async Link(bundle, _metadata) {
        await __classPrivateFieldGet(this, _DefaultLinker_resolver, "f").RegisterBundle(bundle);
        return await __classPrivateFieldGet(this, _DefaultLinker_instances, "m", _DefaultLinker_link).call(this, bundle);
    }
}
_DefaultLinker_resolver = new WeakMap(), _DefaultLinker_permissions = new WeakMap(), _DefaultLinker_instances = new WeakSet(), _DefaultLinker_link = async function _DefaultLinker_link(bundle) {
    assertNonNull(bundle.dependencies, `Expected the bundle's dependencies to be non-null`);
    const provides = bundle.dependencies.provides.flatMap((provide) => provide.definition ? [provide.definition] : []);
    // Recursively resolve and link all dependencies.
    const dependencies = await Promise.all(bundle.dependencies.uses.map((query) => __classPrivateFieldGet(this, _DefaultLinker_instances, "m", _DefaultLinker_linkQuery).call(this, query, bundle)));
    return LinkerResponse.fromPartial({
        bundle: {
            actor: bundle.dependencies.actor,
            code: bundle.code,
            hostname: bundle.dependencies.hostname,
            provides,
            uses: dependencies.flatMap((dependency) => dependency.bundle == null ? [] : [dependency.bundle]),
            buildInfo: bundle.buildInfo,
            assets: bundle.assetIds,
        },
        errors: dependencies.flatMap(({ errors }) => errors),
    });
}, _DefaultLinker_linkQuery = async function _DefaultLinker_linkQuery(query, parentBundle) {
    const use = await __classPrivateFieldGet(this, _DefaultLinker_resolver, "f").Resolve(query);
    if (use.bundle?.dependencies != null &&
        !__classPrivateFieldGet(this, _DefaultLinker_permissions, "f").CanAccess(parentBundle.dependencies.hostname, use.bundle.dependencies.hostname)) {
        return LinkerResponse.fromPartial({
            errors: [
                ResolutionError.fromPartial({
                    text: `access denied to plugin "${use.bundle.dependencies.hostname}"`,
                }),
            ],
        });
    }
    if (use.plugin &&
        !__classPrivateFieldGet(this, _DefaultLinker_permissions, "f").CanAccess(parentBundle.dependencies.hostname, use.plugin.hostname)) {
        return LinkerResponse.fromPartial({
            errors: [
                ResolutionError.fromPartial({ text: `access denied to plugin "${use.plugin.hostname}"` }),
            ],
        });
    }
    if (use.error != null)
        return LinkerResponse.fromPartial({ errors: [use.error] });
    if (use.bundle != null)
        return await __classPrivateFieldGet(this, _DefaultLinker_instances, "m", _DefaultLinker_link).call(this, use.bundle);
    // TODO: Clean this up or extend linker capabilities to allow
    // custom hostname & provides behavior
    //
    // shim for demuxing redditapi hostnames and prefixing w/ category
    // TODO: Clean up special handling https://reddit.atlassian.net/browse/DXC-115
    if (use.plugin?.hostname.includes(REDDIT_API_CNAME) &&
        !use.plugin?.hostname.includes('redditapiv2')) {
        const category = query.typeName.split('.').at(-1); // get the last part of the typename
        const prefix = category ? `${category.toLowerCase()}.` : '';
        use.plugin.hostname = `${prefix}${use.plugin.hostname}`;
        // only return the provides for this category to avoid
        // the wrong hostname being pulled for a method
        const categoryProvides = use.plugin.provides.find((p) => p.fullName === query.typeName);
        use.plugin.provides = categoryProvides ? [categoryProvides] : [];
    }
    return LinkerResponse.fromPartial({ bundle: fakeBundleForPlugin(NonNull(use.plugin)) });
};
function fakeBundleForPlugin(description) {
    return LinkedBundle.fromPartial({
        actor: { name: PLUGIN_NAME, owner: PLUGIN_OWNER, version: '1.0.0' },
        // to-do: fix me by passing in the environment wanted.
        hostname: description.hostname.replace(NODE_HOSTNAME, LOCAL_HOSTNAME),
        provides: description.provides,
    });
}
