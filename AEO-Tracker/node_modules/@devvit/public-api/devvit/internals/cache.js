const SystemClock = {
    now() {
        return new Date();
    },
};
async function poll(clock, start, redis, key, pollEvery, pollingTimeout) {
    const existing = await redis.get(key);
    if (existing) {
        // Cache is now available, resolve the promise with the cached value.
        return JSON.parse(existing).value;
    }
    // If we have exceeded the maximum duration, reject the promise.
    if (clock.now().getTime() - start.getTime() >= pollingTimeout) {
        throw new Error('Cache request timed out');
    }
    // If not, wait and try again
    await new Promise((resolve) => setTimeout(resolve, pollEvery));
    // Don't use this if TTL can be big. Use a loop to avoid call stack overflow.
    return await poll(clock, start, redis, key, pollEvery, pollingTimeout);
}
export function makeCache(redis, state, clock = SystemClock) {
    return async function cache(closure, options) {
        const localCache = (state.__cache = state.__cache || {});
        const key = `__autocache__${options.key}`;
        const lockKey = `__lock__${key}`;
        const ttl = options.ttl;
        const pollEvery = 200; // millis
        const pollingTimeout = Math.max(Math.min(ttl, pollEvery * 3), 1);
        const start = clock.now();
        const expiration = new Date(clock.now().getTime() + ttl);
        const lockExpiration = new Date(clock.now().getTime() + ttl / 2);
        const localCachedAnswer = localCache[key];
        if (localCachedAnswer) {
            const { value, expires } = localCachedAnswer;
            if (expires > clock.now().getTime()) {
                return value;
            }
            else {
                delete localCache[key];
            }
        }
        // Attempt to fetch the cached result.
        const cachedAnswer = await redis.get(key);
        if (cachedAnswer) {
            localCache[key] = JSON.parse(cachedAnswer);
            return JSON.parse(cachedAnswer).value;
        }
        // Attempt to acquire a lock.
        const locked = await redis.set(lockKey, '1', { expiration: lockExpiration, nx: true });
        if (locked) {
            let value;
            try {
                value = await closure();
            }
            catch (e) {
                console.error('error in cache loader', e);
                throw e;
            }
            const entry = { value, expires: expiration.getTime() };
            await redis.set(key, JSON.stringify(entry), { expiration });
            localCache[key] = entry;
            return value;
        }
        else {
            // If the lock is not acquired, enter a polling loop.
            return poll(clock, start, redis, key, pollEvery, pollingTimeout);
        }
    };
}
