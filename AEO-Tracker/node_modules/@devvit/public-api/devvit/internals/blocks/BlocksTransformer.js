import { BlockActionType, BlockAnimationDirection, BlockAnimationLoopMode, BlockAnimationType, BlockAvatarBackground, BlockAvatarFacing, BlockAvatarSize, BlockBorderWidth, BlockButtonAppearance, BlockButtonSize, BlockFullSnooSize, BlockGap, BlockHorizontalAlignment, BlockIconSize, BlockImageResizeMode, BlockPadding, BlockRadius, BlockSizeUnit, BlockSpacerShape, BlockSpacerSize, BlockStackDirection, BlockTextOutline, BlockTextOverflow, BlockTextSize, BlockTextStyle, BlockTextWeight, BlockType, BlockVerticalAlignment, } from '@devvit/protos';
import { Devvit } from '../../Devvit.js';
import { getHexFromNamedHTMLColor, getHexFromRgbaColor, getHexFromRPLColor, isHexColor, isHslColor, isNamedHTMLColor, isRgbaColor, isRPLColor, } from '../helpers/color.js';
const DATA_PREFIX = 'data-';
export class BlocksTransformer {
    async createBlocksElementOrThrow({ type, props, children }) {
        const block = await this.createBlocksElement({ type, props, children });
        if (!block) {
            throw new Error(`Could not create block of type ${type}`);
        }
        return block;
    }
    async createBlocksElement({ type, props, children, }) {
        switch (type) {
            case 'blocks':
                return this.makeRoot(props, ...children);
            case 'hstack':
                return this.makeHStack(props, ...children);
            case 'vstack':
                return this.makeVStack(props, ...children);
            case 'zstack':
                return this.makeZStack(props, ...children);
            case 'text':
                return this.makeText(props, ...children);
            case 'button':
                return this.makeButton(props, ...children);
            case 'image':
                return await this.makeImage(props);
            case 'spacer':
                return this.makeSpacer(props);
            case 'icon':
                return this.makeIcon(props);
            case 'avatar':
                return this.makeAvatar(props);
            case 'fullsnoo':
                return this.makeFullSnoo(props);
            case 'animation':
                return await this.makeAnimation(props);
            case 'webview':
                return this.makeWebView(props);
            case '__fragment':
                throw new Error("root fragment is not supported - use 'blocks' instead");
        }
        return undefined;
    }
    makeRootHeight(height) {
        switch (height) {
            case 'regular':
                return 320;
            case 'tall':
                return 512;
        }
    }
    makeBlockPadding(padding) {
        switch (padding) {
            case 'none':
                return BlockPadding.PADDING_NONE;
            case 'xsmall':
                return BlockPadding.PADDING_XSMALL;
            case 'small':
                return BlockPadding.PADDING_SMALL;
            case 'medium':
                return BlockPadding.PADDING_MEDIUM;
            case 'large':
                return BlockPadding.PADDING_LARGE;
        }
        return undefined;
    }
    makeBlockRadius(radius) {
        switch (radius) {
            case 'none':
                return BlockRadius.RADIUS_NONE;
            case 'small':
                return BlockRadius.RADIUS_SMALL;
            case 'medium':
                return BlockRadius.RADIUS_MEDIUM;
            case 'large':
                return BlockRadius.RADIUS_LARGE;
            case 'full':
                return BlockRadius.RADIUS_FULL;
        }
        return undefined;
    }
    makeBlockGap(gap) {
        switch (gap) {
            case 'none':
                return BlockGap.GAP_NONE;
            case 'small':
                return BlockGap.GAP_SMALL;
            case 'medium':
                return BlockGap.GAP_MEDIUM;
            case 'large':
                return BlockGap.GAP_LARGE;
        }
        return undefined;
    }
    makeBlockAlignment(alignment) {
        if (alignment === undefined)
            return undefined;
        let vertical = undefined;
        let horizontal = undefined;
        if (alignment.includes('top')) {
            vertical = BlockVerticalAlignment.ALIGN_TOP;
        }
        else if (alignment.includes('middle')) {
            vertical = BlockVerticalAlignment.ALIGN_MIDDLE;
        }
        else if (alignment.includes('bottom')) {
            vertical = BlockVerticalAlignment.ALIGN_BOTTOM;
        }
        if (alignment.includes('start')) {
            horizontal = BlockHorizontalAlignment.ALIGN_START;
        }
        else if (alignment.includes('center')) {
            horizontal = BlockHorizontalAlignment.ALIGN_CENTER;
        }
        else if (alignment.includes('end')) {
            horizontal = BlockHorizontalAlignment.ALIGN_END;
        }
        if (vertical !== undefined || horizontal !== undefined) {
            return {
                vertical,
                horizontal,
            };
        }
        return undefined;
    }
    makeBlockBorder(borderWidth, color, lightColor, darkColor) {
        if (!borderWidth && !color)
            return undefined;
        let width = undefined;
        switch (borderWidth) {
            case 'none':
                width = BlockBorderWidth.BORDER_WIDTH_NONE;
                break;
            case 'thin':
                width = BlockBorderWidth.BORDER_WIDTH_THIN;
                break;
            case 'thick':
                width = BlockBorderWidth.BORDER_WIDTH_THICK;
                break;
            default:
                // Default to a thin border when a color was set, but no borderWidth.
                width = BlockBorderWidth.BORDER_WIDTH_THIN;
                break;
        }
        // Default to #00000019 when a border was set, but no color.
        const borderColor = color ?? 'neutral-border-weak';
        const colors = this.getThemedColors(borderColor, lightColor, darkColor);
        return {
            width,
            color: colors?.light,
            colors,
        };
    }
    makeBlockTextSize(textSize) {
        switch (textSize) {
            case 'xsmall':
                return BlockTextSize.TEXT_SIZE_XSMALL;
            case 'small':
                return BlockTextSize.TEXT_SIZE_SMALL;
            case 'medium':
                return BlockTextSize.TEXT_SIZE_MEDIUM;
            case 'large':
                return BlockTextSize.TEXT_SIZE_LARGE;
            case 'xlarge':
                return BlockTextSize.TEXT_SIZE_XLARGE;
            case 'xxlarge':
                return BlockTextSize.TEXT_SIZE_XXLARGE;
        }
        return undefined;
    }
    makeBlockTextStyle(style) {
        switch (style) {
            case 'body':
                return BlockTextStyle.TEXT_STYLE_BODY;
            case 'metadata':
                return BlockTextStyle.TEXT_STYLE_METADATA;
            case 'heading':
                return BlockTextStyle.TEXT_STYLE_HEADING;
        }
        return undefined;
    }
    makeBlockTextOutline(outline) {
        switch (outline) {
            case 'none':
                return BlockTextOutline.TEXT_OUTLINE_NONE;
            case 'thin':
                return BlockTextOutline.TEXT_OUTLINE_THIN;
            case 'thick':
                return BlockTextOutline.TEXT_OUTLINE_THICK;
        }
        return undefined;
    }
    makeBlockTextWeight(weight) {
        switch (weight) {
            case 'regular':
                return BlockTextWeight.TEXT_WEIGHT_REGULAR;
            case 'bold':
                return BlockTextWeight.TEXT_WEIGHT_BOLD;
        }
        return undefined;
    }
    makeBlockTextOverflow(overflow) {
        switch (overflow) {
            case 'clip':
                return BlockTextOverflow.TEXT_OVERFLOW_CLIP;
            case 'ellipsis':
                return BlockTextOverflow.TEXT_OVERFLOW_ELLIPSE;
        }
        return BlockTextOverflow.TEXT_OVERFLOW_ELLIPSE;
    }
    makeBlockButtonAppearance(appearance) {
        switch (appearance) {
            case 'secondary':
                return BlockButtonAppearance.BUTTON_APPEARANCE_SECONDARY;
            case 'primary':
                return BlockButtonAppearance.BUTTON_APPEARANCE_PRIMARY;
            case 'plain':
                return BlockButtonAppearance.BUTTON_APPEARANCE_PLAIN;
            case 'bordered':
                return BlockButtonAppearance.BUTTON_APPEARANCE_BORDERED;
            case 'media':
                return BlockButtonAppearance.BUTTON_APPEARANCE_MEDIA;
            case 'destructive':
                return BlockButtonAppearance.BUTTON_APPEARANCE_DESTRUCTIVE;
            case 'caution':
                return BlockButtonAppearance.BUTTON_APPEARANCE_CAUTION;
            case 'success':
                return BlockButtonAppearance.BUTTON_APPEARANCE_SUCCESS;
        }
        return undefined;
    }
    makeBlockButtonSize(size) {
        switch (size) {
            case 'small':
                return BlockButtonSize.BUTTON_SIZE_SMALL;
            case 'medium':
                return BlockButtonSize.BUTTON_SIZE_MEDIUM;
            case 'large':
                return BlockButtonSize.BUTTON_SIZE_LARGE;
        }
        return undefined;
    }
    makeBlockImageResizeMode(resize) {
        switch (resize) {
            case 'none':
                return BlockImageResizeMode.IMAGE_RESIZE_NONE;
            case 'fit':
                return BlockImageResizeMode.IMAGE_RESIZE_FIT;
            case 'fill':
                return BlockImageResizeMode.IMAGE_RESIZE_FILL;
            case 'cover':
                return BlockImageResizeMode.IMAGE_RESIZE_COVER;
            case 'scale-down':
                return BlockImageResizeMode.IMAGE_RESIZE_SCALE_DOWN;
        }
        return undefined;
    }
    makeBlockSpacerSize(size) {
        switch (size) {
            case 'xsmall':
                return BlockSpacerSize.SPACER_XSMALL;
            case 'small':
                return BlockSpacerSize.SPACER_SMALL;
            case 'medium':
                return BlockSpacerSize.SPACER_MEDIUM;
            case 'large':
                return BlockSpacerSize.SPACER_LARGE;
        }
        return undefined;
    }
    makeBlockSpacerShape(size) {
        switch (size) {
            case 'invisible':
                return BlockSpacerShape.SPACER_INVISIBLE;
            case 'thin':
                return BlockSpacerShape.SPACER_THIN;
            case 'square':
                return BlockSpacerShape.SPACER_SQUARE;
        }
        return undefined;
    }
    makeBlockIconSize(size) {
        switch (size) {
            case 'xsmall':
                return BlockIconSize.ICON_SIZE_XSMALL;
            case 'small':
                return BlockIconSize.ICON_SIZE_SMALL;
            case 'medium':
                return BlockIconSize.ICON_SIZE_MEDIUM;
            case 'large':
                return BlockIconSize.ICON_SIZE_LARGE;
        }
        return undefined;
    }
    makeBlockAvatarSize(size) {
        switch (size) {
            case 'xxsmall':
                return BlockAvatarSize.AVATAR_SIZE_XXSMALL;
            case 'xsmall':
                return BlockAvatarSize.AVATAR_SIZE_XSMALL;
            case 'small':
                return BlockAvatarSize.AVATAR_SIZE_SMALL;
            case 'medium':
                return BlockAvatarSize.AVATAR_SIZE_MEDIUM;
            case 'large':
                return BlockAvatarSize.AVATAR_SIZE_LARGE;
            case 'xlarge':
                return BlockAvatarSize.AVATAR_SIZE_XXLARGE;
            case 'xxlarge':
                return BlockAvatarSize.AVATAR_SIZE_XXLARGE;
            case 'xxxlarge':
                return BlockAvatarSize.AVATAR_SIZE_XXXLARGE;
        }
        return undefined;
    }
    makeBlockAvatarFacing(facing) {
        switch (facing) {
            case 'left':
                return BlockAvatarFacing.AVATAR_FACING_LEFT;
            case 'right':
                return BlockAvatarFacing.AVATAR_FACING_RIGHT;
        }
        return undefined;
    }
    makeBlockFullSnooSize(size) {
        switch (size) {
            case 'xsmall':
                return BlockFullSnooSize.FULLSNOO_XSMALL;
            case 'small':
                return BlockFullSnooSize.FULLSNOO_SMALL;
            case 'medium':
                return BlockFullSnooSize.FULLSNOO_MEDIUM;
            case 'large':
                return BlockFullSnooSize.FULLSNOO_LARGE;
            case 'xlarge':
                return BlockFullSnooSize.FULLSNOO_XLARGE;
            case 'xxlarge':
                return BlockFullSnooSize.FULLSNOO_XXLARGE;
        }
        return undefined;
    }
    makeBlockAvatarBackground(background) {
        switch (background) {
            case 'dark':
                return BlockAvatarBackground.AVATAR_BG_DARK;
            case 'light':
                return BlockAvatarBackground.AVATAR_BG_LIGHT;
        }
        return undefined;
    }
    makeBlockAnimationType(type) {
        if (type === 'lottie' || type === undefined) {
            return BlockAnimationType.ANIM_LOTTIE;
        }
        return BlockAnimationType.UNRECOGNIZED;
    }
    makeBlockAnimationDirection(type) {
        switch (type) {
            case 'backward':
                return BlockAnimationDirection.ANIM_DIR_BACKWARD;
            case 'forward':
                return BlockAnimationDirection.ANIM_DIR_FORWARD;
        }
    }
    makeBlockLoopMode(mode) {
        switch (mode) {
            case 'repeat':
                return BlockAnimationLoopMode.ANIM_LOOP_REPEAT;
            case 'bounce':
                return BlockAnimationLoopMode.ANIM_LOOP_BOUNCE;
        }
        return undefined;
    }
    makeBlockSize(props) {
        if (props && (props.width != null || props.height != null || props.grow)) {
            const { value: width, unit: widthUnit } = this.parseSize(props.width) ?? {};
            const { value: height, unit: heightUnit } = this.parseSize(props.height) ?? {};
            return {
                width,
                widthUnit,
                height,
                heightUnit,
                grow: props.grow,
            };
        }
        return undefined;
    }
    makeBlockSizes(props) {
        if (props) {
            const hasWidth = props.width != null || props.minWidth != null || props.maxWidth != null;
            const hasHeight = props.height != null || props.minHeight != null || props.maxHeight != null;
            if (hasWidth || hasHeight || props.grow != null) {
                return {
                    width: hasWidth
                        ? {
                            value: this.parseSize(props.width),
                            min: this.parseSize(props.minWidth),
                            max: this.parseSize(props.maxWidth),
                        }
                        : undefined,
                    height: hasHeight
                        ? {
                            value: this.parseSize(props.height),
                            min: this.parseSize(props.minHeight),
                            max: this.parseSize(props.maxHeight),
                        }
                        : undefined,
                    grow: props.grow,
                };
            }
        }
        return undefined;
    }
    parseSize(size) {
        if (size == null)
            return undefined;
        if (typeof size === 'number') {
            return { value: size, unit: BlockSizeUnit.SIZE_UNIT_PERCENT };
        }
        // Regex:
        // Group 1: Digits with optional decimal trailer
        // Group 2: Optional suffix: 'px' or '%' (defaults to %)
        // eslint-disable-next-line security/detect-unsafe-regex
        const parts = size.match(/^(\d+(?:\.\d+)?)(px|%)?$/);
        if (parts == null) {
            return undefined;
        }
        let unit = BlockSizeUnit.SIZE_UNIT_PERCENT;
        if (parts?.at(2) === 'px') {
            unit = BlockSizeUnit.SIZE_UNIT_PIXELS;
        }
        const value = Number.parseFloat(parts[1]);
        return { value, unit };
    }
    getDataSet(props) {
        return Object.keys(props)
            .filter((key) => key.startsWith(DATA_PREFIX))
            .reduce((p, c) => {
            p[c.substring(DATA_PREFIX.length)] = props[c];
            return p;
        }, {});
    }
    makeActions(_type, props) {
        const actions = [];
        const dataSet = this.getDataSet(props);
        if (props.onPress) {
            const id = props.onPress;
            actions.push({
                type: BlockActionType.ACTION_CLICK,
                id: id.toString(),
                data: dataSet,
            });
        }
        return actions;
    }
    blockColorToHex(color, theme = 'light') {
        if (!color)
            return undefined;
        color = color.toLowerCase();
        if (isHexColor(color)) {
            return color;
        }
        else if (isRPLColor(color)) {
            return getHexFromRPLColor(color, theme);
        }
        else if (isNamedHTMLColor(color)) {
            return getHexFromNamedHTMLColor(color);
        }
        else if (isRgbaColor(color)) {
            return getHexFromRgbaColor(color);
        }
        else if (isHslColor(color)) {
            return color;
        }
        // Color could not be parsed, return red as fallback.
        console.warn(`Could not parse color: ${color}.`);
        return getHexFromNamedHTMLColor('red');
    }
    async childrenToBlocks(children) {
        const promises = children.map((child) => {
            if (typeof child === 'string') {
                return undefined;
            }
            return this.createBlocksElement(child);
        });
        const out = await Promise.all(promises);
        return out.filter((b) => b !== undefined);
    }
    getThemedColors(color, light, dark) {
        let lightColor = this.blockColorToHex(light, 'light');
        let darkColor = this.blockColorToHex(dark, 'dark');
        const tokens = [];
        // don't spend time parsing color if light/dark are already provided
        if (color && (!lightColor || !darkColor)) {
            // split color string, preserving color functions with spaces, such as rgb(r, g, b)
            // eslint-disable-next-line security/detect-unsafe-regex
            const matches = Array.from(color?.matchAll(/[\w#-]+(?:\([\w\t ,.#-]+\))?/g) ?? []);
            tokens.push(...matches.map((group) => group[0]));
        }
        if (!lightColor) {
            lightColor = this.blockColorToHex(tokens?.at(0), 'light');
        }
        if (!darkColor) {
            // if only one color was provided, use it for both light and dark colors
            darkColor = this.blockColorToHex(tokens?.at(1) ?? tokens?.at(0), 'dark');
        }
        return lightColor || darkColor
            ? {
                light: lightColor,
                dark: darkColor,
            }
            : undefined;
    }
    parsePixels(input) {
        if (typeof input === 'string') {
            return Number(input.slice(0, -2));
        }
        return input;
    }
    childrenToString(children) {
        return children.map((c) => c.toString()).join('');
    }
    async makeRoot(props, ...children) {
        return this.wrapRoot(props, await this.childrenToBlocks(children));
    }
    async wrapRoot(props, children) {
        return this.makeBlock(BlockType.BLOCK_ROOT, {}, {
            rootConfig: {
                children: children,
                height: this.makeRootHeight(Devvit.customPostType?.height ??
                    props?.height ??
                    'regular'),
            },
        });
    }
    async makeStackBlock(direction, props, children) {
        const backgroundColors = this.getThemedColors(props?.backgroundColor, props?.lightBackgroundColor, props?.darkBackgroundColor);
        return this.makeBlock(BlockType.BLOCK_STACK, props, {
            stackConfig: {
                alignment: this.makeBlockAlignment(props?.alignment),
                backgroundColor: backgroundColors?.light,
                backgroundColors,
                border: this.makeBlockBorder(props?.border, props?.borderColor, props?.lightBorderColor, props?.darkBorderColor),
                children: await this.childrenToBlocks(children),
                cornerRadius: this.makeBlockRadius(props?.cornerRadius),
                direction: direction,
                gap: this.makeBlockGap(props?.gap),
                padding: this.makeBlockPadding(props?.padding),
                reverse: props?.reverse,
            },
        });
    }
    async makeHStack(props, ...children) {
        return this.makeStackBlock(BlockStackDirection.STACK_HORIZONTAL, props, children);
    }
    async makeVStack(props, ...children) {
        return this.makeStackBlock(BlockStackDirection.STACK_VERTICAL, props, children);
    }
    async makeZStack(props, ...children) {
        return this.makeStackBlock(BlockStackDirection.STACK_DEPTH, props, children);
    }
    makeText(props, ...children) {
        const colors = this.getThemedColors(props?.color, props?.lightColor, props?.darkColor);
        return this.makeBlock(BlockType.BLOCK_TEXT, props, {
            textConfig: {
                alignment: this.makeBlockAlignment(props?.alignment),
                color: colors?.light,
                colors,
                outline: this.makeBlockTextOutline(props?.outline),
                size: this.makeBlockTextSize(props?.size),
                style: this.makeBlockTextStyle(props?.style),
                text: this.childrenToString(children),
                weight: this.makeBlockTextWeight(props?.weight),
                selectable: props?.selectable,
                wrap: props?.wrap,
                overflow: this.makeBlockTextOverflow(props?.overflow),
            },
        });
    }
    makeButton(props, ...children) {
        const textColors = this.getThemedColors(props?.textColor, props?.lightTextColor, props?.darkTextColor);
        return this.makeBlock(BlockType.BLOCK_BUTTON, props, {
            buttonConfig: {
                buttonAppearance: this.makeBlockButtonAppearance(props?.appearance),
                // not available in all platforms yet
                // backgroundColor: props?.backgroundColor,
                icon: props?.icon,
                buttonSize: this.makeBlockButtonSize(props?.size),
                text: this.childrenToString(children),
                textColor: textColors?.light,
                textColors,
                disabled: props?.disabled,
            },
        });
    }
    async makeImage(props) {
        return (props &&
            this.makeBlock(BlockType.BLOCK_IMAGE, props, {
                imageConfig: {
                    description: props?.description,
                    resizeMode: this.makeBlockImageResizeMode(props.resizeMode),
                    url: props.url,
                    width: this.parsePixels(props.imageWidth),
                    height: this.parsePixels(props.imageHeight),
                },
            }));
    }
    makeSpacer(props) {
        return this.makeBlock(BlockType.BLOCK_SPACER, props, {
            spacerConfig: {
                size: this.makeBlockSpacerSize(props?.size),
                shape: this.makeBlockSpacerShape(props?.shape),
            },
        });
    }
    makeIcon(props) {
        const colors = this.getThemedColors(props?.color, props?.lightColor, props?.darkColor);
        return (props &&
            this.makeBlock(BlockType.BLOCK_ICON, props, {
                iconConfig: {
                    icon: props.name,
                    color: colors?.light,
                    colors,
                    size: this.makeBlockIconSize(props.size),
                },
            }));
    }
    makeAvatar(props) {
        return (props &&
            this.makeBlock(BlockType.BLOCK_AVATAR, props, {
                avatarConfig: {
                    thingId: props.thingId,
                    size: this.makeBlockAvatarSize(props.size),
                    facing: this.makeBlockAvatarFacing(props.facing),
                    background: this.makeBlockAvatarBackground(props.background),
                },
            }));
    }
    makeFullSnoo(props) {
        return (props &&
            this.makeBlock(BlockType.BLOCK_FULLSNOO, props, {
                fullsnooConfig: {
                    userId: props.userId,
                    facing: this.makeBlockAvatarFacing(props.facing),
                    size: this.makeBlockFullSnooSize(props.size),
                },
            }));
    }
    async makeAnimation(props) {
        return (props &&
            this.makeBlock(BlockType.BLOCK_ANIMATION, props, {
                animationConfig: {
                    type: this.makeBlockAnimationType(props.type),
                    url: props.url,
                    loop: props.loop,
                    loopMode: this.makeBlockLoopMode(props.loopMode),
                    autoplay: props.autoplay,
                    width: this.parsePixels(props.imageWidth),
                    height: this.parsePixels(props.imageHeight),
                    direction: this.makeBlockAnimationDirection(props.direction),
                    speed: props.speed,
                },
            }));
    }
    makeWebView(props) {
        return (props && this.makeBlock(BlockType.BLOCK_WEBVIEW, props, { webviewConfig: { url: props.url } }));
    }
    makeBlock(type, props, config) {
        return {
            type,
            // TODO: remove once clients have all updated to handle sizes
            size: this.makeBlockSize(props),
            sizes: this.makeBlockSizes(props),
            config: config,
            actions: (props && this.makeActions(type, props)) ?? [],
        };
    }
    async ensureRootBlock(b) {
        const block = b;
        if (block.type === BlockType.BLOCK_ROOT) {
            if (block.config?.rootConfig && Devvit.customPostType?.height) {
                block.config.rootConfig.height = this.makeRootHeight(Devvit.customPostType?.height);
            }
            return block;
        }
        const root = await this.wrapRoot(undefined, [block]);
        if (!root) {
            throw new Error('Could not create root block');
        }
        return root;
    }
}
