var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _BlocksReconciler_instances, _BlocksReconciler_reset, _BlocksReconciler_makeContextProps, _BlocksReconciler_flatten, _BlocksReconciler_rerenderAlreadyScheduled;
import { BlockRenderEventType, BlockType, EffectType } from '@devvit/protos';
import { getFromMetadata } from '@devvit/runtimes/common/envelope/EnvelopeUtil.js';
import { Header } from '@devvit/runtimes/lib/Header.js';
import { makeAPIClients } from '../../../apis/makeAPIClients.js';
import { getEffectsFromUIClient } from '../../../apis/ui/helpers/getEffectsFromUIClient.js';
import { isValidImageURL } from '@devvit/shared-types/imageUtil.js';
import { Devvit } from '../../Devvit.js';
import { getContextFromMetadata } from '../context.js';
import { makeUniqueIdGenerator } from '../helpers/makeUniqueIdGenerator.js';
import { BlocksTransformer } from './BlocksTransformer.js';
export function assertNotString(reified) {
    if (typeof reified === 'string') {
        throw new Error('Root element cannot be a string');
    }
}
// FIXME: don't build XML with a string concatenation :facepalm:
const toXML = (node) => {
    let xml = '';
    const attributes = node.props
        ? Object.keys(node.props)
            .map((key) => (key === 'onPress' ? '' : `${key}="${node.props[key]}"`))
            .join(' ')
        : '';
    xml += `<${node.type}${attributes ? ' ' + attributes : ''}>`;
    for (const child of node.children) {
        if (typeof child === 'string') {
            xml += child;
        }
        else {
            xml += toXML(child);
        }
    }
    xml += `</${node.type}>`;
    return xml;
};
function getIndentation(level) {
    return '  '.repeat(level);
}
// FIXME: don't build XML with a string concatenation :facepalm:
function indentXML(xml) {
    let formatted = '';
    let indentLevel = 0;
    const xmlArr = xml.split(/>\s*</);
    for (let i = 0; i < xmlArr.length; i++) {
        let node = xmlArr[i];
        if (i === 0) {
            node = node.trim();
        }
        if (i === xmlArr.length - 1) {
            node = node.trim();
        }
        const isClosingTag = node.charAt(0) === '/';
        if (isClosingTag) {
            indentLevel--;
        }
        formatted += getIndentation(indentLevel);
        if (i !== 0) {
            formatted += '<';
        }
        formatted += node;
        if (i !== xmlArr.length - 1) {
            formatted += '>\n';
        }
        if (!isClosingTag && node.indexOf('</') === -1 && node.charAt(node.length - 1) !== '/') {
            indentLevel++;
        }
    }
    return formatted;
}
/**
 * @internal
 * An instance of this class should be instantiated for each OnRender call.
 * This class is responsible for:
 *   - rendering JSX elements into Blocks.
 *   - managing state and hooks for each component.
 *   - drilling the shared clients into function components.
 */
export class BlocksReconciler {
    constructor(component, event, state, metadata) {
        _BlocksReconciler_instances.add(this);
        // hook management
        this.renderState = {};
        this.currentComponentKey = [];
        this.currentHookIndex = 0;
        this.actions = new Map();
        this.forms = new Map();
        this.realtimeChannels = [];
        this.realtimeUpdated = false;
        this.pendingHooks = [];
        this.isRendering = false;
        this.transformer = new BlocksTransformer();
        this.effects = [];
        _BlocksReconciler_rerenderAlreadyScheduled.set(this, false);
        this.component = component;
        this.event = event;
        this.state = {
            __renderState: {},
            ...state,
        };
        this.metadata = metadata;
        if (this.state.__realtimeChannels) {
            this.realtimeChannels = this.state.__realtimeChannels;
        }
        const apiClients = makeAPIClients({
            reconciler: this,
            hooks: true,
            ui: true,
            metadata,
        });
        this.cache = apiClients.cache;
        this.modLog = apiClients.modLog;
        this.reddit = apiClients.reddit;
        this.kvStore = apiClients.kvStore;
        this.redis = apiClients.redis;
        this.settings = apiClients.settings;
        this.scheduler = apiClients.scheduler;
        this.media = apiClients.media;
        this.assets = apiClients.assets;
        this.realtime = apiClients.realtime;
        this.ui = apiClients.ui;
        this.hooks = {
            useState: apiClients.useState,
            useInterval: apiClients.useInterval,
            useForm: apiClients.useForm,
            useChannel: apiClients.useChannel,
        };
    }
    async render() {
        await this.reconcile();
        this.isRendering = true;
        const results = await this.buildBlocksUI();
        this.isRendering = false;
        return results;
    }
    makeUniqueActionID(id) {
        let uniqueId = id;
        let counter = 1;
        while (this.actions.has(uniqueId)) {
            uniqueId = `${id}.${counter++}`;
        }
        return uniqueId;
    }
    async reconcile() {
        const blockElement = {
            type: this.component,
            props: __classPrivateFieldGet(this, _BlocksReconciler_instances, "m", _BlocksReconciler_makeContextProps).call(this),
            children: [],
        };
        const reified = await this.processBlock(blockElement);
        assertNotString(reified);
        await this.transformer.createBlocksElementOrThrow(reified);
        if (this.isUserActionRender && this.blockRenderEventId) {
            const onPress = this.actions.get(this.blockRenderEventId);
            if (onPress) {
                await onPress({});
            }
        }
        for (const hook of this.pendingHooks) {
            await hook();
        }
        this.buildNextState();
        __classPrivateFieldGet(this, _BlocksReconciler_instances, "m", _BlocksReconciler_reset).call(this);
    }
    async buildBlocksUI() {
        const rootBlockElement = {
            type: this.component,
            props: __classPrivateFieldGet(this, _BlocksReconciler_instances, "m", _BlocksReconciler_makeContextProps).call(this),
            children: [],
        };
        const block = await this.renderElement(rootBlockElement);
        return this.transformer.ensureRootBlock(block);
    }
    async renderElement(element) {
        const reified = await this.processBlock(element);
        assertNotString(reified);
        if (Devvit.debug.emitSnapshots || getFromMetadata(Header.DebugRenderXML, this.metadata)) {
            console.log(indentXML(toXML(reified)));
        }
        if (Devvit.debug.emitState) {
            console.log(JSON.stringify(this.state, null, 2));
        }
        return await this.transformer.createBlocksElementOrThrow(reified);
    }
    async processProps(props) {
        if (props.onPress) {
            const onPress = props.onPress;
            const name = onPress.name;
            const id = this.makeUniqueActionID(`${BlockType.BLOCK_BUTTON}.${name ?? 'onPress'}`);
            this.actions.set(id, onPress);
            props.onPress = id;
        }
        if (props.url) {
            props.url = await this.getAssetUrl(props.url);
        }
    }
    async getAssetUrl(asset) {
        // If this image exactly matches an asset, use the public URL for the asset instead
        let assetUrl = undefined;
        // @ts-ignore - it doesn't know what globalThis is
        const assets = globalThis?.devvit?.config?.assets;
        if (assets) {
            assetUrl = assets[asset];
        }
        /**
         * This block triggers a circuit breaker that we bypass if the image is:
         * 1. An asset that is already hosted on a verified image host
         * 2. A data url of a valid mimetype
         */
        if (!assetUrl && !isValidImageURL(asset)) {
            // This should not happen if we've set config.assets everywhere correctly, but it's good to
            // keep it around in case we missed something - instead of crashing & burning, we'll just
            // see some image flicker instead.
            console.log('No assets loaded on the config - falling back to plugin');
            try {
                assetUrl = await this.assets.getURL(asset);
                if (assets && assetUrl) {
                    // Save resolved URL
                    assets[asset] = assetUrl;
                }
            }
            catch {
                // nop - this is fine, just means this isn't an asset
            }
        }
        return assetUrl ?? asset;
    }
    async processBlock(element, idGenerator = makeUniqueIdGenerator(), path = []) {
        const blockElement = element;
        // Intrinsic elements
        if (typeof blockElement.type === 'string') {
            const childrens = await Promise.all(blockElement.children.flatMap(async (child, i) => {
                if (child === undefined || child === null)
                    return [];
                return await this.processBlock(child, idGenerator, [
                    ...path,
                    `${blockElement.type}.${i}`,
                ]);
            }));
            const children = childrens.flat();
            const collapsedChildren = __classPrivateFieldGet(this, _BlocksReconciler_instances, "m", _BlocksReconciler_flatten).call(this, children);
            await this.processProps(blockElement.props || {});
            const reified = {
                type: blockElement.type,
                props: blockElement.props,
                children: collapsedChildren,
            };
            return reified;
        }
        // Function components
        if (typeof blockElement.type === 'function') {
            // Create a unique component key to keep track of its state/hooks.
            const componentKey = idGenerator(`${path.length ? path.join('.') : 'root'}.${blockElement.type.name.length ? blockElement.type.name : 'anonymous'}`);
            this.currentComponentKey.push(componentKey);
            if (!this.renderState[componentKey]) {
                this.renderState[componentKey] = {};
            }
            const children = blockElement.children.flatMap((c) => c);
            const props = {
                ...__classPrivateFieldGet(this, _BlocksReconciler_instances, "m", _BlocksReconciler_makeContextProps).call(this),
                ...blockElement.props,
                children,
            };
            let result;
            while (result === undefined) {
                try {
                    result = await blockElement.type(props, __classPrivateFieldGet(this, _BlocksReconciler_instances, "m", _BlocksReconciler_makeContextProps).call(this));
                }
                catch (promiseOrError) {
                    // If the component throws a promise, wait for it to resolve and try again.
                    // This is for components that have async logic in their hook callbacks.
                    if (promiseOrError instanceof Promise) {
                        result = await promiseOrError;
                    }
                    else {
                        throw promiseOrError;
                    }
                }
            }
            // Ensure that the number of hooks are same from the previous render.
            if (!this.isInitialRender) {
                const previousState = this.getPreviousComponentState();
                const prevHookCount = Object.keys(previousState).length;
                if (prevHookCount !== this.currentHookIndex) {
                    throw new Error('Invalid hook call. Hooks can only be called at the top-level of a function component. Make sure that you are not calling hooks inside loops, conditions, or nested functions.');
                }
            }
            // Remember to always reset the current component key and hook index.
            this.currentComponentKey.pop();
            this.currentHookIndex = 0;
            if (typeof result === 'object') {
                return this.processBlock(result, idGenerator, [...path, blockElement.type.name]);
            }
        }
        // Strings - return as is
        if (typeof blockElement === 'string') {
            return blockElement;
        }
        // Numbers - transform to string
        if (typeof blockElement === 'number') {
            return `${blockElement}`;
        }
        let children = [];
        let pathPrefix = '';
        if (Array.isArray(blockElement)) {
            // Array of elements
            children = blockElement;
        }
        else if (typeof blockElement.type === 'undefined' && blockElement.children) {
            // Fragment
            children = blockElement.children;
            pathPrefix = 'fragmentChild.';
        }
        return {
            type: '__fragment',
            props: undefined,
            children: await Promise.all(children.flatMap(async (child, i) => await this.processBlock(child, idGenerator, [...path, `${pathPrefix}${i}`]))),
        };
    }
    getCurrentComponentKey() {
        if (!this.currentComponentKey.at(-1)) {
            throw new Error('Current component key is missing');
        }
        return this.currentComponentKey;
    }
    getCurrentComponentState() {
        const componentKey = this.currentComponentKey.at(-1);
        if (!componentKey) {
            throw new Error('Current component key is missing');
        }
        return this.renderState[componentKey];
    }
    getPreviousComponentState() {
        const componentKey = this.currentComponentKey.at(-1);
        if (!componentKey) {
            throw new Error('Current component key is missing');
        }
        if (!this.state.__renderState[componentKey]) {
            this.state.__renderState[componentKey] = {};
        }
        return this.state.__renderState[componentKey];
    }
    get isInitialRender() {
        if (!this.event) {
            return false;
        }
        return this.event.type === BlockRenderEventType.RENDER_INITIAL;
    }
    get isUserActionRender() {
        if (!this.event) {
            return false;
        }
        return this.event.type === BlockRenderEventType.RENDER_USER_ACTION;
    }
    get isEffectRender() {
        if (!this.event) {
            return false;
        }
        return this.event.type === BlockRenderEventType.RENDER_EFFECT_EVENT;
    }
    get formSubmittedEvent() {
        if (!this.event) {
            return false;
        }
        return this.event.formSubmitted;
    }
    get blockRenderEventId() {
        if (!this.event) {
            return false;
        }
        return this.event.id;
    }
    get realtimeEvent() {
        if (!this.event) {
            return false;
        }
        const realtimeEvent = this.event.realtimeEvent;
        if (!realtimeEvent?.event?.channel) {
            return false;
        }
        return realtimeEvent;
    }
    runHook(hook) {
        this.pendingHooks.push(hook);
    }
    rerenderIn(delayMs) {
        if (__classPrivateFieldGet(this, _BlocksReconciler_rerenderAlreadyScheduled, "f")) {
            return;
        }
        __classPrivateFieldSet(this, _BlocksReconciler_rerenderAlreadyScheduled, true, "f");
        this.effects.push({
            type: EffectType.EFFECT_RERENDER_UI,
            rerenderUi: {
                delaySeconds: delayMs / 1000,
            },
        });
    }
    addRealtimeChannel(channel) {
        this.realtimeChannels.push(channel);
        this.realtimeUpdated = true;
    }
    removeRealtimeChannel(channel) {
        this.realtimeChannels = this.realtimeChannels.filter((c) => c !== channel);
        this.realtimeUpdated = true;
    }
    get realtimeEffect() {
        if (this.realtimeUpdated && this.realtimeChannels.length > 0) {
            return [
                {
                    type: EffectType.EFFECT_REALTIME_SUB,
                    realtimeSubscriptions: {
                        subscriptionIds: this.realtimeChannels,
                    },
                },
            ];
        }
        else {
            return [];
        }
    }
    getEffects() {
        return [...getEffectsFromUIClient(this.ui), ...this.effects, ...this.realtimeEffect];
    }
    buildNextState() {
        // Flatten the renderStates down to arrays to ensure `undefined` values are maintained through serialization.
        // Input:
        // {"0": "one", "1": undefined, "2": "three"} (length: 3)
        // Before:
        // {"0": "one", "2": "three"} (length: 2; fails consistency check, see line 251)
        // After:
        // ["one", undefined, "three"] (length: 3)
        for (const key of Object.keys(this.renderState)) {
            this.renderState[key] = Object.values(this.renderState[key]);
        }
        this.state = {
            __postData: this.state.__postData,
            __renderState: this.renderState,
            __cache: this.state.__cache,
            ...(this.realtimeChannels.length > 0 ? { __realtimeChannels: this.realtimeChannels } : {}),
        };
    }
}
_BlocksReconciler_rerenderAlreadyScheduled = new WeakMap(), _BlocksReconciler_instances = new WeakSet(), _BlocksReconciler_reset = function _BlocksReconciler_reset() {
    this.actions.clear();
    this.currentComponentKey = [];
    this.currentHookIndex = 0;
    this.pendingHooks = [];
    this.realtimeChannels = [];
    this.realtimeUpdated = false;
}, _BlocksReconciler_makeContextProps = function _BlocksReconciler_makeContextProps() {
    return {
        ...getContextFromMetadata(this.metadata, this.state.__postData?.thingId),
        modLog: this.modLog,
        reddit: this.reddit,
        cache: this.cache,
        kvStore: this.kvStore,
        redis: this.redis,
        settings: this.settings,
        scheduler: this.scheduler,
        media: this.media,
        assets: this.assets,
        realtime: this.realtime,
        ui: this.ui,
        ...this.hooks,
    };
}, _BlocksReconciler_flatten = function _BlocksReconciler_flatten(arr) {
    const out = [];
    for (const child of arr) {
        if (typeof child === 'string') {
            out.push(child);
        }
        else if (child.type === '__fragment') {
            out.push(...__classPrivateFieldGet(this, _BlocksReconciler_instances, "m", _BlocksReconciler_flatten).call(this, child.children));
        }
        else {
            out.push(child);
        }
    }
    return out;
};
