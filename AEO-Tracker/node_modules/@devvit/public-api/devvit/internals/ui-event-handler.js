import { EffectType, UIEventHandlerDefinition } from '@devvit/protos';
import cloneDeep from 'clone-deep';
import isEqual from 'lodash.isequal';
import { makeAPIClients } from '../../apis/makeAPIClients.js';
import { getEffectsFromUIClient } from '../../apis/ui/helpers/getEffectsFromUIClient.js';
import { getFormValues } from '../../apis/ui/helpers/getFormValues.js';
import { Devvit } from '../Devvit.js';
import { BlocksReconciler } from './blocks/BlocksReconciler.js';
import { getContextFromMetadata } from './context.js';
import { extendDevvitPrototype } from './helpers/extendDevvitPrototype.js';
import { getMenuItemById } from './menu-items.js';
async function handleUIEvent(req, metadata) {
    // Keep track of the original state so we can check if it was updated.
    const originalState = req.state ?? {};
    const state = cloneDeep(originalState);
    const apiClients = makeAPIClients({
        ui: true,
        metadata,
    });
    if (req.event?.formSubmitted && req.event.formSubmitted.formId) {
        const formKey = req.event.formSubmitted.formId;
        if (formKey.includes('form.hook.')) {
            if (Devvit.customPostType) {
                const blocksReconciler = new BlocksReconciler(Devvit.customPostType.render, req.event, req.state, metadata);
                await blocksReconciler.reconcile();
                return {
                    state: blocksReconciler.state,
                    effects: blocksReconciler.getEffects(),
                };
            }
        }
        const formDefinition = Devvit.formDefinitions.get(formKey);
        if (!formDefinition) {
            throw new Error(`Form with key ${formKey} not found`);
        }
        let postId;
        let commentId;
        if (state.__contextAction) {
            const { actionId, thingId } = state.__contextAction;
            const menuItem = getMenuItemById(actionId);
            if (menuItem?.location === 'post') {
                postId = thingId;
            }
            else if (menuItem?.location === 'comment') {
                commentId = thingId;
            }
        }
        const context = Object.assign(apiClients, getContextFromMetadata(metadata, postId, commentId));
        await formDefinition.onSubmit({
            values: getFormValues(req.event.formSubmitted.results),
        }, context);
    }
    else if (req.event?.realtimeEvent) {
        if (Devvit.customPostType) {
            const blocksReconciler = new BlocksReconciler(Devvit.customPostType.render, req.event, req.state, metadata);
            await blocksReconciler.reconcile();
            return {
                state: blocksReconciler.state,
                effects: blocksReconciler.getEffects(),
            };
        }
    }
    else if (req.event?.toastAction) {
        throw new Error('Toast actions not yet implemented');
    }
    // Check if the state was updated to determine if we need to rerender.
    const stateWasUpdated = !isEqual(originalState, state);
    const uiEffects = getEffectsFromUIClient(apiClients.ui);
    const effects = stateWasUpdated
        ? [
            ...uiEffects,
            {
                type: EffectType.EFFECT_RERENDER_UI,
                rerenderUi: {
                    delaySeconds: 0,
                },
            },
        ]
        : uiEffects;
    return {
        state,
        effects,
    };
}
export function registerUIEventHandler(config) {
    config.provides(UIEventHandlerDefinition);
    extendDevvitPrototype('HandleUIEvent', handleUIEvent);
}
