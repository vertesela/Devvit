import type { AboutLocationRequest } from '@devvit/protos';
import type { AddButtonWidgetRequest } from '@devvit/protos';
import type { AddCalendarWidgetRequest } from '@devvit/protos';
import type { AddCommunityListWidgetRequest } from '@devvit/protos';
import type { AddCustomWidgetRequest } from '@devvit/protos';
import type { AddImageWidgetRequest } from '@devvit/protos';
import type { AddPostFlairWidgetRequest } from '@devvit/protos';
import type { AddTextAreaWidgetRequest } from '@devvit/protos';
import type { AssetResolver } from '@devvit/protos';
import type { CalendarWidgetConfiguration } from '@devvit/protos';
import { CommunityListWidget_CommunityData } from '@devvit/protos';
import type { Definition } from '@devvit/protos';
import type { DeleteNotesRequest } from '@devvit/protos';
import type { DependencySpec } from '@devvit/protos';
import type { FieldConfig_Boolean } from '@devvit/protos';
import type { FieldConfig_Number } from '@devvit/protos';
import type { FieldConfig_Paragraph } from '@devvit/protos';
import type { FieldConfig_Selection } from '@devvit/protos';
import type { FieldConfig_Selection_Item } from '@devvit/protos';
import type { FieldConfig_String } from '@devvit/protos';
import type { GetNotesRequest } from '@devvit/protos';
import { GetWidgetsResponse_WidgetItem } from '@devvit/protos';
import type { GetWidgetsResponse_WidgetItem_PostFlairTemplate } from '@devvit/protos';
import type { HScanResponse } from '@devvit/protos';
import type { JsonStatus } from '@devvit/protos';
import type { Metadata } from '@devvit/protos';
import type { PackageQuery } from '@devvit/protos';
import type { PostNotesRequest } from '@devvit/protos';
import type { PostRemovalNoteRequest } from '@devvit/protos';
import type * as protos from '@devvit/protos';
import type { SubredditAboutRulesResponse } from '@devvit/protos';
import type { WidgetButton } from '@devvit/protos';
import type { WidgetImage } from '@devvit/protos';
import type { WidgetStyles } from '@devvit/protos';
import type { WikiPageRevision as WikiPageRevision_2 } from '@devvit/protos';
import type { WikiPageSettings_Data } from '@devvit/protos';

export declare enum AboutLocations {
    Reports = "reports",
    Spam = "spam",
    Modqueue = "modqueue",
    Unmoderated = "unmoderated",
    Edited = "edited"
}

declare type AboutSubredditHelperOptions<T extends AboutSubredditTypes> = Prettify<{
    type: T;
} & AboutLocationRequest>;

declare type AboutSubredditOptions<T extends AboutSubredditTypes> = Omit<AboutSubredditHelperOptions<T>, 'location' | 'subreddit'>;

export declare type AboutSubredditTypes = 'comment' | 'post' | 'all';

/**
 * Subclasses are expected to call config.init(), provides(), and uses(). It
 * is erroneous to not override the constructor. Override, invoke
 * `super(config)`, and call the Config APIs.
 */
declare abstract class Actor {
    constructor(config: Config);
}

export declare type AddRemovalNoteOptions = Prettify<PostRemovalNoteRequest>;

export declare type AddWidgetData = (AddImageWidgetRequest & {
    type: 'image';
}) | (AddCalendarWidgetRequest & {
    type: 'calendar';
}) | (AddTextAreaWidgetRequest & {
    type: 'textarea';
}) | (AddButtonWidgetRequest & {
    type: 'button';
}) | (AddCommunityListWidgetRequest & {
    type: 'community-list';
}) | (AddPostFlairWidgetRequest & {
    type: 'post-flair';
}) | (AddCustomWidgetRequest & {
    type: 'custom';
});

export declare const ALL_ICON_NAMES: readonly ["activity", "add-emoji", "add", "add-media", "add-to-feed", "admin", "align-center", "align-left", "align-right", "all", "appearance", "approve", "archived", "aspect-ratio", "aspect-rectangle", "attach", "audio", "author", "avatar-style", "award", "back", "ban", "best", "binoculars", "block", "blockchain", "bold", "bot", "boost", "bounce", "browse", "browser", "cake", "calendar", "camera", "caret-down", "caret-left", "caret-right", "caret-up", "chat", "chat-group", "chat-new", "checkbox-dismiss", "checkbox", "checkmark", "chrome", "clear", "close", "closed-captioning", "code-block", "code-inline", "coins-color-old", "coins-color", "coins", "collapse-left", "collapse-right", "collection", "comment", "comments", "community", "contest", "controversial", "crop", "crosspost", "crowd-control", "custom-feed", "customize", "day", "delete", "discover", "dismiss-all", "distinguish", "down-arrow", "down", "download", "downvote", "downvotes", "drag", "drugs", "duplicate", "edit", "effect", "embed", "emoji", "end-live-chat", "error", "expand-left", "expand-right", "external", "feed-video", "filter", "format", "forward", "gif-post", "heart", "help", "hide", "history", "home", "hot", "ignore-reports", "image-post", "inbox", "info", "invite", "italic", "join", "joined", "jump-down", "jump-up", "karma", "keyboard", "kick", "language", "leave", "left", "link", "link-post", "list-bulleted", "list-numbered", "live-chat", "live", "load", "location", "lock", "logout", "loop", "mark-read", "mask", "media-gallery", "meme", "menu", "message", "mic", "mic-mute", "mod", "mod-mail", "mod-mode", "mod-mute", "mod-overflow", "mod-queue", "mod-unmute", "music", "new", "night", "notification", "notification-frequent", "notification-off", "nsfw", "nsfw-language", "nsfw-violence", "original", "overflow-caret", "overflow-horizontal", "overflow-vertical", "pause", "payment", "peace", "pending-posts", "phone", "pin", "planet", "play", "poll-post", "popular", "posts", "powerup-color-outline", "powerup-fill-color", "powerup", "predictions", "premium", "privacy", "profile", "qa", "qr-code", "quarantined", "quote", "r-slash", "radio-button", "raise-hand", "random", "ratings-everyone", "ratings-mature", "ratings-nsfw", "ratings-violence", "refresh", "remove", "reply", "report", "reverse", "right", "rising", "rotate", "rotate-image", "rpan", "rules", "safari", "save", "saved", "search", "self", "send", "settings", "share-android", "share", "share-ios", "show", "side-menu", "skipback10", "skipforward10", "sort-az", "sort", "sort-price", "sort-za", "spam", "spoiler", "sponsored", "star", "statistics", "status-live", "sticker", "strikethrough", "subtract", "superscript", "swap-camera", "swipe-back", "swipe-down", "swipe", "swipe-up", "table", "tag", "tap", "telescope", "text", "text-post", "text-size", "toggle", "tools", "top", "topic-activism", "topic-addictionsupport", "topic-advice", "topic-animals", "topic-anime", "topic-art", "topic-beauty", "topic-business", "topic-careers", "topic-cars", "topic-celebrity", "topic-craftsdiy", "topic-crypto", "topic-culture", "topic-diy", "topic-entertainment", "topic-ethics", "topic-family", "topic-fashion", "topic", "topic-fitness", "topic-food", "topic-funny", "topic-gender", "topic-health", "topic-help", "topic-history", "topic-hobbies", "topic-homegarden", "topic-internet", "topic-law", "topic-learning", "topic-lifestyle", "topic-marketplace", "topic-mature", "topic-mensfashion", "topic-menshealth", "topic-meta", "topic-military", "topic-movies", "topic-music", "topic-news", "topic-other", "topic-outdoors", "topic-pets", "topic-photography", "topic-places", "topic-podcasts", "topic-politics", "topic-programming", "topic-reading", "topic-religion", "topic-science", "topic-sexorientation", "topic-sports", "topic-style", "topic-tabletop", "topic-technology", "topic-television", "topic-traumasupport", "topic-travel", "topic-videogaming", "topic-womensfashion", "topic-womenshealth", "translate", "trim", "u-slash", "unban", "undo", "unheart", "unlock", "unmod", "unpin", "unverified", "up-arrow", "up", "upload", "upvote", "upvotes", "user", "user-note", "users", "vault", "verified", "video-camera", "video-feed", "video-live-1", "video-live-fill-1", "video-live", "video-post", "video-thread", "video-transcription", "view-card", "view-classic", "view-compact", "view-grid", "views", "volume", "volume-mute", "wallet", "warning", "wiki-ban", "wiki", "wiki-unban", "world"];

export declare type AllIconName = typeof ALL_ICON_NAMES[number];

export declare type AllowableFlairContent = 'all' | 'emoji' | 'text';

/** The event name for when your app is installed */
export declare type AppInstall = 'AppInstall';

export declare type AppInstallDefinition = {
    event: AppInstall;
    onEvent: TriggerOnEventHandler<protos.AppInstall>;
};

/** The event name for when your app is upgraded */
export declare type AppUpgrade = 'AppUpgrade';

export declare type AppUpgradeDefinition = {
    event: AppUpgrade;
    onEvent: TriggerOnEventHandler<protos.AppUpgrade>;
};

/**
 * A map from the local file path of a media asset ("assets/file.png"), to either:
 * - If the relevant app version has finished uploading all its assets: its
 *     publicly accessible URL (https://i.redd.it/<ID>.png)
 * - If the relevant app version has not uploaded all its assets, or this is
 *     from the CLI which doesn't know the public URLs for any assets: the
 *     asset ID for the file as saved in dev-portal (NOT the media service ID).
 *     UUIDv4.
 * Note that this may be `undefined` if the bundle is old and/or there are no
 * assets associated with the app.
 */
declare type AssetMap = {
    [path: string]: string;
} | undefined;

declare class AssetsClient {
    #private;
    constructor(metadata: Metadata, assetsPluginFetcher: () => AssetResolver);
    /**
     * Gets the public URLs for an asset.
     * @param assetPath A path, relative to the 'assets/' folder.
     * @returns The public URL for that asset (https://i.redd.it/<id>.<ext>)
     */
    getURL(assetPath: string): Promise<string>;
    /**
     * Gets the public URLs for multiple assets.
     * @param assetPaths An array of paths, relative to the 'assets/' folder.
     * @returns A map of each asset path to its public URL (https://i.redd.it/<id>.<ext>)
     */
    getURL(assetPaths: string[]): Promise<NonNullable<AssetMap>>;
}

export declare type BanUserOptions = {
    username: string;
    subredditName: string;
    context?: string;
    message?: string;
    reason?: string;
    duration?: number;
    note?: string;
};

export declare type BanWikiContributorOptions = {
    username: string;
    subredditName: string;
    reason?: string;
    duration?: number;
    note?: string;
};

export declare type BaseContext = {
    /** The ID of the current subreddit */
    subredditId: string;
    /** The ID of the current post */
    postId?: string | undefined;
    /** The current user's ID if this event was triggered by a logged in user */
    userId?: string | undefined;
    /** The ID of the current app's account */
    appAccountId: string;
    /** The ID of the current comment */
    commentId?: string | undefined;
    /** Returns a JSON representation of the context */
    toJSON(): Omit<BaseContext, 'toJSON'>;
    /** More useful things, but probably not for the average developer */
    debug: ContextDebugInfo;
};

export declare type BaseField<ValueType> = {
    /** The name of the field. This will be used as the key in the `values` object when the form is submitted */
    name: string;
    /** The label of the field. This will be displayed to the user */
    label: string;
    /** An optional help text that will be displayed below the field */
    helpText?: string | undefined;
    /** If true the field will be required and the user will not be able to submit the form without filling it in */
    required?: boolean | undefined;
    /** If true the field will be disabled */
    disabled?: boolean | undefined;
    /** The default value of the field */
    defaultValue?: ValueType | undefined;
    /** This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. */
    scope?: SettingScopeType | undefined;
};

export declare type BlockElement = {
    type: JSX.ComponentFunction | Devvit.BlockComponent | Devvit.CustomPostComponent | string | undefined;
    props: {} | undefined;
    children: JSX.Children[];
};

/**
 * @mixin
 */
declare type BlockQuoteContainer<Context> = {
    /**
     * Append a Block Quote element
     * @param opts
     * @param cb scoped callback to add child elements to this Block Quote
     */
    blockQuote(opts: BlockQuoteOptions, cb: (blockQuote: BlockQuoteContext) => void): Context;
};

/**
 * @borrows ParagraphContainer
 */
declare interface BlockQuoteContext extends ParagraphContainer<BlockQuoteContext> {
}

declare type BlockQuoteOptions = {
    /**
     * Element for author attribution
     * @see {@link TextNode}
     * @example { author: makeUserLink({ username: 'spez', showPrefix: true }) }
     */
    author?: TextNode;
};

/** A boolean field displayed as a toggle */
export declare type BooleanField = Prettify<Omit<BaseField<boolean>, 'required'> & FieldConfig_Boolean & {
    type: 'boolean';
}>;

declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export declare class ButtonWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get buttons(): WidgetButton[];
    get description(): string;
    get styles(): WidgetStyles;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<ButtonWidget, 'buttons' | 'description' | 'styles'>;
}

declare type CacheHelper = <T extends JSONValue>(fn: () => Promise<T>, options: CacheOptions) => Promise<T>;

declare type CacheOptions = {
    /**
     * Time to live in milliseconds.
     */
    ttl: number;
    /**
     * Key to use for caching.
     */
    key: string;
};

export declare class CalendarWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get googleCalendarId(): string;
    get configuration(): CalendarWidgetConfiguration;
    get styles(): WidgetStyles;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<CalendarWidget, 'googleCalendarId' | 'configuration' | 'styles'>;
}

/**
 * Cancel a scheduled job
 * @param jobId The id of the job to cancel
 */
export declare type CancelJob = (jobId: string) => Promise<void>;

declare type ChannelOptions = {
    /** Name of the channel */
    name: string;
    /** Called every time a message is received on this channel */
    onMessage: (data: Data) => void | Promise<void>;
    /** Optional hook to be informed when the channel has connected */
    onSubscribed?: (() => void | Promise<void>) | undefined;
    /** Optional hook to be informed when the channel has disconnected */
    onUnsubscribed?: (() => void | Promise<void>) | undefined;
};

declare enum ChannelStatus {
    Unknown = 0,
    Connecting = 1,
    Connected = 2,
    Disconnecting = 3,
    Disconnected = 4
}

/**
 * @mixin
 */
declare type CodeBlockContainer<Context> = {
    /**
     * Append a Code Block element
     * @param opts {@link CodeBlockOptions}
     * @param cb scoped callback to add child elements to this Code Block
     */
    codeBlock(opts: CodeBlockOptions, cb: (codeBlock: CodeBlockContext) => void): Context;
};

/**
 * @borrows RawTextContainer
 */
declare interface CodeBlockContext extends RawTextContainer<CodeBlockContext> {
}

declare type CodeBlockOptions = {
    /**
     * Language of the content in this Code Block
     * @example { language: 'javascript' }
     */
    language?: string;
};

/** Determines how the collection items will be displayed in the ui. */
export declare enum CollectionDisplayLayout {
    /** PostCollection items will be displayed as a gallery. */
    Gallery = "GALLERY",
    /** PostCollection items will be displayed as a list. */
    Timeline = "TIMELINE"
}

export declare class Comment {
    #private;
    get id(): T1ID;
    get authorId(): T2ID | undefined;
    get authorName(): string;
    get subredditId(): T5ID;
    get subredditName(): string;
    get body(): string;
    get createdAt(): Date;
    get parentId(): T1ID | T3ID;
    get postId(): T3ID;
    get replies(): Listing<Comment>;
    get distinguishedBy(): string | undefined;
    get locked(): boolean;
    get stickied(): boolean;
    get removed(): boolean;
    get approved(): boolean;
    get spam(): boolean;
    get edited(): boolean;
    get numReports(): number;
    get collapsedBecauseCrowdControl(): boolean;
    get score(): number;
    get permalink(): string;
    get userReportReasons(): string[];
    get modReportReasons(): string[];
    get url(): string;
    toJSON(): Pick<Comment, 'id' | 'authorName' | 'subredditId' | 'subredditName' | 'body' | 'createdAt' | 'parentId' | 'postId' | 'replies' | 'approved' | 'locked' | 'removed' | 'stickied' | 'spam' | 'edited' | 'distinguishedBy' | 'numReports' | 'collapsedBecauseCrowdControl' | 'score' | 'permalink' | 'userReportReasons' | 'modReportReasons' | 'url'>;
    isLocked(): boolean;
    isApproved(): boolean;
    isRemoved(): boolean;
    isSpam(): boolean;
    isStickied(): boolean;
    isDistinguished(): boolean;
    isEdited(): boolean;
    delete(): Promise<void>;
    edit(options: EditCommentOptions): Promise<this>;
    approve(): Promise<void>;
    remove(isSpam?: boolean): Promise<void>;
    lock(): Promise<void>;
    unlock(): Promise<void>;
    reply(options: ReplyToCommentOptions): Promise<Comment>;
    getAuthor(): Promise<User>;
    distinguish(makeSticky?: boolean): Promise<void>;
    distinguishAsAdmin(makeSticky?: boolean): Promise<void>;
    undistinguish(): Promise<void>;
    /**
     * Add a mod note for why the comment was removed
     *
     * @param options.reasonId id of a Removal Reason - you can leave this as an empty string if you don't have one
     * @param options.modNote the reason for removal (maximum 100 characters) (optional)
     * @returns
     */
    addRemovalNote(options: {
        reasonId: string;
        modNote?: string;
    }): Promise<void>;
}

declare const COMMENT_LINK_ELEMENT = "c/";

/** The event name for when a comment is created, after safety delay */
export declare type CommentCreate = 'CommentCreate';

export declare type CommentCreateDefinition = {
    event: CommentCreate;
    onEvent: TriggerOnEventHandler<protos.CommentCreate>;
};

/** The event name for when a comment is deleted */
export declare type CommentDelete = 'CommentDelete';

export declare type CommentDeleteDefinition = {
    event: CommentDelete;
    onEvent: TriggerOnEventHandler<protos.CommentDelete>;
};

declare type CommentLink = {
    e: typeof COMMENT_LINK_ELEMENT;
    t: string;
};

/**
 * @borrows RedditPermalinkOptions
 */
declare type CommentLinkOptions = RedditPermalinkOptions;

export declare type CommentMediaTypes = 'giphy' | 'static' | 'animated' | 'expression';

/** The event name for when a comment is reported */
export declare type CommentReport = 'CommentReport';

export declare type CommentReportDefinition = {
    event: CommentReport;
    onEvent: TriggerOnEventHandler<protos.CommentReport>;
};

export declare type CommentSort = 'confidence' | 'top' | 'new' | 'controversial' | 'old' | 'random' | 'qa' | 'live';

export declare type CommentSubmissionOptions = {
    text: string;
} | {
    richtext: object | RichTextBuilder;
};

/** The event name for when a comment is submitted */
export declare type CommentSubmit = 'CommentSubmit';

export declare type CommentSubmitDefinition = {
    event: CommentSubmit;
    onEvent: TriggerOnEventHandler<protos.CommentSubmit>;
};

/** The event name for when a comment is updated */
export declare type CommentUpdate = 'CommentUpdate';

export declare type CommentUpdateDefinition = {
    event: CommentUpdate;
    onEvent: TriggerOnEventHandler<protos.CommentUpdate>;
};

export declare type CommonSubmitPostOptions = {
    title: string;
    sendreplies?: boolean;
    nsfw?: boolean;
    spoiler?: boolean;
    flairId?: string;
    flairText?: string;
};

export declare class CommunityListWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get communities(): CommunityListWidget_CommunityData[];
    get styles(): WidgetStyles;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<CommunityListWidget, 'communities' | 'styles'>;
}

/**
 * Bundle configuration for code about to be built (eg, dependencies). All
 * Bundle config state that impacts building should be recorded in the
 * implementation. See Actor subclass constructors.
 *
 * This type is = kind of like a builder pattern where export() is the build
 * method. Devvit almost implements this class.
 */
declare type Config = {
    assets: Readonly<AssetMap>;
    export(namespace: Readonly<Namespace>): DependencySpec;
    provides(definition: Readonly<Definition>): void;
    use<T>(definition: Readonly<Definition>, options?: Readonly<DeepPartial<PackageQuery>>): T;
    /**
     * Check if a previous call to `use` was made. This is useful for allowing polyfills
     * to ensure that they can provide functionality in terms of a plugin, or fallback to
     * default functionality if not
     */
    uses(definition: Readonly<Definition>): boolean;
};

export declare type Configuration = {
    /** Allows your app to use the HTTP/Fetch API */
    http?: PluginSettings | boolean;
    /** Allows your app to use the reddit API */
    redditAPI?: PluginSettings | boolean;
    /** Allows your app to use the Key-Value Store */
    kvStore?: PluginSettings | boolean;
    /** Allows your app to use the Redis Plugin */
    redis?: PluginSettings | boolean;
    /** Allows media uploads from apps */
    media?: PluginSettings | boolean;
    /** Allows using ModLog API */
    modLog?: PluginSettings | boolean;
    /** Allows your app to use the Realtime Plugin */
    realtime?: PluginSettings | boolean;
};

/** The current app context of the event or render */
export declare type Context = ContextAPIClients & BaseContext;

export declare type ContextAPIClients = {
    /** A client for the ModLog API */
    modLog: ModLogClient;
    /** A client for the Key Value Store */
    kvStore: KVStore;
    /**
     * @experimental
     *
     * The cache helper will let you cache JSON-able objects in your devvit apps for a limited amount of time.
     *
     * Under the covers, It's just Redis, so you do need to enable the redis feature. This provides a pattern for e.g. fetching
     * remote calls without overwhelming someone's server.
     *
     * ```ts
     * Devvit.configure({
     *   redis: true, // Enable access to Redis
     * });
     *
     * /// ...
     *
     * let component = (context) => {
     *   let cached = context.cache(async () => {
     *     let rsp = await fetch("https://google.com")
     *     return rsp.body
     *   },
     *   {
     *     key: "some-fetch",
     *     ttl: 10_000 // millis
     *   }
     *   doSomethingWith(cached);
     *   return <text>yay</text>
     * }
     * ```
     */
    cache: CacheHelper;
    /** A client for the Redis API */
    redis: RedisClient;
    /** A client for the Reddit API */
    reddit: RedditAPIClient;
    /** A client for the Settings API */
    settings: SettingsClient;
    /** A client for the Scheduler API */
    scheduler: Scheduler;
    /** A client for media API */
    media: MediaPlugin;
    /** A client for resolving static assets to public URLs */
    assets: AssetsClient;
    /** A client for Realtime API */
    realtime: RealtimeClient;
    /** A client for the User Interface API */
    ui: UIClient;
    /**
     * A hook for managing a state between Block renders. This is only available
     * within a Block Component. Returns a tuple containing the current state and
     * a function to update it.
     *
     * ```ts
     * const [counter, setCounter] = useState(0);
     * setCounter(1); // counter = 1
     * setCounter((count) => count + 1) // counter = 2
     * ```
     */
    useState(initialState: boolean | (() => boolean | Promise<boolean>)): UseStateResult<boolean>;
    useState(initialState: number | (() => number | Promise<number>)): UseStateResult<number>;
    useState(initialState: string | (() => string | Promise<string>)): UseStateResult<string>;
    useState<S extends JSONValue | undefined | void>(initialState: S | (() => S | Promise<S>)): UseStateResult<S>;
    /**
     * A hook for managing a callback that runs on an interval between Block renders.
     * This is only available within a Block Component.
     */
    useInterval: UseIntervalHook;
    /**
     * A hook for managing a form between Block renders.
     * This is only available within a Block Component.
     */
    useForm: UseFormHook;
    /**
     * A hook hor managing a realtime pubsub channel between Block renders.
     * This is only available within a Block Component.
     */
    useChannel: UseChannelHook;
};

export declare type ContextDebugInfo = {
    metadata: Metadata;
};

export declare type ConversationData = {
    /** Conversation ID */
    id?: string;
    /** Suject of the conversation */
    subject?: string;
    /**
     * Subreddit owning the modmail conversation
     */
    subreddit?: {
        displayName?: string;
        id?: string;
    };
    /**
     * A ConversationType specifies whether a conversation is with a subreddit
     * itself, with another user, or with another subreddit entirely.
     * - `internal` - This is a conversation with another user outside of the subreddit. The participant ID is that user's ID.
     * - `sr_user` - This is a Mod Discussion, internal to the subreddit. There is no other participant.
     * - `sr_sr` - This is a conversation is with another subreddit. The participant will have a subreddit ID.
     */
    conversationType?: string;
    /** Is the conversation automatically generated e.g. from automod, u/reddit */
    isAuto?: boolean;
    /** Participant. Is absent for mod discussions */
    participant?: Participant;
    /** The last datetime a user made any interaction with the conversation */
    lastUserUpdate?: string;
    /** Is the conversation internal (i.e. mod only) */
    isInternal?: boolean;
    /**
     * The last datetime a mod from the owning subreddit made any interaction
     * with the conversation.
     *
     * (Note that if this is a subreddit to subreddit conversation, the mods of
     * the participant subreddit are irrelevant and do not affect this field.)
     */
    lastModUpdate?: string;
    /** The authors of each message in the modmail conversation. */
    authors: Participant[];
    /** The datetime of the last time the conversation was update. */
    lastUpdated?: string;
    /** State of the conversation */
    state?: ModMailConversationState;
    /** The datetime of the last unread message within this conversation for the current viewer. */
    lastUnread?: string;
    /** Is the conversation highlighted */
    isHighlighted?: boolean;
    /** Number of messages (not actions) in the conversation */
    numMessages?: number;
    /**
     * Conversation messages
     *
     * @example
     * ```ts
     * const arrayOfMessages = Object.values(conversation.messages);
     * const messageById = conversation.messages[messageId];
     * ```
     */
    messages: {
        [id: string]: MessageData;
    };
    /**
     * Conversation mod actions
     *
     * @example
     * ```ts
     * const arrayOfModActions = Object.values(conversation.modActions);
     * const modActionById = conversation.modActions[modActionId];
     * ```
     */
    modActions: {
        [id: string]: ModActionData;
    };
};

export declare type ConversationResponse = {
    conversation: ConversationData;
};

/**
 * A Conversation State is a way in which conversations may be filtered within the UI.
 *
 * A conversation can be in more than one state.
 * For example, a conversation may be both 'highlighted' and 'inprogress'.
 */
export declare type ConversationStateFilter = 'all' | 'new' | 'inprogress' | 'archived' | 'appeals' | 'join_requests' | 'highlighted' | 'mod' | 'notifications' | 'inbox' | 'filtered' | 'default';

export declare type ConversationUserData = {
    /** User ID*/
    id?: string;
    /** Username */
    name?: string;
    /** Recent comments */
    recentComments: {
        [id: string]: {
            comment?: string;
            date?: string;
            permalink?: string;
            title?: string;
        };
    };
    /** Recent posts */
    recentPosts: {
        [id: string]: {
            date?: string;
            permalink?: string;
            title?: string;
        };
    };
    /** Recent conversations */
    recentConvos: {
        [id: string]: {
            date?: string;
            permalink?: string;
            id?: string;
            subject?: string;
        };
    };
    isSuspended?: boolean;
    isShadowBanned?: boolean;
    muteStatus?: {
        isMuted?: boolean;
        muteCount?: number;
        endDate?: string;
        reason?: string;
    };
    banStatus?: {
        isBanned?: boolean;
        isPermanent?: boolean;
        endDate?: string;
        reason?: string;
    };
    approveStatus?: {
        isApproved?: boolean;
    };
    /** When was created */
    created?: string;
};

export declare type CreateCollectionInput = {
    /** The title of the collection. */
    title?: string;
    /** The t5_ id of the subreddit in which this collection will be created. */
    subredditId?: string;
    /** The description of the collection. */
    description?: string;
    /** One of: TIMELINE | GALLERY. This determines the layout of posts in the collection UI. */
    displayLayout?: CollectionDisplayLayout;
};

export declare type CreateFlairTemplateOptions = {
    /** The name of the subreddit to create the flair template in. */
    subredditName: string;
    /** The flair template's allowable content. Either 'all', 'emoji', or 'text'. */
    allowableContent?: AllowableFlairContent;
    /** The background color of the flair. Either 'transparent' or a hex color code. e.g. #FFC0CB */
    backgroundColor?: string;
    maxEmojis?: number;
    /** Whether or not this flair template is only available to moderators. */
    modOnly?: boolean;
    /** The text to display in the flair. */
    text: string;
    /** Either 'dark' or 'light'. */
    textColor?: FlairTextColor;
    /** Whether or not users are allowed to edit this flair template before using it. */
    allowUserEdits?: boolean;
};

export declare type CreateModNoteOptions = Prettify<PostNotesRequest & {
    redditId: T1ID | T3ID;
    label: UserNoteLabel;
}>;

export declare type CreateRelationshipOptions = {
    subredditName: string;
    username: string;
    type: RelationshipType;
    banContext?: string;
    banMessage?: string;
    banReason?: string;
    duration?: number;
    note?: string;
    permissions?: ModeratorPermission[];
};

export declare type CreateWikiPageOptions = {
    /** The name of the subreddit to create the page in. */
    subredditName: string;
    /** The name of the page to create. */
    page: string;
    /** The content of the page. */
    content: string;
    /** The reason for creating the page. */
    reason?: string;
};

export declare type CrosspostOptions = CommonSubmitPostOptions & {
    subredditName: string;
    postId: string;
};

export declare type CustomPostType = {
    /** The name of the custom post type */
    name: string;
    /** A description of the custom post type */
    description?: string;
    /** The fixed height of the post, defaults to 'regular' */
    height?: Devvit.Blocks.RootHeight;
    /** A function component that renders the custom post */
    render: Devvit.CustomPostComponent;
};

export declare class CustomWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get images(): WidgetImage[];
    get text(): string;
    get stylesheetUrl(): string;
    get height(): number;
    get css(): string;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<CustomWidget, 'images' | 'text' | 'stylesheetUrl' | 'height' | 'css'>;
}

export declare type Data = {
    [key: string]: any;
};

declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;

export declare type DeleteNotesOptions = Prettify<DeleteNotesRequest>;

export declare class Devvit extends Actor {
    #private;
    /**
     * Home for debug flags, settings, and other information.
     */
    static debug: {
        /**
         * Should debug block rendering in console.log according to the reified JSX/XML output.  Example:
         *
         *     <hstack><text>hi world</text></hstack>
         *
         */
        emitSnapshots: boolean;
        /**
         * Should console.log the state of the app after every event.
         *
         */
        emitState: boolean;
    };
    /**
     * To use certain APIs and features of Devvit, you must enable them using this function.
     *
     * @param config - The configuration object.
     * @param config.http - Enables the HTTP API.
     * @param config.redditAPI - Enables the Reddit API.
     * @param config.kvStore - Enables the Key Value Storage API.
     * @example
     * ```ts
     * Devvit.configure({
     *   http: true,
     *   redditAPI: true,
     *   kvStore: true,
     *   media: true
     * });
     * ```
     */
    static configure(config: Configuration): void;
    /**
     * Add a menu item to the Reddit UI.
     * @param menuItem - The menu item to add.
     * @param menuItem.label - The label of the menu item.
     * @example
     * ```ts
     * Devvit.addMenuItem({
     *   label: 'My Menu Item',
     *   location: 'subreddit',
     *   onPress: (event, context) => {
     *     const location = event.location;
     *     const targetId = event.targetId;
     *     context.ui.showToast(`You clicked on ${location} ${targetId}`);
     *   }
     * });
     * ```
     */
    static addMenuItem(menuItem: MenuItem): void;
    /**
     * Add a custom post type for your app.
     * @param customPostType - The custom post type to add.
     * @param customPostType.name - The name of the custom post type.
     * @param customPostType.description - An optional description.
     * @param customPostType.height - An optional parameter to set post height, defaults to 'regular'.
     * @param customPostType.render - A function or `Devvit.CustomPostComponent` that returns the UI for the custom post.
     * @example
     * ```ts
     * Devvit.addCustomPostType({
     *   name: 'Counter',
     *   description: 'A simple click counter post.',
     *   render: (context) => {
     *     const [counter, setCounter] = context.useState();
     *
     *     return (
     *       <vstack>
     *         <text>{counter}</text>
     *         <button onPress={() => setCounter(counter => counter + 1)}>Click me!</button>
     *       </vstack>
     *     );
     *   }
     * });
     * ```
     */
    static addCustomPostType(customPostType: CustomPostType): void;
    /**
     * Create a form that can be opened from menu items and custom posts.
     * @param form - The form or a function that returns the form.
     * @param onSubmit - The function to call when the form is submitted.
     * @returns A unique key for the form that can used with `ui.showForm`.
     */
    static createForm(form: Form | FormFunction, onSubmit: FormOnSubmitEventHandler): FormKey;
    /**
     * Add a scheduled job type for your app. This will allow you to schedule jobs using the `scheduler` API.
     * @param job - The scheduled job type to add.
     * @param job.name - The name of the scheduled job type.
     * @param job.onRun - The function to call when the scheduled job is run.
     * @example
     * ```ts
     * Devvit.addSchedulerJob({
     *   name: 'checkNewPosts',
     *   onRun: async (event, context) => {
     *     const newPosts = await context.reddit.getNewPosts({ limit: 5 }).all();
     *     for (const post of newPosts) {
     *       if (post.title.includes('bad word')) {
     *         await post.remove();
     *       }
     *     }
     *   }
     * });
     *
     * Devvit.addMenuItem({
     *   label: 'Check for new posts',
     *   location: 'location',
     *   onPress: (event, context) => {
     *     const { scheduler } = context;
     *     const = await scheduler.runJob({
     *       name: 'checkNewPosts',
     *       when: new Date(Date.now() + 5000) // in 5 seconds
     *     });
     *   }
     * });
     * ```
     */
    static addSchedulerJob(job: ScheduledJobType): void;
    /**
     * Add settings that can be configured to customize the behavior of your app. There are two levels of settings: App settings (scope: 'app') and
     * install settings (scope: 'installation' or unspecified scope). Install settings are meant to be configured by the user that installs your app.
     * This is a good place to add anything that a user might want to change to personalize the app (e.g. the default city to show the weather for or a
     * specific sport team that a subreddit follows). Note that these are good for subreddit level customization but not necessarily good for things
     * that might be different for two users in a subreddit (e.g. setting the default city to show the weather for is only useful at a sub level if
     * the sub is for a specific city or region). Install settings can be viewed and configured here: https://developers.reddit.com/r/subreddit-name/apps/app-name.
     * App settings can be accessed and consumed by all installations of the app. This is mainly useful for developer secrets/API keys that your
     * app needs to function. They can only be changed/viewed by you via the CLI (devvit settings set and devvit settings list). This ensures secrets
     * are persisted in an encrypted store and don't get committed in the source code. You should never paste your actual key into any fields passed into
     * Devvit.addSettings - this is merely where you state what your API key's name and description are. You will be able to set the actual value of the key via CLI.
     * Note: setting names must be unique across all settings.
     * @param fields - Fields for the app and installation settings.
     * @example
     * ```ts
     * Devvit.addSettings([
     *   {
     *     type: 'string',
     *     name: 'weather-api-key',
     *     label: 'My weather.com API key',
     *     scope: SettingScope.App,
     *     isSecret: true
     *   },
     *   {
     *     type: 'string',
     *     name: 'Default City',
     *     label: 'Default city to show the weather for by default',
     *     scope: SettingScope.Installation,
     *     onValidate: ({ value }) => {
     *       if (isValidCity(value)) {
     *         return 'You must ender a valid city: ${validCities.join(", ")}';
     *       }
     *     }
     *   },
     *   {
     *     type: 'number',
     *     name: 'Default Forecast Window (in days)',
     *     label: 'The number of days to show for forecast for by default',
     *     scope: SettingScope.Installation,
     *     onValidate: ({ value }) => {
     *       if (value < 10 || value < 1) {
     *         return 'Forecast window must be from 1 to 10 days';
     *       }
     *     }
     *   },
     * ]);
     * ```
     */
    static addSettings(fields: SettingsFormField[]): void;
    /**
     * Add a trigger handler that will be invoked when the given event
     * occurs in a subreddit where the app is installed.
     *
     * @param triggerDefinition - The trigger definition.
     * @param triggerDefinition.event - The event to listen for.
     * @param triggerDefinition.events - The events to listen for.
     * @param triggerDefinition.onEvent - The function to call when the event happens.
     * @example
     * ```ts
     * Devvit.addTrigger({
     *   event: 'PostSubmit',
     *   async onEvent(event, context) {
     *     console.log("a new post was created!")
     *   }
     * });
     *
     * Devvit.addTrigger({
     *   events: ['PostSubmit', 'PostReport'],
     *   async onEvent(event, context){
     *     if (event.type === 'PostSubmit') {
     *       console.log("a new post was created!")
     *     } else if (event.type === 'PostReport') {
     *       console.log("a post was reported!")
     *     }
     *   }
     * });
     * ```
     */
    static addTrigger(triggerDefinition: PostDeleteDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: PostSubmitDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: PostUpdateDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: PostReportDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: PostCreateDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: PostFlairUpdateDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: CommentDeleteDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: CommentSubmitDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: CommentUpdateDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: CommentCreateDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: CommentReportDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: AppInstallDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: AppUpgradeDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: ModActionDefinition): typeof Devvit;
    static addTrigger(triggerDefinition: ModMailDefinition): typeof Devvit;
    static addTrigger<Event extends TriggerEvent>(triggerDefinition: MultiTriggerDefinition<Event>): typeof Devvit;
}

export declare namespace Devvit {
    export type Fragment = JSX.Fragment;
    export type ElementChildren = JSX.Element | JSX.Children | undefined;
    export type StringChild = Fragment | string | number;
    export type StringChildren = StringChild | (StringChild | StringChild[])[] | undefined;
    export function createElement(type: Blocks.IntrinsicElementsType, props: {} | undefined, ...children: JSX.Children[]): BlockElement;
    /** The current app context of the event or render. */
    export type Context = ContextAPIClients & BaseContext;
    export type BlockComponentProps<P = {}> = P & {
        children?: JSX.Children;
    };
    export type BlockComponent<P = {}> = (props: BlockComponentProps<P>, context: Context) => JSX.Element;
    export type CustomPostComponent = (context: Context) => JSX.Element;
    export namespace Blocks {
        export interface IntrinsicElements {
            blocks: Devvit.Blocks.RootProps;
            hstack: Devvit.Blocks.StackProps;
            vstack: Devvit.Blocks.StackProps;
            zstack: Devvit.Blocks.StackProps;
            text: Devvit.Blocks.TextProps;
            button: Devvit.Blocks.ButtonProps;
            image: Devvit.Blocks.ImageProps;
            spacer: Devvit.Blocks.SpacerProps;
            icon: Devvit.Blocks.IconProps;
            avatar: Devvit.Blocks.AvatarProps;
            fullsnoo: Devvit.Blocks.FullSnooProps;
            animation: Devvit.Blocks.AnimationProps;
            webview: Devvit.Blocks.WebViewProps;
        }
        export type IntrinsicElementsType = keyof IntrinsicElements;
        export type SizePixels = `${number}px`;
        export type SizePercent = `${number}%`;
        export type SizeString = SizePixels | SizePercent | number;
        export type Alignment = `${VerticalAlignment}` | `${HorizontalAlignment}` | `${VerticalAlignment} ${HorizontalAlignment}` | `${HorizontalAlignment} ${VerticalAlignment}`;
        export type AnimationDirection = 'forward' | 'backward';
        export type AnimationLoop = 'repeat' | 'bounce';
        export type AnimationType = 'lottie';
        export type AvatarBackground = 'light' | 'dark';
        export type AvatarFacing = 'left' | 'right';
        export type AvatarSize = 'xxsmall' | 'xsmall' | 'small' | 'medium' | 'large' | 'xlarge' | 'xxlarge' | 'xxxlarge';
        export type ButtonAppearance = 'secondary' | 'primary' | 'plain' | 'bordered' | 'media' | 'destructive' | 'caution' | 'success';
        export type ButtonSize = 'small' | 'medium' | 'large';
        export type ColorString = string;
        export type ContainerBorderWidth = Thickness;
        export type ContainerCornerRadius = 'none' | 'small' | 'medium' | 'large' | 'full';
        export type ContainerGap = 'none' | 'small' | 'medium' | 'large';
        export type ContainerPadding = 'none' | 'xsmall' | 'small' | 'medium' | 'large';
        export type FullSnooSize = 'xsmall' | 'small' | 'medium' | 'large' | 'xlarge' | 'xxlarge';
        export type HorizontalAlignment = 'start' | 'center' | 'end';
        export type IconSize = 'xsmall' | 'small' | 'medium' | 'large';
        export type ImageResizeMode = 'none' | 'fit' | 'fill' | 'cover' | 'scale-down';
        export type SpacerSize = 'xsmall' | 'small' | 'medium' | 'large';
        export type SpacerShape = 'invisible' | 'thin' | 'square';
        export type TextOutline = Thickness;
        export type TextSize = 'xsmall' | 'small' | 'medium' | 'large' | 'xlarge' | 'xxlarge';
        export type TextStyle = 'body' | 'metadata' | 'heading';
        export type TextWeight = 'regular' | 'bold';
        export type TextOverflow = 'clip' | 'ellipsis';
        export type Thickness = 'none' | 'thin' | 'thick';
        export type VerticalAlignment = 'top' | 'middle' | 'bottom';
        export type RootHeight = 'regular' | 'tall';
        export type BaseProps = {
            width?: SizeString;
            height?: SizeString;
            minWidth?: SizeString;
            minHeight?: SizeString;
            maxWidth?: SizeString;
            maxHeight?: SizeString;
            grow?: boolean;
        };
        export type OnPressEvent = {
            state?: Data;
        };
        export type OnPressEventHandler = (event: OnPressEvent) => void | Promise<void>;
        export type Actionable = {
            onPress?: OnPressEventHandler | undefined;
        };
        export type HasElementChildren = {
            children?: Devvit.ElementChildren;
        };
        export type HasStringChildren = {
            children?: Devvit.StringChildren;
        };
        export type RootProps = HasElementChildren & {
            height?: Devvit.Blocks.RootHeight | undefined;
        };
        export type StackProps = BaseProps & HasElementChildren & Actionable & {
            reverse?: boolean | undefined;
            alignment?: Alignment;
            padding?: ContainerPadding | undefined;
            gap?: ContainerGap | undefined;
            border?: ContainerBorderWidth | undefined;
            borderColor?: ColorString | undefined;
            lightBorderColor?: ColorString | undefined;
            darkBorderColor?: ColorString | undefined;
            cornerRadius?: ContainerCornerRadius | undefined;
            backgroundColor?: ColorString | undefined;
            lightBackgroundColor?: ColorString | undefined;
            darkBackgroundColor?: ColorString | undefined;
        };
        export type TextProps = BaseProps & HasStringChildren & Actionable & {
            size?: TextSize | undefined;
            weight?: TextWeight | undefined;
            color?: ColorString | undefined;
            lightColor?: ColorString | undefined;
            darkColor?: ColorString | undefined;
            alignment?: Alignment | undefined;
            outline?: TextOutline | undefined;
            style?: TextStyle | undefined;
            selectable?: boolean | undefined;
            wrap?: boolean | undefined;
            overflow?: TextOverflow | undefined;
        };
        export type ButtonProps = BaseProps & HasStringChildren & Actionable & {
            icon?: IconName | undefined;
            size?: ButtonSize | undefined;
            appearance?: ButtonAppearance | undefined;
            textColor?: ColorString | undefined;
            lightTextColor?: ColorString | undefined;
            darkTextColor?: ColorString | undefined;
            disabled?: boolean | undefined;
        };
        export type ImageProps = BaseProps & Actionable & {
            url: string;
            imageWidth: SizePixels | number;
            imageHeight: SizePixels | number;
            description?: string | undefined;
            resizeMode?: ImageResizeMode | undefined;
        };
        export type SpacerProps = BaseProps & {
            size?: SpacerSize | undefined;
            shape?: SpacerShape | undefined;
        };
        export type IconProps = BaseProps & HasStringChildren & Actionable & {
            name: IconName;
            color?: ColorString | undefined;
            lightColor?: ColorString | undefined;
            darkColor?: ColorString | undefined;
            size?: IconSize | undefined;
        };
        export type AvatarProps = BaseProps & Actionable & {
            thingId: string;
            facing?: AvatarFacing | undefined;
            size?: AvatarSize | undefined;
            background?: AvatarBackground | undefined;
        };
        export type FullSnooProps = BaseProps & Actionable & {
            userId: string;
            facing?: AvatarFacing | undefined;
            size?: FullSnooSize | undefined;
        };
        export type AnimationProps = BaseProps & Actionable & {
            url: string;
            imageWidth: SizePixels | number;
            imageHeight: SizePixels | number;
            type?: AnimationType | undefined;
            loop?: boolean | undefined;
            loopMode?: AnimationLoop | undefined;
            autoplay?: boolean | undefined;
            speed?: number | undefined;
            direction?: AnimationDirection | undefined;
        };
        export type WebViewProps = BaseProps & {
            url: string;
        };
    }
}

export declare type Dispatch<A> = (value: A) => void;

export declare type EditCommentOptions = CommentSubmissionOptions;

export declare type EditFlairTemplateOptions = CreateFlairTemplateOptions & {
    id: string;
};

/**
 * @mixin
 */
declare type EmbedContainer<Context> = {
    /**
     * Append an embedded iframe
     * @param opts {@link EmbedOptions}
     */
    embed(opts: EmbedOptions): Context;
};

declare type EmbedOptions = {
    /** Destination URL when the embed is clicked */
    sourceUrl: string;
    /** URL to load in the embedded iframe */
    contentUrl: string;
    width: number;
    height: number;
};

export declare class Flair {
    #private;
}

export declare type FlairBackgroundColor = `#${string}` | 'transparent';

export declare type FlairSettings = {
    enabled: boolean;
    usersCanAssign: boolean;
};

export declare class FlairTemplate {
    #private;
    /** The flair template's ID */
    get id(): string;
    /** The flair template's text */
    get text(): string;
    /** The flair template's text color. Either 'dark' or 'light'. */
    get textColor(): FlairTextColor;
    /** The flair template's background color. Either 'transparent' or a hex color code. e.g. #FFC0CB */
    get backgroundColor(): FlairBackgroundColor;
    /** The flair template's allowable content. Either 'all', 'emoji', or 'text'. */
    get allowableContent(): AllowableFlairContent;
    /** Is the flair template only available to moderators? */
    get modOnly(): boolean;
    /** The flair template's maximum number of emojis. */
    get maxEmojis(): number;
    /** Does the flair template allow users to edit their flair? */
    get allowUserEdits(): boolean;
    /** Delete this flair template */
    delete(): Promise<void>;
    /** Edit this flair template */
    edit(options: Partial<Omit<EditFlairTemplateOptions, 'id' | 'subredditName'>>): Promise<FlairTemplate>;
}

export declare type FlairTextColor = 'light' | 'dark';

export declare enum FlairType {
    User = "USER_FLAIR",
    Post = "LINK_FLAIR"
}

export declare type Form = {
    /** The fields that will be displayed in the form */
    fields: FormField[];
    /** An optional title for the form */
    title?: string;
    /** An optional description for the form */
    description?: string;
    /** An optional label for the submit button */
    acceptLabel?: string;
    /** An optional label for the cancel button */
    cancelLabel?: string;
};

declare type FormatRange = [
FormattingSpecification,
number,
number
];

declare type FormattingSpecification = number;

export declare type FormDefinition = {
    /** A form or a function that returns a form */
    form: Form | FormFunction;
    /** A callback that will be invoked when the form is submitted */
    onSubmit: FormOnSubmitEventHandler;
};

export declare type FormField = StringField | ParagraphField | NumberField | BooleanField | SelectField | FormFieldGroup;

/** A grouping of fields */
export declare type FormFieldGroup = {
    type: 'group';
    /** The label of the group that will be displayed to the user */
    label: string;
    /** The fields that will be displayed in the group */
    fields: FormField[];
    /** An optional help text that will be displayed below the group */
    helpText?: string | undefined;
};

/**
 * A function that returns a form. You can use this to dynamically generate a form.
 * @example
 * ```ts
 * const formKey = Devvit.createForm((data) => ({
 *   fields: data.fields,
 *   title: data.title,
 * }), callback);
 *
 * ...
 *
 * ui.showForm(formKey, {
 *  fields: [{ type: 'string', name: 'title', label: 'Title' }]
 *  title: 'My dynamic form'
 * });
 * ```
 * */
export declare type FormFunction = (data: Data) => Form;

/** A unique key generated by `Devvit.createForm` or the `useForm` hook. */
export declare type FormKey = `form.${number}` | `form.hook.${string}.${number}`;

export declare type FormOnSubmitEvent = {
    /** The form values that were submitted */
    values: FormValues;
};

export declare type FormOnSubmitEventHandler = (
/** The event object containing the results of the form submission */
event: FormOnSubmitEvent, 
/** The current app context of the form submission event */
context: Devvit.Context) => void | Promise<void>;

export declare type FormValues = Data;

export declare type GetCommentsByUserOptions = {
    username: string;
    sort?: 'hot' | 'new' | 'top' | 'controversial';
    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
    pageSize?: number;
    limit?: number;
    after?: string;
    before?: string;
};

export declare type GetCommentsOptions = {
    postId: string;
    commentId?: string | undefined;
    depth?: number;
    pageSize?: number;
    limit?: number;
    sort?: CommentSort;
};

export declare type GetConversationResponse = {
    conversation?: ConversationData;
    /** If the conversation is with another subreddit, what subreddit we are communicating with. */
    participantSubreddit?: ParticipantSubreddit;
} & WithUserData;

export declare type GetConversationsRequest = {
    /** modmail conversation id */
    after?: string;
    /** array of subreddit names */
    subreddits?: string[];
    /** an integer between 1 and 100 (default: 25) */
    limit?: number;
    /**
     * Sort by:
     * - `recent` - Order by whenever anyone last updated the conversation, mod or participant
     * - `mod` - Order by the last time a mod updated the conversation
     * - `user` - Order by the last time a participant user updated the conversation
     * - `unread` - Order by the most recent unread message in the conversation for this mod
     */
    sort?: 'recent' | 'mod' | 'user' | 'unread';
    /**
     * Filter by conversation state
     *
     * A conversation can be in more than one state.
     * For example, a conversation may be both 'highlighted' and 'inprogress'.
     */
    state?: ConversationStateFilter;
};

export declare type GetConversationsResponse = {
    /**
     * Conversations key-value map
     */
    conversations: {
        [id: string]: ConversationData;
    };
    viewerId?: string;
};

export declare type GetHotPostsOptions = GetPostsOptions & {
    location?: 'GLOBAL' | 'US' | 'AR' | 'AU' | 'BG' | 'CA' | 'CL' | 'CO' | 'HR' | 'CZ' | 'FI' | 'FR' | 'DE' | 'GR' | 'HU' | 'IS' | 'IN' | 'IE' | 'IT' | 'JP' | 'MY' | 'MX' | 'NZ' | 'PH' | 'PL' | 'PT' | 'PR' | 'RO' | 'RS' | 'SG' | 'ES' | 'SE' | 'TW' | 'TH' | 'TR' | 'GB' | 'US_WA' | 'US_DE' | 'US_DC' | 'US_WI' | 'US_WV' | 'US_HI' | 'US_FL' | 'US_WY' | 'US_NH' | 'US_NJ' | 'US_NM' | 'US_TX' | 'US_LA' | 'US_NC' | 'US_ND' | 'US_NE' | 'US_TN' | 'US_NY' | 'US_PA' | 'US_CA' | 'US_NV' | 'US_VA' | 'US_CO' | 'US_AK' | 'US_AL' | 'US_AR' | 'US_VT' | 'US_IL' | 'US_GA' | 'US_IN' | 'US_IA' | 'US_OK' | 'US_AZ' | 'US_ID' | 'US_CT' | 'US_ME' | 'US_MD' | 'US_MA' | 'US_OH' | 'US_UT' | 'US_MO' | 'US_MN' | 'US_MI' | 'US_RI' | 'US_KS' | 'US_MT' | 'US_MS' | 'US_SC' | 'US_KY' | 'US_OR' | 'US_SD';
};

export declare function getModerationLog(options: GetModerationLogOptions, metadata: Metadata | undefined): Listing<ModAction>;

export declare type GetModerationLogOptions = ListingFetchOptions & {
    /** Subreddit name */
    subredditName: string;
    /** (optional) A moderator filter. Accepts an array of usernames */
    moderatorUsernames?: string[];
    /** Type of the Moderator action */
    type?: ModActionType;
};

declare type GetModerationLogOptions_2 = Omit<GetModerationLogOptions, 'subredditName'>;

export declare type GetModNotesOptions = Prettify<Pick<GetNotesRequest, 'subreddit' | 'user'> & {
    filter?: ModNoteType;
} & Pick<ListingFetchOptions, 'limit' | 'before'>>;

export declare type GetPageRevisionsOptions = {
    /** The name of the subreddit the page is in. */
    subredditName: string;
    /** The name of the page to get revisions for. */
    page: string;
    /** The number of revisions to get per request. */
    pageSize?: number;
    /** The maximum number of revisions to get. */
    limit?: number;
    /** The ID of the revision to start at. */
    after?: string;
};

export declare type GetPostsByUserOptions = {
    username: string;
    sort?: 'hot' | 'new' | 'top' | 'controversial';
    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
    pageSize?: number;
    limit?: number;
    after?: string;
    before?: string;
};

export declare type GetPostsOptions = ListingFetchOptions & {
    subredditName?: string;
};

export declare type GetPostsOptionsWithTimeframe = GetPostsOptions & {
    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
};

export declare type GetPrivateMessagesOptions = Prettify<{
    type?: 'inbox' | 'unread' | 'sent';
} & ListingFetchOptions>;

export declare type GetSortedPostsOptions = GetPostsOptionsWithTimeframe & {
    sort: 'top' | 'controversial';
};

export declare type GetSubredditUsersByTypeOptions = ListingFetchOptions & {
    subredditName: string;
    type: 'banned' | 'muted' | 'wikibanned' | 'contributors' | 'wikicontributors' | 'moderators';
    username?: string;
};

declare type GetSubredditUsersOptions = Omit<GetSubredditUsersByTypeOptions, 'type'>;

export declare type GetUserFlairBySubredditOptions = UserFlairPageOptions & {
    /** The subreddit associated with the flair being retrieved. */
    subreddit: string;
    /** The username associated with the flair being retrieved. */
    name?: string;
};

export declare type GetUserFlairBySubredditResponse = {
    /** The list of user flair */
    users: UserFlair[];
    /** The user id of the last user flair in this slice. Its presence indicates
     * that there are more items that can be fetched. Pass this into the "after" parameter
     * in the next call to get the next slice of data  */
    next?: string;
    /** The user id of the first user flair in this slice. Its presence indicates
     * that there are items before this item that can be fetched. Pass this into the "before" parameter
     * in the next call to get the previous slice of data  */
    prev?: string;
};

export declare type GetUserFlairOptions = UserFlairPageOptions & {
    /** If provide the method will return the flairs for the provided users, if not provided
     * it will return a list of all users assigned flairs in the subreddit */
    usernames?: string[];
};

export declare type GetUserOverviewOptions = {
    username: string;
    sort?: 'hot' | 'new' | 'top' | 'controversial';
    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
    pageSize?: number;
    limit?: number;
    after?: string;
    before?: string;
};

declare type GetUsersOptions = Omit<GetSubredditUsersByTypeOptions, 'subredditName' | 'type'>;

/**
 * @mixin
 */
declare type HeadingContainer<Context> = {
    /**
     * Append a Heading
     * @param opts {@link HeadingOptions}
     * @param cb scoped callback to add child elements to this Heading
     */
    heading(opts: HeadingOptions, cb: (heading: HeadingContext) => void): Context;
};

/**
 * @borrows RawTextContainer
 * @borrows LinkContainer
 */
declare interface HeadingContext extends RawTextContainer<HeadingContext>, LinkContainer<HeadingContext> {
}

declare type HeadingLevel = 1 | 2 | 3 | 4 | 5 | 6;

declare type HeadingOptions = {
    /**
     * The depth for this heading (such as <h1>, <h2>, <h3>)
     * @see {@link HeadingLevel}
     */
    level: HeadingLevel;
};

/**
 * @mixin
 */
declare type HorizontalRuleContainer<Context> = {
    /**
     * Append a Horizontal Rule
     */
    horizontalRule(): Context;
};

export declare type IconName = `${AllIconName}` | `${AllIconName}-outline` | `${AllIconName}-fill`;

declare type Image = {
    e: typeof IMAGE_ELEMENT;
    id: MediaAssetId;
    c?: string;
    o?: ObfuscationReason;
};

declare const IMAGE_ELEMENT = "img";

/**
 * @mixin
 */
declare type ImageContainer<Context> = {
    /**
     * Append an Image
     * @param opts {@link ImageOptions}
     */
    image(opts: ImageOptions): Context;
    /**
     * Append an Animated Image
     * @param opts {@link ImageOptions}
     */
    animatedImage(opts: ImageOptions): Context;
};

/**
 * @borrows MediaOptions
 */
declare type ImageOptions = MediaOptions;

export declare class ImageWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get images(): WidgetImage[];
    toJSON(): ReturnType<Widget['toJSON']> & Pick<ImageWidget, 'images'>;
}

export declare type InternalSetPostFlairOptions = SetFlairOptions & {
    postId: T3ID;
};

declare type InviteModeratorOptions = {
    /** The name of the subreddit to invite the user to moderate */
    subredditName: string;
    /** The name of the user to invite as a moderator */
    username: string;
    /** The permissions to grant the user */
    permissions?: ModeratorPermission[];
};

export declare type JSONArray = JSONValue[];

export declare type JSONObject = {
    [key: string]: JSONValue;
};

export declare type JSONPrimitive = boolean | null | number | string;

/**
 * Any JSON type. Ie, a string, number, boolean, null, an array of these JSON
 * types, or an object with JSON type values, recursively.
 *
 * This type is often used to type-check attempts to serialize and deserialize
 * classes, functions, and other _JavaScript_-only types that cannot be
 * represented losslessly in plain JSON.
 *
 * @see https://github.com/microsoft/TypeScript/issues/1897
 * @see https://www.json.org
 */
export declare type JSONValue = JSONPrimitive | JSONArray | JSONObject;

export declare type KVStore = {
    /**
     * Retrieves a value from the store at the given key
     */
    get<T extends JSONValue = JSONValue>(key: string): Promise<T | undefined>;
    /**
     * Assigns a value to a key in the store
     */
    put(key: string, value: JSONValue): Promise<void>;
    /**
     * Deletes a key from the store if present
     */
    delete(key: string): Promise<void>;
    /**
     * Returns a list of keys in the store
     */
    list(): Promise<string[]>;
};

declare type LineBreak = {
    e: typeof LINEBREAK_ELEMENT;
};

declare const LINEBREAK_ELEMENT = "br";

/**
 * @mixin
 */
declare type LineBreakContainer<Context> = {
    /**
     * Append a Line Break
     */
    linebreak(): Context;
};

declare type Link = {
    e: typeof LINK_ELEMENT;
    t: string;
    u: UrlString;
    f?: FormatRange[];
    a?: string;
};

declare const LINK_ELEMENT = "link";

/**
 * @mixin
 */
declare type LinkContainer<Context> = RedditLinkContainer<Context> & {
    /**
     * Append a Link
     * @param opts {@link LinkOptions}
     */
    link(opts: LinkOptions): Context;
};

export declare type LinkFlair = {
    /**
     * One of: "text", "richtext"
     */
    type?: string;
    /**
     * Flair template ID to use when rendering this flair
     */
    templateId?: string;
    /**
     * Plain text representation of the flair
     */
    text?: string;
    /**
     * RichText object representation of the flair
     */
    richtext: {
        /**
         * Enum of element types.  e.g. emoji or text
         */
        elementType?: string;
        /**
         * Text to show up in the flair, e.g. "Need Advice"
         */
        text?: string;
        /**
         * Emoji references, e.g. ":rainbow:"
         */
        emojiRef?: string;
        /**
         * url string, e.g. "https://reddit.com/"
         */
        url?: string;
    }[];
    /**
     * Custom CSS classes from the subreddit's stylesheet to apply to the flair if rendered as HTML
     */
    cssClass?: string;
    /**
     * One of: "light", "dark"
     */
    textColor?: string;
    /**
     * Flair background color as a hex color string (# prefixed)
     * @example "#FF4500"
     */
    backgroundColor?: string;
};

/**
 * @borrows TextOptions
 */
declare type LinkOptions = TextOptions & {
    /** Destination URL */
    url: string;
    /** Tooltip text shown when the link is focused */
    tooltip?: string;
};

/**
 * @mixin
 */
declare type ListContainer<Context> = {
    /**
     * Append a List
     * @param opts {@link ListOptions}
     * @param cb scoped callback to add child elements to this List
     */
    list(opts: ListOptions, cb: (list: ListContext) => void): Context;
};

/**
 * @borrows ListItemContainer
 */
declare interface ListContext extends ListItemContainer<ListContext> {
}

export declare interface Listing<T> {
}

export declare class Listing<T> {
    #private;
    pageSize: number;
    limit: number;
    children: T[];
    get hasMore(): boolean;
    [Symbol.asyncIterator](): AsyncIterator<T>;
    setMore(more: MoreObject | undefined): void;
    preventInitialFetch(): void;
    all(): Promise<T[]>;
    get(count: number): Promise<T[]>;
}

export declare type ListingFetchOptions = {
    after?: string;
    before?: string;
    limit?: number;
    pageSize?: number;
    more?: MoreObject;
};

export declare type ListingFetchResponse<T> = {
    children: T[];
    before?: string;
    after?: string;
    more?: MoreObject;
};

/**
 * @mixin
 */
declare type ListItemContainer<Context> = {
    /**
     * Append a List Item to a List
     * @param cb scoped callback to add child elements to this List Item
     */
    item(cb: (item: ListItemContext) => void): Context;
};

/**
 * @borrows BlockQuoteContainer
 * @borrows CodeBlockContainer
 * @borrows HeadingContainer
 * @borrows HorizontalRuleContainer
 * @borrows ListContainer
 * @borrows ParagraphContainer
 * @borrows TableContainer
 */
declare interface ListItemContext extends BlockQuoteContainer<ListItemContext>, CodeBlockContainer<ListItemContext>, HeadingContainer<ListItemContext>, HorizontalRuleContainer<ListItemContext>, ListContainer<ListItemContext>, ParagraphContainer<ListItemContext>, TableContainer<ListItemContext> {
}

declare type ListOptions = {
    /** Whether to use numbers or dots as list item markers */
    ordered: boolean;
};

export declare type MediaAsset = {
    mediaId: string;
    mediaUrl: string;
};

declare type MediaAssetId = string;

declare type MediaOptions = {
    /** Reddit media ID provided after uploading media */
    mediaId: string;
    /** Media description */
    caption?: string;
    /**
     * If provided, the content should be blurred by default for the provided reason
     * @see {@link ObfuscationReason}
     */
    blur?: ObfuscationReason;
};

export declare type MediaPlugin = {
    /**
     * Uploads media from external URL to Reddit
     *
     * @param options - URL and media type (image, gif, video)
     * @returns A Promise that resolves to a MediaAsset object.
     * @example
     * ```ts
     *  const response = await context.media.upload({
     *    url: "https://media2.giphy.com/media/xTiN0CNHgoRf1Ha7CM/giphy.gif",
     *    type: "gif"
     *  });
     *  await context.reddit.submitPost(
     *     {
     *       subredditName: subreddit.name,
     *       title: 'Hello World with Media',
     *       richtext: new RichTextBuilder()
     *            .image({mediaId: response.mediaId})
     *            .codeBlock({}, (cb) => cb.rawText('This post was created from a Devvit App'))
     *     }
     *   );
     * ```
     */
    upload(opts: UploadMediaOptions): Promise<MediaAsset>;
};

export declare type MenuItem = {
    /** The label of the menu item */
    label: string;
    /** An optional description for the menu item */
    description?: string;
    /** The location(s) where the menu item should be displayed */
    location: MenuItemLocation | MenuItemLocation[];
    /** The user type(s) that the menu item should be displayed for */
    forUserType?: MenuItemUserType | MenuItemUserType[];
    /** A function that is called when the menu item is pressed */
    onPress: (event: MenuItemOnPressEvent, context: Devvit.Context) => void | Promise<void>;
};

export declare type MenuItemLocation = 'subreddit' | 'post' | 'comment';

export declare type MenuItemOnPressEvent = {
    /** The location where the menu item was pressed */
    location: MenuItemLocation;
    /**
     * The ID of subreddit, post, or comment that the menu item was pressed;
     * includes Thing ID prefix:
     * - t1_ - comment
     * - t5_ - subreddit
     * - t3_ - post
     */
    targetId: string;
};

export declare type MenuItemUserType = 'loggedOut' | 'member' | 'moderator';

export declare type MessageData = {
    /** Message ID */
    id?: string;
    /** Message body */
    body?: string;
    /** When was created */
    date?: string;
    author?: Participant;
    isInternal?: boolean;
    bodyMarkdown?: string;
    participatingAs?: string;
};

export declare interface ModAction {
    id: string;
    type: ModActionType;
    moderatorName: string;
    moderatorId: string;
    createdAt: Date;
    subredditName: string;
    subredditId: string;
    description?: string;
    details?: string;
    target?: ModActionTarget;
}

export declare type ModActionData = {
    /** Action id */
    id?: string;
    /** Type of the action */
    actionType: ModMailActionType;
    /** When the action happened */
    date?: string;
    /** Action author */
    author?: {
        /** User id  */
        id?: number;
        /** User name */
        name?: string;
        isMod?: boolean;
        isAdmin?: boolean;
        isHidden?: boolean;
        isDeleted?: boolean;
    };
};

export declare type ModActionDefinition = {
    event: ModActionTrigger;
    onEvent: TriggerOnEventHandler<protos.ModAction>;
};

export declare type ModActionTarget = {
    id: string;
    author?: string;
    body?: string;
    permalink?: string;
    title?: string;
};

/** The event name for when a moderator action is recorded to a subreddit's modlog */
export declare type ModActionTrigger = 'ModAction';

export declare type ModActionType = 'banuser' | 'unbanuser' | 'spamlink' | 'removelink' | 'approvelink' | 'spamcomment' | 'removecomment' | 'approvecomment' | 'addmoderator' | 'showcomment' | 'invitemoderator' | 'uninvitemoderator' | 'acceptmoderatorinvite' | 'removemoderator' | 'addcontributor' | 'removecontributor' | 'editsettings' | 'editflair' | 'distinguish' | 'marknsfw' | 'wikibanned' | 'wikicontributor' | 'wikiunbanned' | 'wikipagelisted' | 'removewikicontributor' | 'wikirevise' | 'wikipermlevel' | 'ignorereports' | 'unignorereports' | 'setpermissions' | 'setsuggestedsort' | 'sticky' | 'unsticky' | 'setcontestmode' | 'unsetcontestmode' | 'lock' | 'unlock' | 'muteuser' | 'unmuteuser' | 'createrule' | 'editrule' | 'reorderrules' | 'deleterule' | 'spoiler' | 'unspoiler' | 'modmail_enrollment' | 'community_styling' | 'community_widgets' | 'markoriginalcontent' | 'collections' | 'events' | 'create_award' | 'disable_award' | 'delete_award' | 'enable_award' | 'mod_award_given' | 'hidden_award' | 'add_community_topics' | 'remove_community_topics' | 'create_scheduled_post' | 'edit_scheduled_post' | 'delete_scheduled_post' | 'submit_scheduled_post' | 'edit_post_requirements' | 'invitesubscriber' | 'submit_content_rating_survey' | 'adjust_post_crowd_control_level' | 'enable_post_crowd_control_filter' | 'disable_post_crowd_control_filter' | 'deleteoverriddenclassification' | 'overrideclassification' | 'reordermoderators' | 'snoozereports' | 'unsnoozereports' | 'addnote' | 'deletenote' | 'addremovalreason' | 'createremovalreason' | 'updateremovalreason' | 'deleteremovalreason' | 'reorderremovalreason' | 'dev_platform_app_changed' | 'dev_platform_app_disabled' | 'dev_platform_app_enabled' | 'dev_platform_app_installed' | 'dev_platform_app_uninstalled';

export declare type ModeratorPermission = 'all' | 'wiki' | 'posts' | 'access' | 'mail' | 'config' | 'flair' | 'chat_operator' | 'chat_config';

/**
 * You must have the `modLog` enabled in `Devvit.configure` to use this client.
 *
 * @example
 * ```ts
 * Devvit.configure({
 *   modLog: true
 * });
 * ```
 */
declare type ModLog = {
    /**
     * Adds a record to the Mod log of the current subreddit
     *
     * @example
     * ```ts
     *
     * await context.modLog.add({
     *   action: 'approvecomment',
     *   target: commentId,
     *   note: "Banned for breaking the rules"
     * });
     * ```
     */
    add(options: Readonly<ModLogAddOptions>): Promise<void>;
};

declare type ModLogAddOptions = {
    action: ModActionType;
    details?: string | undefined;
    description?: string | undefined;
    note?: string | undefined;
    target?: string | undefined;
};

declare class ModLogClient implements ModLog {
    #private;
    constructor(metadata: Metadata);
    add(options: Readonly<ModLogAddOptions>): Promise<void>;
}

export declare type ModLogOptions<T extends AboutSubredditTypes> = Omit<AboutSubredditHelperOptions<T>, 'location'>;

/**
 * An ActionType describes a particular logged action within a conversation. For example,
 * if a mod highlights a conversation, a ModerationAction record with the type `Highlighted`
 * would be created.
 */
export declare enum ModMailActionType {
    Highlighted = "Highlighted",
    Unhighlighted = "Unhighlighted",
    Archived = "Archived",
    Unarchived = "Unarchived",
    ReportedToAdmins = "ReportedToAdmins",
    Muted = "Muted",
    Unmuted = "Unmuted",
    Banned = "Banned",
    Unbanned = "Unbanned",
    Approved = "Approved",
    Disapproved = "Disapproved",
    Filtered = "Filtered",
    Unfiltered = "Unfiltered"
}

export declare enum ModMailConversationState {
    New = "New",
    InProgress = "InProgress",
    Archived = "Archived",
    Appeals = "Appeals",
    JoinRequests = "JoinRequests",
    Filtered = "Filtered"
}

export declare type ModMailDefinition = {
    event: ModMailTrigger;
    onEvent: TriggerOnEventHandler<protos.ModMail>;
};

/**
 * Class providing the methods for working with Mod Mail
 */
export declare class ModMailService {
    #private;
    /**
     * Marks all conversations read for a particular conversation state within the passed list of subreddits.
     *
     * @param subreddits Array of subreddit names
     * @param state One of the possible conversation states ('all' to read all conversations)
     *
     * @returns conversationIds
     *
     * @example
     * ```ts
     * const conversationIds = await reddit.modMail.bulkReadConversations(
     *   ['askReddit', 'myAwesomeSubreddit'],
     *   'filtered'
     * );
     * ```
     */
    bulkReadConversations(subreddits: string[], state: ConversationStateFilter): Promise<string[]>;
    /**
     * Get conversations for a logged in user or subreddits
     *
     * @param params.after id of a modmail
     * @param params.subreddits array of subreddit names
     * @param params.limit an integer between 1 and 100 (default: 25)
     * @param params.sort one of (recent, mod, user, unread)
     * @param params.state One of the possible conversation states ('all' to read all conversations)
     *
     * @example
     * ```ts
     * const {viewerId, conversations} = await reddit.modMail.getConversations({
     *   after: 'abcdef',
     *   limit: 42
     * });
     *
     * const arrayOfConversations = Object.values(conversations);
     * ```
     */
    getConversations(params: GetConversationsRequest): Promise<GetConversationsResponse>;
    /**
     * Returns all messages, mod actions and conversation metadata for a given conversation id
     *
     * @param params.conversationId id of a modmail conversation
     * @param params.markRead should be marked as read (default: false)
     *
     * @example
     * ```ts
     * const { conversation, messages, modActions, user } = await reddit.modMail.getConversation({ conversationId: 'abcdef', markRead: true });
     * ```
     */
    getConversation(params: {
        /** a modmail conversation id */
        conversationId: string;
        /** mark read? */
        markRead?: boolean;
    }): Promise<GetConversationResponse>;
    /**
     * Returns a list of Subreddits that the user moderates with mail permission
     *
     * @example
     * ```ts
     * const subredditsData = await reddit.modMail.getSubreddits();
     *
     * for (const subreddit of Object.values(subreddits)) {
     *   console.log(subreddit.id);
     *   console.log(subreddit.name);
     * }
     * ```
     */
    getSubreddits(): Promise<{
        [key: string]: SubredditData;
    }>;
    /**
     * Creates a new conversation for a particular SR.
     *
     * This endpoint will create a ModmailConversation object
     * as well as the first ModmailMessage within the ModmailConversation object.
     *
     * @note
     * Note on {param.to}:
     * The to field for this endpoint is somewhat confusing. It can be:
     * - A User, passed like "username" or "u/username"
     * - A Subreddit, passed like "r/subreddit"
     * - null, meaning an internal moderator discussion
     *
     * In this way to is a bit of a misnomer in modmail conversations.
     * What it really means is the participant of the conversation who is not a mod of the subreddit.
     *
     * @param params.body markdown text
     * @param params.isAuthorHidden is author hidden? (default: false)
     * @param params.subredditName subreddit name
     * @param params.subject subject of the conversation. max 100 characters
     * @param params.to a user (e.g. u/username), a subreddit (e.g. r/subreddit) or null
     *
     * @example
     * ```ts
     * const { conversation, messages, modActions } = await reddit.modMail.createConversation({
     *   subredditName: 'askReddit',
     *   subject: 'Test conversation',
     *   body: 'Lorem ipsum sit amet',
     *   to: null,
     * });
     * ```
     */
    createConversation(params: {
        body: string;
        isAuthorHidden?: boolean;
        subredditName: string;
        subject: string;
        to?: string | null;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Creates a new message for a particular conversation.
     *
     * @param params.conversationId Id of a modmail conversation
     * @param params.body markdown text
     * @param params.isInternal is internal message? (default: false)
     * @param params.isAuthorHidden is author hidden? (default: false)
     *
     * @example
     * ```ts
     * await reddit.modMail.reply({
     *   body: 'Lorem ipsum sit amet',
     *   conversationId: 'abcdef',
     * });
     * ```
     */
    reply(params: {
        body: string;
        isAuthorHidden?: boolean;
        isInternal?: boolean;
        conversationId: string;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Marks a conversation as highlighted.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.highlightConversation('abcdef');
     * ```
     */
    highlightConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Removes a highlight from a conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unhighlightConversation('abcdef');
     * ```
     */
    unhighlightConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Marks a conversation as archived
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.archive('abcdef');
     * ```
     */
    archiveConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Marks conversation as unarchived.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unarchiveConversation('abcdef');
     * ```
     */
    unarchiveConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Marks a conversation as read for the user.
     *
     * @param params.conversationId Id of a modmail conversation
     * @param params.numHours For how many hous the conversation needs to be muted
     *
     * @example
     * ```ts
     * await reddit.modMail.muteConversation({ conversationId: 'abcdef', numHours: 2 });
     * ```
     */
    muteConversation(params: {
        conversationId: string;
        numHours: number;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Unmutes the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unmuteConversation('abcdef');
     * ```
     */
    unmuteConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Marks a conversations as read for the user.
     *
     * @param conversationIds An array of ids
     *
     * @example
     * ```ts
     * await reddit.modMail.readConversations(['abcdef', 'qwerty']);
     * ```
     */
    readConversations(conversationIds: string[]): Promise<void>;
    /**
     * Marks conversations as unread for the user.
     *
     * @param conversationIds An array of ids
     *
     * @example
     * ```ts
     * await reddit.modMail.unreadConversations(['abcdef', 'qwerty']);
     * ```
     */
    unreadConversations(conversationIds: string[]): Promise<void>;
    /**
     * Approve the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.approveConversation('abcdef');
     * ```
     */
    approveConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Disapprove the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.disapproveConversation('abcdef');
     * ```
     */
    disapproveConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Temporary ban (switch from permanent to temporary ban) the non mod user associated with a particular conversation.
     *
     * @param params.conversationId a modmail conversation id
     * @param params.duration duration in days, max 999
     *
     * @example
     * ```ts
     * await reddit.modMail.tempBanConversation({ conversationId: 'abcdef', duration: 42 });
     * ```
     */
    tempBanConversation(params: {
        conversationId: string;
        duration: number;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Unban the non mod user associated with a particular conversation.
     *
     * @param conversationId a modmail conversation id
     *
     * @example
     * ```ts
     * await reddit.modMail.unbanConversation('abcdef');
     * ```
     */
    unbanConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Endpoint to retrieve the unread conversation count by conversation state.
     *
     * @example
     * ```ts
     * const response = await reddit.modMail.getUnreadCount();
     *
     * console.log(response.highlighted);
     * console.log(response.new);
     * ```
     */
    getUnreadCount(): Promise<UnreadCountResponse>;
    /**
     * Returns recent posts, comments and modmail conversations for a given user.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * const data = await reddit.modMail.getUserConversations('abcdef');
     *
     * console.log(data.recentComments);
     * console.log(data.recentPosts);
     * ```
     */
    getUserConversations(conversationId: string): Promise<ConversationUserData>;
}

/** The event name for when a mod mail is sent/received */
export declare type ModMailTrigger = 'ModMail';

export declare interface ModNote {
    id: string;
    operator: {
        id?: T2ID | undefined;
        name?: string | undefined;
    };
    user: {
        id?: T2ID | undefined;
        name?: string | undefined;
    };
    subreddit: {
        id?: T5ID | undefined;
        name?: string | undefined;
    };
    type: ModNoteType;
    createdAt: Date;
    userNote?: UserNote;
    modAction?: ModAction;
}

export declare class ModNote {
    #private;
}

export declare type ModNoteType = 'NOTE' | 'APPROVAL' | 'REMOVAL' | 'BAN' | 'MUTE' | 'INVITE' | 'SPAM' | 'CONTENT_CHANGE' | 'MOD_ACTION' | 'ALL';

export declare type MoreObject = {
    parentId: T1ID | T3ID;
    children: T1ID[];
    depth: number;
};

export declare type MultiTriggerDefinition<Event extends TriggerEvent> = {
    events: readonly Event[];
    onEvent: TriggerOnEventHandler<TriggerEventType[Event]>;
};

declare type MuteUserOptions = {
    /** The name of the subreddit to mute the user in */
    subredditName: string;
    /** The name of the user to mute */
    username: string;
    /** A mod note on why the user was muted. (optional) */
    note?: string;
};

declare type Namespace = {
    /**
     * Nonnullish address when bound. Set when bound but may be set sooner. May
     * not be unset when unbound.
     *
     * Hostnames are not necessarily unique. Clients always have the same hostname
     * as their EnvelopeDispatcher. Stream IDs are used to distinguish duplicate
     * hostnames.
     */
    hostname: string | undefined;
};

/** A number field */
export declare type NumberField = Prettify<BaseField<number> & Omit<FieldConfig_Number, 'min' | 'max' | 'step'> & {
    type: 'number';
}>;

declare type ObfuscationReason = 'nsfw' | 'spoiler';

/**
 * oEmbed is a format for allowing an embedded representation of a URL on third party sites.
 * The simple API allows a website to display embedded content (such as photos or videos)
 * when a user posts a link to that resource, without having to parse the resource directly.
 * See: https://oembed.com/
 */
export declare type OEmbed = {
    /** The resource type. Valid values, along with value-specific parameters, are described below. E.g. "video" */
    type: string;
    /** A text title, describing the resource. */
    title?: string | undefined;
    /** A URL for the author/owner of the resource. E.g. "YouTube" */
    providerName?: string | undefined;
    /** The name of the resource provider. E.g "https://www.youtube.com/" */
    providerUrl?: string | undefined;
    /** The oEmbed version number. This must be 1.0. */
    version: string;
    /** The width of the optional thumbnail in pixels */
    thumbnailWidth?: number;
    /** The height of the optional thumbnail in pixels */
    thumbnailHeight?: number;
    /** A URL to a thumbnail image representing the resource. */
    thumbnailUrl?: string | undefined;
    /** The HTML required to embed a video player. The HTML should have no padding or margins. Consumers may wish to load the HTML in an off-domain iframe to avoid XSS vulnerabilities. */
    html: string;
    /** The width in pixels required to display the HTML. */
    height?: number;
    /** The height in pixels required to display the HTML. */
    width?: number;
    /** A URL for the author/owner of the resource. E.g. "https://www.youtube.com/@Reddit" */
    authorUrl?: string | undefined;
    /** The name of the author/owner of the resource. E.g. "Reddit" */
    authorName?: string | undefined;
};

export declare type OnTriggerRequest = protos.PostFlairUpdate | protos.PostSubmit | protos.PostCreate | protos.PostUpdate | protos.PostReport | protos.PostDelete | protos.CommentSubmit | protos.CommentCreate | protos.CommentUpdate | protos.CommentReport | protos.CommentDelete | protos.AppInstall | protos.AppUpgrade | protos.ModAction | protos.ModMail;

export declare type OnValidateHandler<ValueType> = (event: SettingsFormFieldValidatorEvent<ValueType>, context: Devvit.Context) => void | string | Promise<void | string>;

/**
 * @mixin
 */
declare type ParagraphContainer<Context> = {
    /**
     * Append a Paragraph
     * @param cb scoped callback to add child elements to this Paragraph
     */
    paragraph(cb: (paragraph: ParagraphContext) => void): Context;
};

/**
 * @borrows TextContainer
 * @borrows ImageContainer
 * @borrows LinkContainer
 * @borrows LineBreakContainer
 */
declare interface ParagraphContext extends TextContainer<ParagraphContext>, ImageContainer<ParagraphContext>, LinkContainer<ParagraphContext>, LineBreakContainer<ParagraphContext> {
}

/** A paragraph or textarea field */
export declare type ParagraphField = Prettify<BaseField<string> & Omit<FieldConfig_Paragraph, 'maxCharacters'> & {
    type: 'paragraph';
}>;

/**
 * Conversation participant
 */
export declare type Participant = {
    isMod?: boolean;
    isAdmin?: boolean;
    name?: string;
    isOp?: boolean;
    isParticipant?: boolean;
    isApproved?: boolean;
    isHidden?: boolean;
    id?: number;
    isDeleted?: boolean;
};

declare type ParticipantSubreddit = {
    id: string;
    name: string;
};

declare type PlainText = Text | Link | RedditLink | LineBreak;

export declare type PluginSettings = {
    /** Whether the plugin is enabled */
    enabled: boolean;
};

export declare class Post {
    #private;
    get id(): T3ID;
    get authorId(): T2ID | undefined;
    get authorName(): string;
    get subredditId(): T5ID;
    get subredditName(): string;
    get permalink(): string;
    get title(): string;
    get body(): string | undefined;
    get url(): string;
    get thumbnail(): {
        url: string;
        height: number;
        width: number;
    } | undefined;
    get createdAt(): Date;
    get score(): number;
    get numberOfComments(): number;
    get numberOfReports(): number;
    get approved(): boolean;
    get spam(): boolean;
    get stickied(): boolean;
    get removed(): boolean;
    /**
     * Who removed this object (username)
     */
    get removedBy(): string | undefined;
    /**
     * who/what removed this object. It will return one of the following:
     * - "anti_evil_ops": object is removed by a aeops member
     * - "author": object is removed by author of the post
     * - "automod_filtered": object is filtered by automod
     * - "community_ops": object is removed by a community team member
     * - "content_takedown": object is removed due to content violation
     * - "copyright_takedown": object is removed due to copyright violation
     * - "deleted": object is deleted
     * - "moderator": object is removed by a mod of the sub
     * - "reddit": object is removed by anyone else
     * - undefined: object is not removed
     */
    get removedByCategory(): string | undefined;
    get archived(): boolean;
    get edited(): boolean;
    get locked(): boolean;
    get nsfw(): boolean;
    get quarantined(): boolean;
    get spoiler(): boolean;
    get hidden(): boolean;
    get ignoringReports(): boolean;
    get distinguishedBy(): string | undefined;
    get comments(): Listing<Comment>;
    get flair(): LinkFlair | undefined;
    get secureMedia(): SecureMedia | undefined;
    get userReportReasons(): string[];
    get modReportReasons(): string[];
    toJSON(): Pick<Post, 'id' | 'authorId' | 'authorName' | 'subredditId' | 'subredditName' | 'permalink' | 'title' | 'body' | 'url' | 'thumbnail' | 'score' | 'numberOfComments' | 'numberOfReports' | 'createdAt' | 'approved' | 'spam' | 'stickied' | 'removed' | 'removedBy' | 'removedByCategory' | 'archived' | 'edited' | 'locked' | 'nsfw' | 'quarantined' | 'spoiler' | 'hidden' | 'ignoringReports' | 'distinguishedBy' | 'flair' | 'secureMedia' | 'userReportReasons' | 'modReportReasons'>;
    isApproved(): boolean;
    isSpam(): boolean;
    isStickied(): boolean;
    isRemoved(): boolean;
    isArchived(): boolean;
    isEdited(): boolean;
    isLocked(): boolean;
    isNsfw(): boolean;
    isQuarantined(): boolean;
    isSpoiler(): boolean;
    isHidden(): boolean;
    isIgnoringReports(): boolean;
    isDistinguishedBy(): string | undefined;
    edit(options: PostTextOptions): Promise<void>;
    addComment(options: CommentSubmissionOptions): Promise<Comment>;
    delete(): Promise<void>;
    approve(): Promise<void>;
    remove(isSpam?: boolean): Promise<void>;
    lock(): Promise<void>;
    unlock(): Promise<void>;
    hide(): Promise<void>;
    unhide(): Promise<void>;
    markAsNsfw(): Promise<void>;
    unmarkAsNsfw(): Promise<void>;
    markAsSpoiler(): Promise<void>;
    unmarkAsSpoiler(): Promise<void>;
    sticky(position?: 1 | 2 | 3 | 4): Promise<void>;
    unsticky(): Promise<void>;
    distinguish(): Promise<void>;
    distinguishAsAdmin(): Promise<void>;
    undistinguish(): Promise<void>;
    ignoreReports(): Promise<void>;
    unignoreReports(): Promise<void>;
    getAuthor(): Promise<User>;
    crosspost(options: Omit<CrosspostOptions, 'postId'>): Promise<Post>;
    /**
     * Add a mod note for why the post was removed
     *
     * @param options.reasonId id of a Removal Reason - you can leave this as an empty string if you don't have one
     * @param options.modNote the reason for removal (maximum 100 characters) (optional)
     * @returns
     */
    addRemovalNote(options: {
        reasonId: string;
        modNote?: string;
    }): Promise<void>;
}

declare const POST_LINK_ELEMENT = "p/";

export declare class PostCollection {
    #private;
    /**
     * The ID of the collection
     */
    get id(): string;
    /**
     * The subreddit ID of the subreddit where the collection belongs.
     */
    get subredditId(): string;
    /**
     * The title of the collection.
     */
    get title(): string;
    /**
     * The description of the collection.
     */
    get description(): string;
    /**
     * The user ID of the author of the collection.
     */
    get authorId(): string;
    /**
     * The username of the author of the collection.
     */
    get authorName(): string;
    /**
     * The permalink to the collection.
     */
    get permalink(): string | undefined;
    /**
     * The primaryLinkId in the collection.
     */
    get primaryLinkId(): string | undefined;
    /**
     * The post IDs of the posts in the collection.
     */
    get linkIds(): string[];
    /**
     * The timestamp when this collection was created.
     */
    get createdAtUtc(): Date;
    /**
     * The timestamp when this collection was last updated.
     */
    get lastUpdateUtc(): Date;
    /**
     * The layout used to display this collection in the UI.
     */
    get displayLayout(): CollectionDisplayLayout;
    /**
     * Adds a post to the collection.
     *
     * @param postId The id of the post to add to the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.addPost("t3_asd")
     * ```
     */
    addPost(postId: string): Promise<void>;
    /**
     * Remove a post from the collection.
     *
     * @param postId The id of the post to add to the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.removePost("t3_asd")
     * ```
     */
    removePost(postId: string): Promise<void>;
    /**
     * Deletes the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.delete()
     * ```
     */
    delete(): Promise<void>;
    /**
     * Follows the collection.
     *
     * @param follow True to follow the collection, false to unfollow the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * // Follow the collection
     * await collection.follow(true)
     * // Unfollow the collection
     * await collection.follow(false)
     * ```
     */
    follow(follow: boolean): Promise<void>;
    /**
     * Sets the order of the posts in the collection.
     *
     * @param postIds Array of post ids that determins the order of the posts in the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.reorder(["t3_asd", "t3_fgh"])
     * ```
     */
    reorder(postIds: string[]): Promise<void>;
    /**
     * Sets the title of the collection.
     *
     * @param title The new title of the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.updateTitle("Dogs")
     * ```
     */
    updateTitle(title: string): Promise<void>;
    /**
     * Sets the description of the collection.
     *
     * @param description The new description of the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.updateDescription("Posts about dogs")
     * ```
     */
    updateDescription(description: string): Promise<void>;
    /**
     * Sets the display layout of the collection
     *
     * @param displayLayout One of: TIMELINE | GALLERY. This determines the layout of posts in the collection UI.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.updateLayout("GALLERY")
     * ```
     */
    updateLayout(displayLayout: CollectionDisplayLayout): Promise<void>;
}

/** The event name for when a post is created, after safety delay */
export declare type PostCreate = 'PostCreate';

export declare type PostCreateDefinition = {
    event: PostCreate;
    onEvent: TriggerOnEventHandler<protos.PostCreate>;
};

/** The event name for when a post is deleted */
export declare type PostDelete = 'PostDelete';

export declare type PostDeleteDefinition = {
    event: PostDelete;
    onEvent: TriggerOnEventHandler<protos.PostDelete>;
};

/** The event name for when the flair of a post is updated */
export declare type PostFlairUpdate = 'PostFlairUpdate';

export declare type PostFlairUpdateDefinition = {
    event: PostFlairUpdate;
    onEvent: TriggerOnEventHandler<protos.PostFlairUpdate>;
};

export declare class PostFlairWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get styles(): WidgetStyles;
    get templates(): GetWidgetsResponse_WidgetItem_PostFlairTemplate[];
    get display(): 'list' | 'cloud';
    toJSON(): ReturnType<Widget['toJSON']> & Pick<PostFlairWidget, 'templates' | 'display' | 'styles'>;
}

declare type PostLink = {
    e: typeof POST_LINK_ELEMENT;
    t: string;
};

/**
 * @borrows RedditPermalinkOptions
 */
declare type PostLinkOptions = RedditPermalinkOptions;

/** The event name for when a post is reported */
export declare type PostReport = 'PostReport';

export declare type PostReportDefinition = {
    event: PostReport;
    onEvent: TriggerOnEventHandler<protos.PostReport>;
};

/** The event name for when a post is submitted */
export declare type PostSubmit = 'PostSubmit';

export declare type PostSubmitDefinition = {
    event: PostSubmit;
    onEvent: TriggerOnEventHandler<protos.PostSubmit>;
};

export declare type PostTextOptions = {
    text: string;
} | {
    richtext: object | RichTextBuilder;
};

/** The event name for when a post is updated */
export declare type PostUpdate = 'PostUpdate';

export declare type PostUpdateDefinition = {
    event: PostUpdate;
    onEvent: TriggerOnEventHandler<protos.PostUpdate>;
};

/**
 * @borrows PrefixedRedditLinkOptions
 */
declare type PrefixedRedditLinkOptions = {
    /** Whether to render a type prefix on the link (such as "r/" or "u/") */
    showPrefix: boolean;
};

declare type Prettify<T> = {
    [K in keyof T]: T[K];
};

export declare class PrivateMessage {
    #private;
    get id(): TID;
    get from(): PrivateMessageAuthor;
    get body(): string;
    get bodyHtml(): string;
    get created(): Date;
    markAsRead(): Promise<void>;
}

declare type PrivateMessageAuthor = (Pick<User, 'username'> & {
    type: 'user';
    id?: T2ID;
}) | (Pick<Subreddit, 'name'> & {
    type: 'subreddit';
    id?: T5ID;
});

/**
 * @mixin
 */
declare type RawTextContainer<Context> = {
    /**
     * Append unstyled text
     * @param text
     */
    rawText(text: string): Context;
};

declare type RawTextOptions = {
    text: string;
};

declare class RealtimeClient {
    #private;
    constructor(metadata: Metadata);
    send(channel: string, data: Data): Promise<void>;
}

/**
 * The Reddit API Client
 *
 * To use the Reddit API Client, add it to the plugin configuration at the top of the file.
 *
 * @example
 * ```ts
 *
 * Devvit.configure({
 *    redditAPI: true,
 *    // other plugins
 * })

 * // use within one of our capability handlers e.g. Menu Actions, Triggers, Scheduled Job Type, etc
 * async (event, context) => {
 *     const { reddit } = context
 *     const subreddit = await reddit.getSubredditById(context.subredditId);
 *     context.reddit.submitPost({
 *       subredditName: subreddit.name,
 *       title: 'test post',
 *       text: 'test body',
 *     })
 *     // additional code
 * }
 * ```
 */
export declare class RedditAPIClient {
    #private;
    constructor(metadata: Metadata);
    /**
     * Get ModMail API object
     *
     * @example
     * ```ts
     * await reddit.modMail.reply({
     *   body: "Here is my message",
     *   conversationId: "abcd42";
     * })
     * ```
     */
    get modMail(): ModMailService;
    /**
     * Gets a {@link Subreddit} object by ID
     *
     * @param {string} id - The ID (starting with t5_) of the subreddit to retrieve. e.g. t5_2qjpg
     * @returns {Promise<Subreddit>} A Promise that resolves a Subreddit object.
     * @example
     * ```ts
     * const memes = await reddit.getSubredditById('t5_2qjpg');
     * ```
     */
    getSubredditById(id: string): Promise<Subreddit>;
    /**
     * Gets a {@link Subreddit} object by name
     *
     * @param {string} name The name of a subreddit omitting the r/. This is case insensitive.
     * @returns {Promise<Subreddit>} A Promise that resolves a Subreddit object.
     * @example
     * ```ts
     * const askReddit = await reddit.getSubredditByName('askReddit');
     * ```
     */
    getSubredditByName(name: string): Promise<Subreddit>;
    /**
     * Add a removal reason to a subreddit
     *
     * @param subredditName Name of the subreddit being removed.
     * @param options Options.
     * @param options.title The title of the removal reason.
     * @param options.message The message associated with the removal reason.
     * @example
     * ```ts
     * const newReason = await reddit.addSubredditRemovalReasons(
     *   'askReddit',
     *   {
     *     title: 'Spam',
     *     message: 'This is spam!'
     *   }
     * );
     * console.log(newReason.id)
     * ```
     *
     * @returns {string} Removal Reason ID
     */
    addSubredditRemovalReason(subredditName: string, options: {
        title: string;
        message: string;
    }): Promise<string>;
    /**
     * Get the list of subreddit's removal reasons (ordered)
     *
     * @param subredditName
     * @example
     * ```ts
     * const reasons = await reddit.getSubredditRemovalReasons('askReddit');
     *
     * for (let reason of reasons) {
     *   console.log(reason.id, reason.message, reason.title)
     * }
     * ```
     *
     * @returns Ordered array of Removal Reasons
     */
    getSubredditRemovalReasons(subredditName: string): Promise<RemovalReason[]>;
    /**
     * Retrieves the current subreddit based on the provided metadata.
     *
     * @returns {Promise<Subreddit>} A Promise that resolves a Subreddit object.
     * @example
     * ```ts
     * const currentSubreddit = await reddit.getCurrentSubreddit(metadata);
     * ```
     */
    getCurrentSubreddit(): Promise<Subreddit>;
    /**
     * Gets a {@link Post} object by ID
     *
     * @param id
     * @returns A Promise that resolves to a Post object.
     */
    getPostById(id: string): Promise<Post>;
    /**
     * Submits a new post to a subreddit.
     *
     * @param options - Either a self post or a link post.
     * @returns A Promise that resolves to a Post object.
     * @example
     * ```ts
     * const post = await reddit.submitPost({
     *   subredditName: 'devvit',
     *   title: 'Hello World',
     *   richtext: new RichTextBuilder()
     *     .heading({ level: 1 }, (h) => {
     *       h.rawText('Hello world');
     *     })
     *     .codeBlock({}, (cb) => cb.rawText('This post was created via the Devvit API'))
     *     .build()
     * });
     * ```
     */
    submitPost(options: SubmitPostOptions): Promise<Post>;
    /**
     * Crossposts a post to a subreddit.
     *
     * @param options - Options for crossposting a post
     * @param options.subredditName - The name of the subreddit to crosspost to
     * @param options.postId - The ID of the post to crosspost
     * @param options.title - The title of the crosspost
     * @returns - A Promise that resolves to a Post object.
     */
    crosspost(options: CrosspostOptions): Promise<Post>;
    /**
     * Gets a {@link User} object by ID
     *
     * @param id - The ID (starting with t2_) of the user to retrieve. e.g. t2_1qjpg
     * @returns A Promise that resolves to a User object.
     * @example
     * ```ts
     * const user = await reddit.getUserById('t2_1qjpg');
     * ```
     */
    getUserById(id: string): Promise<User>;
    getCollectionById(collectionId: string): Promise<PostCollection>;
    createCollection(options: CreateCollectionInput): Promise<PostCollection>;
    getCollectionsForSubreddit(subredditId: string): Promise<PostCollection[]>;
    /**
     * Gets a {@link User} object by username
     *
     * @param username - The username of the user omitting the u/. e.g. 'devvit'
     * @returns A Promise that resolves to a User object.
     * @example
     * ```ts
     * const user = await reddit.getUserByUsername('devvit');
     * ```
     */
    getUserByUsername(username: string): Promise<User>;
    /**
     * Get the current calling user based on the provided metadata.
     *
     * @returns A Promise that resolves to a User object.
     * @example
     * ```ts
     * const user = await reddit.getCurrentUser(metadata);
     * ```
     */
    getCurrentUser(): Promise<User>;
    /**
     * Get the user that the app runs as on the provided metadata.
     *
     * @returns A Promise that resolves to a User object.
     * @example
     * ```ts
     * const user = await reddit.getAppUser(metadata);
     * ```
     */
    getAppUser(): Promise<User>;
    /**
     * Get the snoovatar URL for a given username.
     *
     * @param username - The username of the snoovatar to retrieve
     * @returns A Promise that resolves to a URL of the snoovatar image if it exists.
     */
    getSnoovatarUrl(username: string): Promise<string | undefined>;
    /**
     * Get a {@link Comment} object by ID
     *
     * @param id - The ID (starting with t1_) of the comment to retrieve. e.g. t1_1qjpg
     * @returns A Promise that resolves to a Comment object.
     * @example
     * ```ts
     * const comment = await reddit.getCommentById('t1_1qjpg');
     * ```
     */
    getCommentById(id: string): Promise<Comment>;
    /**
     * Get a list of comments from a specific post or comment.
     *
     * @param options - Options for the request
     * @param options.postId - The ID of the post e.g. 't3_1qjpg'
     * @param options.commentId - The ID of the comment e.g. 't1_1qjpg'
     * @param options.limit - The maximum number of comments to return. e.g. 1000
     * @param options.pageSize - The number of comments to return per request. e.g. 100
     * @returns A Listing of Comment objects.
     * @example
     * ```ts
     * const comments = await reddit.getComments({
     *   postId: 't3_1qjpg',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getComments(options: GetCommentsOptions): Listing<Comment>;
    /**
     * Get a list of comments by a specific user.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user omitting the u/. e.g. 'spez'
     * @param options.sort - The sort order of the comments. e.g. 'new'
     * @param options.timeframe - The timeframe of the comments. e.g. 'all'
     * @param options.limit - The maximum number of comments to return. e.g. 1000
     * @param options.pageSize - The number of comments to return per request. e.g. 100
     * @returns A Listing of Comment objects.
     */
    getCommentsByUser(options: GetCommentsByUserOptions): Listing<Comment>;
    /**
     * Submit a new comment to a post or comment.
     *
     * @param options - You must provide either `options.text` or `options.richtext` but not both.
     * @param options.id - The ID of the post or comment to comment on. e.g. 't3_1qjpg' for post and 't1_1qgif' for comment
     * @param options.text - The text of the comment
     * @param options.richtext - The rich text of the comment
     * @returns A Promise that resolves to a Comment object.
     */
    submitComment(options: CommentSubmissionOptions & {
        id: string;
    }): Promise<Comment>;
    /**
     * Get a list of controversial posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getControversialPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getControversialPosts(options: GetPostsOptionsWithTimeframe): Listing<Post>;
    /**
     * Get a list of controversial posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getControversialPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getTopPosts(options: GetPostsOptionsWithTimeframe): Listing<Post>;
    /**
     * Get a list of hot posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getHotPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getHotPosts(options: GetHotPostsOptions): Listing<Post>;
    /**
     * Get a list of new posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getNewPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getNewPosts(options: GetPostsOptions): Listing<Post>;
    /**
     * Get a list of hot posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getRisingPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getRisingPosts(options: GetPostsOptions): Listing<Post>;
    /**
     * Get a list of posts from a specific user.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user omitting the u/. e.g. 'spez'
     * @param options.sort - The sort method to use. e.g. 'new'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     */
    getPostsByUser(options: GetPostsByUserOptions): Listing<Post>;
    /**
     * Get a list of posts and comments from a specific user.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user omitting the u/. e.g. 'spez'
     * @param options.sort - The sort method to use. e.g. 'new'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of `Post` and `Comment` objects.
     */
    getCommentsAndPostsByUser(options: GetUserOverviewOptions): Listing<Post | Comment>;
    /**
     * Get the moderation log for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the moderation log from. e.g. 'memes'
     * @param options.moderatorUsernames (optional) A moderator filter. Accepts an array of usernames
     * @param options.type (optional) Filter the entries by the type of the Moderator action
     * @param options.limit - (optional) The maximum number of ModActions to return. e.g. 1000
     * @param options.pageSize - (optional) The number of ModActions to return per request. e.g. 100
     * @returns A Listing of ModAction objects.
     * @example
     * ```ts
     * const modActions = await reddit.getModerationLog({
     *   subredditName: 'memes',
     *   moderatorUsernames: ['spez'],
     *   type: 'banuser',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getModerationLog(options: GetModerationLogOptions): Listing<ModAction>;
    /**
     * Get a list of users who have been approved to post in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the approved users from. e.g. 'memes'
     * @param options.username - Use this to see if a user is approved to post in the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getApprovedUsers(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Approve a user to post in a subreddit.
     *
     * @param username - The username of the user to approve. e.g. 'spez'
     * @param subredditName - The name of the subreddit to approve the user in. e.g. 'memes'
     */
    approveUser(username: string, subredditName: string): Promise<void>;
    /**
     * Remove a user's approval to post in a subreddit.
     *
     * @param username - The username of the user to remove approval from. e.g. 'spez'
     * @param subredditName - The name of the subreddit to remove the user's approval from. e.g. 'memes'
     */
    removeUser(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of users who are wiki contributors of a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the wiki contributors from. e.g. 'memes'
     * @param options.username - Use this to see if a user is a wiki contributor for the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getWikiContributors(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Add a user as a wiki contributor for a subreddit.
     *
     * @param username - The username of the user to add as a wiki contributor. e.g. 'spez'
     * @param subredditName - The name of the subreddit to add the user as a wiki contributor. e.g. 'memes'
     */
    addWikiContributor(username: string, subredditName: string): Promise<void>;
    /**
     * Remove a user's wiki contributor status for a subreddit.
     *
     * @param username - The username of the user to remove wiki contributor status from. e.g. 'spez'
     * @param subredditName - The name of the subreddit to remove the user's wiki contributor status from. e.g. 'memes'
     */
    removeWikiContributor(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of users who are banned from a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the banned users from. e.g. 'memes'
     * @param options.username - Use this to see if a user is banned from the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getBannedUsers(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Ban a user from a subreddit.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user to ban. e.g. 'spez'
     * @param options.subredditName - The name of the subreddit to ban the user from. e.g. 'memes'
     * @param options.note - A mod note for the ban. (optional)
     * @param options.duration - The number of days the user should be banned for. (optional)
     * @param options.message - A message to send to the user when they are banned. (optional)
     * @param options.context - The ID of the post or comment that caused the ban. (optional)
     * @param options.reason - The reason for the ban. (optional)
     */
    banUser(options: BanUserOptions): Promise<void>;
    /**
     * Unban a user from a subreddit.
     *
     * @param username - The username of the user to unban. e.g. 'spez'
     * @param subredditName - The name of the subreddit to unban the user from. e.g. 'memes'
     */
    unbanUser(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of users who are banned from contributing to the wiki on a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the banned wiki contributors from. e.g. 'memes'
     * @param options.username - Use this to see if a user is banned from contributing to the wiki on a subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getBannedWikiContributors(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Ban a user from contributing to the wiki on a subreddit.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user to ban. e.g. 'spez'
     * @param options.subredditName - The name of the subreddit to ban the user from contributing to the wiki on. e.g. 'memes'
     * @param options.reason - The reason for the ban. (optional)
     * @param options.duration - The number of days the user should be banned for. (optional)
     * @param options.note - A mod note for the ban. (optional)
     */
    banWikiContributor(options: BanWikiContributorOptions): Promise<void>;
    /**
     *
     * @param username - The username of the user to unban. e.g. 'spez'
     * @param subredditName - The name of the subreddit to unban the user from contributing to the wiki on. e.g. 'memes'
     */
    unbanWikiContributor(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of users who are moderators for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the moderators from. e.g. 'memes'
     * @param options.username - Use this to see if a user is a moderator of the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getModerators(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Invite a user to become a moderator of a subreddit.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user to invite. e.g. 'spez'
     * @param options.subredditName - The name of the subreddit to invite the user to moderate. e.g. 'memes'
     * @param options.permissions - The permissions to give the user. (optional) Defaults to 'all'.
     */
    inviteModerator(options: InviteModeratorOptions): Promise<void>;
    /**
     * Revoke a moderator invite for a user to a subreddit.
     *
     * @param username - The username of the user to revoke the invite for. e.g. 'spez'
     * @param subredditName - The name of the subreddit to revoke the invite for. e.g. 'memes'
     */
    revokeModeratorInvite(username: string, subredditName: string): Promise<void>;
    /**
     * Remove a user as a moderator of a subreddit.
     *
     * @param username - The username of the user to remove as a moderator. e.g. 'spez'
     * @param subredditName - The name of the subreddit to remove the user as a moderator from. e.g. 'memes'
     */
    removeModerator(username: string, subredditName: string): Promise<void>;
    /**
     * Update the permissions of a moderator of a subreddit.
     *
     * @param username - The username of the user to update the permissions for. e.g. 'spez'
     * @param subredditName - The name of the subreddit. e.g. 'memes'
     * @param permissions - The permissions to give the user. e.g ['posts', 'wiki']
     */
    setModeratorPermissions(username: string, subredditName: string, permissions: ModeratorPermission[]): Promise<void>;
    /**
     * Get a list of users who are muted in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the muted users from. e.g. 'memes'
     * @param options.username - Use this to see if a user is muted in the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A listing of User objects.
     */
    getMutedUsers(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Mute a user in a subreddit. Muting a user prevents them from sending modmail.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user to mute. e.g. 'spez'
     * @param options.subredditName - The name of the subreddit to mute the user in. e.g. 'memes'
     * @param options.note - A mod note on why the user was muted. (optional)
     */
    muteUser(options: MuteUserOptions): Promise<void>;
    /**
     * Unmute a user in a subreddit. Unmuting a user allows them to send modmail.
     *
     * @param username - The username of the user to unmute. e.g. 'spez'
     * @param subredditName - The name of the subreddit to unmute the user in. e.g. 'memes'
     */
    unmuteUser(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of mod notes related to a user in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the mod notes from. e.g. 'memes'
     * @param options.username - The username of the user to get the mod notes for. e.g. 'spez'
     * @param options.filter - Filter the mod notes by type. e.g. 'NOTE', 'BAN', 'APPROVAL'
     * @param options.limit - The maximum number of mod notes to return. e.g. 1000
     * @param options.pageSize - The number of mod notes to return per request. e.g. 100
     * @returns A listing of ModNote objects.
     */
    getModNotes(options: GetModNotesOptions): Listing<ModNote>;
    /**
     * Delete a mod note.
     *
     * @param options - Options for the request
     * @param options.subreddit - The name of the subreddit to delete the mod note from. e.g. 'memes'
     * @param options.noteId - The ID of the mod note to delete (should have a ModNote_ prefix).
     * @returns True if it was deleted successfully; false otherwise.
     */
    deleteModNote(options: DeleteNotesOptions): Promise<boolean>;
    /**
     * Add a mod note.
     *
     * @param options - Options for the request
     * @param options.subreddit - The name of the subreddit to add the mod note to. e.g. 'memes'
     * @param options.user - The username of the user to add the mod note to. e.g. 'spez'
     * @param options.redditId - The ID of the comment or post to add the mod note to. e.g. 't3_1234'
     * @param options.label - The label of the mod note. e.g. 'SPAM_WARNING'
     * @param options.note - The text of the mod note.
     * @returns A Promise that resolves if the mod note was successfully added.
     */
    addModNote(options: Omit<CreateModNoteOptions, 'redditId'> & {
        redditId: string;
    }): Promise<ModNote>;
    /**
     * Add a mod note for why a post or comment was removed
     *
     * @param options.itemIds list of thing ids
     * @param options.reasonId id of a Removal Reason - you can leave this as an empty string if you don't have one
     * @param options.modNote the reason for removal (maximum 100 characters) (optional)
     */
    addRemovalNote(options: AddRemovalNoteOptions): Promise<void>;
    /**
     * Sends a private message to a user.
     *
     * @param options - The options for sending the message.
     * @returns A Promise that resolves if the private message was successfully sent.
     */
    sendPrivateMessage(options: SendPrivateMessageOptions): Promise<void>;
    /**
     * Sends a private message to a user on behalf of a subreddit.
     *
     * @param options - The options for sending the message as a subreddit.
     * @returns A Promise that resolves if the private message was successfully sent.
     */
    sendPrivateMessageAsSubreddit(options: SendPrivateMessageAsSubredditOptions): Promise<void>;
    /**
     * Approve a post or comment.
     *
     * @param id - The id of the post (t3_) or comment (t1_) to approve.
     * @example
     * ```ts
     * await reddit.approve('t3_123456');
     * await reddit.approve('t1_123456');
     * ```
     */
    approve(id: string): Promise<void>;
    /**
     * Remove a post or comment.
     *
     * @param id - The id of the post (t3_) or comment (t1_) to remove.
     * @param isSpam - Is the post or comment being removed because it's spam?
     * @example
     * ```ts
     * await reddit.remove('t3_123456', false);
     * await reddit.remove('t1_123456', true);
     * ```
     */
    remove(id: string, isSpam: boolean): Promise<void>;
    /**
     * Get the list of post flair templates for a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the post flair templates for.
     * @returns A Promise that resolves with an array of FlairTemplate objects.
     */
    getPostFlairTemplates(subredditName: string): Promise<FlairTemplate[]>;
    /**
     * Get the list of user flair templates for a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the user flair templates for.
     * @returns A Promise that resolves with an array of FlairTemplate objects.
     */
    getUserFlairTemplates(subredditName: string): Promise<FlairTemplate[]>;
    /**
     * Create a post flair template for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to create the flair template for.
     * @param options.allowableContent - The content that is allowed to be used with this flair template. e.g. 'all' or 'text' or 'emoji'
     * @param options.backgroundColor - The background color of the flair template. e.g. '#ff0000' or 'transparent'
     * @param options.maxEmojis - The maximum number of emojis that can be used with this flair template.
     * @param options.modOnly - Whether or not this flair template is only available to mods.
     * @param options.text - The text of the flair template.
     * @param options.textColor - The text color of the flair template. Either 'dark' or 'light'.
     * @param options.allowUserEdits - Whether or not users can edit the flair template when selecting a flair.
     * @returns The created FlairTemplate object.
     */
    createPostFlairTemplate(options: CreateFlairTemplateOptions): Promise<FlairTemplate>;
    /**
     * Create a user flair template for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to create the flair template for.
     * @param options.allowableContent - The content that is allowed to be used with this flair template. e.g. 'all' or 'text' or 'emoji'
     * @param options.backgroundColor - The background color of the flair template. e.g. '#ff0000' or 'transparent'
     * @param options.maxEmojis - The maximum number of emojis that can be used with this flair template.
     * @param options.modOnly - Whether or not this flair template is only available to mods.
     * @param options.text - The text of the flair template.
     * @param options.textColor - The text color of the flair template. Either 'dark' or 'light'.
     * @param options.allowUserEdits - Whether or not users can edit the flair template when selecting a flair.
     * @returns The created FlairTemplate object.
     */
    createUserFlairTemplate(options: CreateFlairTemplateOptions): Promise<FlairTemplate>;
    /**
     * Edit a flair template for a subreddit. This can be either a post or user flair template.
     * Note: If you leave any of the options fields as undefined, they will reset to their default values.
     *
     * @param options - Options for the request
     * @param options.id - The ID of the flair template to edit.
     * @param options.subredditName - The name of the subreddit to create the flair template for.
     * @param options.allowableContent - The content that is allowed to be used with this flair template. e.g. 'all' or 'text' or 'emoji'
     * @param options.backgroundColor - The background color of the flair template. e.g. '#ff0000' or 'transparent'
     * @param options.maxEmojis - The maximum number of emojis that can be used with this flair template.
     * @param options.modOnly - Is this flair template only available to mods?
     * @param options.text - The text of the flair template.
     * @param options.textColor - The text color of the flair template. Either 'dark' or 'light'.
     * @param options.allowUserEdits - Can users can edit the flair template when selecting a flair?
     * @returns The edited FlairTemplate object.
     */
    editFlairTemplate(options: EditFlairTemplateOptions): Promise<FlairTemplate>;
    /**
     * Delete a flair template from a subreddit.
     *
     * @param subredditName - The name of the subreddit to delete the flair template from.
     * @param flairTemplateId - The ID of the flair template to delete.
     */
    deleteFlairTemplate(subredditName: string, flairTemplateId: string): Promise<void>;
    /**
     * Set the flair for a user in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to set the flair for.
     * @param options.username - The username of the user to set the flair for.
     * @param options.flairTemplateId - The ID of the flair template to use.
     * @param options.text - The text of the flair.
     * @param options.cssClass - The CSS class of the flair.
     * @param options.backgroundColor - The background color of the flair.
     * @param options.textColor - The text color of the flair.
     */
    setUserFlair(options: SetUserFlairOptions): Promise<void>;
    /**
     * Remove the flair for a user in a subreddit.
     *
     * @param subredditName - The name of the subreddit to remove the flair from.
     * @param username - The username of the user to remove the flair from.
     */
    removeUserFlair(subredditName: string, username: string): Promise<void>;
    /**
     * Set the flair for a post in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to set the flair for.
     * @param options.postId - The ID of the post to set the flair for.
     * @param options.flairTemplateId - The ID of the flair template to use.
     * @param options.text - The text of the flair.
     * @param options.cssClass - The CSS class of the flair.
     * @param options.backgroundColor - The background color of the flair.
     * @param options.textColor - The text color of the flair.
     */
    setPostFlair(options: SetPostFlairOptions): Promise<void>;
    /**
     * Remove the flair for a post in a subreddit.
     *
     * @param subredditName - The name of the subreddit to remove the flair from.
     * @param postId - The ID of the post to remove the flair from.
     */
    removePostFlair(subredditName: string, postId: string): Promise<void>;
    /**
     * Get the widgets for a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the widgets for.
     * @returns - An array of Widget objects.
     */
    getWidgets(subredditName: string): Promise<Widget[]>;
    /**
     * Delete a widget from a subreddit.
     *
     * @param subredditName - The name of the subreddit to delete the widget from.
     * @param widgetId - The ID of the widget to delete.
     */
    deleteWidget(subredditName: string, widgetId: string): Promise<void>;
    /**
     * Add a widget to a subreddit.
     *
     * @param widgetData - The data for the widget to add.
     * @returns - The added Widget object.
     */
    addWidget(widgetData: AddWidgetData): Promise<Widget>;
    /**
     * Reorder the widgets for a subreddit.
     *
     * @param subredditName - The name of the subreddit to reorder the widgets for.
     * @param orderByIds - An array of widget IDs in the order that they should be displayed.
     */
    reorderWidgets(subredditName: string, orderByIds: string[]): Promise<void>;
    /**
     * Get a wiki page from a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the wiki page from.
     * @param page - The name of the wiki page to get.
     * @returns The requested WikiPage object.
     */
    getWikiPage(subredditName: string, page: string): Promise<WikiPage>;
    /**
     * Get the wiki pages for a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the wiki pages from.
     * @returns A list of the wiki page names for the subreddit.
     */
    getWikiPages(subredditName: string): Promise<string[]>;
    /**
     * Create a new wiki page for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit the wiki is in.
     * @param options.page - The name of the wiki page to create.
     * @param options.content - The Markdown content of the wiki page.
     * @param options.reason - The reason for creating the wiki page.
     * @returns - The created WikiPage object.
     */
    createWikiPage(options: CreateWikiPageOptions): Promise<WikiPage>;
    /**
     * Update a wiki page.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit the wiki is in.
     * @param options.page - The name of the wiki page to update.
     * @param options.content - The Markdown content of the wiki page.
     * @param options.reason - The reason for updating the wiki page.
     * @returns The updated WikiPage object.
     */
    updateWikiPage(options: UpdateWikiPageOptions): Promise<WikiPage>;
    /**
     * Get the revisions for a wiki page.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit the wiki is in.
     * @param options.page - The name of the wiki page to get the revisions for.
     * @param options.limit - The maximum number of revisions to return.
     * @param options.after - The ID of the revision to start after.
     * @returns A Listing of WikiPageRevision objects.
     */
    getWikiPageRevisions(options: GetPageRevisionsOptions): Listing<WikiPageRevision>;
    /**
     * Revert a wiki page to a previous revision.
     *
     * @param subredditName - The name of the subreddit the wiki is in.
     * @param page - The name of the wiki page to revert.
     * @param revisionId - The ID of the revision to revert to.
     */
    revertWikiPage(subredditName: string, page: string, revisionId: string): Promise<void>;
    /**
     * Get the settings for a wiki page.
     *
     * @param subredditName - The name of the subreddit the wiki is in.
     * @param page - The name of the wiki page to get the settings for.
     * @returns A WikiPageSettings object.
     */
    getWikiPageSettings(subredditName: string, page: string): Promise<WikiPageSettings>;
    /**
     * Update the settings for a wiki page.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit the wiki is in.
     * @param options.page - The name of the wiki page to update the settings for.
     * @param options.listed - Whether the wiki page should be listed in the wiki index.
     * @param options.permLevel - The permission level required to edit the wiki page.
     * @returns A WikiPageSettings object.
     */
    updateWikiPageSettings(options: UpdatePageSettingsOptions): Promise<WikiPageSettings>;
    /**
     * Add an editor to a wiki page.
     *
     * @param subredditName - The name of the subreddit the wiki is in.
     * @param page - The name of the wiki page to add the editor to.
     * @param username - The username of the user to add as an editor.
     */
    addEditorToWikiPage(subredditName: string, page: string, username: string): Promise<void>;
    /**
     * Remove an editor from a wiki page.
     *
     * @param subredditName - The name of the subreddit the wiki is in.
     * @param page - The name of the wiki page to remove the editor from.
     * @param username - The username of the user to remove as an editor.
     */
    removeEditorFromWikiPage(subredditName: string, page: string, username: string): Promise<void>;
    /**
     * Get private messages sent to the currently authenticated user.
     *
     * @param options - Options for the request
     * @param options.type - The type of messages to get.
     */
    getMessages(options: GetPrivateMessagesOptions): Promise<Listing<PrivateMessage>>;
    /**
     * Mark all private messages as read.
     */
    markAllMessagesAsRead(): Promise<void>;
    /**
     * Report a Post or Comment
     *
     * The report is sent to the moderators of the subreddit for review.
     *
     * @param thing Post or Comment
     * @param options Options
     * @param options.reason Why the thing is reported
     *
     * @example
     * ```ts
     * await reddit.report(post, {
     *  reason: 'This is spam!',
     * })
     * ```
     */
    report(thing: Post | Comment, options: {
        reason: string;
    }): Promise<JsonStatus>;
    /**
     * Return a listing of things requiring moderator review, such as reported things and items.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getModQueue();
     * console.log("Posts and Comments: ",  await listing.all())
     * listing = await subreddit.getModQueue({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getModQueue(options: ModLogOptions<'comment'>): Listing<Comment>;
    getModQueue(options: ModLogOptions<'post'>): Listing<Post>;
    getModQueue(options: ModLogOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been reported.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getReports();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getReports({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getReports(options: ModLogOptions<'comment'>): Listing<Comment>;
    getReports(options: ModLogOptions<'post'>): Listing<Post>;
    getReports(options: ModLogOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been marked as spam or otherwise removed.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getSpam();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getSpam({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getSpam(options: ModLogOptions<'comment'>): Listing<Comment>;
    getSpam(options: ModLogOptions<'post'>): Listing<Post>;
    getSpam(options: ModLogOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have yet to be approved/removed by a mod.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getUnmoderated();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getUnmoderated({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getUnmoderated(options: ModLogOptions<'comment'>): Listing<Comment>;
    getUnmoderated(options: ModLogOptions<'post'>): Listing<Post>;
    getUnmoderated(options: ModLogOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been edited recently.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getEdited();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getEdited({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getEdited(options: ModLogOptions<'comment'>): Listing<Comment>;
    getEdited(options: ModLogOptions<'post'>): Listing<Post>;
    getEdited(options: ModLogOptions<'all'>): Listing<Post | Comment>;
}

declare type RedditLink = CommentLink | PostLink | SubredditLink | UserLink | UserMention;

/**
 * @mixin
 */
declare type RedditLinkContainer<Context> = {
    /**
     * Append a link to a Reddit Comment
     * @param opts {@link CommentLinkOptions}
     */
    commentLink(opts: CommentLinkOptions): Context;
    /**
     * Append a link to a Reddit Post
     * @param opts {@link PostLinkOptions}
     */
    postLink(opts: PostLinkOptions): Context;
    /**
     * Append a link to a Reddit Subreddit
     * @param opts {@link SubredditLinkOptions}
     */
    subredditLink(opts: SubredditLinkOptions): Context;
    /**
     * Append a link to a Reddit User
     * @param opts {@link UserLinkOptions}
     */
    userLink(opts: UserLinkOptions): Context;
    /**
     * Append a link to a Reddit User as a @mention
     * @param opts {@link UserMentionOptions}
     */
    userMention(opts: UserMentionOptions): Context;
};

declare type RedditPermalinkOptions = {
    /**
     * Permalink to a Reddit page
     * @example { permalink: "/r/aww/comments/z9m1yj/one_of_them_isnt_a_dog" }
     */
    permalink: string;
};

/**
 * Contains the data for a video hosted on Reddit that is in a post
 */
export declare type RedditVideo = {
    /** The bitrate of the video in kilobits per second. E.g. 450 */
    bitrateKbps?: number;
    /** The URL to the DASH playlist file. E.g. "https://v.redd.it/abc123/DASHPlaylist.mpd" */
    dashUrl?: string;
    /** The duration of the video in seconds. E.g. 30 */
    duration?: number;
    /** The direct URL to the video. E.g. "https://v.redd.it/abc123/DASH_1080.mp4?source=fallback" */
    fallbackUrl?: string;
    /** The height of the video in pixels. E.g. 1080 */
    height?: number;
    /** The URL to the HLS playlist file. E.g. "https://v.redd.it/abc123/HLSPlaylist.m3u8" */
    hlsUrl?: string;
    /** If `true`, the video is a GIF */
    isGif?: boolean;
    /** The URL to the scrubber media file. E.g. "https://v.redd.it/abc123/DASH_96.mp4" */
    scrubberMediaUrl?: string;
    /** The status of the transcoding process. E.g. "completed" */
    transcodingStatus?: string;
    /** The width of the video in pixels. E.g. 1920 */
    width?: number;
};

export declare type RedisClient = {
    /**
     * Marks the given keys to be watched for conditional execution of a transaction.
     * https://redis.io/commands/watch/
     * @arg {} keys - given keys to be watched
     */
    watch(...keys: string[]): Promise<TxClientLike>;
    /**
     * Get the value of key. If the key does not exist the special value nil is returned.
     * https://redis.io/commands/get/
     * @arg {} key
     * @returns value of key or null when key does not exist.
     */
    get(key: string): Promise<string | undefined>;
    /**
     * Set key to hold the string value. If key already holds a value, it is overwritten
     * https://redis.io/commands/set/
     * @arg {} key
     * @arg {} value
     * @arg {} options
     */
    set(key: string, value: string, options?: SetOptions): Promise<string>;
    /**
     * Removes the specified keys. A key is ignored if it does not exist.
     * https://redis.io/commands/del/
     * @arg {} keys
     */
    del(...keys: string[]): Promise<void>;
    /**
     * Returns the string representation of the type of the value stored at key
     * https://redis.io/commands/type/
     * @arg {} key
     * @returns string representation of the type
     */
    type(key: string): Promise<string>;
    /**
     * Returns the substring of the string value stored at key, determined by
     * the offsets start and end (both are inclusive).
     * https://redis.io/commands/getrange/
     * @arg {} key
     * @arg {} start
     * @arg {} end
     * @returns substring determined by offsets [start, end]
     */
    getRange(key: string, start: number, end: number): Promise<string>;
    /**
     * Overwrites part of the string stored at key, starting at the
     * specified offset, for the entire length of value.
     * https://redis.io/commands/setrange/
     * @arg {} key
     * @arg {} offset
     * @returns length of the string after it was modified by the command
     */
    setRange(key: string, offset: number, value: string): Promise<number>;
    /**
     * Returns the length of the string value stored at key.
     * An error is returned when key holds a non-string value.
     * https://redis.io/commands/strlen/
     * @arg {} key
     * @returns length of the string stored at key
     */
    strlen(key: string): Promise<number>;
    /**
     * Increments the number stored at key by increment.
     * https://redis.io/commands/incrby/
     * @arg {} key
     * @arg {} value
     * @returns value of key after the increment
     */
    incrBy(key: string, value: number): Promise<number>;
    /**
     * Returns the values of all specified keys.
     * https://redis.io/commands/mget/
     * @arg {} keys
     * @returns list of values at the specified keys
     */
    mget(keys: string[]): Promise<(string | null)[]>;
    /**
     * Sets the given keys to their respective values.
     * https://redis.io/commands/mset/
     * @arg {} keyValues
     */
    mset(keyValues: {
        [key: string]: string;
    }): Promise<void>;
    /**
     * Set a timeout on key.
     * https://redis.io/commands/expire/
     * @arg {} key
     * @arg {} seconds
     */
    expire(key: string, seconds: number): Promise<void>;
    /**
     * Returns the absolute Unix timestamp in seconds at which the given key will expire
     * https://redis.io/commands/expiretime/
     * @arg {} key
     * @returns expiration Unix timestamp in seconds, or a negative value in order to signal an error
     */
    expireTime(key: string): Promise<number>;
    /**
     * Adds all the specified members with the specified scores to the sorted set stored at key.
     * https://redis.io/commands/zadd/
     * @arg {} key
     * @returns number of elements added to the sorted set
     */
    zAdd(key: string, ...members: ZMember[]): Promise<number>;
    /**
     * Returns the cardinality (number of elements) of the sorted set stored at key.
     * https://redis.io/commands/zcard/
     * @arg {} key
     * @returns cardinality of the sorted set
     */
    zCard(key: string): Promise<number>;
    /**
     * Returns the score of member in the sorted set at key.
     * https://redis.io/commands/zscore/
     * @arg {} key
     * @arg {} member
     * @returns the score of the member (a double-precision floating point number).
     */
    zScore(key: string, member: string): Promise<number>;
    /**
     * Returns the rank of member in the sorted set stored at key
     * https://redis.io/commands/zrank/
     * @arg {} key
     * @arg {} member
     * @returns rank of the member. The rank (or index) is 0-based
     * which means that the member with the lowest score has rank 0
     */
    zRank(key: string, member: string): Promise<number>;
    /**
     * Increments the score of member in the sorted set stored at key by value
     * https://redis.io/commands/zincrby/
     * @arg {} key
     * @arg {} member
     * @arg {} value
     * @returns the new score of member as a double precision floating point number
     */
    zIncrBy(key: string, member: string, value: number): Promise<number>;
    /**
     * Returns the specified range of elements in the sorted set stored at key.
     * https://redis.io/commands/zrange/
     * @arg {} key
     * @arg {} start
     * @arg {} stop
     * @arg {} options
     * @returns list of elements in the specified range
     */
    zRange(key: string, start: number | string, stop: number | string, options?: ZRangeOptions): Promise<{
        member: string;
        score: number;
    }[]>;
    /**
     * Removes the specified members from the sorted set stored at key.
     * https://redis.io/commands/zrem/
     * @arg {} key
     * @arg {} members
     * @returns number of members removed from the sorted set
     */
    zRem(key: string, members: string[]): Promise<number>;
    /**
     * removes all elements in the sorted set stored at key between the
     * lexicographical range specified by min and max
     * https://redis.io/commands/zremrangebylex/
     * @arg {} key
     * @arg {} min
     * @arg {} max
     * @returns number of members removed from the sorted set
     */
    zRemRangeByLex(key: string, min: string, max: string): Promise<number>;
    /**
     * Removes all elements in the sorted set stored at key with rank between start and stop.
     * https://redis.io/commands/zremrangebyrank/
     * @arg {} key
     * @arg {} start
     * @arg {} stop
     * @returns number of members removed from the sorted set
     */
    zRemRangeByRank(key: string, start: number, stop: number): Promise<number>;
    /**
     * Removes all elements in the sorted set stored at key with a score between min and max
     * https://redis.io/commands/zremrangebyscore/
     * @arg {} key
     * @arg {} min
     * @arg {} max
     * @returns number of members removed from the sorted set
     */
    zRemRangeByScore(key: string, min: number, max: number): Promise<number>;
    /**
     * Sets the specified fields to their respective values in the hash stored at key.
     * https://redis.io/commands/hset
     * @arg {} key
     * @arg {} fieldValues
     * @returns number of fields that were added
     */
    hset(key: string, fieldValues: {
        [field: string]: string;
    }): Promise<number>;
    /**
     * Returns the value associated with field in the hash stored at key.
     * https://redis.io/commands/hget
     * @arg {} key
     * @arg {} field
     * @returns value associated with field
     */
    hget(key: string, field: string): Promise<string | undefined>;
    /**
     * Returns a map of fields and their values stored in the hash
     * https://redis.io/commands/hgetall
     * @arg {} key
     * @returns a list of fields and their values stored in the hash
     */
    hgetall(key: string): Promise<Record<string, string> | undefined>;
    /**
     * Removes the specified fields from the hash stored at key.
     * https://redis.io/commands/hdel/
     * @arg {} key
     * @arg {} fields
     * @returns number of fields that were removed from the hash
     */
    hdel(key: string, fields: string[]): Promise<number>;
    /**
     * Iterates fields of Hash types and their associated values.
     * @arg {} key
     * @arg {} cursor
     * @arg {} pattern
     * @arg {} count
     */
    hscan(key: string, cursor: number, pattern?: string | undefined, count?: number | undefined): Promise<HScanResponse>;
    /**
     * Returns all field names in the hash stored at key.
     * @arg {} key
     */
    hkeys(key: string): Promise<string[]>;
    /**
     * Increments the number stored at field in the hash stored at key by increment.
     * https://redis.io/commands/hincrby/
     * @arg {} key
     * @arg {} field
     * @arg {} value
     * @returns value of key after the increment
     */
    hincrby(key: string, field: string, value: number): Promise<number>;
    /**
     * Allows read/write operations to global keys in Redis
     * Global redis enables apps to persist and access state across subreddit installations
     */
    global: Omit<RedisClient, 'global'>;
};

export declare type RelationshipType = 'moderator_invite' | 'contributor' | 'banned' | 'muted' | 'wikibanned' | 'wikicontributor';

/**
 * An individual Removal Reason object.
 */
export declare type RemovalReason = {
    /**
     * The ID of the removal reason.
     */
    id: string;
    /**
     * The message associated with the removal reason.
     */
    message: string;
    /**
     * The title of the removal reason.
     */
    title: string;
};

export declare type RemoveRelationshipOptions = {
    subredditName: string;
    username: string;
    type: RelationshipType | 'moderator';
};

export declare type ReplyToCommentOptions = CommentSubmissionOptions;

/**
 * @mixes ParagraphContainer
 * @mixes HeadingContainer
 * @mixes HorizontalRuleContainer
 * @mixes BlockQuoteContainer
 * @mixes CodeBlockContainer
 * @mixes EmbedContainer
 * @mixes ListContainer
 * @mixes TableContainer
 * @mixes ImageContainer
 * @mixes VideoContainer
 */
export declare class RichTextBuilder implements ParagraphContainer<RichTextBuilder>, HeadingContainer<RichTextBuilder>, HorizontalRuleContainer<RichTextBuilder>, BlockQuoteContainer<RichTextBuilder>, CodeBlockContainer<RichTextBuilder>, EmbedContainer<RichTextBuilder>, ListContainer<RichTextBuilder>, TableContainer<RichTextBuilder>, ImageContainer<RichTextBuilder>, VideoContainer<RichTextBuilder> {
    #private;
    constructor();
    /**
     * Serializes the document to a JSON string
     */
    build(): string;
    paragraph(cb: (paragraph: ParagraphContext) => void): RichTextBuilder;
    heading(opts: HeadingOptions, cb: (heading: HeadingContext) => void): RichTextBuilder;
    horizontalRule(): RichTextBuilder;
    blockQuote(opts: BlockQuoteOptions, cb: (blockQuote: BlockQuoteContext) => void): RichTextBuilder;
    codeBlock(opts: CodeBlockOptions, cb: (codeBlock: CodeBlockContext) => void): RichTextBuilder;
    embed(_opts: EmbedOptions): RichTextBuilder;
    list(opts: ListOptions, cb: (list: ListContext) => void): RichTextBuilder;
    table(cb: (table: TableContext) => void): RichTextBuilder;
    image(opts: ImageOptions): RichTextBuilder;
    animatedImage(opts: ImageOptions): RichTextBuilder;
    video(opts: VideoOptions): RichTextBuilder;
}

/**
 * Schedule a new job to run at a specific time or on a cron schedule
 * @param job The job to schedule
 * @returns {} The id of the scheduled job
 */
export declare type RunJob = (job: ScheduledJobOptions | ScheduledCronJobOptions) => Promise<string>;

export declare type ScheduledCronJob = {
    /** ID of the scheduled job. Use this with scheduler.cancelJob to cancel the job. */
    id: string;
    /** The name of the scheduled job type */
    name: string;
    /** Additional data passed in by the scheduler client */
    data: Data | undefined;
    /** The cron string of when this job should run */
    cron: string;
};

export declare type ScheduledCronJobOptions = {
    /** The name of the scheduled job type */
    name: string;
    /** Additional data passed in by the scheduler client */
    data?: Data | undefined;
    /** The cron string of when this job should run */
    cron: string;
};

export declare type ScheduledJob = {
    /** ID of the scheduled job. Use this with scheduler.cancelJob to cancel the job. */
    id: string;
    /** The name of the scheduled job type */
    name: string;
    /** Additional data passed in by the scheduler client */
    data: Data | undefined;
    /** The Date of when this job should run */
    runAt: Date;
};

export declare type ScheduledJobEvent = {
    /** The name of the scheduled job */
    name: string;
    /** Additional data passed in by the scheduler client */
    data?: Data | undefined;
};

export declare type ScheduledJobHandler = (event: ScheduledJobEvent, context: Devvit.Context) => void | Promise<void>;

export declare type ScheduledJobOptions = {
    /** The name of the scheduled job type */
    name: string;
    /** Additional data passed in by the scheduler client */
    data?: Data | undefined;
    /** The Date of when this job should run */
    runAt: Date;
};

export declare type ScheduledJobType = {
    /** The name of the scheduled job type */
    name: string;
    /** The function that will be called when the job is scheduled to run */
    onRun: ScheduledJobHandler;
};

/**
 * The Scheduler client lets you schedule new jobs or cancel existing jobs.
 * You must have the `scheduler` enabled in `Devvit.configure` to use this client.
 */
export declare type Scheduler = {
    /**
     * Schedule a new job to run at a specific time or on a cron schedule
     * @param job The job to schedule
     * @returns {} The id of the scheduled job
     */
    runJob: RunJob;
    /**
     * Cancel a scheduled job
     * @param jobId The id of the job to cancel
     */
    cancelJob: CancelJob;
    /**
     * Gets the list of all scheduled jobs.
     */
    listJobs: () => Promise<(ScheduledJob | ScheduledCronJob)[]>;
};

export declare type SecureMedia = {
    /** The type of the OEmbed media, if present (e.g. "youtube.com") */
    type?: string;
    oembed?: OEmbed;
    redditVideo?: RedditVideo;
};

/** A dropdown field that allows users to pick from a list of options */
export declare type SelectField = Prettify<BaseField<string[]> & Omit<FieldConfig_Selection, 'choices' | 'renderAsList' | 'minSelections' | 'maxSelections'> & {
    type: 'select';
    options: FieldConfig_Selection_Item[];
}>;

export declare type SendPrivateMessageAsSubredditOptions = SendPrivateMessageOptions & {
    /** The name of the subreddit the message is being sent from (without the leading r/) */
    fromSubredditName: string;
};

export declare type SendPrivateMessageOptions = {
    /** The username of the recipient of the message. (without the leading u/) */
    to: string;
    /** The subject of the message. */
    subject: string;
    /** The body of the message in markdown text format. */
    text: string;
};

export declare type SetFlairOptions = {
    /** The name of the subreddit of the item to set the flair on */
    subredditName: string;
    /** The flair template's ID */
    flairTemplateId?: string;
    /** The flair text */
    text?: string;
    /** The flair CSS class */
    cssClass?: string;
    /** The flair text color. Either 'dark' or 'light'. */
    textColor?: FlairTextColor;
    /** The flair background color. Either 'transparent' or a hex color code. e.g. #FFC0CB */
    backgroundColor?: string;
};

export declare type SetOptions = {
    nx?: boolean;
    xx?: boolean;
    expiration?: Date;
};

export declare type SetPostFlairOptions = SetFlairOptions & {
    /** The ID of the post to set the flair on */
    postId: string;
};

export declare type SetStateAction<S> = S | ((prevState: S) => S);

/**
 * The Settings API Client lets you retrieve the settings values for your app set by the installer.
 * Use this in conjunction with `Devvit.addSettings`.
 */
export declare type SettingsClient = {
    /**
     * Get a single setting value by name.
     * @param name The name of the setting to retrieve.
     * @returns A promise that resolves to the setting value, or undefined if the setting doesn't exist.
     */
    get<T = string | string[] | boolean | number>(name: string): Promise<T | undefined>;
    /**
     * Get all settings values.
     * @returns A promise that resolves to an object containing all settings values.
     */
    getAll<T extends object = SettingsValues>(): Promise<T>;
};

export declare enum SettingScope {
    Installation = "installation",
    App = "app"
}

export declare type SettingScopeType = 'installation' | 'app';

export declare type SettingsFormField = ValidatedStringField | ValidatedParagraphField | ValidatedNumberField | ValidatedBooleanField | ValidatedSelectField | SettingsFormFieldGroup;

export declare type SettingsFormFieldGroup = Prettify<Omit<FormFieldGroup, 'fields'> & {
    fields: SettingsFormField[];
}>;

export declare type SettingsFormFieldValidatorEvent<ValueType> = {
    value: ValueType | undefined;
    isEditing: boolean;
};

export declare type SettingsValues = {
    [key: string]: string | string[] | boolean | number | undefined;
};

export declare type SetUserFlairOptions = SetFlairOptions & {
    /** The username of the user to set the flair on */
    username: string;
};

declare const SPOILER_TEXT_ELEMENT = "spoilertext";

declare type SpoilerText = {
    e: typeof SPOILER_TEXT_ELEMENT;
    c: PlainText[];
};

export declare type StateSetter<S> = Dispatch<SetStateAction<S>>;

/** A text field */
export declare type StringField = Prettify<BaseField<string> & Omit<FieldConfig_String, 'minLength' | 'maxLength'> & {
    type: 'string';
    isSecret?: boolean;
}>;

export declare type SubmitCustomPostOptions = CommonSubmitPostOptions & {
    preview: JSX.Element;
};

export declare type SubmitLinkOptions = CommonSubmitPostOptions & {
    url: string;
    /**
     * @deprecated Unsupported. This property is for backwards compatibility and
     * has no effect. It will removed in a future version. New code should not
     * use it.
     */
    resubmit?: boolean;
};

export declare type SubmitMediaOptions = CommonSubmitPostOptions & {
    kind: 'image' | 'video' | 'videogif';
    videoPosterUrl: string;
};

export declare type SubmitPostOptions = (SubmitLinkOptions | SubmitSelfPostOptions | SubmitCustomPostOptions | SubmitMediaOptions) & {
    subredditName: string;
};

export declare type SubmitSelfPostOptions = PostTextOptions & CommonSubmitPostOptions;

/**
 * A class representing a subreddit.
 */
export declare class Subreddit {
    #private;
    /**
     * The ID (starting with t5_) of the subreddit to retrieve. e.g. t5_2qjpg
     */
    get id(): T5ID;
    /**
     * The name of a subreddit omitting the r/.
     */
    get name(): string;
    /**
     * The creation date of the subreddit.
     */
    get createdAt(): Date;
    /**
     * The type of subreddit (public, private, etc.).
     */
    get type(): SubredditType;
    /**
     * The title of the subreddit.
     */
    get title(): string | undefined;
    /**
     * The description of the subreddit.
     */
    get description(): string | undefined;
    /**
     * The language of the subreddit.
     */
    get language(): string;
    /**
     * The number of subscribers of the subreddit.
     */
    get numberOfSubscribers(): number;
    /**
     * The number of active users of the subreddit.
     */
    get numberOfActiveUsers(): number;
    /**
     * Whether the subreddit is marked as NSFW (Not Safe For Work).
     */
    get nsfw(): boolean;
    /**
     * The settings of the subreddit.
     */
    get settings(): SubredditSettings;
    /**
     * Whether the user flairs are enabled for this subreddit.
     */
    get userFlairsEnabled(): boolean;
    /**
     * Whether the post flairs are enabled for this subreddit.
     */
    get postFlairsEnabled(): boolean;
    /**
     * Whether the user can assign user flairs.
     * This is only true if the user flairs are enabled.
     */
    get usersCanAssignUserFlairs(): boolean;
    /**
     * Whether the user can assign post flairs.
     * This is only true if the post flairs are enabled.
     */
    get usersCanAssignPostFlairs(): boolean;
    /**
     * Returns the HTTP URL for the subreddit.
     * (R2 bug: subreddit.url is a permalink path and does not return a fully qualified URL in subreddit.url)
     */
    get url(): string;
    /**
     * Returns a permalink path
     * (R2 bug: subreddit.url is a permalink, and does not have a subreddit.permalink field)
     */
    get permalink(): string;
    toJSON(): Pick<Subreddit, 'id' | 'name' | 'createdAt' | 'type' | 'title' | 'description' | 'language' | 'nsfw' | 'numberOfSubscribers' | 'numberOfActiveUsers' | 'settings'>;
    submitPost(options: SubmitLinkOptions | SubmitSelfPostOptions): Promise<Post>;
    getControversialPosts(options?: Omit<GetPostsOptionsWithTimeframe, 'subredditName'>): Listing<Post>;
    getTopPosts(options?: Omit<GetPostsOptionsWithTimeframe, 'subredditName'>): Listing<Post>;
    getApprovedUsers(options?: GetUsersOptions): Listing<User>;
    approveUser(username: string): Promise<void>;
    removeUser(username: string): Promise<void>;
    getWikiContributors(options?: GetUsersOptions): Listing<User>;
    addWikiContributor(username: string): Promise<void>;
    removeWikiContributor(username: string): Promise<void>;
    getBannedUsers(options?: GetUsersOptions): Listing<User>;
    banUser(options: Omit<BanUserOptions, 'subredditName'>): Promise<void>;
    unbanUser(username: string): Promise<void>;
    getBannedWikiContributors(options?: GetUsersOptions): Listing<User>;
    banWikiContributor(options: Omit<BanWikiContributorOptions, 'subredditName'>): Promise<void>;
    unbanWikiContributor(username: string): Promise<void>;
    getModerators(options?: GetUsersOptions): Listing<User>;
    inviteModerator(username: string, permissions?: ModeratorPermission[]): Promise<void>;
    revokeModeratorInvite(username: string): Promise<void>;
    removeModerator(username: string): Promise<void>;
    setModeratorPermissions(username: string, permissions: ModeratorPermission[]): Promise<void>;
    getMutedUsers(options?: GetUsersOptions): Listing<User>;
    muteUser(username: string, note?: string): Promise<void>;
    unmuteUser(username: string): Promise<void>;
    getModerationLog(options: GetModerationLogOptions_2): Listing<ModAction>;
    getUserFlairTemplates(): Promise<FlairTemplate[]>;
    getPostFlairTemplates(): Promise<FlairTemplate[]>;
    createPostFlairTemplate(options: Omit<CreateFlairTemplateOptions, 'subredditName'>): Promise<FlairTemplate>;
    createUserFlairTemplate(options: Omit<CreateFlairTemplateOptions, 'subredditName'>): Promise<FlairTemplate>;
    /**
     * Get the user flair for the given subreddit. If `usernames` is provided then it will return only the
     * flair for the specified users. If retrieving the list of flair for a given subreddit and the list is long
     * then this method will return a `next` field which can be passed into the `after` field on the next call to
     * retrieve the next slice of data. To retrieve the previous slice of data pass the `prev` field into the `before` field
     * during the subsequent call.
     *
     * @param options See interface
     * @param metadata See interface
     *
     * @example
     * ```ts
     * const subredditName = "mysubreddit"
     * const subreddit = await reddit.getSubredditByName(subredditName)
     * const response = await subreddit.getUserFlair();
     * const userFlairList = response.users
     * ```
     * @example
     * ```ts
     * const response = await subreddit.getUserFlair({ after: "t2_awefae"});
     * const userFlairList = response.users
     * ```
     *
     * @example
     * ```ts
     * const response = await subreddit.getUserFlair({ usernames: ['toxictoad', 'badapple']});
     * const userFlairList = response.users
     * ```
     */
    getUserFlair(options?: GetUserFlairOptions): Promise<GetUserFlairBySubredditResponse>;
    /**
     * Return a listing of things requiring moderator review, such as reported things and items.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getModQueue();
     * console.log("Posts and Comments: ",  await listing.all())
     * listing = await subreddit.getModQueue({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getModQueue(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getModQueue(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getModQueue(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been reported.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getReports();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getReports({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getReports(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getReports(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getReports(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been marked as spam or otherwise removed.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getSpam();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getSpam({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getSpam(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getSpam(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getSpam(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have yet to be approved/removed by a mod.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getUnmoderated();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getUnmoderated({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getUnmoderated(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getUnmoderated(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getUnmoderated(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been edited recently.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getEdited();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getEdited({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getEdited(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getEdited(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getEdited(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things specified by their fullnames.
     *
     * @param ids Array of thing full ids (e.g. t3_abc123)
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName('askReddit');
     * const listing = subreddit.getCommentsAndPostsByIds(['t3_abc123', 't1_xyz123']);
     * const items = await listing.all();
     * console.log(items) // [Post, Comment]
     * ```
     */
    getCommentsAndPostsByIds(ids: string[]): Listing<Post | Comment>;
}

declare const SUBREDDIT_LINK_ELEMENT = "r/";

export declare type SubredditCollectionsInput = {
    /** The t5_ id of the subreddit that contains the collections to be retrieved. */
    subredditId?: string;
};

export declare type SubredditData = {
    id?: string;
    name?: string;
    displayName?: string;
    communityIcon?: string;
    keyColor?: string;
    subscribers?: number;
    primaryColor?: string;
    lastUpdated?: string;
    icon?: string;
};

declare type SubredditLink = {
    e: typeof SUBREDDIT_LINK_ELEMENT;
    t: string;
    l: boolean;
};

/**
 * @borrows PrefixedRedditLinkOptions
 */
declare type SubredditLinkOptions = PrefixedRedditLinkOptions & {
    /**
     * Subreddit name without the "r/" prefix
     * @example { subredditName: "aww", showPrefix: true }
     */
    subredditName: string;
};

declare type SubredditRule = {
    description: string;
    priority: number;
    shortName: string;
    violationReason: string;
};

export declare class SubredditRulesWidget extends Widget {
    #private;
    constructor(subredditAboutRulesRsp: SubredditAboutRulesResponse, widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get rules(): SubredditRule[];
    toJSON(): ReturnType<Widget['toJSON']> & Pick<SubredditRulesWidget, 'rules'>;
}

export declare type SubredditSettings = {
    /**
     * Whether the subreddit accepts followers or not.
     */
    acceptFollowers: boolean;
    /**
     * Whether all content posted on the subreddit is original.
     */
    allOriginalContent: boolean;
    /**
     * Whether users are allowed to create chat posts on the subreddit.
     */
    allowChatPostCreation: boolean;
    /**
     * Whether the subreddit can be discovered through search.
     */
    allowDiscovery: boolean;
    /**
     * Whether the subreddit allows galleries.
     */
    allowGalleries: boolean;
    /**
     * Whether the subreddit allows images.
     */
    allowImages: boolean;
    /**
     * Whether the subreddit allows polls.
     */
    allowPolls: boolean;
    /**
     * Whether contributors are allowed to make predictions on the subreddit.
     */
    allowPredictionContributors: boolean;
    /**
     * Whether predictions are allowed on the subreddit.
     */
    allowPredictions: boolean;
    /**
     * Whether prediction tournaments are allowed on the subreddit.
     */
    allowPredictionsTournament: boolean;
    /**
     * Whether talks are allowed on the subreddit.
     */
    allowTalks: boolean;
    /**
     * Whether video GIFs are allowed on the subreddit.
     */
    allowVideoGifs: boolean;
    /**
     * Whether videos are allowed on the subreddit.
     */
    allowVideos: boolean;
    /**
     * Whether chat posts are enabled on the subreddit.
     */
    chatPostEnabled: boolean;
    /**
     * Whether collections are enabled on the subreddit.
     */
    collectionsEnabled: boolean;
    /**
     * Whether crossposts can be made to this subreddit.
     */
    crosspostable: boolean;
    /**
     * Whether emojis are enabled on the subreddit.
     */
    emojisEnabled: boolean;
    /**
     * Whether event posts are enabled on the subreddit.
     */
    eventPostsEnabled: boolean;
    /**
     * Whether link flairs are enabled on the subreddit.
     */
    linkFlairEnabled: boolean;
    /**
     * Whether the Original Content tag is enabled.
     */
    originalContentTagEnabled: boolean;
    /**
     * Whether commenting is restricted in the subreddit.
     */
    restrictCommenting: boolean;
    /**
     * Whether posting is restricted in the subreddit.
     */
    restrictPosting: boolean;
    /**
     * Whether posts in the subreddit should be automatically archived after 6 months.
     */
    shouldArchivePosts: boolean;
    /**
     * Whether the Spoiler tag is enabled.
     */
    spoilersEnabled: boolean;
    /**
     * Whether the wiki is enabled for the subreddit.
     */
    wikiEnabled: boolean;
    /**
     * The types of post allowed in this subreddit. Either "any", "link", or "self".
     */
    allowedPostType: 'any' | 'link' | 'self';
    /**
     * List of allowed media types in the comments made in the subreddit.
     */
    allowedMediaInComments: CommentMediaTypes[];
    /**
     * a 6-digit rgb hex color of the banner e.g. `#AABBCC`,
     */
    bannerBackgroundColor?: string;
    /**
     * The background image of the banner.
     */
    bannerBackgroundImage?: string;
    /**
     * The URL of the banner image.
     */
    bannerImage?: string;
    /**
     * The URL of the community icon.
     */
    communityIcon?: string;
    /**
     * The header title.
     */
    headerTitle?: string;
    /**
     * Banner image used on mobile apps.
     */
    mobileBannerImage?: string;
    /**
     * The user flair settings for the subreddit.
     */
    userFlairs: FlairSettings;
    /**
     * The post flair settings for the subreddit.
     */
    postFlairs: FlairSettings;
    /**
     * HTTP URL to the subreddit
     */
    url: string;
};

export declare type SubredditType = 'public' | 'private' | 'restricted' | 'employees_only' | 'gold_restricted' | 'archived';

/**
 * @experimental
 *
 * A helper to allow SVG functionality within image tags.
 *
 * @example
 * ```ts
 * import { Devvit, svg } from '@devvit/public-api';
 * const App = () => {
 *     const color = 'gold'
 *     return (
 *        <hstack>
 *          <image
 *            url={svg`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
 *                      <circle fill="${color}" cx="5" cy="5" r="4" />
 *                    </svg>`}
 *            imageHeight={100}
 *            imageWidth={100}
 *          />
 *        </hstack>
 *     )
 * }
 * ```
 */
export declare function svg(strings: TemplateStringsArray, ...args: (string | number)[]): `data:image/svg+xml;charset=UTF-8,${string}` | '';

/** Commment thing ID. */
declare type T1ID = `${T_PREFIX.COMMENT}${string}`;

/** Account thing ID. */
declare type T2ID = `${T_PREFIX.ACCOUNT}${string}`;

/** Post (also called link) thing ID. */
declare type T3ID = `${T_PREFIX.LINK}${string}`;

/** Message thing ID. */
declare type T4ID = `${T_PREFIX.MESSAGE}${string}`;

/** Subreddit thing ID. */
declare type T5ID = `${T_PREFIX.SUBREDDIT}${string}`;

/** Award thing ID. */
declare type T6ID = `${T_PREFIX.AWARD}${string}`;

declare enum T_PREFIX {
    COMMENT = "t1_",
    ACCOUNT = "t2_",
    LINK = "t3_",// Same as POST
    MESSAGE = "t4_",
    SUBREDDIT = "t5_",
    AWARD = "t6_"
}

/**
 * @mixin
 */
declare type TableCellContainer<Context> = {
    /**
     * Append a Cell to a Table Row
     * @param cb scoped callback to add child elements to this Table Cell
     */
    cell(cb: (cell: TableCellContext) => void): Context;
};

/**
 * @borrows TextContainer
 * @borrows LinkContainer
 * @borrows ImageContainer
 */
declare interface TableCellContext extends TextContainer<TableCellContext>, LinkContainer<TableCellContext>, ImageContainer<TableCellContext> {
}

/**
 * @mixin
 */
declare type TableContainer<Context> = {
    /**
     * Append a Table
     * @param cb scoped callback to add child elements to this Table
     */
    table(cb: (table: TableContext) => void): Context;
};

/**
 * @mixin
 */
declare type TableContentContainer<Context> = {
    /**
     * Append a Table Cell to the Table Header
     * @param opts {@link TableHeaderCellOptions}
     * @param cb scoped callback to add child elements to this Table Header Cell
     */
    headerCell(opts: TableHeaderCellOptions, cb: (cell: TableHeaderCellContext) => void): Context;
    /**
     * Append a Table Row to the Table
     * @param cb scoped callback to add child elements to this Table Row
     */
    row(cb: (row: TableRowContext) => void): Context;
};

/**
 * @borrows TableContentContainer
 */
declare interface TableContext extends TableContentContainer<TableContext> {
}

/**
 * @borrows TableCellContext
 */
declare type TableHeaderCellContext = TableCellContext;

declare type TableHeaderCellOptions = {
    /** Text alignment for the entire column */
    columnAlignment?: 'left' | 'right' | 'center';
};

/**
 * @borrows TableCellContainer
 */
declare interface TableRowContext extends TableCellContainer<TableRowContext> {
}

declare type Text = {
    e: typeof TEXT_ELEMENT;
    t: string;
    f?: FormatRange[];
};

declare const TEXT_ELEMENT = "text";

export declare class TextAreaWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get text(): string;
    get styles(): WidgetStyles;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<TextAreaWidget, 'text' | 'styles'>;
}

/**
 * @mixin
 */
declare type TextContainer<Context> = {
    /**
     * Append Text with optional formatting
     * @param opts {@link TextOptions}
     */
    text(opts: TextOptions): Context;
};

declare type TextNode = PlainText | SpoilerText;

/**
 * @borrows RawTextOptions
 */
declare type TextOptions = RawTextOptions & {
    /**
     * A list of FormatRange specifications which defines text style for an
     * arbitrary substring within the text
     * @see {@link FormatRange}
     * @see {@link makeFormatting}
     * @example // Make the exclamation mark italic:
     * { text: 'Hello!', formatting: [makeFormatting({italic: true, startIndex: 5, length: 1})] }
     */
    formatting?: FormatRange[];
};

declare type TID = T1ID | T2ID | T3ID | T4ID | T5ID | T6ID;

export declare type Toast = {
    /** The message shown within the toast */
    text: string;
    /** The appearance of the toast */
    appearance?: 'neutral' | 'success';
};

export declare type TriggerContext = Omit<Devvit.Context, 'ui'>;

export declare type TriggerDefinition = PostSubmitDefinition | PostCreateDefinition | PostUpdateDefinition | PostFlairUpdateDefinition | PostReportDefinition | PostDeleteDefinition | CommentSubmitDefinition | CommentCreateDefinition | CommentUpdateDefinition | CommentReportDefinition | CommentDeleteDefinition | AppInstallDefinition | AppUpgradeDefinition | ModActionDefinition | ModMailDefinition;

export declare type TriggerEvent = PostSubmit | PostCreate | PostUpdate | PostReport | PostDelete | PostFlairUpdate | CommentSubmit | CommentCreate | CommentUpdate | CommentReport | CommentDelete | AppInstall | AppUpgrade | ModActionTrigger | ModMailTrigger;

/** Maps a TriggerEvent to a Protobuf message and type. */
export declare type TriggerEventType = {
    PostSubmit: {
        type: 'PostSubmit';
    } & protos.PostSubmit;
    PostCreate: {
        type: 'PostCreate';
    } & protos.PostCreate;
    PostUpdate: {
        type: 'PostUpdate';
    } & protos.PostUpdate;
    PostReport: {
        type: 'PostReport';
    } & protos.PostReport;
    PostDelete: {
        type: 'PostDelete';
    } & protos.PostDelete;
    PostFlairUpdate: {
        type: 'PostFlairUpdate';
    } & protos.PostFlairUpdate;
    CommentSubmit: {
        type: 'CommentSubmit';
    } & protos.CommentSubmit;
    CommentCreate: {
        type: 'CommentCreate';
    } & protos.CommentCreate;
    CommentUpdate: {
        type: 'CommentUpdate';
    } & protos.CommentUpdate;
    CommentReport: {
        type: 'CommentReport';
    } & protos.CommentReport;
    CommentDelete: {
        type: 'CommentDelete';
    } & protos.CommentDelete;
    AppInstall: {
        type: 'AppInstall';
    } & protos.AppInstall;
    AppUpgrade: {
        type: 'AppUpgrade';
    } & protos.AppUpgrade;
    ModAction: {
        type: 'ModAction';
    } & protos.ModAction;
    ModMail: {
        type: 'ModMail';
    } & protos.ModMail;
};

export declare type TriggerOnEventHandler<RequestType> = (event: RequestType, context: TriggerContext) => TriggerResult;

declare type TriggerResult = Promise<void> | void;

export declare type TxClientLike = {
    /**
     * Executes all previously queued commands in a transaction and
     * restores the connection state to normal. https://redis.io/commands/exec/
     * @returns array, each element being the reply to each of the commands in the atomic transaction.
     */
    exec(): Promise<any[]>;
    /**
     * Marks the start of a transaction block. Subsequent commands will be
     * queued for atomic execution using EXEC. https://redis.io/commands/multi/
     */
    multi(): Promise<void>;
    discard(): Promise<void>;
    watch(...keys: string[]): Promise<TxClientLike>;
    unwatch(): Promise<TxClientLike>;
    get(key: string): Promise<TxClientLike>;
    set(key: string, value: string, options?: SetOptions): Promise<TxClientLike>;
    del(...keys: string[]): Promise<TxClientLike>;
    incrBy(key: string, value: number): Promise<TxClientLike>;
    type(key: string): Promise<TxClientLike>;
    getRange(key: string, start: number, end: number): Promise<TxClientLike>;
    setRange(key: string, offset: number, value: string): Promise<TxClientLike>;
    strlen(key: string): Promise<TxClientLike>;
    mget(keys: string[]): Promise<TxClientLike>;
    mset(keyValues: {
        [key: string]: string;
    }): Promise<TxClientLike>;
    expire(key: string, seconds: number): Promise<TxClientLike>;
    expireTime(key: string): Promise<TxClientLike>;
    zAdd(key: string, ...members: ZMember[]): Promise<TxClientLike>;
    zCard(key: string): Promise<TxClientLike>;
    zRange(key: string, start: number | string, stop: number | string, options?: ZRangeOptions): Promise<TxClientLike>;
    zRem(key: string, members: string[]): Promise<TxClientLike>;
    zRemRangeByLex(key: string, min: string, max: string): Promise<TxClientLike>;
    zRemRangeByRank(key: string, start: number, stop: number): Promise<TxClientLike>;
    zRemRangeByScore(key: string, min: number, max: number): Promise<TxClientLike>;
    hset(key: string, fieldValues: {
        [field: string]: string;
    }): Promise<TxClientLike>;
    hget(key: string, field: string): Promise<TxClientLike>;
    hincrby(key: string, field: string, value: number): Promise<TxClientLike>;
};

/**
 * The UI client lets your app interact with the Reddit frontend.
 * This client will only be available for capabilities that have
 * a frontend component, such as within the Custom Post component's
 * event handlers, a Form's `onSubmit` handler, and Menu items.
 */
export declare type UIClient = {
    /** Open a form in a modal */
    showForm(formKey: FormKey, data?: Data | undefined): void;
    /** Show a message in a toast. */
    showToast(text: string): void;
    showToast(toast: Toast): void;
    /** Navigate to a URL */
    navigateTo(url: string): void;
    navigateTo(subreddit: Subreddit): void;
    navigateTo(post: Post): void;
    navigateTo(comment: Comment): void;
    navigateTo(user: User): void;
    navigateTo(urlOrThing: string | Subreddit | Post | Comment | User): void;
};

export declare type UnreadCountResponse = {
    archived?: number;
    appeals?: number;
    highlighted?: number;
    notifications?: number;
    joinRequests?: number;
    filtered?: number;
    new?: number;
    inprogress?: number;
    mod?: number;
};

export declare type UpdatePageSettingsOptions = {
    /** The name of the subreddit the page is in. */
    subredditName: string;
    /** The name of the page to update settings for. */
    page: string;
    /** Whether the page should be listed in the wiki index. */
    listed: boolean;
    /** The permission level for the page. */
    permLevel: WikiPagePermissionLevel;
};

export declare type UpdateWikiPageOptions = {
    /** The name of the subreddit the page is in. */
    subredditName: string;
    /** The name of the page to update. */
    page: string;
    /** The new content of the page. */
    content: string;
    /** The reason for updating the page. */
    reason?: string;
};

export declare type UploadMediaOptions = {
    url: string;
    type: string;
};

declare type UrlString = string;

export declare type UseChannelHook = (options: ChannelOptions) => UseChannelResult;

export declare type UseChannelResult = {
    /** Subscribe to the channel */
    subscribe: () => void;
    /** Unsubscribe from the channel */
    unsubscribe: () => void;
    /** Publish a message to the channel */
    send: (data: Data) => Promise<void>;
    /** Current subscription status */
    status: ChannelStatus;
};

/** A hook that returns a form key that can be used in the `ui.showForm` */
export declare type UseFormHook = (form: Form | FormFunction, onSubmit: (values: FormValues) => void | Promise<void>) => FormKey;

/** A hook that can used to run a callback on an interval between Block renders. Only one useInterval hook may be running at a time. */
export declare type UseIntervalHook = (
/** The callback to run on an interval */
callback: () => void | Promise<void>, 
/** The delay between each callback run in milliseconds. Delay must be at least 1000ms. */
delay: number) => UseIntervalResult;

/** An object that contains functions to start and stop the interval created by the `useInterval` hook */
export declare type UseIntervalResult = {
    /** Start the interval */
    start: () => void;
    /** Stop the interval */
    stop: () => void;
};

/**
 * A class representing a user.
 */
export declare class User {
    #private;
    /**
     * The ID (starting with t2_) of the user to retrieve.
     * @example 't2_1w72'
     */
    get id(): T2ID;
    /**
     * The username of the user omitting the u/.
     * @example 'spez'
     */
    get username(): string;
    /**
     * The date the user was created.
     */
    get createdAt(): Date;
    /**
     * The amount of link karma the user has.
     */
    get linkKarma(): number;
    /**
     * The amount of comment karma the user has.
     */
    get commentKarma(): number;
    /**
     * Whether the user's profile is marked as NSFW (Not Safe For Work).
     */
    get nsfw(): boolean;
    /**
     * Whether the user is admin.
     */
    get isAdmin(): boolean;
    /**
     * The permissions the user has on the subreddit.
     */
    get modPermissions(): Map<string, ModeratorPermission[]>;
    /**
     * Returns the HTTP URL for the user
     */
    get url(): string;
    /**
     * Returns a permalink path relative to https://www.reddit.com
     */
    get permalink(): string;
    toJSON(): Pick<User, 'id' | 'username' | 'createdAt' | 'linkKarma' | 'commentKarma' | 'nsfw'> & {
        modPermissionsBySubreddit: Record<string, ModeratorPermission[]>;
    };
    /**
     * Get the mod permissions the user has on the subreddit if they are a moderator.
     *
     * @param subredditName - name of the subreddit
     * @returns the moderator permissions the user has on the subreddit
     */
    getModPermissionsForSubreddit(subredditName: string): Promise<ModeratorPermission[]>;
    /**
     * Get the user's comments.
     *
     * @param options - Options for the request
     * @param options.sort - The sort order of the comments. e.g. 'new'
     * @param options.timeframe - The timeframe of the comments. e.g. 'all'
     * @param options.limit - The maximum number of comments to return. e.g. 1000
     * @param options.pageSize - The number of comments to return per request. e.g. 100
     * @returns A Listing of Comment objects.
     */
    getComments(options: Omit<GetCommentsByUserOptions, 'username'>): Listing<Comment>;
    /**
     * Get the user's posts.
     *
     * @param options - Options for the request
     * @param options.sort - The sort order of the posts. e.g. 'new'
     * @param options.timeframe - The timeframe of the posts. e.g. 'all'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     */
    getPosts(options: Omit<GetPostsByUserOptions, 'username'>): Listing<Post>;
    /**
     * Retrieve the user's flair for the subreddit.
     *
     * @param subreddit - The name of the subreddit associated with the user's flair.
     *
     * @example
     * ```ts
     * const username = "badapple"
     * const subredditName = "mysubreddit"
     * const user = await reddit.getUserByUsername(username);
     * const userFlair = await user.getUserFlairBySubreddit(subredditName);
     * ```
     */
    getUserFlairBySubreddit(subreddit: string): Promise<UserFlair | undefined>;
    getSnoovatarUrl(): Promise<string | undefined>;
}

declare const USER_LINK_ELEMENT = "u/";

declare const USER_MENTION_ELEMENT = "@";

export declare type UserFlair = {
    /** The CSS class applied to this flair in the UI. */
    flairCssClass?: string;
    /** The username of the user to which this flair is assigned.*/
    user?: string;
    /** The text displayed in the UI for this flair. */
    flairText?: string;
};

export declare type UserFlairPageOptions = {
    /** A user id optionally provided which will result in a slice of user flairs, starting after this user, to be returned.  */
    after?: string;
    /** A user id optionally provided which will result in a slice of user flairs, starting before this user, to be returned.  */
    before?: string;
    /** A limit to the number of flairs that will be returned. Default: 25, Max: 1000  */
    limit?: number;
};

declare type UserLink = {
    e: typeof USER_LINK_ELEMENT;
    t: string;
    l: boolean;
};

/**
 * @borrows PrefixedRedditLinkOptions
 */
declare type UserLinkOptions = PrefixedRedditLinkOptions & {
    /**
     * Username the link should point to without "u/" prefix
     * @example { username: 'spez', showPrefix: true }
     */
    username: string;
};

declare type UserMention = {
    e: typeof USER_MENTION_ELEMENT;
    t: string;
    l: boolean;
};

/**
 * @borrows UserLinkOptions
 */
declare type UserMentionOptions = UserLinkOptions;

export declare type UserNote = {
    note?: string;
    redditId: T1ID | T3ID | T5ID;
    label?: UserNoteLabel;
};

export declare type UserNoteLabel = 'BOT_BAN' | 'PERMA_BAN' | 'BAN' | 'ABUSE_WARNING' | 'SPAM_WARNING' | 'SPAM_WATCH' | 'SOLID_CONTRIBUTOR' | 'HELPFUL_USER';

export declare type UseStateHook = Context['useState'];

/** A tuple containing the current state and a function to update it */
export declare type UseStateResult<S> = [S, StateSetter<S>];

export declare type ValidatedBooleanField = Prettify<ValidatedFormField<BooleanField, boolean>>;

export declare type ValidatedFormField<Field, ValueType> = Omit<Field, 'required'> & {
    onValidate?: OnValidateHandler<ValueType>;
};

export declare type ValidatedNumberField = Prettify<ValidatedFormField<NumberField, number>>;

export declare type ValidatedParagraphField = Prettify<ValidatedFormField<ParagraphField, string>>;

export declare type ValidatedSelectField = Prettify<ValidatedFormField<SelectField, string[]>>;

export declare type ValidatedStringField = Prettify<ValidatedFormField<StringField, string>>;

/**
 * @mixin
 */
declare type VideoContainer<Context> = {
    /**
     * Append a Video
     * @param opts {@link VideoOptions}
     */
    video(opts: VideoOptions): Context;
};

/**
 * @borrows MediaOptions
 */
declare type VideoOptions = MediaOptions & {
    /**
     * An {@link Image} element to use as the thumbnail before the video has loaded
     * @see {@link Image}
     * @see {makeImage}
     */
    thumbnail?: Image;
    /** Whether the video should be converted to a looping GIF */
    convertToGif?: boolean;
};

export declare class Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get id(): string;
    get name(): string;
    get subredditName(): string;
    toJSON(): Pick<Widget, 'id' | 'name' | 'subredditName'>;
    delete(): Promise<void>;
}

export declare class WikiPage {
    #private;
    /** The name of the page. */
    get name(): string;
    /** The name of the subreddit the page is in. */
    get subredditName(): string;
    /** The Markdown content of the page. */
    get content(): string;
    /** The ID of the revision. */
    get revisionId(): string;
    /** The date of the revision. */
    get revisionDate(): Date;
    /** The reason for the revision. */
    get revisionReason(): string;
    /** The author of this revision. */
    get revisionAuthor(): User;
    toJSON(): Pick<WikiPage, 'name' | 'subredditName' | 'content' | 'revisionId' | 'revisionDate' | 'revisionReason'> & {
        revisionAuthor: ReturnType<User['toJSON']>;
    };
    /** Update this page. */
    update(content: string, reason?: string): Promise<WikiPage>;
    /** Get the revisions for this page. */
    getRevisions(options: Omit<GetPageRevisionsOptions, 'subredditName' | 'page'>): Promise<Listing<WikiPageRevision>>;
    /** Revert this page to a previous revision. */
    revertTo(revisionId: string): Promise<void>;
    /** Get the settings for this page. */
    getSettings(): Promise<WikiPageSettings>;
    /** Update the settings for this page. */
    updateSettings(options: Omit<UpdatePageSettingsOptions, 'subredditName' | 'page'>): Promise<WikiPageSettings>;
    /** Add an editor to this page. */
    addEditor(username: string): Promise<void>;
    /** Remove an editor from this page. */
    removeEditor(username: string): Promise<void>;
}

export declare enum WikiPagePermissionLevel {
    /** Use subreddit wiki permissions */
    SUBREDDIT_PERMISSIONS = 0,
    /** Only approved wiki contributors for this page may edit */
    APPROVED_CONTRIBUTORS_ONLY = 1,
    /** Only mods may edit and view */
    MODS_ONLY = 2
}

export declare class WikiPageRevision {
    #private;
    constructor(data: WikiPageRevision_2, metadata: Metadata | undefined);
    get id(): string;
    get page(): string;
    get date(): Date;
    get author(): User;
    get reason(): string;
    get hidden(): boolean;
    toJSON(): Pick<WikiPageRevision, 'id' | 'page' | 'date' | 'reason' | 'hidden'> & {
        author: ReturnType<User['toJSON']>;
    };
}

export declare class WikiPageSettings {
    #private;
    constructor(data: WikiPageSettings_Data, metadata: Metadata | undefined);
    get listed(): boolean;
    get permLevel(): WikiPagePermissionLevel;
    get editors(): User[];
    toJSON(): Pick<WikiPageSettings, 'listed' | 'permLevel'> & {
        editors: ReturnType<User['toJSON']>[];
    };
}

export declare type WithUserData = {
    user?: ConversationUserData;
};

export declare type ZMember = {
    score: number;
    member: string;
};

export declare type ZRangeByScoreOptions = {
    withScores?: boolean;
    limit?: {
        offset: number;
        count: number;
    };
};

export declare type ZRangeOptions = {
    reverse?: boolean;
    by: 'score' | 'lex' | 'rank';
};

export { }
declare global {
  namespace JSX {
    interface IntrinsicElements extends Devvit.Blocks.IntrinsicElements {}

    type Fragment = Iterable<JSX.Element>;
    type SyncElement = BlockElement | JSX.Fragment | string | number | boolean | null;
    type Element = SyncElement | Promise<SyncElement>;
    type ElementChildrenAttribute = { children: {} };
    type Children = JSX.Element | JSX.Element[];
    type Props<T extends {} = {}> = T & { children?: Devvit.ElementChildren };

    type ComponentFunction = (props: JSX.Props | undefined) => JSX.Element;
  }
}
