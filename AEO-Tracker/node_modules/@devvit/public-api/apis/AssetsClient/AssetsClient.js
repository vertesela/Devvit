var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssetsClient_instances, _AssetsClient_metadata, _AssetsClient_assetsPluginFetcher, _AssetsClient_getURL, _AssetsClient_getURLs;
export class AssetsClient {
    constructor(metadata, assetsPluginFetcher) {
        _AssetsClient_instances.add(this);
        _AssetsClient_metadata.set(this, void 0);
        _AssetsClient_assetsPluginFetcher.set(this, void 0);
        __classPrivateFieldSet(this, _AssetsClient_metadata, metadata, "f");
        __classPrivateFieldSet(this, _AssetsClient_assetsPluginFetcher, assetsPluginFetcher, "f");
    }
    /**
     * Takes one or more asset names, relative to the 'assets/' folder, and returns either the
     * public URL for that one asset, or a map of each asset name to its URL.
     * @param assetPathOrPaths - Either the path you need the public URL for, or an array of paths.
     * @returns Either the public URL for the one asset you asked for, or a map of assets to their URLs.
     */
    async getURL(assetPathOrPaths) {
        if (typeof assetPathOrPaths === 'string') {
            return __classPrivateFieldGet(this, _AssetsClient_instances, "m", _AssetsClient_getURL).call(this, assetPathOrPaths);
        }
        return __classPrivateFieldGet(this, _AssetsClient_instances, "m", _AssetsClient_getURLs).call(this, assetPathOrPaths);
    }
}
_AssetsClient_metadata = new WeakMap(), _AssetsClient_assetsPluginFetcher = new WeakMap(), _AssetsClient_instances = new WeakSet(), _AssetsClient_getURL = async function _AssetsClient_getURL(assetPath) {
    // Try and short circuit using the locally available assets list if possible
    // @ts-ignore - it doesn't know what globalThis is
    const localUrl = globalThis?.devvit?.config?.assets?.[assetPath];
    if (localUrl) {
        return localUrl;
    }
    const response = await __classPrivateFieldGet(this, _AssetsClient_assetsPluginFetcher, "f").call(this).GetAssetURL({ path: assetPath }, __classPrivateFieldGet(this, _AssetsClient_metadata, "f"));
    if (!response.found) {
        throw new Error(`Could not load the URL for asset ${assetPath}`);
    }
    return response.url; // If found is true, this must be set
}, _AssetsClient_getURLs = async function _AssetsClient_getURLs(assetPaths) {
    const retval = {};
    let missingPaths = [];
    // Try and short circuit using the locally available assets list if possible, keeping a list
    // of all the paths that we couldn't find locally to ask the backend about
    // @ts-ignore - it doesn't know what globalThis is
    const localAssets = globalThis?.devvit?.config?.assets;
    if (localAssets) {
        for (const path of assetPaths) {
            if (localAssets[path]) {
                retval[path] = localAssets[path];
            }
            else {
                missingPaths.push(path);
            }
        }
    }
    else {
        // No local assets - everything is missing
        missingPaths = assetPaths;
    }
    if (missingPaths.length === 0) {
        // Found everything - don't bother the backend
        return retval;
    }
    const response = await __classPrivateFieldGet(this, _AssetsClient_assetsPluginFetcher, "f").call(this).GetAssetURLs({ paths: missingPaths }, __classPrivateFieldGet(this, _AssetsClient_metadata, "f"));
    missingPaths = [];
    for (const [path, result] of Object.entries(response.urls)) {
        if (result.found) {
            // This will only contain one value when being used like this, because we don't allow globbing
            retval[path] = result.paths[0];
        }
        else {
            missingPaths.push(path);
        }
    }
    if (missingPaths.length > 0) {
        throw new Error(`The following assets were missing from the assets list: ${missingPaths.join(', ')}`);
    }
    return retval;
};
