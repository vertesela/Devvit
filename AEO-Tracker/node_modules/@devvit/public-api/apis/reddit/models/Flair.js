var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _FlairTemplate_id, _FlairTemplate_subredditName, _FlairTemplate_text, _FlairTemplate_textColor, _FlairTemplate_backgroundColor, _FlairTemplate_allowableContent, _FlairTemplate_modOnly, _FlairTemplate_maxEmojis, _FlairTemplate_allowUserEdits, _FlairTemplate_metadata, _FlairTemplate_createOrUpdateFlairTemplate, _b, _Flair_setFlair, _Flair_removeFlair;
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { asT3ID } from '@devvit/shared-types/tid.js';
import { Devvit } from '../../../devvit/Devvit.js';
import { makeGettersEnumerable } from '../helpers/makeGettersEnumerable.js';
export var FlairType;
(function (FlairType) {
    FlairType["User"] = "USER_FLAIR";
    FlairType["Post"] = "LINK_FLAIR";
})(FlairType || (FlairType = {}));
export class FlairTemplate {
    /**
     * @internal
     */
    constructor(data, subredditName, metadata) {
        _FlairTemplate_id.set(this, void 0);
        _FlairTemplate_subredditName.set(this, void 0);
        _FlairTemplate_text.set(this, void 0);
        _FlairTemplate_textColor.set(this, void 0);
        _FlairTemplate_backgroundColor.set(this, void 0);
        _FlairTemplate_allowableContent.set(this, void 0);
        _FlairTemplate_modOnly.set(this, void 0);
        _FlairTemplate_maxEmojis.set(this, void 0);
        _FlairTemplate_allowUserEdits.set(this, void 0);
        _FlairTemplate_metadata.set(this, void 0);
        makeGettersEnumerable(this);
        assertNonNull(data.id);
        assertNonNull(data.text);
        __classPrivateFieldSet(this, _FlairTemplate_id, data.id, "f");
        __classPrivateFieldSet(this, _FlairTemplate_subredditName, subredditName, "f");
        __classPrivateFieldSet(this, _FlairTemplate_text, data.text, "f");
        __classPrivateFieldSet(this, _FlairTemplate_textColor, asFlairTextColor(data.textColor), "f");
        __classPrivateFieldSet(this, _FlairTemplate_backgroundColor, asFlairBackgroundColor(data.backgroundColor), "f");
        __classPrivateFieldSet(this, _FlairTemplate_allowableContent, asAllowableContent(data.allowableContent), "f");
        __classPrivateFieldSet(this, _FlairTemplate_modOnly, data.modOnly, "f");
        __classPrivateFieldSet(this, _FlairTemplate_maxEmojis, data.maxEmojis, "f");
        __classPrivateFieldSet(this, _FlairTemplate_allowUserEdits, data.textEditable, "f");
        __classPrivateFieldSet(this, _FlairTemplate_metadata, metadata, "f");
    }
    /** The flair template's ID */
    get id() {
        return __classPrivateFieldGet(this, _FlairTemplate_id, "f");
    }
    /** The flair template's text */
    get text() {
        return __classPrivateFieldGet(this, _FlairTemplate_text, "f");
    }
    /** The flair template's text color. Either 'dark' or 'light'. */
    get textColor() {
        return __classPrivateFieldGet(this, _FlairTemplate_textColor, "f");
    }
    /** The flair template's background color. Either 'transparent' or a hex color code. e.g. #FFC0CB */
    get backgroundColor() {
        return __classPrivateFieldGet(this, _FlairTemplate_backgroundColor, "f");
    }
    /** The flair template's allowable content. Either 'all', 'emoji', or 'text'. */
    get allowableContent() {
        return __classPrivateFieldGet(this, _FlairTemplate_allowableContent, "f");
    }
    /** Is the flair template only available to moderators? */
    get modOnly() {
        return __classPrivateFieldGet(this, _FlairTemplate_modOnly, "f");
    }
    /** The flair template's maximum number of emojis. */
    get maxEmojis() {
        return __classPrivateFieldGet(this, _FlairTemplate_maxEmojis, "f");
    }
    /** Does the flair template allow users to edit their flair? */
    get allowUserEdits() {
        return __classPrivateFieldGet(this, _FlairTemplate_allowUserEdits, "f");
    }
    /** Delete this flair template */
    async delete() {
        return _a.deleteFlairTemplate(__classPrivateFieldGet(this, _FlairTemplate_id, "f"), __classPrivateFieldGet(this, _FlairTemplate_subredditName, "f"), __classPrivateFieldGet(this, _FlairTemplate_metadata, "f"));
    }
    /** Edit this flair template */
    async edit(options) {
        return _a.editFlairTemplate({
            id: __classPrivateFieldGet(this, _FlairTemplate_id, "f"),
            subredditName: __classPrivateFieldGet(this, _FlairTemplate_subredditName, "f"),
            text: options.text ?? __classPrivateFieldGet(this, _FlairTemplate_text, "f"),
            allowableContent: options.allowableContent ?? __classPrivateFieldGet(this, _FlairTemplate_allowableContent, "f"),
            backgroundColor: options.backgroundColor ?? __classPrivateFieldGet(this, _FlairTemplate_backgroundColor, "f"),
            maxEmojis: options.maxEmojis ?? __classPrivateFieldGet(this, _FlairTemplate_maxEmojis, "f"),
            modOnly: options.modOnly ?? __classPrivateFieldGet(this, _FlairTemplate_modOnly, "f"),
            textColor: options.textColor ?? __classPrivateFieldGet(this, _FlairTemplate_textColor, "f"),
            allowUserEdits: options.allowUserEdits ?? __classPrivateFieldGet(this, _FlairTemplate_allowUserEdits, "f"),
        }, __classPrivateFieldGet(this, _FlairTemplate_metadata, "f"));
    }
    /** @internal */
    static async createPostFlairTemplate(options, metadata) {
        return __classPrivateFieldGet(_a, _a, "m", _FlairTemplate_createOrUpdateFlairTemplate).call(_a, { ...options, flairType: FlairType.Post }, metadata);
    }
    /** @internal */
    static async createUserFlairTemplate(options, metadata) {
        return __classPrivateFieldGet(_a, _a, "m", _FlairTemplate_createOrUpdateFlairTemplate).call(_a, { ...options, flairType: FlairType.User }, metadata);
    }
    /** @internal */
    static async editFlairTemplate(editOptions, metadata) {
        return __classPrivateFieldGet(_a, _a, "m", _FlairTemplate_createOrUpdateFlairTemplate).call(_a, editOptions, metadata);
    }
    /** @internal */
    static async getPostFlairTemplates(subredditName, metadata) {
        const client = Devvit.redditAPIPlugins.Flair;
        const response = await client.LinkFlair({
            subreddit: subredditName,
        }, metadata);
        return response.flair?.map((flair) => new _a(flair, subredditName, metadata)) || [];
    }
    /** @internal */
    static async getUserFlairTemplates(subredditName, metadata) {
        const client = Devvit.redditAPIPlugins.Flair;
        const response = await client.UserFlair({
            subreddit: subredditName,
        }, metadata);
        return response.flair?.map((flair) => new _a(flair, subredditName, metadata)) || [];
    }
    /** @internal */
    static async deleteFlairTemplate(subredditName, flairTemplateId, metadata) {
        const client = Devvit.redditAPIPlugins.Flair;
        await client.DeleteFlairTemplate({
            subreddit: subredditName,
            flairTemplateId,
        }, metadata);
    }
}
_a = FlairTemplate, _FlairTemplate_id = new WeakMap(), _FlairTemplate_subredditName = new WeakMap(), _FlairTemplate_text = new WeakMap(), _FlairTemplate_textColor = new WeakMap(), _FlairTemplate_backgroundColor = new WeakMap(), _FlairTemplate_allowableContent = new WeakMap(), _FlairTemplate_modOnly = new WeakMap(), _FlairTemplate_maxEmojis = new WeakMap(), _FlairTemplate_allowUserEdits = new WeakMap(), _FlairTemplate_metadata = new WeakMap(), _FlairTemplate_createOrUpdateFlairTemplate = async function _FlairTemplate_createOrUpdateFlairTemplate(options, metadata) {
    const { subredditName: subreddit, allowableContent = 'all', backgroundColor = 'transparent', flairType = '', maxEmojis = 10, modOnly = false, text, textColor = 'dark', allowUserEdits: textEditable = false, id: flairTemplateId = '', } = options;
    if (modOnly && textEditable) {
        throw new Error('Cannot have a mod only flair that is editable by users');
    }
    const client = Devvit.redditAPIPlugins.Flair;
    const response = await client.FlairTemplate({
        subreddit,
        allowableContent,
        backgroundColor,
        flairType,
        maxEmojis,
        modOnly,
        text,
        textColor,
        textEditable,
        flairTemplateId,
        cssClass: '',
        overrideCss: false,
    }, metadata);
    return new _a(response, subreddit, metadata);
};
/** @internal */
export function convertUserFlairProtoToAPI(userFlair) {
    return {
        flairCssClass: userFlair.flairCssClass,
        user: userFlair.user,
        flairText: userFlair.flairText,
    };
}
export class Flair {
    /**
     * Exposes the ListFlair API. This method will return the list of user flair for the subreddit. If name
     * is specified then it will return the user flair for the given user.
     *
     * @param { GetUserFlairBySubredditOptions } options See the interface
     * @param { Metadata | undefined } metadata See the interface
     *
     * @returns { Promise<GetUserFlairBySubredditResponse> }
     *
     * @example
     * ```ts
     * const response = await reddit.flair.getUserFlairBySubreddit({
     *      subreddit: "EyeBleach",
     *      name: "badapple"
     *   },
     *   metadata
     * );
     * ```
     * @internal
     */
    static async getUserFlairBySubreddit(options, metadata) {
        const client = Devvit.redditAPIPlugins.Flair;
        return client.FlairList(options, metadata);
    }
    /** @internal */
    static setUserFlair(options, metadata) {
        return __classPrivateFieldGet(_b, _b, "m", _Flair_setFlair).call(_b, options, metadata);
    }
    /** @internal */
    static setPostFlair(options, metadata) {
        return __classPrivateFieldGet(_b, _b, "m", _Flair_setFlair).call(_b, {
            ...options,
            postId: asT3ID(options.postId),
        }, metadata);
    }
    /** @internal */
    static async removePostFlair(subredditName, postId, metadata) {
        return __classPrivateFieldGet(_b, _b, "m", _Flair_removeFlair).call(_b, subredditName, postId, undefined, metadata);
    }
    /** @internal */
    static async removeUserFlair(subredditName, username, metadata) {
        return __classPrivateFieldGet(_b, _b, "m", _Flair_removeFlair).call(_b, subredditName, undefined, username, metadata);
    }
}
_b = Flair, _Flair_setFlair = async function _Flair_setFlair(options, metadata) {
    const client = Devvit.redditAPIPlugins.Flair;
    await client.SelectFlair({
        subreddit: options.subredditName,
        flairTemplateId: options.flairTemplateId ?? '',
        text: options.text ?? '',
        name: options.username,
        link: options.postId,
        backgroundColor: options.backgroundColor ?? '',
        textColor: options.textColor ?? 'dark',
        cssClass: options.cssClass ?? '',
        returnRtjson: 'none',
    }, metadata);
}, _Flair_removeFlair = async function _Flair_removeFlair(subredditName, postId, username, metadata) {
    const client = Devvit.redditAPIPlugins.Flair;
    await client.SelectFlair({
        subreddit: subredditName,
        name: username ?? '',
        link: postId ?? '',
        flairTemplateId: '',
        backgroundColor: '',
        text: '',
        textColor: '',
        cssClass: '',
        returnRtjson: 'none',
    }, metadata);
};
function asFlairTextColor(color) {
    assertNonNull(color, 'Flair text color is required');
    if (color === 'light' || color === 'dark') {
        return color;
    }
    throw new Error(`Invalid flair text color: ${color}`);
}
function asFlairBackgroundColor(color) {
    assertNonNull(color, 'Flair background color is required');
    if (color === 'transparent') {
        return color;
    }
    if (/^#([A-Fa-f0-9]{6})$/.test(color)) {
        return color;
    }
    throw new Error(`Invalid flair background color: ${color}`);
}
function asAllowableContent(allowableContent) {
    if (allowableContent === 'all' || allowableContent === 'text' || allowableContent === 'emoji') {
        return allowableContent;
    }
    throw new Error(`Invalid allowable content: ${allowableContent}`);
}
