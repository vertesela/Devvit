var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ModMailService_instances, _ModMailService_metadata, _ModMailService_transformConversationData, _ModMailService_getConversationMessages, _ModMailService_getConversationModActions;
import { Devvit } from '../../../devvit/Devvit.js';
export var ModMailConversationState;
(function (ModMailConversationState) {
    ModMailConversationState["New"] = "New";
    ModMailConversationState["InProgress"] = "InProgress";
    ModMailConversationState["Archived"] = "Archived";
    ModMailConversationState["Appeals"] = "Appeals";
    ModMailConversationState["JoinRequests"] = "JoinRequests";
    ModMailConversationState["Filtered"] = "Filtered";
})(ModMailConversationState || (ModMailConversationState = {}));
const R2_TO_MODMAIL_CONVERSATION_STATE = {
    0: ModMailConversationState.New,
    1: ModMailConversationState.InProgress,
    2: ModMailConversationState.Archived,
    3: ModMailConversationState.Appeals,
    4: ModMailConversationState.JoinRequests,
    5: ModMailConversationState.Filtered,
};
/**
 * An ActionType describes a particular logged action within a conversation. For example,
 * if a mod highlights a conversation, a ModerationAction record with the type `Highlighted`
 * would be created.
 */
export var ModMailActionType;
(function (ModMailActionType) {
    ModMailActionType["Highlighted"] = "Highlighted";
    ModMailActionType["Unhighlighted"] = "Unhighlighted";
    ModMailActionType["Archived"] = "Archived";
    ModMailActionType["Unarchived"] = "Unarchived";
    ModMailActionType["ReportedToAdmins"] = "ReportedToAdmins";
    ModMailActionType["Muted"] = "Muted";
    ModMailActionType["Unmuted"] = "Unmuted";
    ModMailActionType["Banned"] = "Banned";
    ModMailActionType["Unbanned"] = "Unbanned";
    ModMailActionType["Approved"] = "Approved";
    ModMailActionType["Disapproved"] = "Disapproved";
    ModMailActionType["Filtered"] = "Filtered";
    ModMailActionType["Unfiltered"] = "Unfiltered";
})(ModMailActionType || (ModMailActionType = {}));
const R2_TO_MOD_ACTION_TYPE = {
    0: ModMailActionType.Highlighted,
    1: ModMailActionType.Unhighlighted,
    2: ModMailActionType.Archived,
    3: ModMailActionType.Unarchived,
    4: ModMailActionType.ReportedToAdmins,
    5: ModMailActionType.Muted,
    6: ModMailActionType.Unmuted,
    7: ModMailActionType.Banned,
    8: ModMailActionType.Unbanned,
    9: ModMailActionType.Approved,
    10: ModMailActionType.Disapproved,
    11: ModMailActionType.Filtered,
    12: ModMailActionType.Unfiltered,
};
/**
 * Class providing the methods for working with Mod Mail
 */
export class ModMailService {
    /**
     * @internal
     */
    constructor(metadata) {
        _ModMailService_instances.add(this);
        _ModMailService_metadata.set(this, void 0);
        __classPrivateFieldSet(this, _ModMailService_metadata, metadata, "f");
    }
    /**
     * Marks all conversations read for a particular conversation state within the passed list of subreddits.
     *
     * @param subreddits Array of subreddit names
     * @param state One of the possible conversation states ('all' to read all conversations)
     *
     * @returns conversationIds
     *
     * @example
     * ```ts
     * const conversationIds = await reddit.modMail.bulkReadConversations(
     *   ['askReddit', 'myAwesomeSubreddit'],
     *   'filtered'
     * );
     * ```
     */
    async bulkReadConversations(subreddits, state) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const { conversationIds } = await client.BulkReadConversations({
            entity: subreddits.join(','),
            state,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return conversationIds;
    }
    /**
     * Get conversations for a logged in user or subreddits
     *
     * @param params.after id of a modmail
     * @param params.subreddits array of subreddit names
     * @param params.limit an integer between 1 and 100 (default: 25)
     * @param params.sort one of (recent, mod, user, unread)
     * @param params.state One of the possible conversation states ('all' to read all conversations)
     *
     * @example
     * ```ts
     * const {viewerId, conversations} = await reddit.modMail.getConversations({
     *   after: 'abcdef',
     *   limit: 42
     * });
     *
     * const arrayOfConversations = Object.values(conversations);
     * ```
     */
    async getConversations(params) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.GetConversations({
            after: params.after,
            entity: params.subreddits ? params.subreddits.join(',') : undefined,
            limit: params.limit,
            sort: params.sort,
            state: params.state,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        const conversations = {};
        for (const id in response.conversations) {
            conversations[id] = __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversations[id],
                protoMessages: response.messages,
                protoModActions: {},
            });
        }
        return {
            conversations,
            viewerId: response.viewerId,
        };
    }
    /**
     * Returns all messages, mod actions and conversation metadata for a given conversation id
     *
     * @param params.conversationId id of a modmail conversation
     * @param params.markRead should be marked as read (default: false)
     *
     * @example
     * ```ts
     * const { conversation, messages, modActions, user } = await reddit.modMail.getConversation({ conversationId: 'abcdef', markRead: true });
     * ```
     */
    async getConversation(params) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.GetConversation({ ...params, markRead: !!params.markRead }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            participantSubreddit: response.participantSubreddit,
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversation,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
            user: response.user,
        };
    }
    /**
     * Returns a list of Subreddits that the user moderates with mail permission
     *
     * @example
     * ```ts
     * const subredditsData = await reddit.modMail.getSubreddits();
     *
     * for (const subreddit of Object.values(subreddits)) {
     *   console.log(subreddit.id);
     *   console.log(subreddit.name);
     * }
     * ```
     */
    async getSubreddits() {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const { subreddits } = await client.Subreddits({}, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return subreddits;
    }
    /**
     * Creates a new conversation for a particular SR.
     *
     * This endpoint will create a ModmailConversation object
     * as well as the first ModmailMessage within the ModmailConversation object.
     *
     * @note
     * Note on {param.to}:
     * The to field for this endpoint is somewhat confusing. It can be:
     * - A User, passed like "username" or "u/username"
     * - A Subreddit, passed like "r/subreddit"
     * - null, meaning an internal moderator discussion
     *
     * In this way to is a bit of a misnomer in modmail conversations.
     * What it really means is the participant of the conversation who is not a mod of the subreddit.
     *
     * @param params.body markdown text
     * @param params.isAuthorHidden is author hidden? (default: false)
     * @param params.subredditName subreddit name
     * @param params.subject subject of the conversation. max 100 characters
     * @param params.to a user (e.g. u/username), a subreddit (e.g. r/subreddit) or null
     *
     * @example
     * ```ts
     * const { conversation, messages, modActions } = await reddit.modMail.createConversation({
     *   subredditName: 'askReddit',
     *   subject: 'Test conversation',
     *   body: 'Lorem ipsum sit amet',
     *   to: null,
     * });
     * ```
     */
    async createConversation(params) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.CreateConversation({
            body: params.body,
            isAuthorHidden: params.isAuthorHidden ?? false,
            srName: params.subredditName,
            subject: params.subject,
            to: params.to ? params.to : undefined,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversation,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
            user: response.user,
        };
    }
    /**
     * Creates a new message for a particular conversation.
     *
     * @param params.conversationId Id of a modmail conversation
     * @param params.body markdown text
     * @param params.isInternal is internal message? (default: false)
     * @param params.isAuthorHidden is author hidden? (default: false)
     *
     * @example
     * ```ts
     * await reddit.modMail.reply({
     *   body: 'Lorem ipsum sit amet',
     *   conversationId: 'abcdef',
     * });
     * ```
     */
    async reply(params) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.CreateConversationMessage({
            body: params.body,
            conversationId: params.conversationId,
            isAuthorHidden: params.isAuthorHidden ?? false,
            isInternal: params.isInternal ?? false,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversation,
                protoMessages: response.messages,
                protoModActions: {},
            }),
            user: response.user,
        };
    }
    /**
     * Marks a conversation as highlighted.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.highlightConversation('abcdef');
     * ```
     */
    async highlightConversation(conversationId) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.HighlightConversation({
            conversationId: conversationId,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversation,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
        };
    }
    /**
     * Removes a highlight from a conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unhighlightConversation('abcdef');
     * ```
     */
    async unhighlightConversation(conversationId) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.UnhighlightConversation({
            conversationId: conversationId,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversation,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
        };
    }
    /**
     * Marks a conversation as archived
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.archive('abcdef');
     * ```
     */
    async archiveConversation(conversationId) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.ArchiveConversation({
            conversationId: conversationId,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversation,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
        };
    }
    /**
     * Marks conversation as unarchived.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unarchiveConversation('abcdef');
     * ```
     */
    async unarchiveConversation(conversationId) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.UnarchiveConversation({
            conversationId: conversationId,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversation,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
        };
    }
    /**
     * Marks a conversation as read for the user.
     *
     * @param params.conversationId Id of a modmail conversation
     * @param params.numHours For how many hous the conversation needs to be muted
     *
     * @example
     * ```ts
     * await reddit.modMail.muteConversation({ conversationId: 'abcdef', numHours: 2 });
     * ```
     */
    async muteConversation(params) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.MuteConversation({
            conversationId: params.conversationId,
            numHours: params.numHours,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversations,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
            user: response.user,
        };
    }
    /**
     * Unmutes the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unmuteConversation('abcdef');
     * ```
     */
    async unmuteConversation(conversationId) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.UnmuteConversation({
            conversationId,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversations,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
            user: response.user,
        };
    }
    /**
     * Marks a conversations as read for the user.
     *
     * @param conversationIds An array of ids
     *
     * @example
     * ```ts
     * await reddit.modMail.readConversations(['abcdef', 'qwerty']);
     * ```
     */
    async readConversations(conversationIds) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        await client.Read({
            conversationIds: conversationIds.join(','),
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
    }
    /**
     * Marks conversations as unread for the user.
     *
     * @param conversationIds An array of ids
     *
     * @example
     * ```ts
     * await reddit.modMail.unreadConversations(['abcdef', 'qwerty']);
     * ```
     */
    async unreadConversations(conversationIds) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        await client.Unread({
            conversationIds: conversationIds.join(','),
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
    }
    /**
     * Approve the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.approveConversation('abcdef');
     * ```
     */
    async approveConversation(conversationId) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.ApproveConversation({
            conversationId,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversations,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
            user: response.user,
        };
    }
    /**
     * Disapprove the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.disapproveConversation('abcdef');
     * ```
     */
    async disapproveConversation(conversationId) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.DisapproveConversation({
            conversationId,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversations,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
            user: response.user,
        };
    }
    /**
     * Temporary ban (switch from permanent to temporary ban) the non mod user associated with a particular conversation.
     *
     * @param params.conversationId a modmail conversation id
     * @param params.duration duration in days, max 999
     *
     * @example
     * ```ts
     * await reddit.modMail.tempBanConversation({ conversationId: 'abcdef', duration: 42 });
     * ```
     */
    async tempBanConversation(params) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.TempBan({
            ...params,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversations,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
            user: response.user,
        };
    }
    /**
     * Unban the non mod user associated with a particular conversation.
     *
     * @param conversationId a modmail conversation id
     *
     * @example
     * ```ts
     * await reddit.modMail.unbanConversation('abcdef');
     * ```
     */
    async unbanConversation(conversationId) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        const response = await client.Unban({
            conversationId,
        }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
        return {
            conversation: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_transformConversationData).call(this, {
                protoConversation: response.conversations,
                protoMessages: response.messages,
                protoModActions: response.modActions,
            }),
            user: response.user,
        };
    }
    /**
     * Endpoint to retrieve the unread conversation count by conversation state.
     *
     * @example
     * ```ts
     * const response = await reddit.modMail.getUnreadCount();
     *
     * console.log(response.highlighted);
     * console.log(response.new);
     * ```
     */
    async getUnreadCount() {
        const client = Devvit.redditAPIPlugins.NewModmail;
        return await client.UnreadCount({}, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
    }
    /**
     * Returns recent posts, comments and modmail conversations for a given user.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * const data = await reddit.modMail.getUserConversations('abcdef');
     *
     * console.log(data.recentComments);
     * console.log(data.recentPosts);
     * ```
     */
    async getUserConversations(conversationId) {
        const client = Devvit.redditAPIPlugins.NewModmail;
        return await client.UserConversations({ conversationId }, __classPrivateFieldGet(this, _ModMailService_metadata, "f"));
    }
}
_ModMailService_metadata = new WeakMap(), _ModMailService_instances = new WeakSet(), _ModMailService_transformConversationData = function _ModMailService_transformConversationData({ protoConversation, protoMessages, protoModActions, }) {
    return {
        ...protoConversation,
        state: R2_TO_MODMAIL_CONVERSATION_STATE[protoConversation.state],
        messages: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_getConversationMessages).call(this, protoConversation, protoMessages),
        modActions: __classPrivateFieldGet(this, _ModMailService_instances, "m", _ModMailService_getConversationModActions).call(this, protoConversation, protoModActions),
    };
}, _ModMailService_getConversationMessages = function _ModMailService_getConversationMessages(protoConversation, protoMessages) {
    const messages = {};
    const messageIds = protoConversation.objIds
        .filter((o) => o.key === 'messages')
        .map(({ id }) => id);
    for (const messageId of messageIds) {
        const protoMessage = protoMessages[messageId];
        if (protoMessage) {
            messages[messageId] = protoMessage;
        }
    }
    return messages;
}, _ModMailService_getConversationModActions = function _ModMailService_getConversationModActions(protoConversation, protoModActions) {
    const modActions = {};
    const modActionIds = protoConversation.objIds
        .filter((o) => o.key === 'modActions')
        .map(({ id }) => id);
    for (const modActionId of modActionIds) {
        const protoModAction = protoModActions[modActionId];
        if (protoModAction) {
            modActions[modActionId] = {
                ...protoModAction,
                actionType: R2_TO_MOD_ACTION_TYPE[protoModAction.actionTypeId],
            };
        }
    }
    return modActions;
};
