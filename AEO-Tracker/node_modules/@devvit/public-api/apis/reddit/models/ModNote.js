var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _ModNote_fromProto;
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { asT2ID, asT5ID, asTID } from '@devvit/shared-types/tid.js';
import { Devvit } from '../../../devvit/Devvit.js';
import { Listing } from './Listing.js';
function validateUserNoteLabel(str) {
    try {
        str;
        return true;
    }
    catch {
        return false;
    }
}
function validateModNoteType(str) {
    try {
        str;
        return true;
    }
    catch {
        return false;
    }
}
export class ModNote {
    /**
     * @internal
     */
    constructor() { }
    /** @internal */
    static get(options, metadata) {
        const client = Devvit.redditAPIPlugins.ModNote;
        return new Listing({
            hasMore: true,
            before: options.before,
            limit: options.limit,
            pageSize: options.limit,
            fetch: async (fetchOptions) => {
                const protoRes = await client.GetNotes({
                    subreddit: options.subreddit,
                    user: options.user,
                    filter: options.filter,
                    before: fetchOptions.before,
                    limit: fetchOptions.limit,
                }, metadata);
                return {
                    children: protoRes.modNotes?.map((protoModNote) => __classPrivateFieldGet(this, _a, "m", _ModNote_fromProto).call(this, protoModNote)) || [],
                    // if the response says that there are no more pages, then we should set before to undefined
                    // to prevent more requests from being made
                    before: protoRes.hasNextPage ? protoRes.endCursor : undefined,
                    hasMore: protoRes.hasNextPage,
                };
            },
        });
    }
    /** @internal */
    static async delete(options, metadata) {
        const client = Devvit.redditAPIPlugins.ModNote;
        const { deleted } = await client.DeleteNotes(options, metadata);
        return !!deleted;
    }
    /** @internal */
    static async add(options, metadata) {
        const client = Devvit.redditAPIPlugins.ModNote;
        const res = await client.PostNotes(options, metadata);
        if (!res?.created) {
            throw new Error('Failed to create mod note');
        }
        return __classPrivateFieldGet(this, _a, "m", _ModNote_fromProto).call(this, res.created);
    }
    /** @internal */
    static async addRemovalNote(options, metadata) {
        const client = Devvit.redditAPIPlugins.ModNote;
        await client.PostRemovalNote(options, metadata);
    }
}
_a = ModNote, _ModNote_fromProto = function _ModNote_fromProto(protoModNote) {
    // check that all required fields of protoModNote needed to create a ModNote are present
    assertNonNull(protoModNote.id, 'Mod note ID is null or undefined');
    assertNonNull(protoModNote.createdAt, 'Mod note createdAt is null or undefined');
    assertNonNull(protoModNote.type, 'Mod note type is null or undefined');
    assertNonNull(protoModNote.subreddit, 'Mod note subreddit is null or undefined');
    assertNonNull(protoModNote.subredditId, 'Mod note subredditId is null or undefined');
    assertNonNull(protoModNote.operator, 'Mod note operator is null or undefined');
    assertNonNull(protoModNote.operatorId, 'Mod note operatorId is null or undefined');
    assertNonNull(protoModNote.user, 'Mod note user is null or undefined');
    assertNonNull(protoModNote.userId, 'Mod note userId is null or undefined');
    assertNonNull(protoModNote.userNoteData, 'Mod note userNote is null or undefined');
    assertNonNull(protoModNote.modActionData, 'Mod note modAction is null or undefined');
    // check that userNoteData label is valid
    if (!validateUserNoteLabel(protoModNote.userNoteData?.label ?? '')) {
        throw new Error(`Invalid user note label: ${protoModNote.userNoteData?.label}`);
    }
    if (!validateModNoteType(protoModNote.type)) {
        throw new Error(`Invalid mod note type: ${protoModNote.type}`);
    }
    return {
        id: protoModNote.id,
        user: {
            id: asT2ID(protoModNote.userId ?? ''),
            name: protoModNote.user,
        },
        subreddit: {
            id: asT5ID(protoModNote.subredditId ?? ''),
            name: protoModNote.subreddit,
        },
        operator: {
            id: asT2ID(protoModNote.operatorId ?? ''),
            name: protoModNote.operator,
        },
        createdAt: new Date(protoModNote.createdAt * 1000), // convert to ms
        userNote: {
            note: protoModNote.userNoteData?.note,
            redditId: asTID(protoModNote.userNoteData?.redditId ?? ''),
            label: protoModNote.userNoteData?.label,
        },
        type: protoModNote.type,
    };
};
