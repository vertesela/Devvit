var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _WikiPage_name, _WikiPage_subredditName, _WikiPage_content, _WikiPage_revisionId, _WikiPage_revisionDate, _WikiPage_revisionReason, _WikiPage_revisionAuthor, _WikiPage_metadata, _WikiPageRevision_id, _WikiPageRevision_page, _WikiPageRevision_date, _WikiPageRevision_author, _WikiPageRevision_reason, _WikiPageRevision_hidden, _WikiPageSettings_listed, _WikiPageSettings_permLevel, _WikiPageSettings_editors;
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { Devvit } from '../../../devvit/Devvit.js';
import { makeGettersEnumerable } from '../helpers/makeGettersEnumerable.js';
import { Listing } from './Listing.js';
import { User } from './User.js';
export var WikiPagePermissionLevel;
(function (WikiPagePermissionLevel) {
    /** Use subreddit wiki permissions */
    WikiPagePermissionLevel[WikiPagePermissionLevel["SUBREDDIT_PERMISSIONS"] = 0] = "SUBREDDIT_PERMISSIONS";
    /** Only approved wiki contributors for this page may edit */
    WikiPagePermissionLevel[WikiPagePermissionLevel["APPROVED_CONTRIBUTORS_ONLY"] = 1] = "APPROVED_CONTRIBUTORS_ONLY";
    /** Only mods may edit and view */
    WikiPagePermissionLevel[WikiPagePermissionLevel["MODS_ONLY"] = 2] = "MODS_ONLY";
})(WikiPagePermissionLevel || (WikiPagePermissionLevel = {}));
export class WikiPage {
    /**
     * @internal
     */
    constructor(name, subredditName, data, metadata) {
        _WikiPage_name.set(this, void 0);
        _WikiPage_subredditName.set(this, void 0);
        _WikiPage_content.set(this, void 0);
        _WikiPage_revisionId.set(this, void 0);
        _WikiPage_revisionDate.set(this, void 0);
        _WikiPage_revisionReason.set(this, void 0);
        _WikiPage_revisionAuthor.set(this, void 0);
        _WikiPage_metadata.set(this, void 0);
        makeGettersEnumerable(this);
        __classPrivateFieldSet(this, _WikiPage_name, name, "f");
        __classPrivateFieldSet(this, _WikiPage_subredditName, subredditName, "f");
        __classPrivateFieldSet(this, _WikiPage_content, data.contentMd, "f");
        __classPrivateFieldSet(this, _WikiPage_revisionId, data.revisionId, "f");
        __classPrivateFieldSet(this, _WikiPage_revisionDate, new Date(data.revisionDate), "f");
        __classPrivateFieldSet(this, _WikiPage_revisionReason, data.reason ?? '', "f");
        assertNonNull(data.revisionBy?.data, 'Wiki page author details are missing');
        __classPrivateFieldSet(this, _WikiPage_revisionAuthor, new User(data.revisionBy.data, metadata), "f");
        __classPrivateFieldSet(this, _WikiPage_metadata, metadata, "f");
    }
    /** The name of the page. */
    get name() {
        return __classPrivateFieldGet(this, _WikiPage_name, "f");
    }
    /** The name of the subreddit the page is in. */
    get subredditName() {
        return __classPrivateFieldGet(this, _WikiPage_subredditName, "f");
    }
    /** The Markdown content of the page. */
    get content() {
        return __classPrivateFieldGet(this, _WikiPage_content, "f");
    }
    /** The ID of the revision. */
    get revisionId() {
        return __classPrivateFieldGet(this, _WikiPage_revisionId, "f");
    }
    /** The date of the revision. */
    get revisionDate() {
        return __classPrivateFieldGet(this, _WikiPage_revisionDate, "f");
    }
    /** The reason for the revision. */
    get revisionReason() {
        return __classPrivateFieldGet(this, _WikiPage_revisionReason, "f");
    }
    /** The author of this revision. */
    get revisionAuthor() {
        return __classPrivateFieldGet(this, _WikiPage_revisionAuthor, "f");
    }
    toJSON() {
        return {
            name: __classPrivateFieldGet(this, _WikiPage_name, "f"),
            subredditName: __classPrivateFieldGet(this, _WikiPage_subredditName, "f"),
            content: __classPrivateFieldGet(this, _WikiPage_content, "f"),
            revisionId: __classPrivateFieldGet(this, _WikiPage_revisionId, "f"),
            revisionDate: __classPrivateFieldGet(this, _WikiPage_revisionDate, "f"),
            revisionReason: __classPrivateFieldGet(this, _WikiPage_revisionReason, "f"),
            revisionAuthor: __classPrivateFieldGet(this, _WikiPage_revisionAuthor, "f").toJSON(),
        };
    }
    /** Update this page. */
    async update(content, reason) {
        return WikiPage.updatePage({
            subredditName: __classPrivateFieldGet(this, _WikiPage_subredditName, "f"),
            page: __classPrivateFieldGet(this, _WikiPage_name, "f"),
            content,
            reason,
        }, __classPrivateFieldGet(this, _WikiPage_metadata, "f"));
    }
    /** Get the revisions for this page. */
    async getRevisions(options) {
        return WikiPage.getPageRevisions({
            subredditName: __classPrivateFieldGet(this, _WikiPage_subredditName, "f"),
            page: __classPrivateFieldGet(this, _WikiPage_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _WikiPage_metadata, "f"));
    }
    /** Revert this page to a previous revision. */
    async revertTo(revisionId) {
        return WikiPage.revertPage(__classPrivateFieldGet(this, _WikiPage_subredditName, "f"), __classPrivateFieldGet(this, _WikiPage_name, "f"), revisionId, __classPrivateFieldGet(this, _WikiPage_metadata, "f"));
    }
    /** Get the settings for this page. */
    async getSettings() {
        return WikiPage.getPageSettings(__classPrivateFieldGet(this, _WikiPage_subredditName, "f"), __classPrivateFieldGet(this, _WikiPage_name, "f"), __classPrivateFieldGet(this, _WikiPage_metadata, "f"));
    }
    /** Update the settings for this page. */
    async updateSettings(options) {
        return WikiPage.updatePageSettings({
            subredditName: __classPrivateFieldGet(this, _WikiPage_subredditName, "f"),
            page: __classPrivateFieldGet(this, _WikiPage_name, "f"),
            listed: options.listed,
            permLevel: options.permLevel,
        }, __classPrivateFieldGet(this, _WikiPage_metadata, "f"));
    }
    /** Add an editor to this page. */
    async addEditor(username) {
        return WikiPage.addEditor(__classPrivateFieldGet(this, _WikiPage_subredditName, "f"), __classPrivateFieldGet(this, _WikiPage_name, "f"), username, __classPrivateFieldGet(this, _WikiPage_metadata, "f"));
    }
    /** Remove an editor from this page. */
    async removeEditor(username) {
        return WikiPage.removeEditor(__classPrivateFieldGet(this, _WikiPage_subredditName, "f"), __classPrivateFieldGet(this, _WikiPage_name, "f"), username, __classPrivateFieldGet(this, _WikiPage_metadata, "f"));
    }
    /** @internal */
    static async getPage(subredditName, page, metadata) {
        const client = Devvit.redditAPIPlugins.Wiki;
        const response = await client.GetWikiPage({
            subreddit: subredditName,
            page,
        }, metadata);
        assertNonNull(response.data, 'Failed to get wiki page');
        return new WikiPage(page, subredditName, response.data, metadata);
    }
    /** @internal */
    static async getPages(subredditName, metadata) {
        const client = Devvit.redditAPIPlugins.Wiki;
        const response = await client.GetWikiPages({ subreddit: subredditName }, metadata);
        return response.data || [];
    }
    /** @internal */
    static async createPage(options, metadata) {
        return WikiPage.updatePage(options, metadata);
    }
    /** @internal */
    static async updatePage(options, metadata) {
        const client = Devvit.redditAPIPlugins.Wiki;
        await client.EditWikiPage({
            subreddit: options.subredditName,
            page: options.page,
            content: options.content,
            reason: options.reason ?? '',
        }, metadata);
        return WikiPage.getPage(options.subredditName, options.page, metadata);
    }
    /** @internal */
    static getPageRevisions(options, metadata) {
        const client = Devvit.redditAPIPlugins.Wiki;
        return new Listing({
            hasMore: true,
            after: options.after,
            limit: options.limit,
            pageSize: options.pageSize,
            async fetch(fetchOptions) {
                const response = await client.GetWikiPageRevisions({
                    subreddit: options.subredditName,
                    page: options.page,
                    limit: fetchOptions.limit,
                    after: fetchOptions.after,
                    before: fetchOptions.before,
                }, metadata);
                return wikiPageRevisionListingProtoToWikiPageRevision(response, metadata);
            },
        });
    }
    /** @internal */
    static async revertPage(subredditName, page, revisionId, metadata) {
        const client = Devvit.redditAPIPlugins.Wiki;
        await client.RevertWikiPage({
            subreddit: subredditName,
            page,
            revision: revisionId,
        }, metadata);
    }
    /** @internal */
    static async getPageSettings(subredditName, page, metadata) {
        const client = Devvit.redditAPIPlugins.Wiki;
        const response = await client.GetWikiPageSettings({
            subreddit: subredditName,
            page,
        }, metadata);
        assertNonNull(response.data, 'Failed to get wiki page settings');
        return new WikiPageSettings(response.data, metadata);
    }
    /** @internal */
    static async updatePageSettings(options, metadata) {
        const client = Devvit.redditAPIPlugins.Wiki;
        const response = await client.UpdateWikiPageSettings({
            subreddit: options.subredditName,
            page: options.page,
            listed: options.listed ? 'on' : '',
            permlevel: options.permLevel,
        }, metadata);
        assertNonNull(response.data, 'Failed to update wiki page settings');
        return new WikiPageSettings(response.data, metadata);
    }
    /** @internal */
    static async addEditor(subredditName, page, username, metadata) {
        const client = Devvit.redditAPIPlugins.Wiki;
        await client.AllowEditor({
            act: 'add',
            subreddit: subredditName,
            page,
            username,
        }, metadata);
    }
    /** @internal */
    static async removeEditor(subredditName, page, username, metadata) {
        const client = Devvit.redditAPIPlugins.Wiki;
        await client.AllowEditor({
            act: 'del',
            subreddit: subredditName,
            page,
            username,
        }, metadata);
    }
}
_WikiPage_name = new WeakMap(), _WikiPage_subredditName = new WeakMap(), _WikiPage_content = new WeakMap(), _WikiPage_revisionId = new WeakMap(), _WikiPage_revisionDate = new WeakMap(), _WikiPage_revisionReason = new WeakMap(), _WikiPage_revisionAuthor = new WeakMap(), _WikiPage_metadata = new WeakMap();
export class WikiPageRevision {
    constructor(data, metadata) {
        _WikiPageRevision_id.set(this, void 0);
        _WikiPageRevision_page.set(this, void 0);
        _WikiPageRevision_date.set(this, void 0);
        _WikiPageRevision_author.set(this, void 0);
        _WikiPageRevision_reason.set(this, void 0);
        _WikiPageRevision_hidden.set(this, void 0);
        __classPrivateFieldSet(this, _WikiPageRevision_id, data.id, "f");
        __classPrivateFieldSet(this, _WikiPageRevision_page, data.page, "f");
        __classPrivateFieldSet(this, _WikiPageRevision_date, new Date(data.timestamp), "f");
        assertNonNull(data.author?.data, 'Wiki page revision author details are missing');
        __classPrivateFieldSet(this, _WikiPageRevision_author, new User(data.author.data, metadata), "f");
        __classPrivateFieldSet(this, _WikiPageRevision_reason, data.reason ?? '', "f");
        __classPrivateFieldSet(this, _WikiPageRevision_hidden, data.revisionHidden ?? false, "f");
    }
    get id() {
        return __classPrivateFieldGet(this, _WikiPageRevision_id, "f");
    }
    get page() {
        return __classPrivateFieldGet(this, _WikiPageRevision_page, "f");
    }
    get date() {
        return __classPrivateFieldGet(this, _WikiPageRevision_date, "f");
    }
    get author() {
        return __classPrivateFieldGet(this, _WikiPageRevision_author, "f");
    }
    get reason() {
        return __classPrivateFieldGet(this, _WikiPageRevision_reason, "f");
    }
    get hidden() {
        return __classPrivateFieldGet(this, _WikiPageRevision_hidden, "f");
    }
    toJSON() {
        return {
            id: __classPrivateFieldGet(this, _WikiPageRevision_id, "f"),
            page: __classPrivateFieldGet(this, _WikiPageRevision_page, "f"),
            date: __classPrivateFieldGet(this, _WikiPageRevision_date, "f"),
            author: __classPrivateFieldGet(this, _WikiPageRevision_author, "f").toJSON(),
            reason: __classPrivateFieldGet(this, _WikiPageRevision_reason, "f"),
            hidden: __classPrivateFieldGet(this, _WikiPageRevision_hidden, "f"),
        };
    }
}
_WikiPageRevision_id = new WeakMap(), _WikiPageRevision_page = new WeakMap(), _WikiPageRevision_date = new WeakMap(), _WikiPageRevision_author = new WeakMap(), _WikiPageRevision_reason = new WeakMap(), _WikiPageRevision_hidden = new WeakMap();
export class WikiPageSettings {
    constructor(data, metadata) {
        _WikiPageSettings_listed.set(this, void 0);
        _WikiPageSettings_permLevel.set(this, void 0);
        _WikiPageSettings_editors.set(this, void 0);
        __classPrivateFieldSet(this, _WikiPageSettings_listed, data.listed, "f");
        __classPrivateFieldSet(this, _WikiPageSettings_permLevel, data.permLevel, "f");
        __classPrivateFieldSet(this, _WikiPageSettings_editors, data.editors.map((editor) => {
            assertNonNull(editor.data, 'Wiki page editor details are missing');
            return new User(editor.data, metadata);
        }), "f");
    }
    get listed() {
        return __classPrivateFieldGet(this, _WikiPageSettings_listed, "f");
    }
    get permLevel() {
        return __classPrivateFieldGet(this, _WikiPageSettings_permLevel, "f");
    }
    get editors() {
        return __classPrivateFieldGet(this, _WikiPageSettings_editors, "f");
    }
    toJSON() {
        return {
            listed: __classPrivateFieldGet(this, _WikiPageSettings_listed, "f"),
            permLevel: __classPrivateFieldGet(this, _WikiPageSettings_permLevel, "f"),
            editors: __classPrivateFieldGet(this, _WikiPageSettings_editors, "f").map((editor) => editor.toJSON()),
        };
    }
}
_WikiPageSettings_listed = new WeakMap(), _WikiPageSettings_permLevel = new WeakMap(), _WikiPageSettings_editors = new WeakMap();
function wikiPageRevisionListingProtoToWikiPageRevision(listingProto, metadata) {
    assertNonNull(listingProto.data?.children, 'Wiki page revision listing is missing children');
    const children = listingProto.data.children.map((child) => {
        return new WikiPageRevision(child, metadata);
    });
    return {
        children,
        before: listingProto.data.before,
        after: listingProto.data.after,
    };
}
