var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TxClient_storage, _TxClient_transactionId, _TxClient_metadata, _RedisClient_metadata, _RedisClient_storage;
import { RedisKeyScope } from '@devvit/protos';
import { Devvit } from '../../devvit/Devvit.js';
export class TxClient {
    constructor(storage, transactionId, metadata) {
        _TxClient_storage.set(this, void 0);
        _TxClient_transactionId.set(this, void 0);
        _TxClient_metadata.set(this, void 0);
        __classPrivateFieldSet(this, _TxClient_storage, storage, "f");
        __classPrivateFieldSet(this, _TxClient_transactionId, transactionId, "f");
        __classPrivateFieldSet(this, _TxClient_metadata, metadata, "f");
    }
    async get(key) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Get({ key: key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async multi() {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Multi(__classPrivateFieldGet(this, _TxClient_transactionId, "f"), __classPrivateFieldGet(this, _TxClient_metadata, "f"));
    }
    async set(key, value, options) {
        let expiration;
        if (options?.expiration) {
            expiration = Math.floor((options.expiration.getTime() - Date.now()) / 1000); // convert to seconds
            if (expiration < 1) {
                expiration = 1; // minimum expiration is 1 second, clock skew can cause issues, so let's set 1 second.
            }
        }
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Set({
            key,
            value,
            nx: options?.nx === true,
            xx: options?.xx === true,
            expiration: expiration || 0,
            transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f"),
        }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async del(...keys) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Del({ keys: keys, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async type(key) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Type({ key: key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async exec() {
        const response = await __classPrivateFieldGet(this, _TxClient_storage, "f").Exec(__classPrivateFieldGet(this, _TxClient_transactionId, "f"), __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        // eslint-disable-next-line
        let output = [];
        for (const result of response.response) {
            if (result.members) {
                output.push(result.members);
            }
            else if (result.nil !== undefined) {
                output.push(null);
            }
            else if (result.num !== undefined) {
                output.push(result.num);
            }
            else if (result.values !== undefined) {
                output.push(result.values.values);
            }
            else if (result.str !== undefined) {
                output.push(result.str);
            }
        }
        return output;
    }
    async discard() {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Discard(__classPrivateFieldGet(this, _TxClient_transactionId, "f"), __classPrivateFieldGet(this, _TxClient_metadata, "f"));
    }
    async watch(...keys) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Watch({ keys: keys, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async unwatch() {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Unwatch(__classPrivateFieldGet(this, _TxClient_transactionId, "f"), __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async getRange(key, start, end) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").GetRange({ key, start, end, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async setRange(key, offset, value) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").SetRange({ key, offset, value, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async strlen(key) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Strlen({ key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async mget(keys) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").MGet({ keys, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async mset(keyValues) {
        const kv = Object.entries(keyValues).map(([key, value]) => ({ key, value }));
        await __classPrivateFieldGet(this, _TxClient_storage, "f").MSet({ kv, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async incrBy(key, value) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").IncrBy({ key, value, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async expire(key, seconds) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").Expire({ key, seconds, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async expireTime(key) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").ExpireTime({ key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async zAdd(key, ...members) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").ZAdd({ key, members, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async zCard(key) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").ZCard({ key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async zRange(key, start, stop, options) {
        // eslint-disable-next-line
        let opts = { rev: false, byLex: false, byScore: false, offset: 0, count: 1000 };
        if (options?.reverse) {
            opts.rev = options.reverse;
        }
        if (options?.by === 'lex') {
            opts.byLex = true;
        }
        else if (options?.by === 'score') {
            opts.byScore = true;
        }
        await __classPrivateFieldGet(this, _TxClient_storage, "f").ZRange({
            key: { key: key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") },
            start: start + '',
            stop: stop + '',
            ...opts,
        }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async zRem(key, members) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").ZRem({ key: { key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, members: members }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async zRemRangeByLex(key, min, max) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").ZRemRangeByLex({ key: { key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, min: min, max: max }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async zRemRangeByRank(key, start, stop) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").ZRemRangeByRank({ key: { key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, start: start, stop: stop }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async zRemRangeByScore(key, min, max) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").ZRemRangeByScore({ key: { key, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, min: min, max: max }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async hget(key, field) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").HGet({ key: key, field: field, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async hset(key, fieldValues) {
        const fv = Object.entries(fieldValues).map(([field, value]) => ({ field, value }));
        await __classPrivateFieldGet(this, _TxClient_storage, "f").HSet({ key, fv, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
    async hincrby(key, field, value) {
        await __classPrivateFieldGet(this, _TxClient_storage, "f").HIncrBy({ key, field, value, transactionId: __classPrivateFieldGet(this, _TxClient_transactionId, "f") }, __classPrivateFieldGet(this, _TxClient_metadata, "f"));
        return this;
    }
}
_TxClient_storage = new WeakMap(), _TxClient_transactionId = new WeakMap(), _TxClient_metadata = new WeakMap();
/**
 * This is a subset of the overall Redis API.  You should be able to look up https://redis.io/commands
 * for more details on each command.
 *
 * For the moment, we've implemented a lot of the basic string/number commands, sorted sets, and transactions.
 * This is the most powerful subset and the safest.
 */
export class RedisClient {
    constructor(metadata, storage = undefined, scope = RedisKeyScope.INSTALLATION) {
        _RedisClient_metadata.set(this, void 0);
        _RedisClient_storage.set(this, void 0);
        __classPrivateFieldSet(this, _RedisClient_metadata, metadata, "f");
        __classPrivateFieldSet(this, _RedisClient_storage, storage, "f");
        this.scope = scope;
        this.global =
            scope === RedisKeyScope.INSTALLATION
                ? new RedisClient(__classPrivateFieldGet(this, _RedisClient_metadata, "f"), __classPrivateFieldGet(this, _RedisClient_storage, "f"), RedisKeyScope.GLOBAL)
                : this;
    }
    get storage() {
        return __classPrivateFieldGet(this, _RedisClient_storage, "f") || Devvit.redisPlugin;
    }
    async watch(...keys) {
        const txId = await this.storage.Watch({ keys }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return new TxClient(this.storage, txId, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
    }
    async get(key) {
        const response = await this.storage.Get({ key, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.value ?? undefined : response;
    }
    async set(key, value, options) {
        let expiration;
        if (options?.expiration) {
            expiration = Math.floor((options.expiration.getTime() - Date.now()) / 1000); // convert to seconds
            if (expiration < 1) {
                expiration = 1; // minimum expiration is 1 second, clock skew can cause issues, so let's set 1 second.
            }
        }
        const response = await this.storage.Set({
            key,
            value,
            nx: options?.nx === true && !options.xx,
            xx: options?.xx === true && !options.nx,
            expiration: expiration || 0,
            scope: this.scope,
        }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async del(...keys) {
        await this.storage.Del({ keys, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
    }
    async incrBy(key, value) {
        const response = await this.storage.IncrBy({ key, value, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async getRange(key, start, end) {
        const response = await this.storage.GetRange({ key, start, end, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.value : response;
    }
    async setRange(key, offset, value) {
        const response = await this.storage.SetRange({ key, offset, value, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async strlen(key) {
        const response = await this.storage.Strlen({ key, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async expire(key, seconds) {
        await this.storage.Expire({ key, seconds, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
    }
    async expireTime(key) {
        const response = await this.storage.ExpireTime({ key, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async zAdd(key, ...members) {
        return (await this.storage.ZAdd({ key, members, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"))).value;
    }
    async zRange(key, start, stop, options) {
        // eslint-disable-next-line
        let opts = { rev: false, byLex: false, byScore: false, offset: 0, count: 1000 };
        if (options?.reverse) {
            opts.rev = options.reverse;
        }
        if (options?.by === 'lex') {
            opts.byLex = true;
        }
        else if (options?.by === 'score') {
            opts.byScore = true;
        }
        else {
            // LIMIT requires BYLEX/BYSCORE
            opts.offset = 0;
            opts.count = 0;
        }
        return (await this.storage.ZRange({ key: { key: key }, start: start + '', stop: stop + '', ...opts, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"))).members;
    }
    async zRem(key, members) {
        const response = await this.storage.ZRem({ key: { key }, members, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async zRemRangeByLex(key, min, max) {
        const response = await this.storage.ZRemRangeByLex({ key: { key }, min, max, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async zRemRangeByRank(key, start, stop) {
        const response = await this.storage.ZRemRangeByRank({ key: { key }, start, stop, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async zRemRangeByScore(key, min, max) {
        const response = await this.storage.ZRemRangeByScore({ key: { key }, min, max, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async zScore(key, member) {
        const response = await this.storage.ZScore({ key: { key }, member, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.value : response;
    }
    async zRank(key, member) {
        const response = await this.storage.ZRank({ key: { key }, member, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.value : response;
    }
    async zIncrBy(key, member, value) {
        const response = await this.storage.ZIncrBy({ key, member, value, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.value : response;
    }
    async mget(keys) {
        const response = await this.storage.MGet({ keys, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.values.map((value) => value || null) : response;
    }
    async mset(keyValues) {
        const kv = Object.entries(keyValues).map(([key, value]) => ({ key, value }));
        await this.storage.MSet({ kv, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
    }
    async zCard(key) {
        const response = await this.storage.ZCard({ key, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.value : response;
    }
    async type(key) {
        const response = await this.storage.Type({ key: key, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.value : response;
    }
    async hget(key, field) {
        const response = await this.storage.HGet({ key, field, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.value ?? undefined : response;
    }
    async hset(key, fieldValues) {
        const fv = Object.entries(fieldValues).map(([field, value]) => ({ field, value }));
        const response = await this.storage.HSet({ key, fv, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async hgetall(key) {
        const response = await this.storage.HGetAll({ key, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response !== null ? response.fieldValues : response;
    }
    async hdel(key, fields) {
        const response = await this.storage.HDel({ key, fields, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
    async hscan(key, cursor, pattern, count) {
        const request = { key, cursor, pattern, count, scope: this.scope };
        return await this.storage.HScan(request);
    }
    async hkeys(key) {
        const response = await this.storage.HKeys({ key, scope: this.scope });
        return response !== null ? response.keys : response;
    }
    async hincrby(key, field, value) {
        const response = await this.storage.HIncrBy({ key, field, value, scope: this.scope }, __classPrivateFieldGet(this, _RedisClient_metadata, "f"));
        return response.value;
    }
}
_RedisClient_metadata = new WeakMap(), _RedisClient_storage = new WeakMap();
