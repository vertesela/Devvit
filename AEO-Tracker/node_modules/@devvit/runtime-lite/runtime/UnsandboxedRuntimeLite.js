var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UnsandboxedRuntimeLite_instances, _UnsandboxedRuntimeLite_actor, _UnsandboxedRuntimeLite_aborted, _UnsandboxedRuntimeLite_methodMsgMap, _UnsandboxedRuntimeLite_plugins, _UnsandboxedRuntimeLite_pluginCallId, _UnsandboxedRuntimeLite_pluginReturnHandlers, _UnsandboxedRuntimeLite_config, _UnsandboxedRuntimeLite_extractMessageTypes, _UnsandboxedRuntimeLite_logErr;
import * as protos from '@devvit/protos';
import { inspect } from '@devvit/shared-types/inspect.js';
import { QueueConsole } from '../console/QueueConsole.js';
import { CircuitBreak, isCircuitBreaker } from '../types/CircuitBreaker.js';
import { ActorResponse } from '../types/Commands.js';
import { box } from './RuntimeLite.js';
export class UnsandboxedRuntimeLite {
    /**
     * @arg modules Environment dependencies available via `require(id)` to
     *              bundles loaded. @devvit/protos is provided by default.
     */
    constructor(modules = {}) {
        _UnsandboxedRuntimeLite_instances.add(this);
        _UnsandboxedRuntimeLite_actor.set(this, void 0);
        _UnsandboxedRuntimeLite_aborted.set(this, false);
        _UnsandboxedRuntimeLite_methodMsgMap.set(this, {});
        _UnsandboxedRuntimeLite_plugins.set(this, []);
        _UnsandboxedRuntimeLite_pluginCallId.set(this, 0);
        _UnsandboxedRuntimeLite_pluginReturnHandlers.set(this, {});
        /**
         * Create a Config object used to construct a new Actor with all dependencies stubbed out
         */
        _UnsandboxedRuntimeLite_config.set(this, (assets) => ({
            assets,
            use: (def) => {
                if (__classPrivateFieldGet(this, _UnsandboxedRuntimeLite_plugins, "f").includes(def.fullName)) {
                    const proxy = {};
                    for (const method of Object.values(def.methods)) {
                        proxy[method.name] = async (req, metadata) => {
                            var _a;
                            const id = __classPrivateFieldSet(this, _UnsandboxedRuntimeLite_pluginCallId, (_a = __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_pluginCallId, "f"), ++_a), "f");
                            const handler = new Promise((resolve, reject) => {
                                __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_pluginReturnHandlers, "f")[id] = { resolve, reject };
                            });
                            box.postMessage([
                                ActorResponse.PLUGIN_CALL,
                                id,
                                def.fullName,
                                method.name,
                                req,
                                metadata,
                            ]);
                            return handler;
                        };
                    }
                    return proxy;
                }
                else {
                    const circuitBreaker = {};
                    for (const method of Object.values(def.methods)) {
                        circuitBreaker[method.name] = () => {
                            __classPrivateFieldSet(this, _UnsandboxedRuntimeLite_aborted, true, "f");
                            box.console.logs = [];
                            throw CircuitBreak(method.name);
                        };
                    }
                    return circuitBreaker;
                }
            },
            provides: () => { },
        }));
        /**
         * Cache the Request and Response message classes to use when handling binary messages
         * @param provides From `LinkedBundle.provides`
         */
        _UnsandboxedRuntimeLite_extractMessageTypes.set(this, (provides) => provides.reduce((provideMap, provide) => {
            const protoDefLookup = protos;
            return {
                ...provideMap,
                ...Object.entries(protoDefLookup[provide.name + 'Definition'].methods).reduce((methods, [_, m]) => {
                    const method = m;
                    return {
                        ...methods,
                        [method.name]: {
                            req: method.requestType,
                            res: method.responseType,
                        },
                    };
                }, {}),
            };
        }, {}));
        modules = { '@devvit/protos': protos, ...modules };
        box.require = (module) => modules[module];
        box.fetch = () => {
            __classPrivateFieldSet(this, _UnsandboxedRuntimeLite_aborted, true, "f");
            box.console.logs = [];
            throw CircuitBreak('fetch');
        };
    }
    enableAppLogging() {
        box.console = new QueueConsole();
    }
    getCallState() {
        return { logs: box.console.logs ?? [] };
    }
    async init() {
        box.log('[Unsandboxed Runtime] Init');
    }
    setPluginList(plugins) {
        __classPrivateFieldSet(this, _UnsandboxedRuntimeLite_plugins, plugins, "f");
    }
    loadBundle(bundle) {
        box.console.logs = [];
        const module = {};
        try {
            // eslint-disable-next-line security/detect-eval-with-expression
            eval(bundle.code);
        }
        catch (err) {
            __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_instances, "m", _UnsandboxedRuntimeLite_logErr).call(this, err);
            throw err;
        }
        const config = __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_config, "f").call(this, bundle.assets);
        box.devvit ?? (box.devvit = { config: { assets: config.assets } });
        box.devvit.config = { assets: config.assets };
        try {
            if (!module?.exports?.default)
                throw Error('bundle missing default export');
            __classPrivateFieldSet(this, _UnsandboxedRuntimeLite_actor, new module.exports.default(config), "f");
            __classPrivateFieldSet(this, _UnsandboxedRuntimeLite_methodMsgMap, __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_extractMessageTypes, "f").call(this, bundle.provides), "f");
        }
        catch (err) {
            __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_instances, "m", _UnsandboxedRuntimeLite_logErr).call(this, err);
            throw err;
        }
    }
    /** @arg args A Protobuf message or encoded message. */
    async call(method, args, meta, binary) {
        const { req, res } = __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_methodMsgMap, "f")[method];
        __classPrivateFieldSet(this, _UnsandboxedRuntimeLite_aborted, false, "f");
        box.console.logs = [];
        let value = undefined;
        try {
            let argsObj = args;
            if (binary) {
                argsObj = req.decode(args);
            }
            value = await __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_actor, "f")?.[method]?.(argsObj, meta);
            if (binary) {
                value = res.encode(res.fromJSON(value)).finish();
            }
            if (__classPrivateFieldGet(this, _UnsandboxedRuntimeLite_aborted, "f")) {
                box.console.logs = [];
                throw CircuitBreak(method);
            }
            return { error: undefined, success: true, value };
        }
        catch (err) {
            __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_instances, "m", _UnsandboxedRuntimeLite_logErr).call(this, err);
            return { error: err, success: false, value };
        }
    }
    onPluginResponse(id, result) {
        const handler = __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_pluginReturnHandlers, "f")[id];
        if (result.success) {
            handler.resolve(result.value);
        }
        else {
            handler.reject(result.error);
        }
        delete __classPrivateFieldGet(this, _UnsandboxedRuntimeLite_pluginReturnHandlers, "f")[id];
    }
    quit() {
        box.log('[Unsandboxed Runtime] Quitting');
        box.close();
    }
}
_UnsandboxedRuntimeLite_actor = new WeakMap(), _UnsandboxedRuntimeLite_aborted = new WeakMap(), _UnsandboxedRuntimeLite_methodMsgMap = new WeakMap(), _UnsandboxedRuntimeLite_plugins = new WeakMap(), _UnsandboxedRuntimeLite_pluginCallId = new WeakMap(), _UnsandboxedRuntimeLite_pluginReturnHandlers = new WeakMap(), _UnsandboxedRuntimeLite_config = new WeakMap(), _UnsandboxedRuntimeLite_extractMessageTypes = new WeakMap(), _UnsandboxedRuntimeLite_instances = new WeakSet(), _UnsandboxedRuntimeLite_logErr = function _UnsandboxedRuntimeLite_logErr(err) {
    var _a;
    // Don't log circuit breaks. The runtime operates optimistically. When
    // it fails, all side-effects are rolled back. Logs should not be reported.
    if (!isCircuitBreaker(err)) {
        (_a = box.console).logs ?? (_a.logs = []);
        box.console.logs.push({ method: 'error', args: [inspect(err)] });
    }
};
