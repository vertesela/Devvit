import type { LinkedBundle, Metadata } from '@devvit/protos';
import type { AppLog } from '../console/AppConsole.js';
import type { CallResponse } from '../runtime/RuntimeLite.js';
import type { CircuitBreakCause } from './CircuitBreaker.js';
export declare enum ActorCommand {
    /**
     * Collect and post app console logs in command responses. For a sandboxed
     * app, this would be every console.log() call made in the VM. When disabled,
     * logs are present but empty.
     */
    ENABLE_APP_LOGGING = "enableAppLogging",
    /** Enable runtime debug logs. */
    ENABLE_DEBUG_LOGGING = "enableDebugLogging",
    ENABLE_SANDBOX = "enableSandbox",
    ENABLE_PLUGINS = "enablePlugins",
    LOAD_BUNDLE = "loadBundle",
    CALL = "call",
    PLUGIN_RESPONSE = "pluginResponse",
    QUIT = "quit"
}
type EnableAppLoggingCommand = [ActorCommand.ENABLE_APP_LOGGING];
type EnableDebugLoggingCommand = [ActorCommand.ENABLE_DEBUG_LOGGING];
type EnableSandboxCommand = [ActorCommand.ENABLE_SANDBOX];
type EnablePluginsCommand = [cmd: ActorCommand.ENABLE_PLUGINS, plugins: string[]];
type LoadBundleCommand = [ActorCommand.LOAD_BUNDLE, LinkedBundle];
/** See RuntimeLite.call(). */
type CallCommand = [
    cmd: ActorCommand.CALL,
    id: number,
    method: string,
    args: unknown,
    meta: Metadata,
    binary: false
] | [
    cmd: ActorCommand.CALL,
    id: number,
    method: string,
    argsB64: Uint8Array,
    metaJSON: string,
    binary: true
];
type PluginResponseCommand = [
    cmd: ActorCommand.PLUGIN_RESPONSE,
    id: number,
    response: CallResponse
];
type QuitCommand = [ActorCommand.QUIT];
export type CommandMessageLike = EnableAppLoggingCommand | EnableDebugLoggingCommand | EnablePluginsCommand | EnableSandboxCommand | LoadBundleCommand | CallCommand | PluginResponseCommand | QuitCommand;
export declare enum ActorResponse {
    READY = "ready",
    SANDBOX_LOADED = "sandboxLoaded",
    PLUGINS_CONFIGURED = "pluginsConfigured",
    BUNDLE_LOADED = "bundleLoaded",
    BUNDLE_LOAD_FAILED = "bundleLoadFailed",
    RETURN = "return",
    ERROR = "error",
    CIRCUIT_BREAKER = "circuitBreaker",
    PLUGIN_CALL = "pluginCall",
    /**
     * An un-awaited promise rejected. This response has no originating request.
     */
    UNHANDLED_REJECTION = "unhandledRejection"
}
type ReadyResponse = [cmd: ActorResponse.READY];
type SandboxLoadedResponse = [cmd: ActorResponse.SANDBOX_LOADED];
type PluginsConfiguredResponse = [cmd: ActorResponse.PLUGINS_CONFIGURED];
type BundleLoadedResponse = [cmd: ActorResponse.BUNDLE_LOADED, logs: AppLog[]];
type BundleLoadFailedResponse = [
    cmd: ActorResponse.BUNDLE_LOAD_FAILED,
    id: unknown,
    error: Error,
    logs: AppLog[]
];
type ReturnValueResponse = [
    cmd: ActorResponse.RETURN,
    id: number,
    response: Uint8Array | unknown,
    logs: AppLog[]
];
type ErrorResponse = [cmd: ActorResponse.ERROR, id: number, error: Error, logs: AppLog[]];
type CircuitBreakCallResponse = [
    cmd: ActorResponse.CIRCUIT_BREAKER,
    id: number,
    response: Uint8Array | undefined,
    cause: CircuitBreakCause
];
type PluginCallResponse = [
    cmd: ActorResponse.PLUGIN_CALL,
    id: number,
    serviceName: string,
    method: string,
    req: unknown,
    meta: unknown
];
type UnhandledRejectionResponse = [
    cmd: ActorResponse.UNHANDLED_REJECTION,
    id: unknown,
    error: Error | string | undefined,
    logs: AppLog[]
];
export type ResponseMessageLike = ReadyResponse | PluginsConfiguredResponse | SandboxLoadedResponse | BundleLoadedResponse | BundleLoadFailedResponse | ReturnValueResponse | ErrorResponse | CircuitBreakCallResponse | PluginCallResponse | UnhandledRejectionResponse;
export {};
//# sourceMappingURL=Commands.d.ts.map