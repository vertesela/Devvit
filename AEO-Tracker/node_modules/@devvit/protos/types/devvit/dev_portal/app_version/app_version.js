/**
 * #app_version.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Int32Value, StringValue } from '../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
import { Bundle } from '../../plugin/buildpack/buildpack_common.js';
import { LinkedBundle } from '../../runtime/bundle.js';
import { ActorTypeInfo } from '../actor/actor_type.js';
import { AppInfo } from '../app/info/app_info.js';
import { InstallationInfo } from '../installation/installation.js';
import { AppVersionInfo, computePoolFromJSON, computePoolToJSON, installationTypeFromJSON, installationTypeToJSON, OptionalVersionVisibility, reviewStatusFromJSON, reviewStatusToJSON, versionVisibilityFromJSON, versionVisibilityToJSON, } from './info/app_version_info.js';
function createBaseAppVersionCreationRequest() {
    return {
        appId: "",
        visibility: 0,
        validInstallTypes: [],
        majorVersion: 0,
        minorVersion: 0,
        patchVersion: 0,
        prereleaseVersion: undefined,
        actorBundles: [],
        about: "",
    };
}
export const AppVersionCreationRequest = {
    $type: "devvit.dev_portal.app_version.AppVersionCreationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.appId !== "") {
            writer.uint32(10).string(message.appId);
        }
        if (message.visibility !== 0) {
            writer.uint32(16).int32(message.visibility);
        }
        writer.uint32(26).fork();
        for (const v of message.validInstallTypes) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.majorVersion !== 0) {
            writer.uint32(32).int32(message.majorVersion);
        }
        if (message.minorVersion !== 0) {
            writer.uint32(40).int32(message.minorVersion);
        }
        if (message.patchVersion !== 0) {
            writer.uint32(48).int32(message.patchVersion);
        }
        if (message.prereleaseVersion !== undefined) {
            Int32Value.encode({ value: message.prereleaseVersion }, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.actorBundles) {
            Bundle.encode(v, writer.uint32(66).fork()).ldelim();
        }
        if (message.about !== "") {
            writer.uint32(74).string(message.about);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppVersionCreationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.appId = reader.string();
                    break;
                case 2:
                    message.visibility = reader.int32();
                    break;
                case 3:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.validInstallTypes.push(reader.int32());
                        }
                    }
                    else {
                        message.validInstallTypes.push(reader.int32());
                    }
                    break;
                case 4:
                    message.majorVersion = reader.int32();
                    break;
                case 5:
                    message.minorVersion = reader.int32();
                    break;
                case 6:
                    message.patchVersion = reader.int32();
                    break;
                case 7:
                    message.prereleaseVersion = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.actorBundles.push(Bundle.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.about = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            appId: isSet(object.appId) ? String(object.appId) : "",
            visibility: isSet(object.visibility) ? versionVisibilityFromJSON(object.visibility) : 0,
            validInstallTypes: Array.isArray(object?.validInstallTypes)
                ? object.validInstallTypes.map((e) => installationTypeFromJSON(e))
                : [],
            majorVersion: isSet(object.majorVersion) ? Number(object.majorVersion) : 0,
            minorVersion: isSet(object.minorVersion) ? Number(object.minorVersion) : 0,
            patchVersion: isSet(object.patchVersion) ? Number(object.patchVersion) : 0,
            prereleaseVersion: isSet(object.prereleaseVersion) ? Number(object.prereleaseVersion) : undefined,
            actorBundles: Array.isArray(object?.actorBundles) ? object.actorBundles.map((e) => Bundle.fromJSON(e)) : [],
            about: isSet(object.about) ? String(object.about) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.appId !== undefined && (obj.appId = message.appId);
        message.visibility !== undefined && (obj.visibility = versionVisibilityToJSON(message.visibility));
        if (message.validInstallTypes) {
            obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
        }
        else {
            obj.validInstallTypes = [];
        }
        message.majorVersion !== undefined && (obj.majorVersion = Math.round(message.majorVersion));
        message.minorVersion !== undefined && (obj.minorVersion = Math.round(message.minorVersion));
        message.patchVersion !== undefined && (obj.patchVersion = Math.round(message.patchVersion));
        message.prereleaseVersion !== undefined && (obj.prereleaseVersion = message.prereleaseVersion);
        if (message.actorBundles) {
            obj.actorBundles = message.actorBundles.map((e) => e ? Bundle.toJSON(e) : undefined);
        }
        else {
            obj.actorBundles = [];
        }
        message.about !== undefined && (obj.about = message.about);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppVersionCreationRequest();
        message.appId = object.appId ?? "";
        message.visibility = object.visibility ?? 0;
        message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
        message.majorVersion = object.majorVersion ?? 0;
        message.minorVersion = object.minorVersion ?? 0;
        message.patchVersion = object.patchVersion ?? 0;
        message.prereleaseVersion = object.prereleaseVersion ?? undefined;
        message.actorBundles = object.actorBundles?.map((e) => Bundle.fromPartial(e)) || [];
        message.about = object.about ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.AppVersionCreationRequest", AppVersionCreationRequest);
function createBaseAppSlugAndVersion() {
    return { slug: "", version: "" };
}
export const AppSlugAndVersion = {
    $type: "devvit.dev_portal.app_version.AppSlugAndVersion",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== "") {
            writer.uint32(10).string(message.slug);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppSlugAndVersion();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slug = reader.string();
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            slug: isSet(object.slug) ? String(object.slug) : "",
            version: isSet(object.version) ? String(object.version) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.slug !== undefined && (obj.slug = message.slug);
        message.version !== undefined && (obj.version = message.version);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppSlugAndVersion();
        message.slug = object.slug ?? "";
        message.version = object.version ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.AppSlugAndVersion", AppSlugAndVersion);
function createBaseAppVersionUpdateRequest() {
    return { id: "", visibility: undefined, validInstallTypes: [], about: undefined, pool: 0, reviewStatus: undefined };
}
export const AppVersionUpdateRequest = {
    $type: "devvit.dev_portal.app_version.AppVersionUpdateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.visibility !== undefined) {
            OptionalVersionVisibility.encode(message.visibility, writer.uint32(18).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.validInstallTypes) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.about !== undefined) {
            StringValue.encode({ value: message.about }, writer.uint32(42).fork()).ldelim();
        }
        if (message.pool !== 0) {
            writer.uint32(48).int32(message.pool);
        }
        if (message.reviewStatus !== undefined) {
            writer.uint32(56).int32(message.reviewStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppVersionUpdateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.visibility = OptionalVersionVisibility.decode(reader, reader.uint32());
                    break;
                case 4:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.validInstallTypes.push(reader.int32());
                        }
                    }
                    else {
                        message.validInstallTypes.push(reader.int32());
                    }
                    break;
                case 5:
                    message.about = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.pool = reader.int32();
                    break;
                case 7:
                    message.reviewStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            visibility: isSet(object.visibility) ? OptionalVersionVisibility.fromJSON(object.visibility) : undefined,
            validInstallTypes: Array.isArray(object?.validInstallTypes)
                ? object.validInstallTypes.map((e) => installationTypeFromJSON(e))
                : [],
            about: isSet(object.about) ? String(object.about) : undefined,
            pool: isSet(object.pool) ? computePoolFromJSON(object.pool) : 0,
            reviewStatus: isSet(object.reviewStatus) ? reviewStatusFromJSON(object.reviewStatus) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.visibility !== undefined &&
            (obj.visibility = message.visibility ? OptionalVersionVisibility.toJSON(message.visibility) : undefined);
        if (message.validInstallTypes) {
            obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
        }
        else {
            obj.validInstallTypes = [];
        }
        message.about !== undefined && (obj.about = message.about);
        message.pool !== undefined && (obj.pool = computePoolToJSON(message.pool));
        message.reviewStatus !== undefined &&
            (obj.reviewStatus = message.reviewStatus !== undefined ? reviewStatusToJSON(message.reviewStatus) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppVersionUpdateRequest();
        message.id = object.id ?? "";
        message.visibility = (object.visibility !== undefined && object.visibility !== null)
            ? OptionalVersionVisibility.fromPartial(object.visibility)
            : undefined;
        message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
        message.about = object.about ?? undefined;
        message.pool = object.pool ?? 0;
        message.reviewStatus = object.reviewStatus ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.AppVersionUpdateRequest", AppVersionUpdateRequest);
function createBaseValidInstallLocationsRequest() {
    return { id: "", pageInfo: [] };
}
export const ValidInstallLocationsRequest = {
    $type: "devvit.dev_portal.app_version.ValidInstallLocationsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        for (const v of message.pageInfo) {
            InstallLocationPageInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidInstallLocationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.pageInfo.push(InstallLocationPageInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            pageInfo: Array.isArray(object?.pageInfo)
                ? object.pageInfo.map((e) => InstallLocationPageInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        if (message.pageInfo) {
            obj.pageInfo = message.pageInfo.map((e) => e ? InstallLocationPageInfo.toJSON(e) : undefined);
        }
        else {
            obj.pageInfo = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseValidInstallLocationsRequest();
        message.id = object.id ?? "";
        message.pageInfo = object.pageInfo?.map((e) => InstallLocationPageInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.ValidInstallLocationsRequest", ValidInstallLocationsRequest);
function createBaseInstallLocationPageInfo() {
    return { type: 0, before: undefined, after: undefined };
}
export const InstallLocationPageInfo = {
    $type: "devvit.dev_portal.app_version.InstallLocationPageInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.before !== undefined) {
            writer.uint32(18).string(message.before);
        }
        if (message.after !== undefined) {
            writer.uint32(26).string(message.after);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallLocationPageInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.before = reader.string();
                    break;
                case 3:
                    message.after = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            before: isSet(object.before) ? String(object.before) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = installationTypeToJSON(message.type));
        message.before !== undefined && (obj.before = message.before);
        message.after !== undefined && (obj.after = message.after);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallLocationPageInfo();
        message.type = object.type ?? 0;
        message.before = object.before ?? undefined;
        message.after = object.after ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.InstallLocationPageInfo", InstallLocationPageInfo);
function createBaseFullAppVersionInfo() {
    return { appVersion: undefined, app: undefined, actorTypes: [], installations: [] };
}
export const FullAppVersionInfo = {
    $type: "devvit.dev_portal.app_version.FullAppVersionInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.appVersion !== undefined) {
            AppVersionInfo.encode(message.appVersion, writer.uint32(10).fork()).ldelim();
        }
        if (message.app !== undefined) {
            AppInfo.encode(message.app, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.actorTypes) {
            ActorTypeInfo.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.installations) {
            InstallationInfo.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullAppVersionInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.app = AppInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.actorTypes.push(ActorTypeInfo.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.installations.push(InstallationInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            appVersion: isSet(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : undefined,
            app: isSet(object.app) ? AppInfo.fromJSON(object.app) : undefined,
            actorTypes: Array.isArray(object?.actorTypes) ? object.actorTypes.map((e) => ActorTypeInfo.fromJSON(e)) : [],
            installations: Array.isArray(object?.installations)
                ? object.installations.map((e) => InstallationInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.appVersion !== undefined &&
            (obj.appVersion = message.appVersion ? AppVersionInfo.toJSON(message.appVersion) : undefined);
        message.app !== undefined && (obj.app = message.app ? AppInfo.toJSON(message.app) : undefined);
        if (message.actorTypes) {
            obj.actorTypes = message.actorTypes.map((e) => e ? ActorTypeInfo.toJSON(e) : undefined);
        }
        else {
            obj.actorTypes = [];
        }
        if (message.installations) {
            obj.installations = message.installations.map((e) => e ? InstallationInfo.toJSON(e) : undefined);
        }
        else {
            obj.installations = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFullAppVersionInfo();
        message.appVersion = (object.appVersion !== undefined && object.appVersion !== null)
            ? AppVersionInfo.fromPartial(object.appVersion)
            : undefined;
        message.app = (object.app !== undefined && object.app !== null) ? AppInfo.fromPartial(object.app) : undefined;
        message.actorTypes = object.actorTypes?.map((e) => ActorTypeInfo.fromPartial(e)) || [];
        message.installations = object.installations?.map((e) => InstallationInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.FullAppVersionInfo", FullAppVersionInfo);
function createBaseValidInstallLocationsResponse() {
    return { locations: [] };
}
export const ValidInstallLocationsResponse = {
    $type: "devvit.dev_portal.app_version.ValidInstallLocationsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.locations) {
            InstallLocationInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidInstallLocationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.locations.push(InstallLocationInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            locations: Array.isArray(object?.locations)
                ? object.locations.map((e) => InstallLocationInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.locations) {
            obj.locations = message.locations.map((e) => e ? InstallLocationInfo.toJSON(e) : undefined);
        }
        else {
            obj.locations = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseValidInstallLocationsResponse();
        message.locations = object.locations?.map((e) => InstallLocationInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.ValidInstallLocationsResponse", ValidInstallLocationsResponse);
function createBaseInstallLocationInfo() {
    return { type: 0, locations: [], pageInfo: undefined };
}
export const InstallLocationInfo = {
    $type: "devvit.dev_portal.app_version.InstallLocationInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        for (const v of message.locations) {
            InstallLocationDetails.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pageInfo !== undefined) {
            PageInfo.encode(message.pageInfo, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallLocationInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.locations.push(InstallLocationDetails.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pageInfo = PageInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            locations: Array.isArray(object?.locations)
                ? object.locations.map((e) => InstallLocationDetails.fromJSON(e))
                : [],
            pageInfo: isSet(object.pageInfo) ? PageInfo.fromJSON(object.pageInfo) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = installationTypeToJSON(message.type));
        if (message.locations) {
            obj.locations = message.locations.map((e) => e ? InstallLocationDetails.toJSON(e) : undefined);
        }
        else {
            obj.locations = [];
        }
        message.pageInfo !== undefined && (obj.pageInfo = message.pageInfo ? PageInfo.toJSON(message.pageInfo) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallLocationInfo();
        message.type = object.type ?? 0;
        message.locations = object.locations?.map((e) => InstallLocationDetails.fromPartial(e)) || [];
        message.pageInfo = (object.pageInfo !== undefined && object.pageInfo !== null)
            ? PageInfo.fromPartial(object.pageInfo)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.InstallLocationInfo", InstallLocationInfo);
function createBaseInstallLocationDetails() {
    return { thingId: "", name: "", existingInstallId: undefined, icon: undefined };
}
export const InstallLocationDetails = {
    $type: "devvit.dev_portal.app_version.InstallLocationDetails",
    encode(message, writer = _m0.Writer.create()) {
        if (message.thingId !== "") {
            writer.uint32(10).string(message.thingId);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.existingInstallId !== undefined) {
            StringValue.encode({ value: message.existingInstallId }, writer.uint32(26).fork()).ldelim();
        }
        if (message.icon !== undefined) {
            StringValue.encode({ value: message.icon }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallLocationDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.thingId = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.existingInstallId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.icon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            thingId: isSet(object.thingId) ? String(object.thingId) : "",
            name: isSet(object.name) ? String(object.name) : "",
            existingInstallId: isSet(object.existingInstallId) ? String(object.existingInstallId) : undefined,
            icon: isSet(object.icon) ? String(object.icon) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.thingId !== undefined && (obj.thingId = message.thingId);
        message.name !== undefined && (obj.name = message.name);
        message.existingInstallId !== undefined && (obj.existingInstallId = message.existingInstallId);
        message.icon !== undefined && (obj.icon = message.icon);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallLocationDetails();
        message.thingId = object.thingId ?? "";
        message.name = object.name ?? "";
        message.existingInstallId = object.existingInstallId ?? undefined;
        message.icon = object.icon ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.InstallLocationDetails", InstallLocationDetails);
function createBasePageInfo() {
    return { hasNextPage: false, hasPreviousPage: false, startCursor: "", endCursor: "" };
}
export const PageInfo = {
    $type: "devvit.dev_portal.app_version.PageInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.hasNextPage === true) {
            writer.uint32(8).bool(message.hasNextPage);
        }
        if (message.hasPreviousPage === true) {
            writer.uint32(16).bool(message.hasPreviousPage);
        }
        if (message.startCursor !== "") {
            writer.uint32(26).string(message.startCursor);
        }
        if (message.endCursor !== "") {
            writer.uint32(34).string(message.endCursor);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hasNextPage = reader.bool();
                    break;
                case 2:
                    message.hasPreviousPage = reader.bool();
                    break;
                case 3:
                    message.startCursor = reader.string();
                    break;
                case 4:
                    message.endCursor = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            hasNextPage: isSet(object.hasNextPage) ? Boolean(object.hasNextPage) : false,
            hasPreviousPage: isSet(object.hasPreviousPage) ? Boolean(object.hasPreviousPage) : false,
            startCursor: isSet(object.startCursor) ? String(object.startCursor) : "",
            endCursor: isSet(object.endCursor) ? String(object.endCursor) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.hasNextPage !== undefined && (obj.hasNextPage = message.hasNextPage);
        message.hasPreviousPage !== undefined && (obj.hasPreviousPage = message.hasPreviousPage);
        message.startCursor !== undefined && (obj.startCursor = message.startCursor);
        message.endCursor !== undefined && (obj.endCursor = message.endCursor);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePageInfo();
        message.hasNextPage = object.hasNextPage ?? false;
        message.hasPreviousPage = object.hasPreviousPage ?? false;
        message.startCursor = object.startCursor ?? "";
        message.endCursor = object.endCursor ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.PageInfo", PageInfo);
function createBaseGetAppVersionBundleResponse() {
    return { actorBundles: [] };
}
export const GetAppVersionBundleResponse = {
    $type: "devvit.dev_portal.app_version.GetAppVersionBundleResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actorBundles) {
            GetAppVersionBundleResponse_BundleInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAppVersionBundleResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actorBundles.push(GetAppVersionBundleResponse_BundleInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actorBundles: Array.isArray(object?.actorBundles)
                ? object.actorBundles.map((e) => GetAppVersionBundleResponse_BundleInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.actorBundles) {
            obj.actorBundles = message.actorBundles.map((e) => e ? GetAppVersionBundleResponse_BundleInfo.toJSON(e) : undefined);
        }
        else {
            obj.actorBundles = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetAppVersionBundleResponse();
        message.actorBundles = object.actorBundles?.map((e) => GetAppVersionBundleResponse_BundleInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.GetAppVersionBundleResponse", GetAppVersionBundleResponse);
function createBaseGetAppVersionBundleResponse_BundleInfo() {
    return { actor: "", bundle: undefined };
}
export const GetAppVersionBundleResponse_BundleInfo = {
    $type: "devvit.dev_portal.app_version.GetAppVersionBundleResponse.BundleInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actor !== "") {
            writer.uint32(10).string(message.actor);
        }
        if (message.bundle !== undefined) {
            LinkedBundle.encode(message.bundle, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAppVersionBundleResponse_BundleInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actor = reader.string();
                    break;
                case 2:
                    message.bundle = LinkedBundle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actor: isSet(object.actor) ? String(object.actor) : "",
            bundle: isSet(object.bundle) ? LinkedBundle.fromJSON(object.bundle) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.actor !== undefined && (obj.actor = message.actor);
        message.bundle !== undefined && (obj.bundle = message.bundle ? LinkedBundle.toJSON(message.bundle) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetAppVersionBundleResponse_BundleInfo();
        message.actor = object.actor ?? "";
        message.bundle = (object.bundle !== undefined && object.bundle !== null)
            ? LinkedBundle.fromPartial(object.bundle)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.GetAppVersionBundleResponse.BundleInfo", GetAppVersionBundleResponse_BundleInfo);
function isSet(value) {
    return value !== null && value !== undefined;
}
