/**
 * #installation.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Struct } from '../../../google/protobuf/struct.js';
import { Timestamp } from '../../../google/protobuf/timestamp.js';
import { BoolValue, StringValue } from '../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
import { thingTypeFromJSON, thingTypeToJSON } from '../../reddit/thing_type.js';
import { AppInfo } from '../app/info/app_info.js';
import { AppVersionInfo, installationTypeFromJSON, installationTypeToJSON, } from '../app_version/info/app_version_info.js';
export var UpgradeStrategy;
(function (UpgradeStrategy) {
    UpgradeStrategy[UpgradeStrategy["MANUAL"] = 0] = "MANUAL";
    UpgradeStrategy[UpgradeStrategy["AUTOMATIC"] = 1] = "AUTOMATIC";
    UpgradeStrategy[UpgradeStrategy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(UpgradeStrategy || (UpgradeStrategy = {}));
export function upgradeStrategyFromJSON(object) {
    switch (object) {
        case 0:
        case "MANUAL":
            return UpgradeStrategy.MANUAL;
        case 1:
        case "AUTOMATIC":
            return UpgradeStrategy.AUTOMATIC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return UpgradeStrategy.UNRECOGNIZED;
    }
}
export function upgradeStrategyToJSON(object) {
    switch (object) {
        case UpgradeStrategy.MANUAL:
            return 0;
        case UpgradeStrategy.AUTOMATIC:
            return 1;
        case UpgradeStrategy.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var InstallationHistoryEventName;
(function (InstallationHistoryEventName) {
    InstallationHistoryEventName[InstallationHistoryEventName["INSTALLED"] = 0] = "INSTALLED";
    InstallationHistoryEventName[InstallationHistoryEventName["UNINSTALLED"] = 1] = "UNINSTALLED";
    InstallationHistoryEventName[InstallationHistoryEventName["UPGRADED"] = 2] = "UPGRADED";
    InstallationHistoryEventName[InstallationHistoryEventName["UPDATED"] = 3] = "UPDATED";
    InstallationHistoryEventName[InstallationHistoryEventName["BANNED"] = 4] = "BANNED";
    InstallationHistoryEventName[InstallationHistoryEventName["UNBANNED"] = 5] = "UNBANNED";
    InstallationHistoryEventName[InstallationHistoryEventName["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InstallationHistoryEventName || (InstallationHistoryEventName = {}));
export function installationHistoryEventNameFromJSON(object) {
    switch (object) {
        case 0:
        case "INSTALLED":
            return InstallationHistoryEventName.INSTALLED;
        case 1:
        case "UNINSTALLED":
            return InstallationHistoryEventName.UNINSTALLED;
        case 2:
        case "UPGRADED":
            return InstallationHistoryEventName.UPGRADED;
        case 3:
        case "UPDATED":
            return InstallationHistoryEventName.UPDATED;
        case 4:
        case "BANNED":
            return InstallationHistoryEventName.BANNED;
        case 5:
        case "UNBANNED":
            return InstallationHistoryEventName.UNBANNED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return InstallationHistoryEventName.UNRECOGNIZED;
    }
}
export function installationHistoryEventNameToJSON(object) {
    switch (object) {
        case InstallationHistoryEventName.INSTALLED:
            return 0;
        case InstallationHistoryEventName.UNINSTALLED:
            return 1;
        case InstallationHistoryEventName.UPGRADED:
            return 2;
        case InstallationHistoryEventName.UPDATED:
            return 3;
        case InstallationHistoryEventName.BANNED:
            return 4;
        case InstallationHistoryEventName.UNBANNED:
            return 5;
        case InstallationHistoryEventName.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseOptionalUpgradeStrategy() {
    return { value: 0 };
}
export const OptionalUpgradeStrategy = {
    $type: "devvit.dev_portal.installation.OptionalUpgradeStrategy",
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== 0) {
            writer.uint32(8).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOptionalUpgradeStrategy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? upgradeStrategyFromJSON(object.value) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = upgradeStrategyToJSON(message.value));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseOptionalUpgradeStrategy();
        message.value = object.value ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.OptionalUpgradeStrategy", OptionalUpgradeStrategy);
function createBaseInstallationCreationRequest() {
    return {
        appVersionId: "",
        runAs: undefined,
        type: 0,
        location: "",
        upgradeStrategy: 0,
        upgradeStrategyConfig: undefined,
    };
}
export const InstallationCreationRequest = {
    $type: "devvit.dev_portal.installation.InstallationCreationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.appVersionId !== "") {
            writer.uint32(10).string(message.appVersionId);
        }
        if (message.runAs !== undefined) {
            StringValue.encode({ value: message.runAs }, writer.uint32(26).fork()).ldelim();
        }
        if (message.type !== 0) {
            writer.uint32(32).int32(message.type);
        }
        if (message.location !== "") {
            writer.uint32(42).string(message.location);
        }
        if (message.upgradeStrategy !== 0) {
            writer.uint32(48).int32(message.upgradeStrategy);
        }
        if (message.upgradeStrategyConfig !== undefined) {
            Struct.encode(Struct.wrap(message.upgradeStrategyConfig), writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationCreationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.appVersionId = reader.string();
                    break;
                case 3:
                    message.runAs = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                case 5:
                    message.location = reader.string();
                    break;
                case 6:
                    message.upgradeStrategy = reader.int32();
                    break;
                case 7:
                    message.upgradeStrategyConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            appVersionId: isSet(object.appVersionId) ? String(object.appVersionId) : "",
            runAs: isSet(object.runAs) ? String(object.runAs) : undefined,
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            location: isSet(object.location) ? String(object.location) : "",
            upgradeStrategy: isSet(object.upgradeStrategy) ? upgradeStrategyFromJSON(object.upgradeStrategy) : 0,
            upgradeStrategyConfig: isObject(object.upgradeStrategyConfig) ? object.upgradeStrategyConfig : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.appVersionId !== undefined && (obj.appVersionId = message.appVersionId);
        message.runAs !== undefined && (obj.runAs = message.runAs);
        message.type !== undefined && (obj.type = installationTypeToJSON(message.type));
        message.location !== undefined && (obj.location = message.location);
        message.upgradeStrategy !== undefined && (obj.upgradeStrategy = upgradeStrategyToJSON(message.upgradeStrategy));
        message.upgradeStrategyConfig !== undefined && (obj.upgradeStrategyConfig = message.upgradeStrategyConfig);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationCreationRequest();
        message.appVersionId = object.appVersionId ?? "";
        message.runAs = object.runAs ?? undefined;
        message.type = object.type ?? 0;
        message.location = object.location ?? "";
        message.upgradeStrategy = object.upgradeStrategy ?? 0;
        message.upgradeStrategyConfig = object.upgradeStrategyConfig ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationCreationRequest", InstallationCreationRequest);
function createBaseInstallationUpdateRequest() {
    return {
        id: "",
        runAs: undefined,
        upgradeStrategy: undefined,
        upgradeStrategyConfig: undefined,
        isEnabled: undefined,
    };
}
export const InstallationUpdateRequest = {
    $type: "devvit.dev_portal.installation.InstallationUpdateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.runAs !== undefined) {
            StringValue.encode({ value: message.runAs }, writer.uint32(26).fork()).ldelim();
        }
        if (message.upgradeStrategy !== undefined) {
            OptionalUpgradeStrategy.encode(message.upgradeStrategy, writer.uint32(34).fork()).ldelim();
        }
        if (message.upgradeStrategyConfig !== undefined) {
            Struct.encode(Struct.wrap(message.upgradeStrategyConfig), writer.uint32(42).fork()).ldelim();
        }
        if (message.isEnabled !== undefined) {
            BoolValue.encode({ value: message.isEnabled }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationUpdateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 3:
                    message.runAs = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.upgradeStrategy = OptionalUpgradeStrategy.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.upgradeStrategyConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.isEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            runAs: isSet(object.runAs) ? String(object.runAs) : undefined,
            upgradeStrategy: isSet(object.upgradeStrategy)
                ? OptionalUpgradeStrategy.fromJSON(object.upgradeStrategy)
                : undefined,
            upgradeStrategyConfig: isObject(object.upgradeStrategyConfig) ? object.upgradeStrategyConfig : undefined,
            isEnabled: isSet(object.isEnabled) ? Boolean(object.isEnabled) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.runAs !== undefined && (obj.runAs = message.runAs);
        message.upgradeStrategy !== undefined && (obj.upgradeStrategy = message.upgradeStrategy
            ? OptionalUpgradeStrategy.toJSON(message.upgradeStrategy)
            : undefined);
        message.upgradeStrategyConfig !== undefined && (obj.upgradeStrategyConfig = message.upgradeStrategyConfig);
        message.isEnabled !== undefined && (obj.isEnabled = message.isEnabled);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationUpdateRequest();
        message.id = object.id ?? "";
        message.runAs = object.runAs ?? undefined;
        message.upgradeStrategy = (object.upgradeStrategy !== undefined && object.upgradeStrategy !== null)
            ? OptionalUpgradeStrategy.fromPartial(object.upgradeStrategy)
            : undefined;
        message.upgradeStrategyConfig = object.upgradeStrategyConfig ?? undefined;
        message.isEnabled = object.isEnabled ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationUpdateRequest", InstallationUpdateRequest);
function createBaseInstallationUpgradeRequest() {
    return { id: "", appVersionId: undefined };
}
export const InstallationUpgradeRequest = {
    $type: "devvit.dev_portal.installation.InstallationUpgradeRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.appVersionId !== undefined) {
            StringValue.encode({ value: message.appVersionId }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationUpgradeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.appVersionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            appVersionId: isSet(object.appVersionId) ? String(object.appVersionId) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.appVersionId !== undefined && (obj.appVersionId = message.appVersionId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationUpgradeRequest();
        message.id = object.id ?? "";
        message.appVersionId = object.appVersionId ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationUpgradeRequest", InstallationUpgradeRequest);
function createBaseInstallationUpgradeManyRequest() {
    return { ids: [], appVersionId: "" };
}
export const InstallationUpgradeManyRequest = {
    $type: "devvit.dev_portal.installation.InstallationUpgradeManyRequest",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.ids) {
            writer.uint32(10).string(v);
        }
        if (message.appVersionId !== "") {
            writer.uint32(18).string(message.appVersionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationUpgradeManyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ids.push(reader.string());
                    break;
                case 2:
                    message.appVersionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            ids: Array.isArray(object?.ids) ? object.ids.map((e) => String(e)) : [],
            appVersionId: isSet(object.appVersionId) ? String(object.appVersionId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids) {
            obj.ids = message.ids.map((e) => e);
        }
        else {
            obj.ids = [];
        }
        message.appVersionId !== undefined && (obj.appVersionId = message.appVersionId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationUpgradeManyRequest();
        message.ids = object.ids?.map((e) => e) || [];
        message.appVersionId = object.appVersionId ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationUpgradeManyRequest", InstallationUpgradeManyRequest);
function createBaseGetByAppNameAndInstallLocationRequest() {
    return { slug: "", type: 0, location: "" };
}
export const GetByAppNameAndInstallLocationRequest = {
    $type: "devvit.dev_portal.installation.GetByAppNameAndInstallLocationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== "") {
            writer.uint32(10).string(message.slug);
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        if (message.location !== "") {
            writer.uint32(26).string(message.location);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetByAppNameAndInstallLocationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slug = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.location = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            slug: isSet(object.slug) ? String(object.slug) : "",
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            location: isSet(object.location) ? String(object.location) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.slug !== undefined && (obj.slug = message.slug);
        message.type !== undefined && (obj.type = installationTypeToJSON(message.type));
        message.location !== undefined && (obj.location = message.location);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetByAppNameAndInstallLocationRequest();
        message.slug = object.slug ?? "";
        message.type = object.type ?? 0;
        message.location = object.location ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetByAppNameAndInstallLocationRequest", GetByAppNameAndInstallLocationRequest);
function createBaseGetAllWithInstallLocationRequest() {
    return { type: 0, location: "" };
}
export const GetAllWithInstallLocationRequest = {
    $type: "devvit.dev_portal.installation.GetAllWithInstallLocationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.location !== "") {
            writer.uint32(18).string(message.location);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAllWithInstallLocationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.location = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            location: isSet(object.location) ? String(object.location) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = installationTypeToJSON(message.type));
        message.location !== undefined && (obj.location = message.location);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetAllWithInstallLocationRequest();
        message.type = object.type ?? 0;
        message.location = object.location ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetAllWithInstallLocationRequest", GetAllWithInstallLocationRequest);
function createBaseGetAllWithInstallerRequest() {
    return { installedBy: "" };
}
export const GetAllWithInstallerRequest = {
    $type: "devvit.dev_portal.installation.GetAllWithInstallerRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.installedBy !== "") {
            writer.uint32(10).string(message.installedBy);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAllWithInstallerRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.installedBy = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { installedBy: isSet(object.installedBy) ? String(object.installedBy) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.installedBy !== undefined && (obj.installedBy = message.installedBy);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetAllWithInstallerRequest();
        message.installedBy = object.installedBy ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetAllWithInstallerRequest", GetAllWithInstallerRequest);
function createBaseGetInstallationHistoryRequest() {
    return { type: 0, location: "", slug: "", from: undefined, to: undefined, take: undefined, desc: undefined };
}
export const GetInstallationHistoryRequest = {
    $type: "devvit.dev_portal.installation.GetInstallationHistoryRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.location !== "") {
            writer.uint32(18).string(message.location);
        }
        if (message.slug !== "") {
            writer.uint32(26).string(message.slug);
        }
        if (message.from !== undefined) {
            Timestamp.encode(toTimestamp(message.from), writer.uint32(34).fork()).ldelim();
        }
        if (message.to !== undefined) {
            Timestamp.encode(toTimestamp(message.to), writer.uint32(42).fork()).ldelim();
        }
        if (message.take !== undefined) {
            writer.uint32(48).uint32(message.take);
        }
        if (message.desc !== undefined) {
            writer.uint32(56).bool(message.desc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInstallationHistoryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.location = reader.string();
                    break;
                case 3:
                    message.slug = reader.string();
                    break;
                case 4:
                    message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.take = reader.uint32();
                    break;
                case 7:
                    message.desc = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            location: isSet(object.location) ? String(object.location) : "",
            slug: isSet(object.slug) ? String(object.slug) : "",
            from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
            to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
            take: isSet(object.take) ? Number(object.take) : undefined,
            desc: isSet(object.desc) ? Boolean(object.desc) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = installationTypeToJSON(message.type));
        message.location !== undefined && (obj.location = message.location);
        message.slug !== undefined && (obj.slug = message.slug);
        message.from !== undefined && (obj.from = message.from.toISOString());
        message.to !== undefined && (obj.to = message.to.toISOString());
        message.take !== undefined && (obj.take = Math.round(message.take));
        message.desc !== undefined && (obj.desc = message.desc);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetInstallationHistoryRequest();
        message.type = object.type ?? 0;
        message.location = object.location ?? "";
        message.slug = object.slug ?? "";
        message.from = object.from ?? undefined;
        message.to = object.to ?? undefined;
        message.take = object.take ?? undefined;
        message.desc = object.desc ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetInstallationHistoryRequest", GetInstallationHistoryRequest);
function createBaseInstallationInfo() {
    return {
        id: "",
        upgradeStrategy: 0,
        upgradeStrategyConfig: undefined,
        runAs: undefined,
        type: 0,
        location: undefined,
        isEnabled: false,
    };
}
export const InstallationInfo = {
    $type: "devvit.dev_portal.installation.InstallationInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.upgradeStrategy !== 0) {
            writer.uint32(24).int32(message.upgradeStrategy);
        }
        if (message.upgradeStrategyConfig !== undefined) {
            Struct.encode(Struct.wrap(message.upgradeStrategyConfig), writer.uint32(34).fork()).ldelim();
        }
        if (message.runAs !== undefined) {
            StringValue.encode({ value: message.runAs }, writer.uint32(50).fork()).ldelim();
        }
        if (message.type !== 0) {
            writer.uint32(56).int32(message.type);
        }
        if (message.location !== undefined) {
            InstallationLocationInfo.encode(message.location, writer.uint32(66).fork()).ldelim();
        }
        if (message.isEnabled === true) {
            writer.uint32(72).bool(message.isEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 3:
                    message.upgradeStrategy = reader.int32();
                    break;
                case 4:
                    message.upgradeStrategyConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.runAs = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.type = reader.int32();
                    break;
                case 8:
                    message.location = InstallationLocationInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.isEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            upgradeStrategy: isSet(object.upgradeStrategy) ? upgradeStrategyFromJSON(object.upgradeStrategy) : 0,
            upgradeStrategyConfig: isObject(object.upgradeStrategyConfig) ? object.upgradeStrategyConfig : undefined,
            runAs: isSet(object.runAs) ? String(object.runAs) : undefined,
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            location: isSet(object.location) ? InstallationLocationInfo.fromJSON(object.location) : undefined,
            isEnabled: isSet(object.isEnabled) ? Boolean(object.isEnabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.upgradeStrategy !== undefined && (obj.upgradeStrategy = upgradeStrategyToJSON(message.upgradeStrategy));
        message.upgradeStrategyConfig !== undefined && (obj.upgradeStrategyConfig = message.upgradeStrategyConfig);
        message.runAs !== undefined && (obj.runAs = message.runAs);
        message.type !== undefined && (obj.type = installationTypeToJSON(message.type));
        message.location !== undefined &&
            (obj.location = message.location ? InstallationLocationInfo.toJSON(message.location) : undefined);
        message.isEnabled !== undefined && (obj.isEnabled = message.isEnabled);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationInfo();
        message.id = object.id ?? "";
        message.upgradeStrategy = object.upgradeStrategy ?? 0;
        message.upgradeStrategyConfig = object.upgradeStrategyConfig ?? undefined;
        message.runAs = object.runAs ?? undefined;
        message.type = object.type ?? 0;
        message.location = (object.location !== undefined && object.location !== null)
            ? InstallationLocationInfo.fromPartial(object.location)
            : undefined;
        message.isEnabled = object.isEnabled ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationInfo", InstallationInfo);
function createBaseInstallationLocationInfo() {
    return { id: "", name: "", type: 0, icon: undefined, isNsfw: false, isUnavailable: false };
}
export const InstallationLocationInfo = {
    $type: "devvit.dev_portal.installation.InstallationLocationInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.type !== 0) {
            writer.uint32(24).int32(message.type);
        }
        if (message.icon !== undefined) {
            StringValue.encode({ value: message.icon }, writer.uint32(34).fork()).ldelim();
        }
        if (message.isNsfw === true) {
            writer.uint32(40).bool(message.isNsfw);
        }
        if (message.isUnavailable === true) {
            writer.uint32(48).bool(message.isUnavailable);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationLocationInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.icon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.isNsfw = reader.bool();
                    break;
                case 6:
                    message.isUnavailable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            name: isSet(object.name) ? String(object.name) : "",
            type: isSet(object.type) ? thingTypeFromJSON(object.type) : 0,
            icon: isSet(object.icon) ? String(object.icon) : undefined,
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : false,
            isUnavailable: isSet(object.isUnavailable) ? Boolean(object.isUnavailable) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.name !== undefined && (obj.name = message.name);
        message.type !== undefined && (obj.type = thingTypeToJSON(message.type));
        message.icon !== undefined && (obj.icon = message.icon);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        message.isUnavailable !== undefined && (obj.isUnavailable = message.isUnavailable);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationLocationInfo();
        message.id = object.id ?? "";
        message.name = object.name ?? "";
        message.type = object.type ?? 0;
        message.icon = object.icon ?? undefined;
        message.isNsfw = object.isNsfw ?? false;
        message.isUnavailable = object.isUnavailable ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationLocationInfo", InstallationLocationInfo);
function createBaseFullInstallationInfo() {
    return { installation: undefined, appVersion: undefined, app: undefined };
}
export const FullInstallationInfo = {
    $type: "devvit.dev_portal.installation.FullInstallationInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.installation !== undefined) {
            InstallationInfo.encode(message.installation, writer.uint32(10).fork()).ldelim();
        }
        if (message.appVersion !== undefined) {
            AppVersionInfo.encode(message.appVersion, writer.uint32(18).fork()).ldelim();
        }
        if (message.app !== undefined) {
            AppInfo.encode(message.app, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullInstallationInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.installation = InstallationInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.app = AppInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            installation: isSet(object.installation) ? InstallationInfo.fromJSON(object.installation) : undefined,
            appVersion: isSet(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : undefined,
            app: isSet(object.app) ? AppInfo.fromJSON(object.app) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.installation !== undefined &&
            (obj.installation = message.installation ? InstallationInfo.toJSON(message.installation) : undefined);
        message.appVersion !== undefined &&
            (obj.appVersion = message.appVersion ? AppVersionInfo.toJSON(message.appVersion) : undefined);
        message.app !== undefined && (obj.app = message.app ? AppInfo.toJSON(message.app) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFullInstallationInfo();
        message.installation = (object.installation !== undefined && object.installation !== null)
            ? InstallationInfo.fromPartial(object.installation)
            : undefined;
        message.appVersion = (object.appVersion !== undefined && object.appVersion !== null)
            ? AppVersionInfo.fromPartial(object.appVersion)
            : undefined;
        message.app = (object.app !== undefined && object.app !== null) ? AppInfo.fromPartial(object.app) : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.FullInstallationInfo", FullInstallationInfo);
function createBaseMultipleInstallationsResponse() {
    return { installations: [] };
}
export const MultipleInstallationsResponse = {
    $type: "devvit.dev_portal.installation.MultipleInstallationsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.installations) {
            InstallationInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMultipleInstallationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.installations.push(InstallationInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            installations: Array.isArray(object?.installations)
                ? object.installations.map((e) => InstallationInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.installations) {
            obj.installations = message.installations.map((e) => e ? InstallationInfo.toJSON(e) : undefined);
        }
        else {
            obj.installations = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMultipleInstallationsResponse();
        message.installations = object.installations?.map((e) => InstallationInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.MultipleInstallationsResponse", MultipleInstallationsResponse);
function createBaseGetAllWithAppResponse() {
    return { installations: [] };
}
export const GetAllWithAppResponse = {
    $type: "devvit.dev_portal.installation.GetAllWithAppResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.installations) {
            InstallationWithAppVersion.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAllWithAppResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.installations.push(InstallationWithAppVersion.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            installations: Array.isArray(object?.installations)
                ? object.installations.map((e) => InstallationWithAppVersion.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.installations) {
            obj.installations = message.installations.map((e) => e ? InstallationWithAppVersion.toJSON(e) : undefined);
        }
        else {
            obj.installations = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetAllWithAppResponse();
        message.installations = object.installations?.map((e) => InstallationWithAppVersion.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetAllWithAppResponse", GetAllWithAppResponse);
function createBaseInstallationWithAppVersion() {
    return { installation: undefined, appVersion: undefined };
}
export const InstallationWithAppVersion = {
    $type: "devvit.dev_portal.installation.InstallationWithAppVersion",
    encode(message, writer = _m0.Writer.create()) {
        if (message.installation !== undefined) {
            InstallationInfo.encode(message.installation, writer.uint32(10).fork()).ldelim();
        }
        if (message.appVersion !== undefined) {
            AppVersionInfo.encode(message.appVersion, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationWithAppVersion();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.installation = InstallationInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            installation: isSet(object.installation) ? InstallationInfo.fromJSON(object.installation) : undefined,
            appVersion: isSet(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.installation !== undefined &&
            (obj.installation = message.installation ? InstallationInfo.toJSON(message.installation) : undefined);
        message.appVersion !== undefined &&
            (obj.appVersion = message.appVersion ? AppVersionInfo.toJSON(message.appVersion) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationWithAppVersion();
        message.installation = (object.installation !== undefined && object.installation !== null)
            ? InstallationInfo.fromPartial(object.installation)
            : undefined;
        message.appVersion = (object.appVersion !== undefined && object.appVersion !== null)
            ? AppVersionInfo.fromPartial(object.appVersion)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationWithAppVersion", InstallationWithAppVersion);
function createBaseInstallationUpgradeManyResponse() {
    return { details: [] };
}
export const InstallationUpgradeManyResponse = {
    $type: "devvit.dev_portal.installation.InstallationUpgradeManyResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.details) {
            InstallationUpgradeManyResponse_InstallationUpgradeDetails.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationUpgradeManyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.details.push(InstallationUpgradeManyResponse_InstallationUpgradeDetails.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: Array.isArray(object?.details)
                ? object.details.map((e) => InstallationUpgradeManyResponse_InstallationUpgradeDetails.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.details) {
            obj.details = message.details.map((e) => e ? InstallationUpgradeManyResponse_InstallationUpgradeDetails.toJSON(e) : undefined);
        }
        else {
            obj.details = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationUpgradeManyResponse();
        message.details =
            object.details?.map((e) => InstallationUpgradeManyResponse_InstallationUpgradeDetails.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationUpgradeManyResponse", InstallationUpgradeManyResponse);
function createBaseInstallationUpgradeManyResponse_InstallationUpgradeDetails() {
    return { id: "", success: false, error: undefined };
}
export const InstallationUpgradeManyResponse_InstallationUpgradeDetails = {
    $type: "devvit.dev_portal.installation.InstallationUpgradeManyResponse.InstallationUpgradeDetails",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.success === true) {
            writer.uint32(16).bool(message.success);
        }
        if (message.error !== undefined) {
            writer.uint32(26).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationUpgradeManyResponse_InstallationUpgradeDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.success = reader.bool();
                    break;
                case 3:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            success: isSet(object.success) ? Boolean(object.success) : false,
            error: isSet(object.error) ? String(object.error) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.success !== undefined && (obj.success = message.success);
        message.error !== undefined && (obj.error = message.error);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationUpgradeManyResponse_InstallationUpgradeDetails();
        message.id = object.id ?? "";
        message.success = object.success ?? false;
        message.error = object.error ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationUpgradeManyResponse.InstallationUpgradeDetails", InstallationUpgradeManyResponse_InstallationUpgradeDetails);
function createBaseInstallationLocationDetails() {
    return { type: 0, thingId: "", name: "" };
}
export const InstallationLocationDetails = {
    $type: "devvit.dev_portal.installation.InstallationLocationDetails",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.thingId !== "") {
            writer.uint32(18).string(message.thingId);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationLocationDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.thingId = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            thingId: isSet(object.thingId) ? String(object.thingId) : "",
            name: isSet(object.name) ? String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = installationTypeToJSON(message.type));
        message.thingId !== undefined && (obj.thingId = message.thingId);
        message.name !== undefined && (obj.name = message.name);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationLocationDetails();
        message.type = object.type ?? 0;
        message.thingId = object.thingId ?? "";
        message.name = object.name ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationLocationDetails", InstallationLocationDetails);
function createBaseInstallationHistoryEvent() {
    return { userId: "", name: 0, details: {}, createdAt: undefined };
}
export const InstallationHistoryEvent = {
    $type: "devvit.dev_portal.installation.InstallationHistoryEvent",
    encode(message, writer = _m0.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.name !== 0) {
            writer.uint32(16).int32(message.name);
        }
        Object.entries(message.details).forEach(([key, value]) => {
            InstallationHistoryEvent_DetailsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.createdAt !== undefined) {
            Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationHistoryEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.name = reader.int32();
                    break;
                case 3:
                    const entry3 = InstallationHistoryEvent_DetailsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.details[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            userId: isSet(object.userId) ? String(object.userId) : "",
            name: isSet(object.name) ? installationHistoryEventNameFromJSON(object.name) : 0,
            details: isObject(object.details)
                ? Object.entries(object.details).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.userId !== undefined && (obj.userId = message.userId);
        message.name !== undefined && (obj.name = installationHistoryEventNameToJSON(message.name));
        obj.details = {};
        if (message.details) {
            Object.entries(message.details).forEach(([k, v]) => {
                obj.details[k] = v;
            });
        }
        message.createdAt !== undefined && (obj.createdAt = message.createdAt.toISOString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationHistoryEvent();
        message.userId = object.userId ?? "";
        message.name = object.name ?? 0;
        message.details = Object.entries(object.details ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        message.createdAt = object.createdAt ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationHistoryEvent", InstallationHistoryEvent);
function createBaseInstallationHistoryEvent_DetailsEntry() {
    return { key: "", value: "" };
}
export const InstallationHistoryEvent_DetailsEntry = {
    $type: "devvit.dev_portal.installation.InstallationHistoryEvent.DetailsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationHistoryEvent_DetailsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInstallationHistoryEvent_DetailsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationHistoryEvent.DetailsEntry", InstallationHistoryEvent_DetailsEntry);
function createBaseGetInstallationHistoryResponse() {
    return { events: [], totalEvents: 0 };
}
export const GetInstallationHistoryResponse = {
    $type: "devvit.dev_portal.installation.GetInstallationHistoryResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.events) {
            InstallationHistoryEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.totalEvents !== 0) {
            writer.uint32(64).uint32(message.totalEvents);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInstallationHistoryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.events.push(InstallationHistoryEvent.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.totalEvents = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            events: Array.isArray(object?.events) ? object.events.map((e) => InstallationHistoryEvent.fromJSON(e)) : [],
            totalEvents: isSet(object.totalEvents) ? Number(object.totalEvents) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.events) {
            obj.events = message.events.map((e) => e ? InstallationHistoryEvent.toJSON(e) : undefined);
        }
        else {
            obj.events = [];
        }
        message.totalEvents !== undefined && (obj.totalEvents = Math.round(message.totalEvents));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetInstallationHistoryResponse();
        message.events = object.events?.map((e) => InstallationHistoryEvent.fromPartial(e)) || [];
        message.totalEvents = object.totalEvents ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetInstallationHistoryResponse", GetInstallationHistoryResponse);
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
