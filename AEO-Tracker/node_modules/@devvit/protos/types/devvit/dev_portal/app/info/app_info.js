/**
 * #app_info.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Timestamp } from '../../../../google/protobuf/timestamp.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { computePoolFromJSON, computePoolToJSON } from '../../app_version/info/app_version_info.js';
import { Redditor } from '../../reddit/redditor.js';
import { categoriesFromJSON, categoriesToJSON } from '../categories/categories.js';
function createBaseAppInfo() {
    return {
        id: "",
        slug: "",
        name: "",
        description: "",
        appAccount: undefined,
        isNsfw: false,
        isDelisted: false,
        isFirstParty: false,
        isArchived: false,
        createdAt: undefined,
        owner: undefined,
        categories: [],
        stats: undefined,
        termsAndConditions: "",
        privacyPolicy: "",
        defaultPool: 0,
    };
}
export const AppInfo = {
    $type: "devvit.dev_portal.app.info.AppInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.slug !== "") {
            writer.uint32(18).string(message.slug);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(34).string(message.description);
        }
        if (message.appAccount !== undefined) {
            Redditor.encode(message.appAccount, writer.uint32(122).fork()).ldelim();
        }
        if (message.isNsfw === true) {
            writer.uint32(40).bool(message.isNsfw);
        }
        if (message.isDelisted === true) {
            writer.uint32(48).bool(message.isDelisted);
        }
        if (message.isFirstParty === true) {
            writer.uint32(104).bool(message.isFirstParty);
        }
        if (message.isArchived === true) {
            writer.uint32(112).bool(message.isArchived);
        }
        if (message.createdAt !== undefined) {
            Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).ldelim();
        }
        if (message.owner !== undefined) {
            Redditor.encode(message.owner, writer.uint32(66).fork()).ldelim();
        }
        writer.uint32(74).fork();
        for (const v of message.categories) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.stats !== undefined) {
            AppStats.encode(message.stats, writer.uint32(82).fork()).ldelim();
        }
        if (message.termsAndConditions !== "") {
            writer.uint32(90).string(message.termsAndConditions);
        }
        if (message.privacyPolicy !== "") {
            writer.uint32(98).string(message.privacyPolicy);
        }
        if (message.defaultPool !== 0) {
            writer.uint32(128).int32(message.defaultPool);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.slug = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 15:
                    message.appAccount = Redditor.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.isNsfw = reader.bool();
                    break;
                case 6:
                    message.isDelisted = reader.bool();
                    break;
                case 13:
                    message.isFirstParty = reader.bool();
                    break;
                case 14:
                    message.isArchived = reader.bool();
                    break;
                case 7:
                    message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.owner = Redditor.decode(reader, reader.uint32());
                    break;
                case 9:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.categories.push(reader.int32());
                        }
                    }
                    else {
                        message.categories.push(reader.int32());
                    }
                    break;
                case 10:
                    message.stats = AppStats.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.termsAndConditions = reader.string();
                    break;
                case 12:
                    message.privacyPolicy = reader.string();
                    break;
                case 16:
                    message.defaultPool = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            slug: isSet(object.slug) ? String(object.slug) : "",
            name: isSet(object.name) ? String(object.name) : "",
            description: isSet(object.description) ? String(object.description) : "",
            appAccount: isSet(object.appAccount) ? Redditor.fromJSON(object.appAccount) : undefined,
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : false,
            isDelisted: isSet(object.isDelisted) ? Boolean(object.isDelisted) : false,
            isFirstParty: isSet(object.isFirstParty) ? Boolean(object.isFirstParty) : false,
            isArchived: isSet(object.isArchived) ? Boolean(object.isArchived) : false,
            createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
            owner: isSet(object.owner) ? Redditor.fromJSON(object.owner) : undefined,
            categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
            stats: isSet(object.stats) ? AppStats.fromJSON(object.stats) : undefined,
            termsAndConditions: isSet(object.termsAndConditions) ? String(object.termsAndConditions) : "",
            privacyPolicy: isSet(object.privacyPolicy) ? String(object.privacyPolicy) : "",
            defaultPool: isSet(object.defaultPool) ? computePoolFromJSON(object.defaultPool) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.slug !== undefined && (obj.slug = message.slug);
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined && (obj.description = message.description);
        message.appAccount !== undefined &&
            (obj.appAccount = message.appAccount ? Redditor.toJSON(message.appAccount) : undefined);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        message.isDelisted !== undefined && (obj.isDelisted = message.isDelisted);
        message.isFirstParty !== undefined && (obj.isFirstParty = message.isFirstParty);
        message.isArchived !== undefined && (obj.isArchived = message.isArchived);
        message.createdAt !== undefined && (obj.createdAt = message.createdAt.toISOString());
        message.owner !== undefined && (obj.owner = message.owner ? Redditor.toJSON(message.owner) : undefined);
        if (message.categories) {
            obj.categories = message.categories.map((e) => categoriesToJSON(e));
        }
        else {
            obj.categories = [];
        }
        message.stats !== undefined && (obj.stats = message.stats ? AppStats.toJSON(message.stats) : undefined);
        message.termsAndConditions !== undefined && (obj.termsAndConditions = message.termsAndConditions);
        message.privacyPolicy !== undefined && (obj.privacyPolicy = message.privacyPolicy);
        message.defaultPool !== undefined && (obj.defaultPool = computePoolToJSON(message.defaultPool));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppInfo();
        message.id = object.id ?? "";
        message.slug = object.slug ?? "";
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.appAccount = (object.appAccount !== undefined && object.appAccount !== null)
            ? Redditor.fromPartial(object.appAccount)
            : undefined;
        message.isNsfw = object.isNsfw ?? false;
        message.isDelisted = object.isDelisted ?? false;
        message.isFirstParty = object.isFirstParty ?? false;
        message.isArchived = object.isArchived ?? false;
        message.createdAt = object.createdAt ?? undefined;
        message.owner = (object.owner !== undefined && object.owner !== null)
            ? Redditor.fromPartial(object.owner)
            : undefined;
        message.categories = object.categories?.map((e) => e) || [];
        message.stats = (object.stats !== undefined && object.stats !== null)
            ? AppStats.fromPartial(object.stats)
            : undefined;
        message.termsAndConditions = object.termsAndConditions ?? "";
        message.privacyPolicy = object.privacyPolicy ?? "";
        message.defaultPool = object.defaultPool ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.info.AppInfo", AppInfo);
function createBaseMultipleAppInfos() {
    return { apps: [] };
}
export const MultipleAppInfos = {
    $type: "devvit.dev_portal.app.info.MultipleAppInfos",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.apps) {
            AppInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMultipleAppInfos();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apps.push(AppInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { apps: Array.isArray(object?.apps) ? object.apps.map((e) => AppInfo.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.apps) {
            obj.apps = message.apps.map((e) => e ? AppInfo.toJSON(e) : undefined);
        }
        else {
            obj.apps = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMultipleAppInfos();
        message.apps = object.apps?.map((e) => AppInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.info.MultipleAppInfos", MultipleAppInfos);
function createBaseAppStats() {
    return { installCount: 0 };
}
export const AppStats = {
    $type: "devvit.dev_portal.app.info.AppStats",
    encode(message, writer = _m0.Writer.create()) {
        if (message.installCount !== 0) {
            writer.uint32(8).int32(message.installCount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.installCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { installCount: isSet(object.installCount) ? Number(object.installCount) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.installCount !== undefined && (obj.installCount = Math.round(message.installCount));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppStats();
        message.installCount = object.installCount ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.info.AppStats", AppStats);
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
