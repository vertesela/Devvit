/**
 * #app.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int32Value, StringValue } from '../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
import { AppVersionInfo, computePoolFromJSON, computePoolToJSON, } from '../app_version/info/app_version_info.js';
import { categoriesFromJSON, categoriesToJSON } from './categories/categories.js';
import { AppInfo } from './info/app_info.js';
export var OrderBy;
(function (OrderBy) {
    OrderBy[OrderBy["DATE_CREATED"] = 0] = "DATE_CREATED";
    OrderBy[OrderBy["NAME"] = 1] = "NAME";
    OrderBy[OrderBy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderBy || (OrderBy = {}));
export function orderByFromJSON(object) {
    switch (object) {
        case 0:
        case "DATE_CREATED":
            return OrderBy.DATE_CREATED;
        case 1:
        case "NAME":
            return OrderBy.NAME;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OrderBy.UNRECOGNIZED;
    }
}
export function orderByToJSON(object) {
    switch (object) {
        case OrderBy.DATE_CREATED:
            return 0;
        case OrderBy.NAME:
            return 1;
        case OrderBy.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseAppSearchRequest() {
    return {
        searchTerm: undefined,
        categories: [],
        page: undefined,
        pageSize: undefined,
        orderBy: 0,
        isAscending: undefined,
    };
}
export const AppSearchRequest = {
    $type: "devvit.dev_portal.app.AppSearchRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.searchTerm !== undefined) {
            StringValue.encode({ value: message.searchTerm }, writer.uint32(10).fork()).ldelim();
        }
        writer.uint32(18).fork();
        for (const v of message.categories) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.page !== undefined) {
            Int32Value.encode({ value: message.page }, writer.uint32(26).fork()).ldelim();
        }
        if (message.pageSize !== undefined) {
            Int32Value.encode({ value: message.pageSize }, writer.uint32(34).fork()).ldelim();
        }
        if (message.orderBy !== 0) {
            writer.uint32(40).int32(message.orderBy);
        }
        if (message.isAscending !== undefined) {
            BoolValue.encode({ value: message.isAscending }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppSearchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.searchTerm = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.categories.push(reader.int32());
                        }
                    }
                    else {
                        message.categories.push(reader.int32());
                    }
                    break;
                case 3:
                    message.page = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.pageSize = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.orderBy = reader.int32();
                    break;
                case 6:
                    message.isAscending = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            searchTerm: isSet(object.searchTerm) ? String(object.searchTerm) : undefined,
            categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
            page: isSet(object.page) ? Number(object.page) : undefined,
            pageSize: isSet(object.pageSize) ? Number(object.pageSize) : undefined,
            orderBy: isSet(object.orderBy) ? orderByFromJSON(object.orderBy) : 0,
            isAscending: isSet(object.isAscending) ? Boolean(object.isAscending) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.searchTerm !== undefined && (obj.searchTerm = message.searchTerm);
        if (message.categories) {
            obj.categories = message.categories.map((e) => categoriesToJSON(e));
        }
        else {
            obj.categories = [];
        }
        message.page !== undefined && (obj.page = message.page);
        message.pageSize !== undefined && (obj.pageSize = message.pageSize);
        message.orderBy !== undefined && (obj.orderBy = orderByToJSON(message.orderBy));
        message.isAscending !== undefined && (obj.isAscending = message.isAscending);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppSearchRequest();
        message.searchTerm = object.searchTerm ?? undefined;
        message.categories = object.categories?.map((e) => e) || [];
        message.page = object.page ?? undefined;
        message.pageSize = object.pageSize ?? undefined;
        message.orderBy = object.orderBy ?? 0;
        message.isAscending = object.isAscending ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppSearchRequest", AppSearchRequest);
function createBaseGetAppBySlugRequest() {
    return { slug: "" };
}
export const GetAppBySlugRequest = {
    $type: "devvit.dev_portal.app.GetAppBySlugRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== "") {
            writer.uint32(10).string(message.slug);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAppBySlugRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slug = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { slug: isSet(object.slug) ? String(object.slug) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.slug !== undefined && (obj.slug = message.slug);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetAppBySlugRequest();
        message.slug = object.slug ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.GetAppBySlugRequest", GetAppBySlugRequest);
function createBaseGetAllWithOwnerRequest() {
    return { owner: "" };
}
export const GetAllWithOwnerRequest = {
    $type: "devvit.dev_portal.app.GetAllWithOwnerRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.owner !== "") {
            writer.uint32(10).string(message.owner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAllWithOwnerRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { owner: isSet(object.owner) ? String(object.owner) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.owner !== undefined && (obj.owner = message.owner);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetAllWithOwnerRequest();
        message.owner = object.owner ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.GetAllWithOwnerRequest", GetAllWithOwnerRequest);
function createBaseAppCreationRequest() {
    return { name: "", description: "", isNsfw: false, categories: [], autogenerateName: false, captcha: "" };
}
export const AppCreationRequest = {
    $type: "devvit.dev_portal.app.AppCreationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.isNsfw === true) {
            writer.uint32(24).bool(message.isNsfw);
        }
        writer.uint32(34).fork();
        for (const v of message.categories) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.autogenerateName === true) {
            writer.uint32(40).bool(message.autogenerateName);
        }
        if (message.captcha !== "") {
            writer.uint32(50).string(message.captcha);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppCreationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.isNsfw = reader.bool();
                    break;
                case 4:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.categories.push(reader.int32());
                        }
                    }
                    else {
                        message.categories.push(reader.int32());
                    }
                    break;
                case 5:
                    message.autogenerateName = reader.bool();
                    break;
                case 6:
                    message.captcha = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            description: isSet(object.description) ? String(object.description) : "",
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : false,
            categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
            autogenerateName: isSet(object.autogenerateName) ? Boolean(object.autogenerateName) : false,
            captcha: isSet(object.captcha) ? String(object.captcha) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined && (obj.description = message.description);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        if (message.categories) {
            obj.categories = message.categories.map((e) => categoriesToJSON(e));
        }
        else {
            obj.categories = [];
        }
        message.autogenerateName !== undefined && (obj.autogenerateName = message.autogenerateName);
        message.captcha !== undefined && (obj.captcha = message.captcha);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppCreationRequest();
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.isNsfw = object.isNsfw ?? false;
        message.categories = object.categories?.map((e) => e) || [];
        message.autogenerateName = object.autogenerateName ?? false;
        message.captcha = object.captcha ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppCreationRequest", AppCreationRequest);
function createBaseGetPopularAppsRequest() {
    return { limit: 0 };
}
export const GetPopularAppsRequest = {
    $type: "devvit.dev_portal.app.GetPopularAppsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.limit !== 0) {
            writer.uint32(8).int32(message.limit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPopularAppsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.limit = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { limit: isSet(object.limit) ? Number(object.limit) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.limit !== undefined && (obj.limit = Math.round(message.limit));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetPopularAppsRequest();
        message.limit = object.limit ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.GetPopularAppsRequest", GetPopularAppsRequest);
function createBaseMediaSignature() {
    return { filePath: "", size: 0, hash: "" };
}
export const MediaSignature = {
    $type: "devvit.dev_portal.app.MediaSignature",
    encode(message, writer = _m0.Writer.create()) {
        if (message.filePath !== "") {
            writer.uint32(10).string(message.filePath);
        }
        if (message.size !== 0) {
            writer.uint32(16).int32(message.size);
        }
        if (message.hash !== "") {
            writer.uint32(26).string(message.hash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMediaSignature();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.filePath = reader.string();
                    break;
                case 2:
                    message.size = reader.int32();
                    break;
                case 3:
                    message.hash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            filePath: isSet(object.filePath) ? String(object.filePath) : "",
            size: isSet(object.size) ? Number(object.size) : 0,
            hash: isSet(object.hash) ? String(object.hash) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.filePath !== undefined && (obj.filePath = message.filePath);
        message.size !== undefined && (obj.size = Math.round(message.size));
        message.hash !== undefined && (obj.hash = message.hash);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMediaSignature();
        message.filePath = object.filePath ?? "";
        message.size = object.size ?? 0;
        message.hash = object.hash ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.MediaSignature", MediaSignature);
function createBaseCheckIfMediaExistsRequest() {
    return { id: undefined, slug: undefined, signatures: [] };
}
export const CheckIfMediaExistsRequest = {
    $type: "devvit.dev_portal.app.CheckIfMediaExistsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== undefined) {
            writer.uint32(10).string(message.id);
        }
        if (message.slug !== undefined) {
            writer.uint32(18).string(message.slug);
        }
        for (const v of message.signatures) {
            MediaSignature.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckIfMediaExistsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.slug = reader.string();
                    break;
                case 3:
                    message.signatures.push(MediaSignature.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : undefined,
            slug: isSet(object.slug) ? String(object.slug) : undefined,
            signatures: Array.isArray(object?.signatures)
                ? object.signatures.map((e) => MediaSignature.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.slug !== undefined && (obj.slug = message.slug);
        if (message.signatures) {
            obj.signatures = message.signatures.map((e) => e ? MediaSignature.toJSON(e) : undefined);
        }
        else {
            obj.signatures = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCheckIfMediaExistsRequest();
        message.id = object.id ?? undefined;
        message.slug = object.slug ?? undefined;
        message.signatures = object.signatures?.map((e) => MediaSignature.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.CheckIfMediaExistsRequest", CheckIfMediaExistsRequest);
function createBaseUploadNewMediaRequest() {
    return { id: undefined, slug: undefined, size: 0, hash: "", contents: new Uint8Array() };
}
export const UploadNewMediaRequest = {
    $type: "devvit.dev_portal.app.UploadNewMediaRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== undefined) {
            writer.uint32(10).string(message.id);
        }
        if (message.slug !== undefined) {
            writer.uint32(18).string(message.slug);
        }
        if (message.size !== 0) {
            writer.uint32(24).int32(message.size);
        }
        if (message.hash !== "") {
            writer.uint32(34).string(message.hash);
        }
        if (message.contents.length !== 0) {
            writer.uint32(42).bytes(message.contents);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadNewMediaRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.slug = reader.string();
                    break;
                case 3:
                    message.size = reader.int32();
                    break;
                case 4:
                    message.hash = reader.string();
                    break;
                case 5:
                    message.contents = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : undefined,
            slug: isSet(object.slug) ? String(object.slug) : undefined,
            size: isSet(object.size) ? Number(object.size) : 0,
            hash: isSet(object.hash) ? String(object.hash) : "",
            contents: isSet(object.contents) ? bytesFromBase64(object.contents) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.slug !== undefined && (obj.slug = message.slug);
        message.size !== undefined && (obj.size = Math.round(message.size));
        message.hash !== undefined && (obj.hash = message.hash);
        message.contents !== undefined &&
            (obj.contents = base64FromBytes(message.contents !== undefined ? message.contents : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUploadNewMediaRequest();
        message.id = object.id ?? undefined;
        message.slug = object.slug ?? undefined;
        message.size = object.size ?? 0;
        message.hash = object.hash ?? "";
        message.contents = object.contents ?? new Uint8Array();
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.UploadNewMediaRequest", UploadNewMediaRequest);
function createBaseAppUpdateRequest() {
    return {
        id: "",
        slug: undefined,
        name: undefined,
        description: undefined,
        isNsfw: undefined,
        isDelisted: undefined,
        categories: [],
        termsAndConditions: undefined,
        privacyPolicy: undefined,
        defaultPool: undefined,
    };
}
export const AppUpdateRequest = {
    $type: "devvit.dev_portal.app.AppUpdateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.slug !== undefined) {
            StringValue.encode({ value: message.slug }, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
        }
        if (message.isNsfw !== undefined) {
            BoolValue.encode({ value: message.isNsfw }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isDelisted !== undefined) {
            BoolValue.encode({ value: message.isDelisted }, writer.uint32(50).fork()).ldelim();
        }
        writer.uint32(58).fork();
        for (const v of message.categories) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.termsAndConditions !== undefined) {
            StringValue.encode({ value: message.termsAndConditions }, writer.uint32(66).fork()).ldelim();
        }
        if (message.privacyPolicy !== undefined) {
            StringValue.encode({ value: message.privacyPolicy }, writer.uint32(74).fork()).ldelim();
        }
        if (message.defaultPool !== undefined) {
            writer.uint32(80).int32(message.defaultPool);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppUpdateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.slug = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.isDelisted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.categories.push(reader.int32());
                        }
                    }
                    else {
                        message.categories.push(reader.int32());
                    }
                    break;
                case 8:
                    message.termsAndConditions = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.privacyPolicy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.defaultPool = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            slug: isSet(object.slug) ? String(object.slug) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : undefined,
            isDelisted: isSet(object.isDelisted) ? Boolean(object.isDelisted) : undefined,
            categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
            termsAndConditions: isSet(object.termsAndConditions) ? String(object.termsAndConditions) : undefined,
            privacyPolicy: isSet(object.privacyPolicy) ? String(object.privacyPolicy) : undefined,
            defaultPool: isSet(object.defaultPool) ? computePoolFromJSON(object.defaultPool) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.slug !== undefined && (obj.slug = message.slug);
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined && (obj.description = message.description);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        message.isDelisted !== undefined && (obj.isDelisted = message.isDelisted);
        if (message.categories) {
            obj.categories = message.categories.map((e) => categoriesToJSON(e));
        }
        else {
            obj.categories = [];
        }
        message.termsAndConditions !== undefined && (obj.termsAndConditions = message.termsAndConditions);
        message.privacyPolicy !== undefined && (obj.privacyPolicy = message.privacyPolicy);
        message.defaultPool !== undefined &&
            (obj.defaultPool = message.defaultPool !== undefined ? computePoolToJSON(message.defaultPool) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppUpdateRequest();
        message.id = object.id ?? "";
        message.slug = object.slug ?? undefined;
        message.name = object.name ?? undefined;
        message.description = object.description ?? undefined;
        message.isNsfw = object.isNsfw ?? undefined;
        message.isDelisted = object.isDelisted ?? undefined;
        message.categories = object.categories?.map((e) => e) || [];
        message.termsAndConditions = object.termsAndConditions ?? undefined;
        message.privacyPolicy = object.privacyPolicy ?? undefined;
        message.defaultPool = object.defaultPool ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppUpdateRequest", AppUpdateRequest);
function createBaseFullAppInfo() {
    return { app: undefined, versions: [] };
}
export const FullAppInfo = {
    $type: "devvit.dev_portal.app.FullAppInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.app !== undefined) {
            AppInfo.encode(message.app, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.versions) {
            AppVersionInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullAppInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.app = AppInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.versions.push(AppVersionInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            app: isSet(object.app) ? AppInfo.fromJSON(object.app) : undefined,
            versions: Array.isArray(object?.versions) ? object.versions.map((e) => AppVersionInfo.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.app !== undefined && (obj.app = message.app ? AppInfo.toJSON(message.app) : undefined);
        if (message.versions) {
            obj.versions = message.versions.map((e) => e ? AppVersionInfo.toJSON(e) : undefined);
        }
        else {
            obj.versions = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFullAppInfo();
        message.app = (object.app !== undefined && object.app !== null) ? AppInfo.fromPartial(object.app) : undefined;
        message.versions = object.versions?.map((e) => AppVersionInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.FullAppInfo", FullAppInfo);
function createBaseMediaSignatureStatus() {
    return { filePath: "", isNew: false, existingMediaId: undefined };
}
export const MediaSignatureStatus = {
    $type: "devvit.dev_portal.app.MediaSignatureStatus",
    encode(message, writer = _m0.Writer.create()) {
        if (message.filePath !== "") {
            writer.uint32(10).string(message.filePath);
        }
        if (message.isNew === true) {
            writer.uint32(16).bool(message.isNew);
        }
        if (message.existingMediaId !== undefined) {
            writer.uint32(26).string(message.existingMediaId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMediaSignatureStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.filePath = reader.string();
                    break;
                case 2:
                    message.isNew = reader.bool();
                    break;
                case 3:
                    message.existingMediaId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            filePath: isSet(object.filePath) ? String(object.filePath) : "",
            isNew: isSet(object.isNew) ? Boolean(object.isNew) : false,
            existingMediaId: isSet(object.existingMediaId) ? String(object.existingMediaId) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.filePath !== undefined && (obj.filePath = message.filePath);
        message.isNew !== undefined && (obj.isNew = message.isNew);
        message.existingMediaId !== undefined && (obj.existingMediaId = message.existingMediaId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMediaSignatureStatus();
        message.filePath = object.filePath ?? "";
        message.isNew = object.isNew ?? false;
        message.existingMediaId = object.existingMediaId ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.MediaSignatureStatus", MediaSignatureStatus);
function createBaseCheckIfMediaExistsResponse() {
    return { statuses: [] };
}
export const CheckIfMediaExistsResponse = {
    $type: "devvit.dev_portal.app.CheckIfMediaExistsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.statuses) {
            MediaSignatureStatus.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckIfMediaExistsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.statuses.push(MediaSignatureStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            statuses: Array.isArray(object?.statuses)
                ? object.statuses.map((e) => MediaSignatureStatus.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.statuses) {
            obj.statuses = message.statuses.map((e) => e ? MediaSignatureStatus.toJSON(e) : undefined);
        }
        else {
            obj.statuses = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCheckIfMediaExistsResponse();
        message.statuses = object.statuses?.map((e) => MediaSignatureStatus.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.CheckIfMediaExistsResponse", CheckIfMediaExistsResponse);
function createBaseUploadNewMediaResponse() {
    return { assetId: "", mediaId: "" };
}
export const UploadNewMediaResponse = {
    $type: "devvit.dev_portal.app.UploadNewMediaResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.assetId !== "") {
            writer.uint32(10).string(message.assetId);
        }
        if (message.mediaId !== "") {
            writer.uint32(18).string(message.mediaId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadNewMediaResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.assetId = reader.string();
                    break;
                case 2:
                    message.mediaId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            assetId: isSet(object.assetId) ? String(object.assetId) : "",
            mediaId: isSet(object.mediaId) ? String(object.mediaId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.assetId !== undefined && (obj.assetId = message.assetId);
        message.mediaId !== undefined && (obj.mediaId = message.mediaId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUploadNewMediaResponse();
        message.assetId = object.assetId ?? "";
        message.mediaId = object.mediaId ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.UploadNewMediaResponse", UploadNewMediaResponse);
function createBaseAppSearchResponse() {
    return { apps: [], totalResults: 0, pageNumber: 0, pageSize: 0 };
}
export const AppSearchResponse = {
    $type: "devvit.dev_portal.app.AppSearchResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.apps) {
            AppInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.totalResults !== 0) {
            writer.uint32(16).int32(message.totalResults);
        }
        if (message.pageNumber !== 0) {
            writer.uint32(24).int32(message.pageNumber);
        }
        if (message.pageSize !== 0) {
            writer.uint32(32).int32(message.pageSize);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppSearchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apps.push(AppInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalResults = reader.int32();
                    break;
                case 3:
                    message.pageNumber = reader.int32();
                    break;
                case 4:
                    message.pageSize = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            apps: Array.isArray(object?.apps) ? object.apps.map((e) => AppInfo.fromJSON(e)) : [],
            totalResults: isSet(object.totalResults) ? Number(object.totalResults) : 0,
            pageNumber: isSet(object.pageNumber) ? Number(object.pageNumber) : 0,
            pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.apps) {
            obj.apps = message.apps.map((e) => e ? AppInfo.toJSON(e) : undefined);
        }
        else {
            obj.apps = [];
        }
        message.totalResults !== undefined && (obj.totalResults = Math.round(message.totalResults));
        message.pageNumber !== undefined && (obj.pageNumber = Math.round(message.pageNumber));
        message.pageSize !== undefined && (obj.pageSize = Math.round(message.pageSize));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppSearchResponse();
        message.apps = object.apps?.map((e) => AppInfo.fromPartial(e)) || [];
        message.totalResults = object.totalResults ?? 0;
        message.pageNumber = object.pageNumber ?? 0;
        message.pageSize = object.pageSize ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppSearchResponse", AppSearchResponse);
function createBaseUnpublishAppRequest() {
    return { slug: undefined, shouldDelist: false };
}
export const UnpublishAppRequest = {
    $type: "devvit.dev_portal.app.UnpublishAppRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== undefined) {
            StringValue.encode({ value: message.slug }, writer.uint32(10).fork()).ldelim();
        }
        if (message.shouldDelist === true) {
            writer.uint32(16).bool(message.shouldDelist);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnpublishAppRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slug = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.shouldDelist = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            slug: isSet(object.slug) ? String(object.slug) : undefined,
            shouldDelist: isSet(object.shouldDelist) ? Boolean(object.shouldDelist) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.slug !== undefined && (obj.slug = message.slug);
        message.shouldDelist !== undefined && (obj.shouldDelist = message.shouldDelist);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUnpublishAppRequest();
        message.slug = object.slug ?? undefined;
        message.shouldDelist = object.shouldDelist ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.UnpublishAppRequest", UnpublishAppRequest);
function createBaseAppExistsRequest() {
    return { slug: undefined };
}
export const AppExistsRequest = {
    $type: "devvit.dev_portal.app.AppExistsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== undefined) {
            StringValue.encode({ value: message.slug }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppExistsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slug = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { slug: isSet(object.slug) ? String(object.slug) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.slug !== undefined && (obj.slug = message.slug);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppExistsRequest();
        message.slug = object.slug ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppExistsRequest", AppExistsRequest);
function createBaseAppExistsResponse() {
    return { exists: false };
}
export const AppExistsResponse = {
    $type: "devvit.dev_portal.app.AppExistsResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.exists === true) {
            writer.uint32(8).bool(message.exists);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppExistsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exists = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { exists: isSet(object.exists) ? Boolean(object.exists) : false };
    },
    toJSON(message) {
        const obj = {};
        message.exists !== undefined && (obj.exists = message.exists);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppExistsResponse();
        message.exists = object.exists ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppExistsResponse", AppExistsResponse);
function createBaseAppAccountExistsRequest() {
    return { accountName: "" };
}
export const AppAccountExistsRequest = {
    $type: "devvit.dev_portal.app.AppAccountExistsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.accountName !== "") {
            writer.uint32(10).string(message.accountName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppAccountExistsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { accountName: isSet(object.accountName) ? String(object.accountName) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.accountName !== undefined && (obj.accountName = message.accountName);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppAccountExistsRequest();
        message.accountName = object.accountName ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppAccountExistsRequest", AppAccountExistsRequest);
function createBaseAppAccountExistsResponse() {
    return { exists: false, suggestions: [] };
}
export const AppAccountExistsResponse = {
    $type: "devvit.dev_portal.app.AppAccountExistsResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.exists === true) {
            writer.uint32(8).bool(message.exists);
        }
        for (const v of message.suggestions) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppAccountExistsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exists = reader.bool();
                    break;
                case 2:
                    message.suggestions.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            exists: isSet(object.exists) ? Boolean(object.exists) : false,
            suggestions: Array.isArray(object?.suggestions) ? object.suggestions.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.exists !== undefined && (obj.exists = message.exists);
        if (message.suggestions) {
            obj.suggestions = message.suggestions.map((e) => e);
        }
        else {
            obj.suggestions = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppAccountExistsResponse();
        message.exists = object.exists ?? false;
        message.suggestions = object.suggestions?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppAccountExistsResponse", AppAccountExistsResponse);
function createBaseCreateAppAccountRequest() {
    return { slug: "", accountName: undefined, captcha: "" };
}
export const CreateAppAccountRequest = {
    $type: "devvit.dev_portal.app.CreateAppAccountRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== "") {
            writer.uint32(10).string(message.slug);
        }
        if (message.accountName !== undefined) {
            writer.uint32(18).string(message.accountName);
        }
        if (message.captcha !== "") {
            writer.uint32(26).string(message.captcha);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateAppAccountRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slug = reader.string();
                    break;
                case 2:
                    message.accountName = reader.string();
                    break;
                case 3:
                    message.captcha = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            slug: isSet(object.slug) ? String(object.slug) : "",
            accountName: isSet(object.accountName) ? String(object.accountName) : undefined,
            captcha: isSet(object.captcha) ? String(object.captcha) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.slug !== undefined && (obj.slug = message.slug);
        message.accountName !== undefined && (obj.accountName = message.accountName);
        message.captcha !== undefined && (obj.captcha = message.captcha);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateAppAccountRequest();
        message.slug = object.slug ?? "";
        message.accountName = object.accountName ?? undefined;
        message.captcha = object.captcha ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.CreateAppAccountRequest", CreateAppAccountRequest);
function createBaseCreateAppAccountResponse() {
    return { created: false, errors: undefined };
}
export const CreateAppAccountResponse = {
    $type: "devvit.dev_portal.app.CreateAppAccountResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.created === true) {
            writer.uint32(8).bool(message.created);
        }
        if (message.errors !== undefined) {
            writer.uint32(18).string(message.errors);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateAppAccountResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.created = reader.bool();
                    break;
                case 2:
                    message.errors = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            created: isSet(object.created) ? Boolean(object.created) : false,
            errors: isSet(object.errors) ? String(object.errors) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.created !== undefined && (obj.created = message.created);
        message.errors !== undefined && (obj.errors = message.errors);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateAppAccountResponse();
        message.created = object.created ?? false;
        message.errors = object.errors ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.CreateAppAccountResponse", CreateAppAccountResponse);
function createBaseRecoverAppAccountRequest() {
    return {
        name: "",
        slug: "",
        description: "",
        isNsfw: false,
        categories: [],
        ownerId: "",
        username: "",
        password: "",
    };
}
export const RecoverAppAccountRequest = {
    $type: "devvit.dev_portal.app.RecoverAppAccountRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.slug !== "") {
            writer.uint32(18).string(message.slug);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.isNsfw === true) {
            writer.uint32(32).bool(message.isNsfw);
        }
        writer.uint32(42).fork();
        for (const v of message.categories) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.ownerId !== "") {
            writer.uint32(50).string(message.ownerId);
        }
        if (message.username !== "") {
            writer.uint32(58).string(message.username);
        }
        if (message.password !== "") {
            writer.uint32(66).string(message.password);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecoverAppAccountRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.slug = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.isNsfw = reader.bool();
                    break;
                case 5:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.categories.push(reader.int32());
                        }
                    }
                    else {
                        message.categories.push(reader.int32());
                    }
                    break;
                case 6:
                    message.ownerId = reader.string();
                    break;
                case 7:
                    message.username = reader.string();
                    break;
                case 8:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            slug: isSet(object.slug) ? String(object.slug) : "",
            description: isSet(object.description) ? String(object.description) : "",
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : false,
            categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
            ownerId: isSet(object.ownerId) ? String(object.ownerId) : "",
            username: isSet(object.username) ? String(object.username) : "",
            password: isSet(object.password) ? String(object.password) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.slug !== undefined && (obj.slug = message.slug);
        message.description !== undefined && (obj.description = message.description);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        if (message.categories) {
            obj.categories = message.categories.map((e) => categoriesToJSON(e));
        }
        else {
            obj.categories = [];
        }
        message.ownerId !== undefined && (obj.ownerId = message.ownerId);
        message.username !== undefined && (obj.username = message.username);
        message.password !== undefined && (obj.password = message.password);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRecoverAppAccountRequest();
        message.name = object.name ?? "";
        message.slug = object.slug ?? "";
        message.description = object.description ?? "";
        message.isNsfw = object.isNsfw ?? false;
        message.categories = object.categories?.map((e) => e) || [];
        message.ownerId = object.ownerId ?? "";
        message.username = object.username ?? "";
        message.password = object.password ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.RecoverAppAccountRequest", RecoverAppAccountRequest);
var globalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
