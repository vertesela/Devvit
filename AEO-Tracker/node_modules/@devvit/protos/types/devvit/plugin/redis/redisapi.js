/**
 * #redisapi.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import Long from "long";
import _m0 from 'protobufjs/minimal.js';
import { Empty } from '../../../google/protobuf/empty.js';
import { DoubleValue, Int64Value, StringValue } from '../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
/**
 * This key scope determines the key namespacing in Redis storage
 * By default, all keys in Redis are namespaced to an installation
 * Global redis enables apps to persist and access state across subreddit installations
 * Default key format - installation:app:custom-key
 * Global redis key format - global:app:custom-key
 */
export var RedisKeyScope;
(function (RedisKeyScope) {
    RedisKeyScope[RedisKeyScope["INSTALLATION"] = 0] = "INSTALLATION";
    RedisKeyScope[RedisKeyScope["GLOBAL"] = 1] = "GLOBAL";
    RedisKeyScope[RedisKeyScope["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RedisKeyScope || (RedisKeyScope = {}));
export function redisKeyScopeFromJSON(object) {
    switch (object) {
        case 0:
        case "INSTALLATION":
            return RedisKeyScope.INSTALLATION;
        case 1:
        case "GLOBAL":
            return RedisKeyScope.GLOBAL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return RedisKeyScope.UNRECOGNIZED;
    }
}
export function redisKeyScopeToJSON(object) {
    switch (object) {
        case RedisKeyScope.INSTALLATION:
            return 0;
        case RedisKeyScope.GLOBAL:
            return 1;
        case RedisKeyScope.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseTransactionResponses() {
    return { response: [] };
}
export const TransactionResponses = {
    $type: "devvit.plugin.redis.TransactionResponses",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.response) {
            TransactionResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionResponses();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.response.push(TransactionResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            response: Array.isArray(object?.response) ? object.response.map((e) => TransactionResponse.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.response) {
            obj.response = message.response.map((e) => e ? TransactionResponse.toJSON(e) : undefined);
        }
        else {
            obj.response = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTransactionResponses();
        message.response = object.response?.map((e) => TransactionResponse.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.TransactionResponses", TransactionResponses);
function createBaseTransactionResponse() {
    return { str: undefined, nil: undefined, num: undefined, members: undefined, values: undefined };
}
export const TransactionResponse = {
    $type: "devvit.plugin.redis.TransactionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.str !== undefined) {
            StringValue.encode({ value: message.str }, writer.uint32(10).fork()).ldelim();
        }
        if (message.nil !== undefined) {
            Empty.encode(message.nil, writer.uint32(18).fork()).ldelim();
        }
        if (message.num !== undefined) {
            Int64Value.encode({ value: message.num }, writer.uint32(26).fork()).ldelim();
        }
        if (message.members !== undefined) {
            ZMembers.encode(message.members, writer.uint32(34).fork()).ldelim();
        }
        if (message.values !== undefined) {
            RedisValues.encode(message.values, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.str = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.nil = Empty.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.num = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.members = ZMembers.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.values = RedisValues.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            str: isSet(object.str) ? String(object.str) : undefined,
            nil: isSet(object.nil) ? Empty.fromJSON(object.nil) : undefined,
            num: isSet(object.num) ? Number(object.num) : undefined,
            members: isSet(object.members) ? ZMembers.fromJSON(object.members) : undefined,
            values: isSet(object.values) ? RedisValues.fromJSON(object.values) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.str !== undefined && (obj.str = message.str);
        message.nil !== undefined && (obj.nil = message.nil ? Empty.toJSON(message.nil) : undefined);
        message.num !== undefined && (obj.num = message.num);
        message.members !== undefined && (obj.members = message.members ? ZMembers.toJSON(message.members) : undefined);
        message.values !== undefined && (obj.values = message.values ? RedisValues.toJSON(message.values) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTransactionResponse();
        message.str = object.str ?? undefined;
        message.nil = (object.nil !== undefined && object.nil !== null) ? Empty.fromPartial(object.nil) : undefined;
        message.num = object.num ?? undefined;
        message.members = (object.members !== undefined && object.members !== null)
            ? ZMembers.fromPartial(object.members)
            : undefined;
        message.values = (object.values !== undefined && object.values !== null)
            ? RedisValues.fromPartial(object.values)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.TransactionResponse", TransactionResponse);
function createBaseZRangeRequest() {
    return {
        key: undefined,
        start: "",
        stop: "",
        byScore: false,
        byLex: false,
        rev: false,
        offset: 0,
        count: 0,
        scope: undefined,
    };
}
export const ZRangeRequest = {
    $type: "devvit.plugin.redis.ZRangeRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.start !== "") {
            writer.uint32(18).string(message.start);
        }
        if (message.stop !== "") {
            writer.uint32(26).string(message.stop);
        }
        if (message.byScore === true) {
            writer.uint32(32).bool(message.byScore);
        }
        if (message.byLex === true) {
            writer.uint32(40).bool(message.byLex);
        }
        if (message.rev === true) {
            writer.uint32(48).bool(message.rev);
        }
        if (message.offset !== 0) {
            writer.uint32(56).int32(message.offset);
        }
        if (message.count !== 0) {
            writer.uint32(64).int32(message.count);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRangeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.start = reader.string();
                    break;
                case 3:
                    message.stop = reader.string();
                    break;
                case 4:
                    message.byScore = reader.bool();
                    break;
                case 5:
                    message.byLex = reader.bool();
                    break;
                case 6:
                    message.rev = reader.bool();
                    break;
                case 7:
                    message.offset = reader.int32();
                    break;
                case 8:
                    message.count = reader.int32();
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            start: isSet(object.start) ? String(object.start) : "",
            stop: isSet(object.stop) ? String(object.stop) : "",
            byScore: isSet(object.byScore) ? Boolean(object.byScore) : false,
            byLex: isSet(object.byLex) ? Boolean(object.byLex) : false,
            rev: isSet(object.rev) ? Boolean(object.rev) : false,
            offset: isSet(object.offset) ? Number(object.offset) : 0,
            count: isSet(object.count) ? Number(object.count) : 0,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? KeyRequest.toJSON(message.key) : undefined);
        message.start !== undefined && (obj.start = message.start);
        message.stop !== undefined && (obj.stop = message.stop);
        message.byScore !== undefined && (obj.byScore = message.byScore);
        message.byLex !== undefined && (obj.byLex = message.byLex);
        message.rev !== undefined && (obj.rev = message.rev);
        message.offset !== undefined && (obj.offset = Math.round(message.offset));
        message.count !== undefined && (obj.count = Math.round(message.count));
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZRangeRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.start = object.start ?? "";
        message.stop = object.stop ?? "";
        message.byScore = object.byScore ?? false;
        message.byLex = object.byLex ?? false;
        message.rev = object.rev ?? false;
        message.offset = object.offset ?? 0;
        message.count = object.count ?? 0;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZRangeRequest", ZRangeRequest);
function createBaseZRangeByLexRequest() {
    return { key: undefined, min: "", max: "", scope: undefined };
}
export const ZRangeByLexRequest = {
    $type: "devvit.plugin.redis.ZRangeByLexRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== "") {
            writer.uint32(18).string(message.min);
        }
        if (message.max !== "") {
            writer.uint32(26).string(message.max);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRangeByLexRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.min = reader.string();
                    break;
                case 3:
                    message.max = reader.string();
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            min: isSet(object.min) ? String(object.min) : "",
            max: isSet(object.max) ? String(object.max) : "",
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? KeyRequest.toJSON(message.key) : undefined);
        message.min !== undefined && (obj.min = message.min);
        message.max !== undefined && (obj.max = message.max);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZRangeByLexRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.min = object.min ?? "";
        message.max = object.max ?? "";
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZRangeByLexRequest", ZRangeByLexRequest);
function createBaseZRangeByScoreRequest() {
    return { key: undefined, min: 0, max: 0, withScores: false, scope: undefined };
}
export const ZRangeByScoreRequest = {
    $type: "devvit.plugin.redis.ZRangeByScoreRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== 0) {
            writer.uint32(17).double(message.min);
        }
        if (message.max !== 0) {
            writer.uint32(25).double(message.max);
        }
        if (message.withScores === true) {
            writer.uint32(32).bool(message.withScores);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRangeByScoreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.min = reader.double();
                    break;
                case 3:
                    message.max = reader.double();
                    break;
                case 4:
                    message.withScores = reader.bool();
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            min: isSet(object.min) ? Number(object.min) : 0,
            max: isSet(object.max) ? Number(object.max) : 0,
            withScores: isSet(object.withScores) ? Boolean(object.withScores) : false,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? KeyRequest.toJSON(message.key) : undefined);
        message.min !== undefined && (obj.min = message.min);
        message.max !== undefined && (obj.max = message.max);
        message.withScores !== undefined && (obj.withScores = message.withScores);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZRangeByScoreRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.min = object.min ?? 0;
        message.max = object.max ?? 0;
        message.withScores = object.withScores ?? false;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZRangeByScoreRequest", ZRangeByScoreRequest);
function createBaseZRemRequest() {
    return { key: undefined, members: [], scope: undefined };
}
export const ZRemRequest = {
    $type: "devvit.plugin.redis.ZRemRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.members) {
            writer.uint32(18).string(v);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRemRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.members.push(reader.string());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            members: Array.isArray(object?.members) ? object.members.map((e) => String(e)) : [],
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? KeyRequest.toJSON(message.key) : undefined);
        if (message.members) {
            obj.members = message.members.map((e) => e);
        }
        else {
            obj.members = [];
        }
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZRemRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.members = object.members?.map((e) => e) || [];
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZRemRequest", ZRemRequest);
function createBaseZRemRangeByLexRequest() {
    return { key: undefined, min: "", max: "", scope: undefined };
}
export const ZRemRangeByLexRequest = {
    $type: "devvit.plugin.redis.ZRemRangeByLexRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== "") {
            writer.uint32(18).string(message.min);
        }
        if (message.max !== "") {
            writer.uint32(26).string(message.max);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRemRangeByLexRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.min = reader.string();
                    break;
                case 3:
                    message.max = reader.string();
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            min: isSet(object.min) ? String(object.min) : "",
            max: isSet(object.max) ? String(object.max) : "",
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? KeyRequest.toJSON(message.key) : undefined);
        message.min !== undefined && (obj.min = message.min);
        message.max !== undefined && (obj.max = message.max);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZRemRangeByLexRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.min = object.min ?? "";
        message.max = object.max ?? "";
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZRemRangeByLexRequest", ZRemRangeByLexRequest);
function createBaseZRemRangeByRankRequest() {
    return { key: undefined, start: 0, stop: 0, scope: undefined };
}
export const ZRemRangeByRankRequest = {
    $type: "devvit.plugin.redis.ZRemRangeByRankRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.start !== 0) {
            writer.uint32(16).int32(message.start);
        }
        if (message.stop !== 0) {
            writer.uint32(24).int32(message.stop);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRemRangeByRankRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.start = reader.int32();
                    break;
                case 3:
                    message.stop = reader.int32();
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            start: isSet(object.start) ? Number(object.start) : 0,
            stop: isSet(object.stop) ? Number(object.stop) : 0,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? KeyRequest.toJSON(message.key) : undefined);
        message.start !== undefined && (obj.start = Math.round(message.start));
        message.stop !== undefined && (obj.stop = Math.round(message.stop));
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZRemRangeByRankRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.start = object.start ?? 0;
        message.stop = object.stop ?? 0;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZRemRangeByRankRequest", ZRemRangeByRankRequest);
function createBaseZRemRangeByScoreRequest() {
    return { key: undefined, min: 0, max: 0, scope: undefined };
}
export const ZRemRangeByScoreRequest = {
    $type: "devvit.plugin.redis.ZRemRangeByScoreRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== 0) {
            writer.uint32(17).double(message.min);
        }
        if (message.max !== 0) {
            writer.uint32(25).double(message.max);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRemRangeByScoreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.min = reader.double();
                    break;
                case 3:
                    message.max = reader.double();
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            min: isSet(object.min) ? Number(object.min) : 0,
            max: isSet(object.max) ? Number(object.max) : 0,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? KeyRequest.toJSON(message.key) : undefined);
        message.min !== undefined && (obj.min = message.min);
        message.max !== undefined && (obj.max = message.max);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZRemRangeByScoreRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.min = object.min ?? 0;
        message.max = object.max ?? 0;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZRemRangeByScoreRequest", ZRemRangeByScoreRequest);
function createBaseZScoreRequest() {
    return { key: undefined, member: "", scope: undefined };
}
export const ZScoreRequest = {
    $type: "devvit.plugin.redis.ZScoreRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZScoreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.member = reader.string();
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            member: isSet(object.member) ? String(object.member) : "",
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? KeyRequest.toJSON(message.key) : undefined);
        message.member !== undefined && (obj.member = message.member);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZScoreRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.member = object.member ?? "";
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZScoreRequest", ZScoreRequest);
function createBaseZRankRequest() {
    return { key: undefined, member: "", scope: undefined };
}
export const ZRankRequest = {
    $type: "devvit.plugin.redis.ZRankRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            KeyRequest.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZRankRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = KeyRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.member = reader.string();
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? KeyRequest.fromJSON(object.key) : undefined,
            member: isSet(object.member) ? String(object.member) : "",
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? KeyRequest.toJSON(message.key) : undefined);
        message.member !== undefined && (obj.member = message.member);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZRankRequest();
        message.key = (object.key !== undefined && object.key !== null) ? KeyRequest.fromPartial(object.key) : undefined;
        message.member = object.member ?? "";
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZRankRequest", ZRankRequest);
function createBaseZIncrByRequest() {
    return { key: "", member: "", value: 0, transactionId: undefined, scope: undefined };
}
export const ZIncrByRequest = {
    $type: "devvit.plugin.redis.ZIncrByRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        if (message.value !== 0) {
            writer.uint32(25).double(message.value);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZIncrByRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.member = reader.string();
                    break;
                case 3:
                    message.value = reader.double();
                    break;
                case 6:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            member: isSet(object.member) ? String(object.member) : "",
            value: isSet(object.value) ? Number(object.value) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.member !== undefined && (obj.member = message.member);
        message.value !== undefined && (obj.value = message.value);
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZIncrByRequest();
        message.key = object.key ?? "";
        message.member = object.member ?? "";
        message.value = object.value ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZIncrByRequest", ZIncrByRequest);
function createBaseKeyRequest() {
    return { key: "", transactionId: undefined, scope: undefined };
}
export const KeyRequest = {
    $type: "devvit.plugin.redis.KeyRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(18).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseKeyRequest();
        message.key = object.key ?? "";
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.KeyRequest", KeyRequest);
function createBaseIncrByRequest() {
    return { key: "", value: 0, transactionId: undefined, scope: undefined };
}
export const IncrByRequest = {
    $type: "devvit.plugin.redis.IncrByRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int64(message.value);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncrByRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = longToNumber(reader.int64());
                    break;
                case 6:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? Number(object.value) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = Math.round(message.value));
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseIncrByRequest();
        message.key = object.key ?? "";
        message.value = object.value ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.IncrByRequest", IncrByRequest);
function createBaseSetRequest() {
    return { key: "", value: "", expiration: 0, nx: false, xx: false, transactionId: undefined, scope: undefined };
}
export const SetRequest = {
    $type: "devvit.plugin.redis.SetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        if (message.expiration !== 0) {
            writer.uint32(24).int64(message.expiration);
        }
        if (message.nx === true) {
            writer.uint32(32).bool(message.nx);
        }
        if (message.xx === true) {
            writer.uint32(40).bool(message.xx);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                case 3:
                    message.expiration = longToNumber(reader.int64());
                    break;
                case 4:
                    message.nx = reader.bool();
                    break;
                case 5:
                    message.xx = reader.bool();
                    break;
                case 6:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? String(object.value) : "",
            expiration: isSet(object.expiration) ? Number(object.expiration) : 0,
            nx: isSet(object.nx) ? Boolean(object.nx) : false,
            xx: isSet(object.xx) ? Boolean(object.xx) : false,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        message.expiration !== undefined && (obj.expiration = Math.round(message.expiration));
        message.nx !== undefined && (obj.nx = message.nx);
        message.xx !== undefined && (obj.xx = message.xx);
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSetRequest();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        message.expiration = object.expiration ?? 0;
        message.nx = object.nx ?? false;
        message.xx = object.xx ?? false;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.SetRequest", SetRequest);
function createBaseKeyRangeRequest() {
    return { key: "", start: 0, end: 0, transactionId: undefined, scope: undefined };
}
export const KeyRangeRequest = {
    $type: "devvit.plugin.redis.KeyRangeRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.start !== 0) {
            writer.uint32(16).int32(message.start);
        }
        if (message.end !== 0) {
            writer.uint32(24).int32(message.end);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(34).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyRangeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.start = reader.int32();
                    break;
                case 3:
                    message.end = reader.int32();
                    break;
                case 4:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            start: isSet(object.start) ? Number(object.start) : 0,
            end: isSet(object.end) ? Number(object.end) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.start !== undefined && (obj.start = Math.round(message.start));
        message.end !== undefined && (obj.end = Math.round(message.end));
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseKeyRangeRequest();
        message.key = object.key ?? "";
        message.start = object.start ?? 0;
        message.end = object.end ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.KeyRangeRequest", KeyRangeRequest);
function createBaseSetRangeRequest() {
    return { key: "", offset: 0, value: "", transactionId: undefined, scope: undefined };
}
export const SetRangeRequest = {
    $type: "devvit.plugin.redis.SetRangeRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.offset !== 0) {
            writer.uint32(16).int32(message.offset);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(34).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetRangeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.offset = reader.int32();
                    break;
                case 3:
                    message.value = reader.string();
                    break;
                case 4:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            offset: isSet(object.offset) ? Number(object.offset) : 0,
            value: isSet(object.value) ? String(object.value) : "",
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.offset !== undefined && (obj.offset = Math.round(message.offset));
        message.value !== undefined && (obj.value = message.value);
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSetRangeRequest();
        message.key = object.key ?? "";
        message.offset = object.offset ?? 0;
        message.value = object.value ?? "";
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.SetRangeRequest", SetRangeRequest);
function createBaseKeysRequest() {
    return { keys: [], transactionId: undefined, scope: undefined };
}
export const KeysRequest = {
    $type: "devvit.plugin.redis.KeysRequest",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.keys) {
            writer.uint32(10).string(v);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(18).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeysRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keys.push(reader.string());
                    break;
                case 2:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            keys: Array.isArray(object?.keys) ? object.keys.map((e) => String(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.keys) {
            obj.keys = message.keys.map((e) => e);
        }
        else {
            obj.keys = [];
        }
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseKeysRequest();
        message.keys = object.keys?.map((e) => e) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.KeysRequest", KeysRequest);
function createBaseKeysResponse() {
    return { keys: [] };
}
export const KeysResponse = {
    $type: "devvit.plugin.redis.KeysResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.keys) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeysResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keys.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { keys: Array.isArray(object?.keys) ? object.keys.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.keys) {
            obj.keys = message.keys.map((e) => e);
        }
        else {
            obj.keys = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseKeysResponse();
        message.keys = object.keys?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.KeysResponse", KeysResponse);
function createBaseHGetRequest() {
    return { key: "", field: "", transactionId: undefined, scope: undefined };
}
export const HGetRequest = {
    $type: "devvit.plugin.redis.HGetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.field !== "") {
            writer.uint32(18).string(message.field);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHGetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.field = reader.string();
                    break;
                case 3:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            field: isSet(object.field) ? String(object.field) : "",
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.field !== undefined && (obj.field = message.field);
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHGetRequest();
        message.key = object.key ?? "";
        message.field = object.field ?? "";
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.HGetRequest", HGetRequest);
function createBaseHSetRequest() {
    return { key: "", fv: [], transactionId: undefined, scope: undefined };
}
export const HSetRequest = {
    $type: "devvit.plugin.redis.HSetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        for (const v of message.fv) {
            RedisFieldValue.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHSetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.fv.push(RedisFieldValue.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            fv: Array.isArray(object?.fv) ? object.fv.map((e) => RedisFieldValue.fromJSON(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        if (message.fv) {
            obj.fv = message.fv.map((e) => e ? RedisFieldValue.toJSON(e) : undefined);
        }
        else {
            obj.fv = [];
        }
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHSetRequest();
        message.key = object.key ?? "";
        message.fv = object.fv?.map((e) => RedisFieldValue.fromPartial(e)) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.HSetRequest", HSetRequest);
function createBaseHDelRequest() {
    return { key: "", fields: [], transactionId: undefined, scope: undefined };
}
export const HDelRequest = {
    $type: "devvit.plugin.redis.HDelRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        for (const v of message.fields) {
            writer.uint32(18).string(v);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHDelRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.fields.push(reader.string());
                    break;
                case 3:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            fields: Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        if (message.fields) {
            obj.fields = message.fields.map((e) => e);
        }
        else {
            obj.fields = [];
        }
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHDelRequest();
        message.key = object.key ?? "";
        message.fields = object.fields?.map((e) => e) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.HDelRequest", HDelRequest);
function createBaseHScanRequest() {
    return { key: "", cursor: 0, pattern: undefined, count: undefined, transactionId: undefined, scope: undefined };
}
export const HScanRequest = {
    $type: "devvit.plugin.redis.HScanRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.cursor !== 0) {
            writer.uint32(16).uint64(message.cursor);
        }
        if (message.pattern !== undefined) {
            writer.uint32(26).string(message.pattern);
        }
        if (message.count !== undefined) {
            writer.uint32(32).int64(message.count);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(42).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHScanRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.cursor = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.pattern = reader.string();
                    break;
                case 4:
                    message.count = longToNumber(reader.int64());
                    break;
                case 5:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            cursor: isSet(object.cursor) ? Number(object.cursor) : 0,
            pattern: isSet(object.pattern) ? String(object.pattern) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.cursor !== undefined && (obj.cursor = Math.round(message.cursor));
        message.pattern !== undefined && (obj.pattern = message.pattern);
        message.count !== undefined && (obj.count = Math.round(message.count));
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHScanRequest();
        message.key = object.key ?? "";
        message.cursor = object.cursor ?? 0;
        message.pattern = object.pattern ?? undefined;
        message.count = object.count ?? undefined;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.HScanRequest", HScanRequest);
function createBaseHScanResponse() {
    return { cursor: 0, fieldValues: [] };
}
export const HScanResponse = {
    $type: "devvit.plugin.redis.HScanResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.cursor !== 0) {
            writer.uint32(8).uint64(message.cursor);
        }
        for (const v of message.fieldValues) {
            RedisFieldValue.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHScanResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cursor = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.fieldValues.push(RedisFieldValue.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            cursor: isSet(object.cursor) ? Number(object.cursor) : 0,
            fieldValues: Array.isArray(object?.fieldValues)
                ? object.fieldValues.map((e) => RedisFieldValue.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.cursor !== undefined && (obj.cursor = Math.round(message.cursor));
        if (message.fieldValues) {
            obj.fieldValues = message.fieldValues.map((e) => e ? RedisFieldValue.toJSON(e) : undefined);
        }
        else {
            obj.fieldValues = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHScanResponse();
        message.cursor = object.cursor ?? 0;
        message.fieldValues = object.fieldValues?.map((e) => RedisFieldValue.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.HScanResponse", HScanResponse);
function createBaseHIncrByRequest() {
    return { key: "", field: "", value: 0, transactionId: undefined, scope: undefined };
}
export const HIncrByRequest = {
    $type: "devvit.plugin.redis.HIncrByRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.field !== "") {
            writer.uint32(18).string(message.field);
        }
        if (message.value !== 0) {
            writer.uint32(24).int64(message.value);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(50).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHIncrByRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.field = reader.string();
                    break;
                case 3:
                    message.value = longToNumber(reader.int64());
                    break;
                case 6:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            field: isSet(object.field) ? String(object.field) : "",
            value: isSet(object.value) ? Number(object.value) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.field !== undefined && (obj.field = message.field);
        message.value !== undefined && (obj.value = Math.round(message.value));
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHIncrByRequest();
        message.key = object.key ?? "";
        message.field = object.field ?? "";
        message.value = object.value ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.HIncrByRequest", HIncrByRequest);
function createBaseRedisFieldValue() {
    return { field: "", value: "" };
}
export const RedisFieldValue = {
    $type: "devvit.plugin.redis.RedisFieldValue",
    encode(message, writer = _m0.Writer.create()) {
        if (message.field !== "") {
            writer.uint32(10).string(message.field);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisFieldValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.field = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            field: isSet(object.field) ? String(object.field) : "",
            value: isSet(object.value) ? String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.field !== undefined && (obj.field = message.field);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedisFieldValue();
        message.field = object.field ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.RedisFieldValue", RedisFieldValue);
function createBaseRedisFieldValues() {
    return { fieldValues: {} };
}
export const RedisFieldValues = {
    $type: "devvit.plugin.redis.RedisFieldValues",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.fieldValues).forEach(([key, value]) => {
            RedisFieldValues_FieldValuesEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisFieldValues();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = RedisFieldValues_FieldValuesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.fieldValues[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            fieldValues: isObject(object.fieldValues)
                ? Object.entries(object.fieldValues).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        obj.fieldValues = {};
        if (message.fieldValues) {
            Object.entries(message.fieldValues).forEach(([k, v]) => {
                obj.fieldValues[k] = v;
            });
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedisFieldValues();
        message.fieldValues = Object.entries(object.fieldValues ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.RedisFieldValues", RedisFieldValues);
function createBaseRedisFieldValues_FieldValuesEntry() {
    return { key: "", value: "" };
}
export const RedisFieldValues_FieldValuesEntry = {
    $type: "devvit.plugin.redis.RedisFieldValues.FieldValuesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisFieldValues_FieldValuesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedisFieldValues_FieldValuesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.RedisFieldValues.FieldValuesEntry", RedisFieldValues_FieldValuesEntry);
function createBaseKeyValuesRequest() {
    return { kv: [], transactionId: undefined, scope: undefined };
}
export const KeyValuesRequest = {
    $type: "devvit.plugin.redis.KeyValuesRequest",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.kv) {
            RedisKeyValue.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(18).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyValuesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kv.push(RedisKeyValue.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kv: Array.isArray(object?.kv) ? object.kv.map((e) => RedisKeyValue.fromJSON(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.kv) {
            obj.kv = message.kv.map((e) => e ? RedisKeyValue.toJSON(e) : undefined);
        }
        else {
            obj.kv = [];
        }
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseKeyValuesRequest();
        message.kv = object.kv?.map((e) => RedisKeyValue.fromPartial(e)) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.KeyValuesRequest", KeyValuesRequest);
function createBaseRedisKeyValue() {
    return { key: "", value: "" };
}
export const RedisKeyValue = {
    $type: "devvit.plugin.redis.RedisKeyValue",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisKeyValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedisKeyValue();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.RedisKeyValue", RedisKeyValue);
function createBaseRedisValues() {
    return { values: [] };
}
export const RedisValues = {
    $type: "devvit.plugin.redis.RedisValues",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.values) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedisValues();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.values.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { values: Array.isArray(object?.values) ? object.values.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.values) {
            obj.values = message.values.map((e) => e);
        }
        else {
            obj.values = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedisValues();
        message.values = object.values?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.RedisValues", RedisValues);
function createBaseExpireRequest() {
    return { key: "", seconds: 0, transactionId: undefined, scope: undefined };
}
export const ExpireRequest = {
    $type: "devvit.plugin.redis.ExpireRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.seconds !== 0) {
            writer.uint32(16).int32(message.seconds);
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpireRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.seconds = reader.int32();
                    break;
                case 3:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            seconds: isSet(object.seconds) ? Number(object.seconds) : 0,
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.seconds !== undefined && (obj.seconds = Math.round(message.seconds));
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseExpireRequest();
        message.key = object.key ?? "";
        message.seconds = object.seconds ?? 0;
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ExpireRequest", ExpireRequest);
function createBaseZAddRequest() {
    return { key: "", members: [], transactionId: undefined, scope: undefined };
}
export const ZAddRequest = {
    $type: "devvit.plugin.redis.ZAddRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        for (const v of message.members) {
            ZMember.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== undefined) {
            writer.uint32(800).int32(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZAddRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.members.push(ZMember.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            members: Array.isArray(object?.members) ? object.members.map((e) => ZMember.fromJSON(e)) : [],
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            scope: isSet(object.scope) ? redisKeyScopeFromJSON(object.scope) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        if (message.members) {
            obj.members = message.members.map((e) => e ? ZMember.toJSON(e) : undefined);
        }
        else {
            obj.members = [];
        }
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        message.scope !== undefined &&
            (obj.scope = message.scope !== undefined ? redisKeyScopeToJSON(message.scope) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZAddRequest();
        message.key = object.key ?? "";
        message.members = object.members?.map((e) => ZMember.fromPartial(e)) || [];
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.scope = object.scope ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZAddRequest", ZAddRequest);
function createBaseZMembers() {
    return { members: [] };
}
export const ZMembers = {
    $type: "devvit.plugin.redis.ZMembers",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.members) {
            ZMember.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZMembers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.members.push(ZMember.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { members: Array.isArray(object?.members) ? object.members.map((e) => ZMember.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.members) {
            obj.members = message.members.map((e) => e ? ZMember.toJSON(e) : undefined);
        }
        else {
            obj.members = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZMembers();
        message.members = object.members?.map((e) => ZMember.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZMembers", ZMembers);
function createBaseZMember() {
    return { score: 0, member: "" };
}
export const ZMember = {
    $type: "devvit.plugin.redis.ZMember",
    encode(message, writer = _m0.Writer.create()) {
        if (message.score !== 0) {
            writer.uint32(9).double(message.score);
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZMember();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.score = reader.double();
                    break;
                case 2:
                    message.member = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            score: isSet(object.score) ? Number(object.score) : 0,
            member: isSet(object.member) ? String(object.member) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.score !== undefined && (obj.score = message.score);
        message.member !== undefined && (obj.member = message.member);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseZMember();
        message.score = object.score ?? 0;
        message.member = object.member ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.ZMember", ZMember);
function createBaseTransactionId() {
    return { id: "" };
}
export const TransactionId = {
    $type: "devvit.plugin.redis.TransactionId",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTransactionId();
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.TransactionId", TransactionId);
function createBaseWatchRequest() {
    return { transactionId: undefined, keys: [] };
}
export const WatchRequest = {
    $type: "devvit.plugin.redis.WatchRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.transactionId !== undefined) {
            TransactionId.encode(message.transactionId, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.keys) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWatchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transactionId = TransactionId.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.keys.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
            keys: Array.isArray(object?.keys) ? object.keys.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.transactionId !== undefined &&
            (obj.transactionId = message.transactionId ? TransactionId.toJSON(message.transactionId) : undefined);
        if (message.keys) {
            obj.keys = message.keys.map((e) => e);
        }
        else {
            obj.keys = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWatchRequest();
        message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
            ? TransactionId.fromPartial(object.transactionId)
            : undefined;
        message.keys = object.keys?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redis.WatchRequest", WatchRequest);
export class RedisAPIClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.plugin.redis.RedisAPI";
        this.rpc = rpc;
        this.Get = this.Get.bind(this);
        this.Set = this.Set.bind(this);
        this.Del = this.Del.bind(this);
        this.Type = this.Type.bind(this);
        this.IncrBy = this.IncrBy.bind(this);
        this.HSet = this.HSet.bind(this);
        this.HGet = this.HGet.bind(this);
        this.HGetAll = this.HGetAll.bind(this);
        this.HDel = this.HDel.bind(this);
        this.HScan = this.HScan.bind(this);
        this.HKeys = this.HKeys.bind(this);
        this.HIncrBy = this.HIncrBy.bind(this);
        this.Multi = this.Multi.bind(this);
        this.Exec = this.Exec.bind(this);
        this.Discard = this.Discard.bind(this);
        this.Watch = this.Watch.bind(this);
        this.Unwatch = this.Unwatch.bind(this);
        this.GetRange = this.GetRange.bind(this);
        this.SetRange = this.SetRange.bind(this);
        this.Strlen = this.Strlen.bind(this);
        this.MGet = this.MGet.bind(this);
        this.MSet = this.MSet.bind(this);
        this.Expire = this.Expire.bind(this);
        this.ExpireTime = this.ExpireTime.bind(this);
        this.ZAdd = this.ZAdd.bind(this);
        this.ZCard = this.ZCard.bind(this);
        this.ZRange = this.ZRange.bind(this);
        this.ZRem = this.ZRem.bind(this);
        this.ZRemRangeByLex = this.ZRemRangeByLex.bind(this);
        this.ZRemRangeByRank = this.ZRemRangeByRank.bind(this);
        this.ZRemRangeByScore = this.ZRemRangeByScore.bind(this);
        this.ZScore = this.ZScore.bind(this);
        this.ZRank = this.ZRank.bind(this);
        this.ZIncrBy = this.ZIncrBy.bind(this);
    }
    Get(request) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Get", data);
        return promise.then((data) => StringValue.decode(new _m0.Reader(data)));
    }
    Set(request) {
        const data = SetRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Set", data);
        return promise.then((data) => StringValue.decode(new _m0.Reader(data)));
    }
    Del(request) {
        const data = KeysRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Del", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    Type(request) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Type", data);
        return promise.then((data) => StringValue.decode(new _m0.Reader(data)));
    }
    IncrBy(request) {
        const data = IncrByRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "IncrBy", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    HSet(request) {
        const data = HSetRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HSet", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    HGet(request) {
        const data = HGetRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HGet", data);
        return promise.then((data) => StringValue.decode(new _m0.Reader(data)));
    }
    HGetAll(request) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HGetAll", data);
        return promise.then((data) => RedisFieldValues.decode(new _m0.Reader(data)));
    }
    HDel(request) {
        const data = HDelRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HDel", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    HScan(request) {
        const data = HScanRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HScan", data);
        return promise.then((data) => HScanResponse.decode(new _m0.Reader(data)));
    }
    HKeys(request) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HKeys", data);
        return promise.then((data) => KeysResponse.decode(new _m0.Reader(data)));
    }
    HIncrBy(request) {
        const data = HIncrByRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "HIncrBy", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    Multi(request) {
        const data = TransactionId.encode(request).finish();
        const promise = this.rpc.request(this.service, "Multi", data);
        return promise.then((data) => Empty.decode(new _m0.Reader(data)));
    }
    Exec(request) {
        const data = TransactionId.encode(request).finish();
        const promise = this.rpc.request(this.service, "Exec", data);
        return promise.then((data) => TransactionResponses.decode(new _m0.Reader(data)));
    }
    Discard(request) {
        const data = TransactionId.encode(request).finish();
        const promise = this.rpc.request(this.service, "Discard", data);
        return promise.then((data) => Empty.decode(new _m0.Reader(data)));
    }
    Watch(request) {
        const data = WatchRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Watch", data);
        return promise.then((data) => TransactionId.decode(new _m0.Reader(data)));
    }
    Unwatch(request) {
        const data = TransactionId.encode(request).finish();
        const promise = this.rpc.request(this.service, "Unwatch", data);
        return promise.then((data) => Empty.decode(new _m0.Reader(data)));
    }
    GetRange(request) {
        const data = KeyRangeRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "GetRange", data);
        return promise.then((data) => StringValue.decode(new _m0.Reader(data)));
    }
    SetRange(request) {
        const data = SetRangeRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "SetRange", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    Strlen(request) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Strlen", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    MGet(request) {
        const data = KeysRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "MGet", data);
        return promise.then((data) => RedisValues.decode(new _m0.Reader(data)));
    }
    MSet(request) {
        const data = KeyValuesRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "MSet", data);
        return promise.then((data) => Empty.decode(new _m0.Reader(data)));
    }
    Expire(request) {
        const data = ExpireRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Expire", data);
        return promise.then((data) => Empty.decode(new _m0.Reader(data)));
    }
    ExpireTime(request) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ExpireTime", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    ZAdd(request) {
        const data = ZAddRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZAdd", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    ZCard(request) {
        const data = KeyRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZCard", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    ZRange(request) {
        const data = ZRangeRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRange", data);
        return promise.then((data) => ZMembers.decode(new _m0.Reader(data)));
    }
    ZRem(request) {
        const data = ZRemRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRem", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    ZRemRangeByLex(request) {
        const data = ZRemRangeByLexRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRemRangeByLex", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    ZRemRangeByRank(request) {
        const data = ZRemRangeByRankRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRemRangeByRank", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    ZRemRangeByScore(request) {
        const data = ZRemRangeByScoreRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRemRangeByScore", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    ZScore(request) {
        const data = ZScoreRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZScore", data);
        return promise.then((data) => DoubleValue.decode(new _m0.Reader(data)));
    }
    ZRank(request) {
        const data = ZRankRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZRank", data);
        return promise.then((data) => Int64Value.decode(new _m0.Reader(data)));
    }
    ZIncrBy(request) {
        const data = ZIncrByRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ZIncrBy", data);
        return promise.then((data) => DoubleValue.decode(new _m0.Reader(data)));
    }
}
export const RedisAPIDefinition = {
    name: "RedisAPI",
    fullName: "devvit.plugin.redis.RedisAPI",
    methods: {
        /** Simple Key-Value operations */
        get: {
            name: "Get",
            requestType: KeyRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        set: {
            name: "Set",
            requestType: SetRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        del: {
            name: "Del",
            requestType: KeysRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        type: {
            name: "Type",
            requestType: KeyRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        /** Number operations */
        incrBy: {
            name: "IncrBy",
            requestType: IncrByRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        /** Redis Hash operations */
        hSet: {
            name: "HSet",
            requestType: HSetRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        hGet: {
            name: "HGet",
            requestType: HGetRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        hGetAll: {
            name: "HGetAll",
            requestType: KeyRequest,
            requestStream: false,
            responseType: RedisFieldValues,
            responseStream: false,
            options: {},
        },
        hDel: {
            name: "HDel",
            requestType: HDelRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        hScan: {
            name: "HScan",
            requestType: HScanRequest,
            requestStream: false,
            responseType: HScanResponse,
            responseStream: false,
            options: {},
        },
        hKeys: {
            name: "HKeys",
            requestType: KeyRequest,
            requestStream: false,
            responseType: KeysResponse,
            responseStream: false,
            options: {},
        },
        hIncrBy: {
            name: "HIncrBy",
            requestType: HIncrByRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        /** Transactions */
        multi: {
            name: "Multi",
            requestType: TransactionId,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        exec: {
            name: "Exec",
            requestType: TransactionId,
            requestStream: false,
            responseType: TransactionResponses,
            responseStream: false,
            options: {},
        },
        discard: {
            name: "Discard",
            requestType: TransactionId,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        watch: {
            name: "Watch",
            requestType: WatchRequest,
            requestStream: false,
            responseType: TransactionId,
            responseStream: false,
            options: {},
        },
        unwatch: {
            name: "Unwatch",
            requestType: TransactionId,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** String operations */
        getRange: {
            name: "GetRange",
            requestType: KeyRangeRequest,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
        setRange: {
            name: "SetRange",
            requestType: SetRangeRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        strlen: {
            name: "Strlen",
            requestType: KeyRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        /** Batch Key-Value operations */
        mGet: {
            name: "MGet",
            requestType: KeysRequest,
            requestStream: false,
            responseType: RedisValues,
            responseStream: false,
            options: {},
        },
        mSet: {
            name: "MSet",
            requestType: KeyValuesRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** Key expiration */
        expire: {
            name: "Expire",
            requestType: ExpireRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        expireTime: {
            name: "ExpireTime",
            requestType: KeyRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        /** Sorted sets */
        zAdd: {
            name: "ZAdd",
            requestType: ZAddRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zCard: {
            name: "ZCard",
            requestType: KeyRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zRange: {
            name: "ZRange",
            requestType: ZRangeRequest,
            requestStream: false,
            responseType: ZMembers,
            responseStream: false,
            options: {},
        },
        zRem: {
            name: "ZRem",
            requestType: ZRemRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zRemRangeByLex: {
            name: "ZRemRangeByLex",
            requestType: ZRemRangeByLexRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zRemRangeByRank: {
            name: "ZRemRangeByRank",
            requestType: ZRemRangeByRankRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zRemRangeByScore: {
            name: "ZRemRangeByScore",
            requestType: ZRemRangeByScoreRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zScore: {
            name: "ZScore",
            requestType: ZScoreRequest,
            requestStream: false,
            responseType: DoubleValue,
            responseStream: false,
            options: {},
        },
        zRank: {
            name: "ZRank",
            requestType: ZRankRequest,
            requestStream: false,
            responseType: Int64Value,
            responseStream: false,
            options: {},
        },
        zIncrBy: {
            name: "ZIncrBy",
            requestType: ZIncrByRequest,
            requestStream: false,
            responseType: DoubleValue,
            responseStream: false,
            options: {},
        },
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
