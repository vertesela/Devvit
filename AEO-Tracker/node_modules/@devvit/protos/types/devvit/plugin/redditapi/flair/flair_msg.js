/**
 * #flair_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import Long from "long";
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
function createBaseClearFlairTemplatesRequest() {
    return { subreddit: "", flairType: "" };
}
export const ClearFlairTemplatesRequest = {
    $type: "devvit.plugin.redditapi.flair.ClearFlairTemplatesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairType !== "") {
            writer.uint32(18).string(message.flairType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClearFlairTemplatesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.flairType = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            flairType: isSet(object.flairType) ? String(object.flairType) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.flairType !== undefined && (obj.flairType = message.flairType);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseClearFlairTemplatesRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairType = object.flairType ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.ClearFlairTemplatesRequest", ClearFlairTemplatesRequest);
function createBaseDeleteFlairRequest() {
    return { subreddit: "", name: "" };
}
export const DeleteFlairRequest = {
    $type: "devvit.plugin.redditapi.flair.DeleteFlairRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteFlairRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            name: isSet(object.name) ? String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.name !== undefined && (obj.name = message.name);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDeleteFlairRequest();
        message.subreddit = object.subreddit ?? "";
        message.name = object.name ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.DeleteFlairRequest", DeleteFlairRequest);
function createBaseDeleteFlairTemplateRequest() {
    return { subreddit: "", flairTemplateId: "" };
}
export const DeleteFlairTemplateRequest = {
    $type: "devvit.plugin.redditapi.flair.DeleteFlairTemplateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairTemplateId !== "") {
            writer.uint32(18).string(message.flairTemplateId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteFlairTemplateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.flairTemplateId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            flairTemplateId: isSet(object.flairTemplateId) ? String(object.flairTemplateId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.flairTemplateId !== undefined && (obj.flairTemplateId = message.flairTemplateId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDeleteFlairTemplateRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairTemplateId = object.flairTemplateId ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.DeleteFlairTemplateRequest", DeleteFlairTemplateRequest);
function createBaseFlairRequest() {
    return { subreddit: "", cssClass: undefined, link: undefined, name: undefined, text: undefined };
}
export const FlairRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.cssClass !== undefined) {
            StringValue.encode({ value: message.cssClass }, writer.uint32(18).fork()).ldelim();
        }
        if (message.link !== undefined) {
            StringValue.encode({ value: message.link }, writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
        }
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.cssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.link = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            cssClass: isSet(object.cssClass) ? String(object.cssClass) : undefined,
            link: isSet(object.link) ? String(object.link) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            text: isSet(object.text) ? String(object.text) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.cssClass !== undefined && (obj.cssClass = message.cssClass);
        message.link !== undefined && (obj.link = message.link);
        message.name !== undefined && (obj.name = message.name);
        message.text !== undefined && (obj.text = message.text);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairRequest();
        message.subreddit = object.subreddit ?? "";
        message.cssClass = object.cssClass ?? undefined;
        message.link = object.link ?? undefined;
        message.name = object.name ?? undefined;
        message.text = object.text ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairRequest", FlairRequest);
function createBaseFlairTemplateOrderRequest() {
    return { subreddit: "", flairType: "", order: [] };
}
export const FlairTemplateOrderRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairTemplateOrderRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairType !== "") {
            writer.uint32(18).string(message.flairType);
        }
        for (const v of message.order) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairTemplateOrderRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.flairType = reader.string();
                    break;
                case 3:
                    message.order.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            flairType: isSet(object.flairType) ? String(object.flairType) : "",
            order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.flairType !== undefined && (obj.flairType = message.flairType);
        if (message.order) {
            obj.order = message.order.map((e) => e);
        }
        else {
            obj.order = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairTemplateOrderRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairType = object.flairType ?? "";
        message.order = object.order?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairTemplateOrderRequest", FlairTemplateOrderRequest);
function createBaseFlairConfigRequest() {
    return {
        subreddit: "",
        flairEnabled: false,
        flairPosition: "",
        flairSelfAssignEnabled: false,
        linkFlairPosition: "",
        linkFlairSelfAssignEnabled: false,
    };
}
export const FlairConfigRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairConfigRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairEnabled === true) {
            writer.uint32(16).bool(message.flairEnabled);
        }
        if (message.flairPosition !== "") {
            writer.uint32(26).string(message.flairPosition);
        }
        if (message.flairSelfAssignEnabled === true) {
            writer.uint32(32).bool(message.flairSelfAssignEnabled);
        }
        if (message.linkFlairPosition !== "") {
            writer.uint32(42).string(message.linkFlairPosition);
        }
        if (message.linkFlairSelfAssignEnabled === true) {
            writer.uint32(48).bool(message.linkFlairSelfAssignEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairConfigRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.flairEnabled = reader.bool();
                    break;
                case 3:
                    message.flairPosition = reader.string();
                    break;
                case 4:
                    message.flairSelfAssignEnabled = reader.bool();
                    break;
                case 5:
                    message.linkFlairPosition = reader.string();
                    break;
                case 6:
                    message.linkFlairSelfAssignEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            flairEnabled: isSet(object.flairEnabled) ? Boolean(object.flairEnabled) : false,
            flairPosition: isSet(object.flairPosition) ? String(object.flairPosition) : "",
            flairSelfAssignEnabled: isSet(object.flairSelfAssignEnabled) ? Boolean(object.flairSelfAssignEnabled) : false,
            linkFlairPosition: isSet(object.linkFlairPosition) ? String(object.linkFlairPosition) : "",
            linkFlairSelfAssignEnabled: isSet(object.linkFlairSelfAssignEnabled)
                ? Boolean(object.linkFlairSelfAssignEnabled)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.flairEnabled !== undefined && (obj.flairEnabled = message.flairEnabled);
        message.flairPosition !== undefined && (obj.flairPosition = message.flairPosition);
        message.flairSelfAssignEnabled !== undefined && (obj.flairSelfAssignEnabled = message.flairSelfAssignEnabled);
        message.linkFlairPosition !== undefined && (obj.linkFlairPosition = message.linkFlairPosition);
        message.linkFlairSelfAssignEnabled !== undefined &&
            (obj.linkFlairSelfAssignEnabled = message.linkFlairSelfAssignEnabled);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairConfigRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairEnabled = object.flairEnabled ?? false;
        message.flairPosition = object.flairPosition ?? "";
        message.flairSelfAssignEnabled = object.flairSelfAssignEnabled ?? false;
        message.linkFlairPosition = object.linkFlairPosition ?? "";
        message.linkFlairSelfAssignEnabled = object.linkFlairSelfAssignEnabled ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairConfigRequest", FlairConfigRequest);
function createBaseFlairCsvRequest() {
    return { subreddit: "", flairCsv: "" };
}
export const FlairCsvRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairCsv !== "") {
            writer.uint32(18).string(message.flairCsv);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.flairCsv = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            flairCsv: isSet(object.flairCsv) ? String(object.flairCsv) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.flairCsv !== undefined && (obj.flairCsv = message.flairCsv);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairCsvRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairCsv = object.flairCsv ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvRequest", FlairCsvRequest);
function createBaseFlairListRequest() {
    return {
        subreddit: "",
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        name: undefined,
        show: undefined,
    };
}
export const FlairListRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairListRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(34).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(50).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairListRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.count !== undefined && (obj.count = message.count);
        message.limit !== undefined && (obj.limit = message.limit);
        message.name !== undefined && (obj.name = message.name);
        message.show !== undefined && (obj.show = message.show);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairListRequest();
        message.subreddit = object.subreddit ?? "";
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.name = object.name ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairListRequest", FlairListRequest);
function createBaseFlairSelectorRequest() {
    return { subreddit: "", isNewlink: false, link: undefined, name: "" };
}
export const FlairSelectorRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairSelectorRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.isNewlink === true) {
            writer.uint32(16).bool(message.isNewlink);
        }
        if (message.link !== undefined) {
            StringValue.encode({ value: message.link }, writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== "") {
            writer.uint32(34).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairSelectorRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.isNewlink = reader.bool();
                    break;
                case 3:
                    message.link = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            isNewlink: isSet(object.isNewlink) ? Boolean(object.isNewlink) : false,
            link: isSet(object.link) ? String(object.link) : undefined,
            name: isSet(object.name) ? String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.isNewlink !== undefined && (obj.isNewlink = message.isNewlink);
        message.link !== undefined && (obj.link = message.link);
        message.name !== undefined && (obj.name = message.name);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairSelectorRequest();
        message.subreddit = object.subreddit ?? "";
        message.isNewlink = object.isNewlink ?? false;
        message.link = object.link ?? undefined;
        message.name = object.name ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairSelectorRequest", FlairSelectorRequest);
function createBaseFlairTemplateRequest() {
    return {
        subreddit: "",
        allowableContent: "",
        backgroundColor: "",
        cssClass: "",
        flairTemplateId: "",
        flairType: "",
        maxEmojis: 0,
        modOnly: false,
        overrideCss: false,
        text: "",
        textColor: "",
        textEditable: false,
    };
}
export const FlairTemplateRequest = {
    $type: "devvit.plugin.redditapi.flair.FlairTemplateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.allowableContent !== "") {
            writer.uint32(18).string(message.allowableContent);
        }
        if (message.backgroundColor !== "") {
            writer.uint32(26).string(message.backgroundColor);
        }
        if (message.cssClass !== "") {
            writer.uint32(34).string(message.cssClass);
        }
        if (message.flairTemplateId !== "") {
            writer.uint32(42).string(message.flairTemplateId);
        }
        if (message.flairType !== "") {
            writer.uint32(50).string(message.flairType);
        }
        if (message.maxEmojis !== 0) {
            writer.uint32(56).int64(message.maxEmojis);
        }
        if (message.modOnly === true) {
            writer.uint32(64).bool(message.modOnly);
        }
        if (message.overrideCss === true) {
            writer.uint32(72).bool(message.overrideCss);
        }
        if (message.text !== "") {
            writer.uint32(82).string(message.text);
        }
        if (message.textColor !== "") {
            writer.uint32(90).string(message.textColor);
        }
        if (message.textEditable === true) {
            writer.uint32(96).bool(message.textEditable);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairTemplateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.allowableContent = reader.string();
                    break;
                case 3:
                    message.backgroundColor = reader.string();
                    break;
                case 4:
                    message.cssClass = reader.string();
                    break;
                case 5:
                    message.flairTemplateId = reader.string();
                    break;
                case 6:
                    message.flairType = reader.string();
                    break;
                case 7:
                    message.maxEmojis = longToNumber(reader.int64());
                    break;
                case 8:
                    message.modOnly = reader.bool();
                    break;
                case 9:
                    message.overrideCss = reader.bool();
                    break;
                case 10:
                    message.text = reader.string();
                    break;
                case 11:
                    message.textColor = reader.string();
                    break;
                case 12:
                    message.textEditable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            allowableContent: isSet(object.allowableContent) ? String(object.allowableContent) : "",
            backgroundColor: isSet(object.backgroundColor) ? String(object.backgroundColor) : "",
            cssClass: isSet(object.cssClass) ? String(object.cssClass) : "",
            flairTemplateId: isSet(object.flairTemplateId) ? String(object.flairTemplateId) : "",
            flairType: isSet(object.flairType) ? String(object.flairType) : "",
            maxEmojis: isSet(object.maxEmojis) ? Number(object.maxEmojis) : 0,
            modOnly: isSet(object.modOnly) ? Boolean(object.modOnly) : false,
            overrideCss: isSet(object.overrideCss) ? Boolean(object.overrideCss) : false,
            text: isSet(object.text) ? String(object.text) : "",
            textColor: isSet(object.textColor) ? String(object.textColor) : "",
            textEditable: isSet(object.textEditable) ? Boolean(object.textEditable) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.allowableContent !== undefined && (obj.allowableContent = message.allowableContent);
        message.backgroundColor !== undefined && (obj.backgroundColor = message.backgroundColor);
        message.cssClass !== undefined && (obj.cssClass = message.cssClass);
        message.flairTemplateId !== undefined && (obj.flairTemplateId = message.flairTemplateId);
        message.flairType !== undefined && (obj.flairType = message.flairType);
        message.maxEmojis !== undefined && (obj.maxEmojis = Math.round(message.maxEmojis));
        message.modOnly !== undefined && (obj.modOnly = message.modOnly);
        message.overrideCss !== undefined && (obj.overrideCss = message.overrideCss);
        message.text !== undefined && (obj.text = message.text);
        message.textColor !== undefined && (obj.textColor = message.textColor);
        message.textEditable !== undefined && (obj.textEditable = message.textEditable);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairTemplateRequest();
        message.subreddit = object.subreddit ?? "";
        message.allowableContent = object.allowableContent ?? "";
        message.backgroundColor = object.backgroundColor ?? "";
        message.cssClass = object.cssClass ?? "";
        message.flairTemplateId = object.flairTemplateId ?? "";
        message.flairType = object.flairType ?? "";
        message.maxEmojis = object.maxEmojis ?? 0;
        message.modOnly = object.modOnly ?? false;
        message.overrideCss = object.overrideCss ?? false;
        message.text = object.text ?? "";
        message.textColor = object.textColor ?? "";
        message.textEditable = object.textEditable ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairTemplateRequest", FlairTemplateRequest);
function createBaseLinkFlairRequest() {
    return { subreddit: "" };
}
export const LinkFlairRequest = {
    $type: "devvit.plugin.redditapi.flair.LinkFlairRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLinkFlairRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { subreddit: isSet(object.subreddit) ? String(object.subreddit) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseLinkFlairRequest();
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.LinkFlairRequest", LinkFlairRequest);
function createBaseSelectFlairRequest() {
    return {
        subreddit: "",
        backgroundColor: "",
        cssClass: "",
        flairTemplateId: "",
        link: "",
        name: "",
        returnRtjson: "",
        text: "",
        textColor: "",
    };
}
export const SelectFlairRequest = {
    $type: "devvit.plugin.redditapi.flair.SelectFlairRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.backgroundColor !== "") {
            writer.uint32(18).string(message.backgroundColor);
        }
        if (message.cssClass !== "") {
            writer.uint32(26).string(message.cssClass);
        }
        if (message.flairTemplateId !== "") {
            writer.uint32(34).string(message.flairTemplateId);
        }
        if (message.link !== "") {
            writer.uint32(42).string(message.link);
        }
        if (message.name !== "") {
            writer.uint32(50).string(message.name);
        }
        if (message.returnRtjson !== "") {
            writer.uint32(58).string(message.returnRtjson);
        }
        if (message.text !== "") {
            writer.uint32(66).string(message.text);
        }
        if (message.textColor !== "") {
            writer.uint32(74).string(message.textColor);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelectFlairRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.backgroundColor = reader.string();
                    break;
                case 3:
                    message.cssClass = reader.string();
                    break;
                case 4:
                    message.flairTemplateId = reader.string();
                    break;
                case 5:
                    message.link = reader.string();
                    break;
                case 6:
                    message.name = reader.string();
                    break;
                case 7:
                    message.returnRtjson = reader.string();
                    break;
                case 8:
                    message.text = reader.string();
                    break;
                case 9:
                    message.textColor = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            backgroundColor: isSet(object.backgroundColor) ? String(object.backgroundColor) : "",
            cssClass: isSet(object.cssClass) ? String(object.cssClass) : "",
            flairTemplateId: isSet(object.flairTemplateId) ? String(object.flairTemplateId) : "",
            link: isSet(object.link) ? String(object.link) : "",
            name: isSet(object.name) ? String(object.name) : "",
            returnRtjson: isSet(object.returnRtjson) ? String(object.returnRtjson) : "",
            text: isSet(object.text) ? String(object.text) : "",
            textColor: isSet(object.textColor) ? String(object.textColor) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.backgroundColor !== undefined && (obj.backgroundColor = message.backgroundColor);
        message.cssClass !== undefined && (obj.cssClass = message.cssClass);
        message.flairTemplateId !== undefined && (obj.flairTemplateId = message.flairTemplateId);
        message.link !== undefined && (obj.link = message.link);
        message.name !== undefined && (obj.name = message.name);
        message.returnRtjson !== undefined && (obj.returnRtjson = message.returnRtjson);
        message.text !== undefined && (obj.text = message.text);
        message.textColor !== undefined && (obj.textColor = message.textColor);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSelectFlairRequest();
        message.subreddit = object.subreddit ?? "";
        message.backgroundColor = object.backgroundColor ?? "";
        message.cssClass = object.cssClass ?? "";
        message.flairTemplateId = object.flairTemplateId ?? "";
        message.link = object.link ?? "";
        message.name = object.name ?? "";
        message.returnRtjson = object.returnRtjson ?? "";
        message.text = object.text ?? "";
        message.textColor = object.textColor ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.SelectFlairRequest", SelectFlairRequest);
function createBaseSetFlairEnabledRequest() {
    return { subreddit: "", flairEnabled: false };
}
export const SetFlairEnabledRequest = {
    $type: "devvit.plugin.redditapi.flair.SetFlairEnabledRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.flairEnabled === true) {
            writer.uint32(16).bool(message.flairEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetFlairEnabledRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.flairEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            flairEnabled: isSet(object.flairEnabled) ? Boolean(object.flairEnabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.flairEnabled !== undefined && (obj.flairEnabled = message.flairEnabled);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSetFlairEnabledRequest();
        message.subreddit = object.subreddit ?? "";
        message.flairEnabled = object.flairEnabled ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.SetFlairEnabledRequest", SetFlairEnabledRequest);
function createBaseFlairObject() {
    return {
        allowableContent: undefined,
        text: undefined,
        textColor: undefined,
        modOnly: false,
        backgroundColor: undefined,
        id: undefined,
        cssClass: undefined,
        maxEmojis: 0,
        richtext: [],
        textEditable: false,
        overrideCss: false,
        type: undefined,
        flairType: undefined,
    };
}
export const FlairObject = {
    $type: "devvit.plugin.redditapi.flair.FlairObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.allowableContent !== undefined) {
            StringValue.encode({ value: message.allowableContent }, writer.uint32(10).fork()).ldelim();
        }
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(18).fork()).ldelim();
        }
        if (message.textColor !== undefined) {
            StringValue.encode({ value: message.textColor }, writer.uint32(26).fork()).ldelim();
        }
        if (message.modOnly === true) {
            writer.uint32(32).bool(message.modOnly);
        }
        if (message.backgroundColor !== undefined) {
            StringValue.encode({ value: message.backgroundColor }, writer.uint32(42).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(50).fork()).ldelim();
        }
        if (message.cssClass !== undefined) {
            StringValue.encode({ value: message.cssClass }, writer.uint32(58).fork()).ldelim();
        }
        if (message.maxEmojis !== 0) {
            writer.uint32(64).int64(message.maxEmojis);
        }
        for (const v of message.richtext) {
            StringValue.encode({ value: v }, writer.uint32(74).fork()).ldelim();
        }
        if (message.textEditable === true) {
            writer.uint32(80).bool(message.textEditable);
        }
        if (message.overrideCss === true) {
            writer.uint32(88).bool(message.overrideCss);
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(98).fork()).ldelim();
        }
        if (message.flairType !== undefined) {
            StringValue.encode({ value: message.flairType }, writer.uint32(106).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.allowableContent = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.textColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.modOnly = reader.bool();
                    break;
                case 5:
                    message.backgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.cssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.maxEmojis = longToNumber(reader.int64());
                    break;
                case 9:
                    message.richtext.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 10:
                    message.textEditable = reader.bool();
                    break;
                case 11:
                    message.overrideCss = reader.bool();
                    break;
                case 12:
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.flairType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            allowableContent: isSet(object.allowableContent) ? String(object.allowableContent) : undefined,
            text: isSet(object.text) ? String(object.text) : undefined,
            textColor: isSet(object.textColor) ? String(object.textColor) : undefined,
            modOnly: isSet(object.modOnly) ? Boolean(object.modOnly) : false,
            backgroundColor: isSet(object.backgroundColor) ? String(object.backgroundColor) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            cssClass: isSet(object.cssClass) ? String(object.cssClass) : undefined,
            maxEmojis: isSet(object.maxEmojis) ? Number(object.maxEmojis) : 0,
            richtext: Array.isArray(object?.richtext) ? object.richtext.map((e) => String(e)) : [],
            textEditable: isSet(object.textEditable) ? Boolean(object.textEditable) : false,
            overrideCss: isSet(object.overrideCss) ? Boolean(object.overrideCss) : false,
            type: isSet(object.type) ? String(object.type) : undefined,
            flairType: isSet(object.flairType) ? String(object.flairType) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.allowableContent !== undefined && (obj.allowableContent = message.allowableContent);
        message.text !== undefined && (obj.text = message.text);
        message.textColor !== undefined && (obj.textColor = message.textColor);
        message.modOnly !== undefined && (obj.modOnly = message.modOnly);
        message.backgroundColor !== undefined && (obj.backgroundColor = message.backgroundColor);
        message.id !== undefined && (obj.id = message.id);
        message.cssClass !== undefined && (obj.cssClass = message.cssClass);
        message.maxEmojis !== undefined && (obj.maxEmojis = Math.round(message.maxEmojis));
        if (message.richtext) {
            obj.richtext = message.richtext.map((e) => e);
        }
        else {
            obj.richtext = [];
        }
        message.textEditable !== undefined && (obj.textEditable = message.textEditable);
        message.overrideCss !== undefined && (obj.overrideCss = message.overrideCss);
        message.type !== undefined && (obj.type = message.type);
        message.flairType !== undefined && (obj.flairType = message.flairType);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairObject();
        message.allowableContent = object.allowableContent ?? undefined;
        message.text = object.text ?? undefined;
        message.textColor = object.textColor ?? undefined;
        message.modOnly = object.modOnly ?? false;
        message.backgroundColor = object.backgroundColor ?? undefined;
        message.id = object.id ?? undefined;
        message.cssClass = object.cssClass ?? undefined;
        message.maxEmojis = object.maxEmojis ?? 0;
        message.richtext = object.richtext?.map((e) => e) || [];
        message.textEditable = object.textEditable ?? false;
        message.overrideCss = object.overrideCss ?? false;
        message.type = object.type ?? undefined;
        message.flairType = object.flairType ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairObject", FlairObject);
function createBaseFlairArray() {
    return { flair: [] };
}
export const FlairArray = {
    $type: "devvit.plugin.redditapi.flair.FlairArray",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.flair) {
            FlairObject.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairArray();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.flair.push(FlairObject.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { flair: Array.isArray(object?.flair) ? object.flair.map((e) => FlairObject.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.flair) {
            obj.flair = message.flair.map((e) => e ? FlairObject.toJSON(e) : undefined);
        }
        else {
            obj.flair = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairArray();
        message.flair = object.flair?.map((e) => FlairObject.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairArray", FlairArray);
function createBaseFlairSelectorResponseOption() {
    return {
        flairCssClass: undefined,
        flairTemplateId: undefined,
        flairText: undefined,
        flairTextEditable: undefined,
        flairPosition: undefined,
    };
}
export const FlairSelectorResponseOption = {
    $type: "devvit.plugin.redditapi.flair.FlairSelectorResponseOption",
    encode(message, writer = _m0.Writer.create()) {
        if (message.flairCssClass !== undefined) {
            StringValue.encode({ value: message.flairCssClass }, writer.uint32(10).fork()).ldelim();
        }
        if (message.flairTemplateId !== undefined) {
            StringValue.encode({ value: message.flairTemplateId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.flairText !== undefined) {
            StringValue.encode({ value: message.flairText }, writer.uint32(26).fork()).ldelim();
        }
        if (message.flairTextEditable !== undefined) {
            BoolValue.encode({ value: message.flairTextEditable }, writer.uint32(34).fork()).ldelim();
        }
        if (message.flairPosition !== undefined) {
            StringValue.encode({ value: message.flairPosition }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairSelectorResponseOption();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.flairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.flairTemplateId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.flairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.flairTextEditable = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.flairPosition = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            flairCssClass: isSet(object.flairCssClass) ? String(object.flairCssClass) : undefined,
            flairTemplateId: isSet(object.flairTemplateId) ? String(object.flairTemplateId) : undefined,
            flairText: isSet(object.flairText) ? String(object.flairText) : undefined,
            flairTextEditable: isSet(object.flairTextEditable) ? Boolean(object.flairTextEditable) : undefined,
            flairPosition: isSet(object.flairPosition) ? String(object.flairPosition) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.flairCssClass !== undefined && (obj.flairCssClass = message.flairCssClass);
        message.flairTemplateId !== undefined && (obj.flairTemplateId = message.flairTemplateId);
        message.flairText !== undefined && (obj.flairText = message.flairText);
        message.flairTextEditable !== undefined && (obj.flairTextEditable = message.flairTextEditable);
        message.flairPosition !== undefined && (obj.flairPosition = message.flairPosition);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairSelectorResponseOption();
        message.flairCssClass = object.flairCssClass ?? undefined;
        message.flairTemplateId = object.flairTemplateId ?? undefined;
        message.flairText = object.flairText ?? undefined;
        message.flairTextEditable = object.flairTextEditable ?? undefined;
        message.flairPosition = object.flairPosition ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairSelectorResponseOption", FlairSelectorResponseOption);
function createBaseFlairSelectorResponse() {
    return { current: undefined, choices: [] };
}
export const FlairSelectorResponse = {
    $type: "devvit.plugin.redditapi.flair.FlairSelectorResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.current !== undefined) {
            FlairSelectorResponseOption.encode(message.current, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.choices) {
            FlairSelectorResponseOption.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairSelectorResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.current = FlairSelectorResponseOption.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.choices.push(FlairSelectorResponseOption.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            current: isSet(object.current) ? FlairSelectorResponseOption.fromJSON(object.current) : undefined,
            choices: Array.isArray(object?.choices)
                ? object.choices.map((e) => FlairSelectorResponseOption.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.current !== undefined &&
            (obj.current = message.current ? FlairSelectorResponseOption.toJSON(message.current) : undefined);
        if (message.choices) {
            obj.choices = message.choices.map((e) => e ? FlairSelectorResponseOption.toJSON(e) : undefined);
        }
        else {
            obj.choices = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairSelectorResponse();
        message.current = (object.current !== undefined && object.current !== null)
            ? FlairSelectorResponseOption.fromPartial(object.current)
            : undefined;
        message.choices = object.choices?.map((e) => FlairSelectorResponseOption.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairSelectorResponse", FlairSelectorResponse);
function createBaseUserFlair() {
    return { flairCssClass: undefined, user: undefined, flairText: undefined };
}
export const UserFlair = {
    $type: "devvit.plugin.redditapi.flair.UserFlair",
    encode(message, writer = _m0.Writer.create()) {
        if (message.flairCssClass !== undefined) {
            StringValue.encode({ value: message.flairCssClass }, writer.uint32(10).fork()).ldelim();
        }
        if (message.user !== undefined) {
            StringValue.encode({ value: message.user }, writer.uint32(18).fork()).ldelim();
        }
        if (message.flairText !== undefined) {
            StringValue.encode({ value: message.flairText }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserFlair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.flairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.user = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.flairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            flairCssClass: isSet(object.flairCssClass) ? String(object.flairCssClass) : undefined,
            user: isSet(object.user) ? String(object.user) : undefined,
            flairText: isSet(object.flairText) ? String(object.flairText) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.flairCssClass !== undefined && (obj.flairCssClass = message.flairCssClass);
        message.user !== undefined && (obj.user = message.user);
        message.flairText !== undefined && (obj.flairText = message.flairText);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUserFlair();
        message.flairCssClass = object.flairCssClass ?? undefined;
        message.user = object.user ?? undefined;
        message.flairText = object.flairText ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.UserFlair", UserFlair);
function createBaseFlairListResponse() {
    return { users: [], next: undefined, prev: undefined };
}
export const FlairListResponse = {
    $type: "devvit.plugin.redditapi.flair.FlairListResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.users) {
            UserFlair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.next !== undefined) {
            StringValue.encode({ value: message.next }, writer.uint32(18).fork()).ldelim();
        }
        if (message.prev !== undefined) {
            StringValue.encode({ value: message.prev }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairListResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.users.push(UserFlair.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.next = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.prev = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            users: Array.isArray(object?.users) ? object.users.map((e) => UserFlair.fromJSON(e)) : [],
            next: isSet(object.next) ? String(object.next) : undefined,
            prev: isSet(object.prev) ? String(object.prev) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.users) {
            obj.users = message.users.map((e) => e ? UserFlair.toJSON(e) : undefined);
        }
        else {
            obj.users = [];
        }
        message.next !== undefined && (obj.next = message.next);
        message.prev !== undefined && (obj.prev = message.prev);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairListResponse();
        message.users = object.users?.map((e) => UserFlair.fromPartial(e)) || [];
        message.next = object.next ?? undefined;
        message.prev = object.prev ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairListResponse", FlairListResponse);
function createBaseFlairCsvResultError() {
    return { css: undefined, row: undefined, user: undefined };
}
export const FlairCsvResultError = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResultError",
    encode(message, writer = _m0.Writer.create()) {
        if (message.css !== undefined) {
            StringValue.encode({ value: message.css }, writer.uint32(10).fork()).ldelim();
        }
        if (message.row !== undefined) {
            StringValue.encode({ value: message.row }, writer.uint32(18).fork()).ldelim();
        }
        if (message.user !== undefined) {
            StringValue.encode({ value: message.user }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvResultError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.css = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.row = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.user = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            css: isSet(object.css) ? String(object.css) : undefined,
            row: isSet(object.row) ? String(object.row) : undefined,
            user: isSet(object.user) ? String(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.css !== undefined && (obj.css = message.css);
        message.row !== undefined && (obj.row = message.row);
        message.user !== undefined && (obj.user = message.user);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairCsvResultError();
        message.css = object.css ?? undefined;
        message.row = object.row ?? undefined;
        message.user = object.user ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvResultError", FlairCsvResultError);
function createBaseFlairCsvResultWarning() {
    return { text: undefined };
}
export const FlairCsvResultWarning = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResultWarning",
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvResultWarning();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { text: isSet(object.text) ? String(object.text) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.text !== undefined && (obj.text = message.text);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairCsvResultWarning();
        message.text = object.text ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvResultWarning", FlairCsvResultWarning);
function createBaseFlairCsvResult() {
    return { status: undefined, ok: undefined, errors: undefined, warnings: undefined };
}
export const FlairCsvResult = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResult",
    encode(message, writer = _m0.Writer.create()) {
        if (message.status !== undefined) {
            StringValue.encode({ value: message.status }, writer.uint32(10).fork()).ldelim();
        }
        if (message.ok !== undefined) {
            BoolValue.encode({ value: message.ok }, writer.uint32(18).fork()).ldelim();
        }
        if (message.errors !== undefined) {
            FlairCsvResultError.encode(message.errors, writer.uint32(26).fork()).ldelim();
        }
        if (message.warnings !== undefined) {
            FlairCsvResultWarning.encode(message.warnings, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.status = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.ok = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.errors = FlairCsvResultError.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.warnings = FlairCsvResultWarning.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            status: isSet(object.status) ? String(object.status) : undefined,
            ok: isSet(object.ok) ? Boolean(object.ok) : undefined,
            errors: isSet(object.errors) ? FlairCsvResultError.fromJSON(object.errors) : undefined,
            warnings: isSet(object.warnings) ? FlairCsvResultWarning.fromJSON(object.warnings) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.status !== undefined && (obj.status = message.status);
        message.ok !== undefined && (obj.ok = message.ok);
        message.errors !== undefined &&
            (obj.errors = message.errors ? FlairCsvResultError.toJSON(message.errors) : undefined);
        message.warnings !== undefined &&
            (obj.warnings = message.warnings ? FlairCsvResultWarning.toJSON(message.warnings) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairCsvResult();
        message.status = object.status ?? undefined;
        message.ok = object.ok ?? undefined;
        message.errors = (object.errors !== undefined && object.errors !== null)
            ? FlairCsvResultError.fromPartial(object.errors)
            : undefined;
        message.warnings = (object.warnings !== undefined && object.warnings !== null)
            ? FlairCsvResultWarning.fromPartial(object.warnings)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvResult", FlairCsvResult);
function createBaseFlairCsvResponse() {
    return { result: [] };
}
export const FlairCsvResponse = {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.result) {
            FlairCsvResult.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlairCsvResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.result.push(FlairCsvResult.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { result: Array.isArray(object?.result) ? object.result.map((e) => FlairCsvResult.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.result) {
            obj.result = message.result.map((e) => e ? FlairCsvResult.toJSON(e) : undefined);
        }
        else {
            obj.result = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFlairCsvResponse();
        message.result = object.result?.map((e) => FlairCsvResult.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvResponse", FlairCsvResponse);
var globalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
