/**
 * #moderation_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Int32Value, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
function createBaseAboutLogRequest() {
    return {
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        show: undefined,
        mod: undefined,
        type: undefined,
        subreddit: undefined,
    };
}
export const AboutLogRequest = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
        }
        if (message.mod !== undefined) {
            StringValue.encode({ value: message.mod }, writer.uint32(50).fork()).ldelim();
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(66).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.mod = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            mod: isSet(object.mod) ? String(object.mod) : undefined,
            type: isSet(object.type) ? String(object.type) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.count !== undefined && (obj.count = message.count);
        message.limit !== undefined && (obj.limit = message.limit);
        message.show !== undefined && (obj.show = message.show);
        message.mod !== undefined && (obj.mod = message.mod);
        message.type !== undefined && (obj.type = message.type);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAboutLogRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.show = object.show ?? undefined;
        message.mod = object.mod ?? undefined;
        message.type = object.type ?? undefined;
        message.subreddit = object.subreddit ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogRequest", AboutLogRequest);
function createBaseAboutLocationRequest() {
    return {
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        location: "",
        only: undefined,
        show: undefined,
        subreddit: "",
    };
}
export const AboutLocationRequest = {
    $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.location !== "") {
            writer.uint32(42).string(message.location);
        }
        if (message.only !== undefined) {
            StringValue.encode({ value: message.only }, writer.uint32(50).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
        }
        if (message.subreddit !== "") {
            writer.uint32(66).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLocationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.location = reader.string();
                    break;
                case 6:
                    message.only = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            location: isSet(object.location) ? String(object.location) : "",
            only: isSet(object.only) ? String(object.only) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.count !== undefined && (obj.count = message.count);
        message.limit !== undefined && (obj.limit = message.limit);
        message.location !== undefined && (obj.location = message.location);
        message.only !== undefined && (obj.only = message.only);
        message.show !== undefined && (obj.show = message.show);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAboutLocationRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.location = object.location ?? "";
        message.only = object.only ?? undefined;
        message.show = object.show ?? undefined;
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLocationRequest", AboutLocationRequest);
function createBaseAcceptModeratorInviteRequest() {
    return { subreddit: "" };
}
export const AcceptModeratorInviteRequest = {
    $type: "devvit.plugin.redditapi.moderation.AcceptModeratorInviteRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAcceptModeratorInviteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { subreddit: isSet(object.subreddit) ? String(object.subreddit) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAcceptModeratorInviteRequest();
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AcceptModeratorInviteRequest", AcceptModeratorInviteRequest);
function createBaseBasicModerationIdRequest() {
    return { id: "" };
}
export const BasicModerationIdRequest = {
    $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicModerationIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBasicModerationIdRequest();
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.BasicModerationIdRequest", BasicModerationIdRequest);
function createBaseDistinguishRequest() {
    return { how: "", id: "", sticky: false };
}
export const DistinguishRequest = {
    $type: "devvit.plugin.redditapi.moderation.DistinguishRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.how !== "") {
            writer.uint32(10).string(message.how);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.sticky === true) {
            writer.uint32(24).bool(message.sticky);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDistinguishRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.how = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.sticky = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            how: isSet(object.how) ? String(object.how) : "",
            id: isSet(object.id) ? String(object.id) : "",
            sticky: isSet(object.sticky) ? Boolean(object.sticky) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.how !== undefined && (obj.how = message.how);
        message.id !== undefined && (obj.id = message.id);
        message.sticky !== undefined && (obj.sticky = message.sticky);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDistinguishRequest();
        message.how = object.how ?? "";
        message.id = object.id ?? "";
        message.sticky = object.sticky ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.DistinguishRequest", DistinguishRequest);
function createBaseRemoveRequest() {
    return { id: "", spam: false };
}
export const RemoveRequest = {
    $type: "devvit.plugin.redditapi.moderation.RemoveRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.spam === true) {
            writer.uint32(16).bool(message.spam);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoveRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.spam = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "", spam: isSet(object.spam) ? Boolean(object.spam) : false };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.spam !== undefined && (obj.spam = message.spam);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRemoveRequest();
        message.id = object.id ?? "";
        message.spam = object.spam ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.RemoveRequest", RemoveRequest);
function createBaseSnoozeReportsRequest() {
    return { id: "", reason: "" };
}
export const SnoozeReportsRequest = {
    $type: "devvit.plugin.redditapi.moderation.SnoozeReportsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.reason !== "") {
            writer.uint32(18).string(message.reason);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSnoozeReportsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "", reason: isSet(object.reason) ? String(object.reason) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.reason !== undefined && (obj.reason = message.reason);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSnoozeReportsRequest();
        message.id = object.id ?? "";
        message.reason = object.reason ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.SnoozeReportsRequest", SnoozeReportsRequest);
function createBaseUpdateCrowdControlLevelRequest() {
    return { id: "", level: 0 };
}
export const UpdateCrowdControlLevelRequest = {
    $type: "devvit.plugin.redditapi.moderation.UpdateCrowdControlLevelRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.level !== 0) {
            writer.uint32(16).int32(message.level);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCrowdControlLevelRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.level = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "", level: isSet(object.level) ? Number(object.level) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.level !== undefined && (obj.level = Math.round(message.level));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateCrowdControlLevelRequest();
        message.id = object.id ?? "";
        message.level = object.level ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.UpdateCrowdControlLevelRequest", UpdateCrowdControlLevelRequest);
function createBaseStylesheetRequest() {
    return { subreddit: "" };
}
export const StylesheetRequest = {
    $type: "devvit.plugin.redditapi.moderation.StylesheetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStylesheetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { subreddit: isSet(object.subreddit) ? String(object.subreddit) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStylesheetRequest();
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.StylesheetRequest", StylesheetRequest);
function createBaseAboutLogResponse() {
    return { kind: "", data: undefined };
}
export const AboutLogResponse = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            AboutLogResponse_AboutLogListing.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = AboutLogResponse_AboutLogListing.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? AboutLogResponse_AboutLogListing.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? AboutLogResponse_AboutLogListing.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAboutLogResponse();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? AboutLogResponse_AboutLogListing.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogResponse", AboutLogResponse);
function createBaseAboutLogResponse_LogObject() {
    return {
        description: undefined,
        targetBody: undefined,
        modId36: undefined,
        createdUtc: undefined,
        subreddit: undefined,
        targetTitle: undefined,
        targetPermalink: undefined,
        subredditNamePrefixed: undefined,
        details: undefined,
        action: undefined,
        targetAuthor: undefined,
        targetFullname: undefined,
        srId36: undefined,
        id: undefined,
        mod: undefined,
    };
}
export const AboutLogResponse_LogObject = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.LogObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(10).fork()).ldelim();
        }
        if (message.targetBody !== undefined) {
            StringValue.encode({ value: message.targetBody }, writer.uint32(18).fork()).ldelim();
        }
        if (message.modId36 !== undefined) {
            StringValue.encode({ value: message.modId36 }, writer.uint32(26).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(34).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.targetTitle !== undefined) {
            StringValue.encode({ value: message.targetTitle }, writer.uint32(50).fork()).ldelim();
        }
        if (message.targetPermalink !== undefined) {
            StringValue.encode({ value: message.targetPermalink }, writer.uint32(58).fork()).ldelim();
        }
        if (message.subredditNamePrefixed !== undefined) {
            StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(66).fork()).ldelim();
        }
        if (message.details !== undefined) {
            StringValue.encode({ value: message.details }, writer.uint32(74).fork()).ldelim();
        }
        if (message.action !== undefined) {
            StringValue.encode({ value: message.action }, writer.uint32(82).fork()).ldelim();
        }
        if (message.targetAuthor !== undefined) {
            StringValue.encode({ value: message.targetAuthor }, writer.uint32(90).fork()).ldelim();
        }
        if (message.targetFullname !== undefined) {
            StringValue.encode({ value: message.targetFullname }, writer.uint32(98).fork()).ldelim();
        }
        if (message.srId36 !== undefined) {
            StringValue.encode({ value: message.srId36 }, writer.uint32(106).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(114).fork()).ldelim();
        }
        if (message.mod !== undefined) {
            StringValue.encode({ value: message.mod }, writer.uint32(122).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogResponse_LogObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.targetBody = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.modId36 = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.targetTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.targetPermalink = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.details = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.action = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.targetAuthor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.targetFullname = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.srId36 = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.mod = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet(object.description) ? String(object.description) : undefined,
            targetBody: isSet(object.targetBody) ? String(object.targetBody) : undefined,
            modId36: isSet(object.modId36) ? String(object.modId36) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            targetTitle: isSet(object.targetTitle) ? String(object.targetTitle) : undefined,
            targetPermalink: isSet(object.targetPermalink) ? String(object.targetPermalink) : undefined,
            subredditNamePrefixed: isSet(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : undefined,
            details: isSet(object.details) ? String(object.details) : undefined,
            action: isSet(object.action) ? String(object.action) : undefined,
            targetAuthor: isSet(object.targetAuthor) ? String(object.targetAuthor) : undefined,
            targetFullname: isSet(object.targetFullname) ? String(object.targetFullname) : undefined,
            srId36: isSet(object.srId36) ? String(object.srId36) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            mod: isSet(object.mod) ? String(object.mod) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.description !== undefined && (obj.description = message.description);
        message.targetBody !== undefined && (obj.targetBody = message.targetBody);
        message.modId36 !== undefined && (obj.modId36 = message.modId36);
        message.createdUtc !== undefined && (obj.createdUtc = message.createdUtc);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.targetTitle !== undefined && (obj.targetTitle = message.targetTitle);
        message.targetPermalink !== undefined && (obj.targetPermalink = message.targetPermalink);
        message.subredditNamePrefixed !== undefined && (obj.subredditNamePrefixed = message.subredditNamePrefixed);
        message.details !== undefined && (obj.details = message.details);
        message.action !== undefined && (obj.action = message.action);
        message.targetAuthor !== undefined && (obj.targetAuthor = message.targetAuthor);
        message.targetFullname !== undefined && (obj.targetFullname = message.targetFullname);
        message.srId36 !== undefined && (obj.srId36 = message.srId36);
        message.id !== undefined && (obj.id = message.id);
        message.mod !== undefined && (obj.mod = message.mod);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAboutLogResponse_LogObject();
        message.description = object.description ?? undefined;
        message.targetBody = object.targetBody ?? undefined;
        message.modId36 = object.modId36 ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.subreddit = object.subreddit ?? undefined;
        message.targetTitle = object.targetTitle ?? undefined;
        message.targetPermalink = object.targetPermalink ?? undefined;
        message.subredditNamePrefixed = object.subredditNamePrefixed ?? undefined;
        message.details = object.details ?? undefined;
        message.action = object.action ?? undefined;
        message.targetAuthor = object.targetAuthor ?? undefined;
        message.targetFullname = object.targetFullname ?? undefined;
        message.srId36 = object.srId36 ?? undefined;
        message.id = object.id ?? undefined;
        message.mod = object.mod ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogResponse.LogObject", AboutLogResponse_LogObject);
function createBaseAboutLogResponse_AboutLogListing() {
    return { after: undefined, before: undefined, children: [], dist: undefined };
}
export const AboutLogResponse_AboutLogListing = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.children) {
            AboutLogResponse_AboutLogListing_WrappedLogObject.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.dist !== undefined) {
            Int32Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogResponse_AboutLogListing();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.children.push(AboutLogResponse_AboutLogListing_WrappedLogObject.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.dist = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            children: Array.isArray(object?.children)
                ? object.children.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.fromJSON(e))
                : [],
            dist: isSet(object.dist) ? Number(object.dist) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        if (message.children) {
            obj.children = message.children.map((e) => e ? AboutLogResponse_AboutLogListing_WrappedLogObject.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        message.dist !== undefined && (obj.dist = message.dist);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAboutLogResponse_AboutLogListing();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.children = object.children?.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.fromPartial(e)) ||
            [];
        message.dist = object.dist ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing", AboutLogResponse_AboutLogListing);
function createBaseAboutLogResponse_AboutLogListing_WrappedLogObject() {
    return { kind: "", data: undefined };
}
export const AboutLogResponse_AboutLogListing_WrappedLogObject = {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing.WrappedLogObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            AboutLogResponse_LogObject.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutLogResponse_AboutLogListing_WrappedLogObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = AboutLogResponse_LogObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? AboutLogResponse_LogObject.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? AboutLogResponse_LogObject.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAboutLogResponse_AboutLogListing_WrappedLogObject();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? AboutLogResponse_LogObject.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing.WrappedLogObject", AboutLogResponse_AboutLogListing_WrappedLogObject);
function isSet(value) {
    return value !== null && value !== undefined;
}
