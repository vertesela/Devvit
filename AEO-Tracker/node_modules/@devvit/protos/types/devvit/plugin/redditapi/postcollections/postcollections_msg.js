/**
 * #postcollections_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Timestamp } from '../../../../google/protobuf/timestamp.js';
import { BoolValue, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
function createBaseCollectionRequest() {
    return { collectionId: undefined, includeLinks: undefined };
}
export const CollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.CollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.includeLinks !== undefined) {
            BoolValue.encode({ value: message.includeLinks }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.includeLinks = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            includeLinks: isSet(object.includeLinks) ? Boolean(object.includeLinks) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.includeLinks !== undefined && (obj.includeLinks = message.includeLinks);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.includeLinks = object.includeLinks ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.CollectionRequest", CollectionRequest);
function createBaseCreateCollectionRequest() {
    return { title: undefined, srFullname: undefined, description: undefined, displayLayout: undefined };
}
export const CreateCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.CreateCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(10).fork()).ldelim();
        }
        if (message.srFullname !== undefined) {
            StringValue.encode({ value: message.srFullname }, writer.uint32(18).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();
        }
        if (message.displayLayout !== undefined) {
            StringValue.encode({ value: message.displayLayout }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.srFullname = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.displayLayout = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet(object.title) ? String(object.title) : undefined,
            srFullname: isSet(object.srFullname) ? String(object.srFullname) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            displayLayout: isSet(object.displayLayout) ? String(object.displayLayout) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.srFullname !== undefined && (obj.srFullname = message.srFullname);
        message.description !== undefined && (obj.description = message.description);
        message.displayLayout !== undefined && (obj.displayLayout = message.displayLayout);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateCollectionRequest();
        message.title = object.title ?? undefined;
        message.srFullname = object.srFullname ?? undefined;
        message.description = object.description ?? undefined;
        message.displayLayout = object.displayLayout ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.CreateCollectionRequest", CreateCollectionRequest);
function createBaseAddPostToCollectionRequest() {
    return { collectionId: undefined, linkFullname: undefined };
}
export const AddPostToCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.AddPostToCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.linkFullname !== undefined) {
            StringValue.encode({ value: message.linkFullname }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddPostToCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.linkFullname = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            linkFullname: isSet(object.linkFullname) ? String(object.linkFullname) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.linkFullname !== undefined && (obj.linkFullname = message.linkFullname);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAddPostToCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.linkFullname = object.linkFullname ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.AddPostToCollectionRequest", AddPostToCollectionRequest);
function createBaseDeleteCollectionRequest() {
    return { collectionId: undefined };
}
export const DeleteCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.DeleteCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDeleteCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.DeleteCollectionRequest", DeleteCollectionRequest);
function createBaseFollowCollectionRequest() {
    return { collectionId: undefined, follow: undefined };
}
export const FollowCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.FollowCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.follow !== undefined) {
            BoolValue.encode({ value: message.follow }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFollowCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.follow = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            follow: isSet(object.follow) ? Boolean(object.follow) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.follow !== undefined && (obj.follow = message.follow);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFollowCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.follow = object.follow ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.FollowCollectionRequest", FollowCollectionRequest);
function createBaseRemovePostInCollectionRequest() {
    return { collectionId: undefined, linkFullname: undefined };
}
export const RemovePostInCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.RemovePostInCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.linkFullname !== undefined) {
            StringValue.encode({ value: message.linkFullname }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemovePostInCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.linkFullname = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            linkFullname: isSet(object.linkFullname) ? String(object.linkFullname) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.linkFullname !== undefined && (obj.linkFullname = message.linkFullname);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRemovePostInCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.linkFullname = object.linkFullname ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.RemovePostInCollectionRequest", RemovePostInCollectionRequest);
function createBaseReorderCollectionRequest() {
    return { collectionId: undefined, linkIds: undefined };
}
export const ReorderCollectionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.ReorderCollectionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.linkIds !== undefined) {
            StringValue.encode({ value: message.linkIds }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReorderCollectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.linkIds = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            linkIds: isSet(object.linkIds) ? String(object.linkIds) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.linkIds !== undefined && (obj.linkIds = message.linkIds);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseReorderCollectionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.linkIds = object.linkIds ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.ReorderCollectionRequest", ReorderCollectionRequest);
function createBaseSubredditCollectionsRequest() {
    return { srFullname: undefined };
}
export const SubredditCollectionsRequest = {
    $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.srFullname !== undefined) {
            StringValue.encode({ value: message.srFullname }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditCollectionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.srFullname = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { srFullname: isSet(object.srFullname) ? String(object.srFullname) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.srFullname !== undefined && (obj.srFullname = message.srFullname);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditCollectionsRequest();
        message.srFullname = object.srFullname ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.SubredditCollectionsRequest", SubredditCollectionsRequest);
function createBaseUpdateCollectionDescriptionRequest() {
    return { collectionId: undefined, description: undefined };
}
export const UpdateCollectionDescriptionRequest = {
    $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDescriptionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCollectionDescriptionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.description !== undefined && (obj.description = message.description);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateCollectionDescriptionRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.UpdateCollectionDescriptionRequest", UpdateCollectionDescriptionRequest);
function createBaseUpdateCollectionTitleRequest() {
    return { collectionId: undefined, title: undefined };
}
export const UpdateCollectionTitleRequest = {
    $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionTitleRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCollectionTitleRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.title !== undefined && (obj.title = message.title);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateCollectionTitleRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.title = object.title ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.UpdateCollectionTitleRequest", UpdateCollectionTitleRequest);
function createBaseUpdateCollectionDisplayLayoutRequest() {
    return { collectionId: undefined, displayLayout: undefined };
}
export const UpdateCollectionDisplayLayoutRequest = {
    $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDisplayLayoutRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.displayLayout !== undefined) {
            StringValue.encode({ value: message.displayLayout }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCollectionDisplayLayoutRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.displayLayout = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            displayLayout: isSet(object.displayLayout) ? String(object.displayLayout) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.displayLayout !== undefined && (obj.displayLayout = message.displayLayout);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateCollectionDisplayLayoutRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.displayLayout = object.displayLayout ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.UpdateCollectionDisplayLayoutRequest", UpdateCollectionDisplayLayoutRequest);
function createBaseCollectionResponse() {
    return {
        collectionId: undefined,
        subredditId: undefined,
        title: undefined,
        description: undefined,
        authorId: undefined,
        authorName: undefined,
        permalink: undefined,
        linkIds: [],
        primaryLinkId: undefined,
        displayLayout: undefined,
        createdAtUtc: undefined,
        lastUpdateUtc: undefined,
    };
}
export const CollectionResponse = {
    $type: "devvit.plugin.redditapi.postcollections.CollectionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(26).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
        }
        if (message.authorId !== undefined) {
            StringValue.encode({ value: message.authorId }, writer.uint32(42).fork()).ldelim();
        }
        if (message.authorName !== undefined) {
            StringValue.encode({ value: message.authorName }, writer.uint32(50).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.linkIds) {
            StringValue.encode({ value: v }, writer.uint32(66).fork()).ldelim();
        }
        if (message.primaryLinkId !== undefined) {
            StringValue.encode({ value: message.primaryLinkId }, writer.uint32(74).fork()).ldelim();
        }
        if (message.displayLayout !== undefined) {
            StringValue.encode({ value: message.displayLayout }, writer.uint32(82).fork()).ldelim();
        }
        if (message.createdAtUtc !== undefined) {
            Timestamp.encode(toTimestamp(message.createdAtUtc), writer.uint32(90).fork()).ldelim();
        }
        if (message.lastUpdateUtc !== undefined) {
            Timestamp.encode(toTimestamp(message.lastUpdateUtc), writer.uint32(98).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCollectionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.authorId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.authorName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.linkIds.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 9:
                    message.primaryLinkId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.displayLayout = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.createdAtUtc = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.lastUpdateUtc = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            authorId: isSet(object.authorId) ? String(object.authorId) : undefined,
            authorName: isSet(object.authorName) ? String(object.authorName) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            linkIds: Array.isArray(object?.linkIds) ? object.linkIds.map((e) => String(e)) : [],
            primaryLinkId: isSet(object.primaryLinkId) ? String(object.primaryLinkId) : undefined,
            displayLayout: isSet(object.displayLayout) ? String(object.displayLayout) : undefined,
            createdAtUtc: isSet(object.createdAtUtc) ? fromJsonTimestamp(object.createdAtUtc) : undefined,
            lastUpdateUtc: isSet(object.lastUpdateUtc) ? fromJsonTimestamp(object.lastUpdateUtc) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.subredditId !== undefined && (obj.subredditId = message.subredditId);
        message.title !== undefined && (obj.title = message.title);
        message.description !== undefined && (obj.description = message.description);
        message.authorId !== undefined && (obj.authorId = message.authorId);
        message.authorName !== undefined && (obj.authorName = message.authorName);
        message.permalink !== undefined && (obj.permalink = message.permalink);
        if (message.linkIds) {
            obj.linkIds = message.linkIds.map((e) => e);
        }
        else {
            obj.linkIds = [];
        }
        message.primaryLinkId !== undefined && (obj.primaryLinkId = message.primaryLinkId);
        message.displayLayout !== undefined && (obj.displayLayout = message.displayLayout);
        message.createdAtUtc !== undefined && (obj.createdAtUtc = message.createdAtUtc.toISOString());
        message.lastUpdateUtc !== undefined && (obj.lastUpdateUtc = message.lastUpdateUtc.toISOString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCollectionResponse();
        message.collectionId = object.collectionId ?? undefined;
        message.subredditId = object.subredditId ?? undefined;
        message.title = object.title ?? undefined;
        message.description = object.description ?? undefined;
        message.authorId = object.authorId ?? undefined;
        message.authorName = object.authorName ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.linkIds = object.linkIds?.map((e) => e) || [];
        message.primaryLinkId = object.primaryLinkId ?? undefined;
        message.displayLayout = object.displayLayout ?? undefined;
        message.createdAtUtc = object.createdAtUtc ?? undefined;
        message.lastUpdateUtc = object.lastUpdateUtc ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.CollectionResponse", CollectionResponse);
function createBaseSubredditCollectionsResponse() {
    return { collections: [] };
}
export const SubredditCollectionsResponse = {
    $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.collections) {
            CollectionResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditCollectionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collections.push(CollectionResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collections: Array.isArray(object?.collections)
                ? object.collections.map((e) => CollectionResponse.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.collections) {
            obj.collections = message.collections.map((e) => e ? CollectionResponse.toJSON(e) : undefined);
        }
        else {
            obj.collections = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditCollectionsResponse();
        message.collections = object.collections?.map((e) => CollectionResponse.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.postcollections.SubredditCollectionsResponse", SubredditCollectionsResponse);
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
