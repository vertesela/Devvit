/**
 * #common_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Any } from '../../../../google/protobuf/any.js';
import { ListValue } from '../../../../google/protobuf/struct.js';
import { BoolValue, Int32Value, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { User } from '../../../reddit/user.js';
function createBaseListing() {
    return { kind: "", data: undefined };
}
export const Listing = {
    $type: "devvit.plugin.redditapi.common.Listing",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            Listing_ListingData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListing();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = Listing_ListingData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? Listing_ListingData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined && (obj.data = message.data ? Listing_ListingData.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseListing();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? Listing_ListingData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.Listing", Listing);
function createBaseListing_ListingData() {
    return { after: undefined, before: undefined, children: [], dist: undefined };
}
export const Listing_ListingData = {
    $type: "devvit.plugin.redditapi.common.Listing.ListingData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.children) {
            WrappedRedditObject.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.dist !== undefined) {
            Int64Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListing_ListingData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.children.push(WrappedRedditObject.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.dist = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            children: Array.isArray(object?.children) ? object.children.map((e) => WrappedRedditObject.fromJSON(e)) : [],
            dist: isSet(object.dist) ? Number(object.dist) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        if (message.children) {
            obj.children = message.children.map((e) => e ? WrappedRedditObject.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        message.dist !== undefined && (obj.dist = message.dist);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseListing_ListingData();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.children = object.children?.map((e) => WrappedRedditObject.fromPartial(e)) || [];
        message.dist = object.dist ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.Listing.ListingData", Listing_ListingData);
function createBaseWrappedRedditObject() {
    return { kind: "", data: undefined };
}
export const WrappedRedditObject = {
    $type: "devvit.plugin.redditapi.common.WrappedRedditObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            RedditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWrappedRedditObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = RedditObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? RedditObject.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined && (obj.data = message.data ? RedditObject.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWrappedRedditObject();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? RedditObject.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.WrappedRedditObject", WrappedRedditObject);
function createBaseJsonRedditObjects() {
    return { json: undefined };
}
export const JsonRedditObjects = {
    $type: "devvit.plugin.redditapi.common.JsonRedditObjects",
    encode(message, writer = _m0.Writer.create()) {
        if (message.json !== undefined) {
            JsonRedditObjects_JsonType.encode(message.json, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonRedditObjects();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 4:
                    message.json = JsonRedditObjects_JsonType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { json: isSet(object.json) ? JsonRedditObjects_JsonType.fromJSON(object.json) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.json !== undefined &&
            (obj.json = message.json ? JsonRedditObjects_JsonType.toJSON(message.json) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseJsonRedditObjects();
        message.json = (object.json !== undefined && object.json !== null)
            ? JsonRedditObjects_JsonType.fromPartial(object.json)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonRedditObjects", JsonRedditObjects);
function createBaseJsonRedditObjects_JsonType() {
    return { errors: [], data: undefined };
}
export const JsonRedditObjects_JsonType = {
    $type: "devvit.plugin.redditapi.common.JsonRedditObjects.JsonType",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.errors) {
            Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            JsonRedditObjects_JsonType_JsonData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonRedditObjects_JsonType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.errors.push(Any.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.data = JsonRedditObjects_JsonType_JsonData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            errors: Array.isArray(object?.errors) ? object.errors.map((e) => Any.fromJSON(e)) : [],
            data: isSet(object.data) ? JsonRedditObjects_JsonType_JsonData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.errors) {
            obj.errors = message.errors.map((e) => e ? Any.toJSON(e) : undefined);
        }
        else {
            obj.errors = [];
        }
        message.data !== undefined &&
            (obj.data = message.data ? JsonRedditObjects_JsonType_JsonData.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseJsonRedditObjects_JsonType();
        message.errors = object.errors?.map((e) => Any.fromPartial(e)) || [];
        message.data = (object.data !== undefined && object.data !== null)
            ? JsonRedditObjects_JsonType_JsonData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonRedditObjects.JsonType", JsonRedditObjects_JsonType);
function createBaseJsonRedditObjects_JsonType_JsonData() {
    return { things: [] };
}
export const JsonRedditObjects_JsonType_JsonData = {
    $type: "devvit.plugin.redditapi.common.JsonRedditObjects.JsonType.JsonData",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.things) {
            WrappedRedditObject.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonRedditObjects_JsonType_JsonData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.things.push(WrappedRedditObject.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            things: Array.isArray(object?.things) ? object.things.map((e) => WrappedRedditObject.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.things) {
            obj.things = message.things.map((e) => e ? WrappedRedditObject.toJSON(e) : undefined);
        }
        else {
            obj.things = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseJsonRedditObjects_JsonType_JsonData();
        message.things = object.things?.map((e) => WrappedRedditObject.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonRedditObjects.JsonType.JsonData", JsonRedditObjects_JsonType_JsonData);
function createBaseRedditObject() {
    return {
        allAwardings: [],
        approved: undefined,
        approvedAtUtc: undefined,
        approvedBy: undefined,
        archived: undefined,
        associatedAward: undefined,
        author: undefined,
        authorFlairBackgroundColor: undefined,
        authorFlairCssClass: undefined,
        authorFlairRichtext: [],
        authorFlairTemplateId: undefined,
        authorFlairText: undefined,
        authorFlairTextColor: undefined,
        authorFlairType: undefined,
        authorFullname: undefined,
        authorIsBlocked: undefined,
        authorPatreonFlair: undefined,
        authorPremium: undefined,
        awarders: [],
        bannedAtUtc: undefined,
        bannedBy: undefined,
        body: undefined,
        bodyHtml: undefined,
        canGild: undefined,
        canModPost: undefined,
        collapsed: undefined,
        collapsedBecauseCrowdControl: undefined,
        collapsedReason: undefined,
        collapsedReasonCode: undefined,
        commentType: undefined,
        controversiality: undefined,
        created: undefined,
        createdUtc: undefined,
        distinguished: undefined,
        downs: undefined,
        edited: undefined,
        gilded: undefined,
        gildings: undefined,
        id: undefined,
        ignoreReports: undefined,
        isSubmitter: undefined,
        likes: undefined,
        linkId: undefined,
        locked: undefined,
        modNote: undefined,
        modReasonBy: undefined,
        modReasonTitle: undefined,
        name: undefined,
        noFollow: undefined,
        numReports: undefined,
        parentId: undefined,
        permalink: undefined,
        removalReason: undefined,
        removed: undefined,
        replies: undefined,
        reportReasons: undefined,
        rteMode: undefined,
        saved: undefined,
        score: undefined,
        scoreHidden: undefined,
        sendReplies: undefined,
        spam: undefined,
        stickied: undefined,
        subreddit: undefined,
        subredditId: undefined,
        subredditNamePrefixed: undefined,
        subredditType: undefined,
        topAwardedType: undefined,
        totalAwardsReceived: undefined,
        treatmentTags: [],
        unrepliableReason: undefined,
        ups: undefined,
        depth: undefined,
        linkTitle: undefined,
        linkAuthor: undefined,
        numComments: undefined,
        over18: undefined,
        linkPermalink: undefined,
        quarantine: undefined,
        linkUrl: undefined,
        selftext: undefined,
        selftextHtml: undefined,
        thumbnail: undefined,
        thumbnailWidth: undefined,
        thumbnailHeight: undefined,
        title: undefined,
        url: undefined,
        displayName: undefined,
        modPermissions: [],
        count: undefined,
        children: undefined,
        replyList: undefined,
        hidden: undefined,
        linkFlairBackgroundColor: undefined,
        linkFlairCssClass: undefined,
        linkFlairRichtext: [],
        linkFlairTemplateId: undefined,
        linkFlairText: undefined,
        linkFlairTextColor: undefined,
        linkFlairType: undefined,
        secureMedia: undefined,
        spoiler: false,
        modReports: [],
        userReports: [],
        removedBy: undefined,
        removedByCategory: undefined,
    };
}
export const RedditObject = {
    $type: "devvit.plugin.redditapi.common.RedditObject",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.allAwardings) {
            Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.approved !== undefined) {
            BoolValue.encode({ value: message.approved }, writer.uint32(18).fork()).ldelim();
        }
        if (message.approvedAtUtc !== undefined) {
            Int64Value.encode({ value: message.approvedAtUtc }, writer.uint32(26).fork()).ldelim();
        }
        if (message.approvedBy !== undefined) {
            StringValue.encode({ value: message.approvedBy }, writer.uint32(34).fork()).ldelim();
        }
        if (message.archived !== undefined) {
            BoolValue.encode({ value: message.archived }, writer.uint32(42).fork()).ldelim();
        }
        if (message.associatedAward !== undefined) {
            StringValue.encode({ value: message.associatedAward }, writer.uint32(50).fork()).ldelim();
        }
        if (message.author !== undefined) {
            StringValue.encode({ value: message.author }, writer.uint32(58).fork()).ldelim();
        }
        if (message.authorFlairBackgroundColor !== undefined) {
            StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(66).fork()).ldelim();
        }
        if (message.authorFlairCssClass !== undefined) {
            StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(74).fork()).ldelim();
        }
        for (const v of message.authorFlairRichtext) {
            RedditObject_AuthorFlairRichText.encode(v, writer.uint32(82).fork()).ldelim();
        }
        if (message.authorFlairTemplateId !== undefined) {
            StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(90).fork()).ldelim();
        }
        if (message.authorFlairText !== undefined) {
            StringValue.encode({ value: message.authorFlairText }, writer.uint32(98).fork()).ldelim();
        }
        if (message.authorFlairTextColor !== undefined) {
            StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(106).fork()).ldelim();
        }
        if (message.authorFlairType !== undefined) {
            StringValue.encode({ value: message.authorFlairType }, writer.uint32(114).fork()).ldelim();
        }
        if (message.authorFullname !== undefined) {
            StringValue.encode({ value: message.authorFullname }, writer.uint32(122).fork()).ldelim();
        }
        if (message.authorIsBlocked !== undefined) {
            BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(130).fork()).ldelim();
        }
        if (message.authorPatreonFlair !== undefined) {
            BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(138).fork()).ldelim();
        }
        if (message.authorPremium !== undefined) {
            BoolValue.encode({ value: message.authorPremium }, writer.uint32(146).fork()).ldelim();
        }
        for (const v of message.awarders) {
            StringValue.encode({ value: v }, writer.uint32(154).fork()).ldelim();
        }
        if (message.bannedAtUtc !== undefined) {
            Int64Value.encode({ value: message.bannedAtUtc }, writer.uint32(162).fork()).ldelim();
        }
        if (message.bannedBy !== undefined) {
            StringValue.encode({ value: message.bannedBy }, writer.uint32(170).fork()).ldelim();
        }
        if (message.body !== undefined) {
            StringValue.encode({ value: message.body }, writer.uint32(178).fork()).ldelim();
        }
        if (message.bodyHtml !== undefined) {
            StringValue.encode({ value: message.bodyHtml }, writer.uint32(186).fork()).ldelim();
        }
        if (message.canGild !== undefined) {
            BoolValue.encode({ value: message.canGild }, writer.uint32(194).fork()).ldelim();
        }
        if (message.canModPost !== undefined) {
            BoolValue.encode({ value: message.canModPost }, writer.uint32(202).fork()).ldelim();
        }
        if (message.collapsed !== undefined) {
            BoolValue.encode({ value: message.collapsed }, writer.uint32(210).fork()).ldelim();
        }
        if (message.collapsedBecauseCrowdControl !== undefined) {
            BoolValue.encode({ value: message.collapsedBecauseCrowdControl }, writer.uint32(218).fork()).ldelim();
        }
        if (message.collapsedReason !== undefined) {
            StringValue.encode({ value: message.collapsedReason }, writer.uint32(226).fork()).ldelim();
        }
        if (message.collapsedReasonCode !== undefined) {
            StringValue.encode({ value: message.collapsedReasonCode }, writer.uint32(234).fork()).ldelim();
        }
        if (message.commentType !== undefined) {
            StringValue.encode({ value: message.commentType }, writer.uint32(242).fork()).ldelim();
        }
        if (message.controversiality !== undefined) {
            Int64Value.encode({ value: message.controversiality }, writer.uint32(250).fork()).ldelim();
        }
        if (message.created !== undefined) {
            Int64Value.encode({ value: message.created }, writer.uint32(258).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(266).fork()).ldelim();
        }
        if (message.distinguished !== undefined) {
            StringValue.encode({ value: message.distinguished }, writer.uint32(274).fork()).ldelim();
        }
        if (message.downs !== undefined) {
            Int64Value.encode({ value: message.downs }, writer.uint32(282).fork()).ldelim();
        }
        if (message.edited !== undefined) {
            BoolValue.encode({ value: message.edited }, writer.uint32(290).fork()).ldelim();
        }
        if (message.gilded !== undefined) {
            Int64Value.encode({ value: message.gilded }, writer.uint32(298).fork()).ldelim();
        }
        if (message.gildings !== undefined) {
            Any.encode(message.gildings, writer.uint32(306).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(314).fork()).ldelim();
        }
        if (message.ignoreReports !== undefined) {
            BoolValue.encode({ value: message.ignoreReports }, writer.uint32(322).fork()).ldelim();
        }
        if (message.isSubmitter !== undefined) {
            BoolValue.encode({ value: message.isSubmitter }, writer.uint32(330).fork()).ldelim();
        }
        if (message.likes !== undefined) {
            BoolValue.encode({ value: message.likes }, writer.uint32(338).fork()).ldelim();
        }
        if (message.linkId !== undefined) {
            StringValue.encode({ value: message.linkId }, writer.uint32(346).fork()).ldelim();
        }
        if (message.locked !== undefined) {
            BoolValue.encode({ value: message.locked }, writer.uint32(354).fork()).ldelim();
        }
        if (message.modNote !== undefined) {
            StringValue.encode({ value: message.modNote }, writer.uint32(362).fork()).ldelim();
        }
        if (message.modReasonBy !== undefined) {
            StringValue.encode({ value: message.modReasonBy }, writer.uint32(370).fork()).ldelim();
        }
        if (message.modReasonTitle !== undefined) {
            StringValue.encode({ value: message.modReasonTitle }, writer.uint32(378).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(394).fork()).ldelim();
        }
        if (message.noFollow !== undefined) {
            BoolValue.encode({ value: message.noFollow }, writer.uint32(402).fork()).ldelim();
        }
        if (message.numReports !== undefined) {
            Int64Value.encode({ value: message.numReports }, writer.uint32(418).fork()).ldelim();
        }
        if (message.parentId !== undefined) {
            StringValue.encode({ value: message.parentId }, writer.uint32(426).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(434).fork()).ldelim();
        }
        if (message.removalReason !== undefined) {
            StringValue.encode({ value: message.removalReason }, writer.uint32(442).fork()).ldelim();
        }
        if (message.removed !== undefined) {
            BoolValue.encode({ value: message.removed }, writer.uint32(450).fork()).ldelim();
        }
        if (message.replies !== undefined) {
            StringValue.encode({ value: message.replies }, writer.uint32(458).fork()).ldelim();
        }
        if (message.reportReasons !== undefined) {
            ListValue.encode(ListValue.wrap(message.reportReasons), writer.uint32(466).fork()).ldelim();
        }
        if (message.rteMode !== undefined) {
            StringValue.encode({ value: message.rteMode }, writer.uint32(474).fork()).ldelim();
        }
        if (message.saved !== undefined) {
            BoolValue.encode({ value: message.saved }, writer.uint32(482).fork()).ldelim();
        }
        if (message.score !== undefined) {
            Int64Value.encode({ value: message.score }, writer.uint32(490).fork()).ldelim();
        }
        if (message.scoreHidden !== undefined) {
            BoolValue.encode({ value: message.scoreHidden }, writer.uint32(498).fork()).ldelim();
        }
        if (message.sendReplies !== undefined) {
            BoolValue.encode({ value: message.sendReplies }, writer.uint32(506).fork()).ldelim();
        }
        if (message.spam !== undefined) {
            BoolValue.encode({ value: message.spam }, writer.uint32(514).fork()).ldelim();
        }
        if (message.stickied !== undefined) {
            BoolValue.encode({ value: message.stickied }, writer.uint32(522).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(530).fork()).ldelim();
        }
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(538).fork()).ldelim();
        }
        if (message.subredditNamePrefixed !== undefined) {
            StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(546).fork()).ldelim();
        }
        if (message.subredditType !== undefined) {
            StringValue.encode({ value: message.subredditType }, writer.uint32(554).fork()).ldelim();
        }
        if (message.topAwardedType !== undefined) {
            StringValue.encode({ value: message.topAwardedType }, writer.uint32(562).fork()).ldelim();
        }
        if (message.totalAwardsReceived !== undefined) {
            Int64Value.encode({ value: message.totalAwardsReceived }, writer.uint32(570).fork()).ldelim();
        }
        for (const v of message.treatmentTags) {
            Any.encode(v, writer.uint32(578).fork()).ldelim();
        }
        if (message.unrepliableReason !== undefined) {
            StringValue.encode({ value: message.unrepliableReason }, writer.uint32(586).fork()).ldelim();
        }
        if (message.ups !== undefined) {
            Int64Value.encode({ value: message.ups }, writer.uint32(594).fork()).ldelim();
        }
        if (message.depth !== undefined) {
            Int64Value.encode({ value: message.depth }, writer.uint32(610).fork()).ldelim();
        }
        if (message.linkTitle !== undefined) {
            StringValue.encode({ value: message.linkTitle }, writer.uint32(618).fork()).ldelim();
        }
        if (message.linkAuthor !== undefined) {
            StringValue.encode({ value: message.linkAuthor }, writer.uint32(626).fork()).ldelim();
        }
        if (message.numComments !== undefined) {
            Int64Value.encode({ value: message.numComments }, writer.uint32(634).fork()).ldelim();
        }
        if (message.over18 !== undefined) {
            BoolValue.encode({ value: message.over18 }, writer.uint32(642).fork()).ldelim();
        }
        if (message.linkPermalink !== undefined) {
            StringValue.encode({ value: message.linkPermalink }, writer.uint32(650).fork()).ldelim();
        }
        if (message.quarantine !== undefined) {
            BoolValue.encode({ value: message.quarantine }, writer.uint32(658).fork()).ldelim();
        }
        if (message.linkUrl !== undefined) {
            StringValue.encode({ value: message.linkUrl }, writer.uint32(666).fork()).ldelim();
        }
        if (message.selftext !== undefined) {
            StringValue.encode({ value: message.selftext }, writer.uint32(674).fork()).ldelim();
        }
        if (message.selftextHtml !== undefined) {
            StringValue.encode({ value: message.selftextHtml }, writer.uint32(682).fork()).ldelim();
        }
        if (message.thumbnail !== undefined) {
            StringValue.encode({ value: message.thumbnail }, writer.uint32(698).fork()).ldelim();
        }
        if (message.thumbnailWidth !== undefined) {
            Int64Value.encode({ value: message.thumbnailWidth }, writer.uint32(706).fork()).ldelim();
        }
        if (message.thumbnailHeight !== undefined) {
            Int64Value.encode({ value: message.thumbnailHeight }, writer.uint32(714).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(722).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(730).fork()).ldelim();
        }
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(738).fork()).ldelim();
        }
        for (const v of message.modPermissions) {
            StringValue.encode({ value: v }, writer.uint32(746).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(754).fork()).ldelim();
        }
        if (message.children !== undefined) {
            ListValue.encode(ListValue.wrap(message.children), writer.uint32(762).fork()).ldelim();
        }
        if (message.replyList !== undefined) {
            Listing.encode(message.replyList, writer.uint32(770).fork()).ldelim();
        }
        if (message.hidden !== undefined) {
            BoolValue.encode({ value: message.hidden }, writer.uint32(778).fork()).ldelim();
        }
        if (message.linkFlairBackgroundColor !== undefined) {
            StringValue.encode({ value: message.linkFlairBackgroundColor }, writer.uint32(786).fork()).ldelim();
        }
        if (message.linkFlairCssClass !== undefined) {
            StringValue.encode({ value: message.linkFlairCssClass }, writer.uint32(794).fork()).ldelim();
        }
        for (const v of message.linkFlairRichtext) {
            RedditObject_LinkFlairRichText.encode(v, writer.uint32(802).fork()).ldelim();
        }
        if (message.linkFlairTemplateId !== undefined) {
            StringValue.encode({ value: message.linkFlairTemplateId }, writer.uint32(810).fork()).ldelim();
        }
        if (message.linkFlairText !== undefined) {
            StringValue.encode({ value: message.linkFlairText }, writer.uint32(818).fork()).ldelim();
        }
        if (message.linkFlairTextColor !== undefined) {
            StringValue.encode({ value: message.linkFlairTextColor }, writer.uint32(826).fork()).ldelim();
        }
        if (message.linkFlairType !== undefined) {
            StringValue.encode({ value: message.linkFlairType }, writer.uint32(834).fork()).ldelim();
        }
        if (message.secureMedia !== undefined) {
            RedditObject_SecureMedia.encode(message.secureMedia, writer.uint32(842).fork()).ldelim();
        }
        if (message.spoiler === true) {
            writer.uint32(848).bool(message.spoiler);
        }
        for (const v of message.modReports) {
            ListValue.encode(ListValue.wrap(v), writer.uint32(858).fork()).ldelim();
        }
        for (const v of message.userReports) {
            ListValue.encode(ListValue.wrap(v), writer.uint32(866).fork()).ldelim();
        }
        if (message.removedBy !== undefined) {
            StringValue.encode({ value: message.removedBy }, writer.uint32(874).fork()).ldelim();
        }
        if (message.removedByCategory !== undefined) {
            StringValue.encode({ value: message.removedByCategory }, writer.uint32(882).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedditObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.allAwardings.push(Any.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.approved = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.approvedAtUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.archived = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.associatedAward = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.author = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.authorFlairRichtext.push(RedditObject_AuthorFlairRichText.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 20:
                    message.bannedAtUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.body = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.bodyHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.canGild = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 26:
                    message.collapsed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 27:
                    message.collapsedBecauseCrowdControl = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 28:
                    message.collapsedReason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 29:
                    message.collapsedReasonCode = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 30:
                    message.commentType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 31:
                    message.controversiality = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 32:
                    message.created = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 33:
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 34:
                    message.distinguished = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 35:
                    message.downs = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 36:
                    message.edited = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 37:
                    message.gilded = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 38:
                    message.gildings = Any.decode(reader, reader.uint32());
                    break;
                case 39:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 40:
                    message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 41:
                    message.isSubmitter = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 42:
                    message.likes = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 43:
                    message.linkId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 44:
                    message.locked = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 45:
                    message.modNote = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 46:
                    message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 47:
                    message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 49:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 50:
                    message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 52:
                    message.numReports = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 53:
                    message.parentId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 54:
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 55:
                    message.removalReason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 56:
                    message.removed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 57:
                    message.replies = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 58:
                    message.reportReasons = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
                    break;
                case 59:
                    message.rteMode = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 60:
                    message.saved = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 61:
                    message.score = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 62:
                    message.scoreHidden = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 63:
                    message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 64:
                    message.spam = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 65:
                    message.stickied = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 66:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 67:
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 68:
                    message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 69:
                    message.subredditType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 70:
                    message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 71:
                    message.totalAwardsReceived = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 72:
                    message.treatmentTags.push(Any.decode(reader, reader.uint32()));
                    break;
                case 73:
                    message.unrepliableReason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 74:
                    message.ups = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 76:
                    message.depth = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 77:
                    message.linkTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 78:
                    message.linkAuthor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 79:
                    message.numComments = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 80:
                    message.over18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 81:
                    message.linkPermalink = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 82:
                    message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 83:
                    message.linkUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 84:
                    message.selftext = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 85:
                    message.selftextHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 87:
                    message.thumbnail = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 88:
                    message.thumbnailWidth = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 89:
                    message.thumbnailHeight = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 90:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 91:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 92:
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 93:
                    message.modPermissions.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 94:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 95:
                    message.children = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
                    break;
                case 96:
                    message.replyList = Listing.decode(reader, reader.uint32());
                    break;
                case 97:
                    message.hidden = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 98:
                    message.linkFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 99:
                    message.linkFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 100:
                    message.linkFlairRichtext.push(RedditObject_LinkFlairRichText.decode(reader, reader.uint32()));
                    break;
                case 101:
                    message.linkFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 102:
                    message.linkFlairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 103:
                    message.linkFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 104:
                    message.linkFlairType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 105:
                    message.secureMedia = RedditObject_SecureMedia.decode(reader, reader.uint32());
                    break;
                case 106:
                    message.spoiler = reader.bool();
                    break;
                case 107:
                    message.modReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
                    break;
                case 108:
                    message.userReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
                    break;
                case 109:
                    message.removedBy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 110:
                    message.removedByCategory = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            allAwardings: Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Any.fromJSON(e)) : [],
            approved: isSet(object.approved) ? Boolean(object.approved) : undefined,
            approvedAtUtc: isSet(object.approvedAtUtc) ? Number(object.approvedAtUtc) : undefined,
            approvedBy: isSet(object.approvedBy) ? String(object.approvedBy) : undefined,
            archived: isSet(object.archived) ? Boolean(object.archived) : undefined,
            associatedAward: isSet(object.associatedAward) ? String(object.associatedAward) : undefined,
            author: isSet(object.author) ? String(object.author) : undefined,
            authorFlairBackgroundColor: isSet(object.authorFlairBackgroundColor)
                ? String(object.authorFlairBackgroundColor)
                : undefined,
            authorFlairCssClass: isSet(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : undefined,
            authorFlairRichtext: Array.isArray(object?.authorFlairRichtext)
                ? object.authorFlairRichtext.map((e) => RedditObject_AuthorFlairRichText.fromJSON(e))
                : [],
            authorFlairTemplateId: isSet(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : undefined,
            authorFlairText: isSet(object.authorFlairText) ? String(object.authorFlairText) : undefined,
            authorFlairTextColor: isSet(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : undefined,
            authorFlairType: isSet(object.authorFlairType) ? String(object.authorFlairType) : undefined,
            authorFullname: isSet(object.authorFullname) ? String(object.authorFullname) : undefined,
            authorIsBlocked: isSet(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : undefined,
            authorPatreonFlair: isSet(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : undefined,
            authorPremium: isSet(object.authorPremium) ? Boolean(object.authorPremium) : undefined,
            awarders: Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
            bannedAtUtc: isSet(object.bannedAtUtc) ? Number(object.bannedAtUtc) : undefined,
            bannedBy: isSet(object.bannedBy) ? String(object.bannedBy) : undefined,
            body: isSet(object.body) ? String(object.body) : undefined,
            bodyHtml: isSet(object.bodyHtml) ? String(object.bodyHtml) : undefined,
            canGild: isSet(object.canGild) ? Boolean(object.canGild) : undefined,
            canModPost: isSet(object.canModPost) ? Boolean(object.canModPost) : undefined,
            collapsed: isSet(object.collapsed) ? Boolean(object.collapsed) : undefined,
            collapsedBecauseCrowdControl: isSet(object.collapsedBecauseCrowdControl)
                ? Boolean(object.collapsedBecauseCrowdControl)
                : undefined,
            collapsedReason: isSet(object.collapsedReason) ? String(object.collapsedReason) : undefined,
            collapsedReasonCode: isSet(object.collapsedReasonCode) ? String(object.collapsedReasonCode) : undefined,
            commentType: isSet(object.commentType) ? String(object.commentType) : undefined,
            controversiality: isSet(object.controversiality) ? Number(object.controversiality) : undefined,
            created: isSet(object.created) ? Number(object.created) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            distinguished: isSet(object.distinguished) ? String(object.distinguished) : undefined,
            downs: isSet(object.downs) ? Number(object.downs) : undefined,
            edited: isSet(object.edited) ? Boolean(object.edited) : undefined,
            gilded: isSet(object.gilded) ? Number(object.gilded) : undefined,
            gildings: isSet(object.gildings) ? Any.fromJSON(object.gildings) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            ignoreReports: isSet(object.ignoreReports) ? Boolean(object.ignoreReports) : undefined,
            isSubmitter: isSet(object.isSubmitter) ? Boolean(object.isSubmitter) : undefined,
            likes: isSet(object.likes) ? Boolean(object.likes) : undefined,
            linkId: isSet(object.linkId) ? String(object.linkId) : undefined,
            locked: isSet(object.locked) ? Boolean(object.locked) : undefined,
            modNote: isSet(object.modNote) ? String(object.modNote) : undefined,
            modReasonBy: isSet(object.modReasonBy) ? String(object.modReasonBy) : undefined,
            modReasonTitle: isSet(object.modReasonTitle) ? String(object.modReasonTitle) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            noFollow: isSet(object.noFollow) ? Boolean(object.noFollow) : undefined,
            numReports: isSet(object.numReports) ? Number(object.numReports) : undefined,
            parentId: isSet(object.parentId) ? String(object.parentId) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            removalReason: isSet(object.removalReason) ? String(object.removalReason) : undefined,
            removed: isSet(object.removed) ? Boolean(object.removed) : undefined,
            replies: isSet(object.replies) ? String(object.replies) : undefined,
            reportReasons: Array.isArray(object.reportReasons) ? [...object.reportReasons] : undefined,
            rteMode: isSet(object.rteMode) ? String(object.rteMode) : undefined,
            saved: isSet(object.saved) ? Boolean(object.saved) : undefined,
            score: isSet(object.score) ? Number(object.score) : undefined,
            scoreHidden: isSet(object.scoreHidden) ? Boolean(object.scoreHidden) : undefined,
            sendReplies: isSet(object.sendReplies) ? Boolean(object.sendReplies) : undefined,
            spam: isSet(object.spam) ? Boolean(object.spam) : undefined,
            stickied: isSet(object.stickied) ? Boolean(object.stickied) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            subredditNamePrefixed: isSet(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : undefined,
            subredditType: isSet(object.subredditType) ? String(object.subredditType) : undefined,
            topAwardedType: isSet(object.topAwardedType) ? String(object.topAwardedType) : undefined,
            totalAwardsReceived: isSet(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : undefined,
            treatmentTags: Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => Any.fromJSON(e)) : [],
            unrepliableReason: isSet(object.unrepliableReason) ? String(object.unrepliableReason) : undefined,
            ups: isSet(object.ups) ? Number(object.ups) : undefined,
            depth: isSet(object.depth) ? Number(object.depth) : undefined,
            linkTitle: isSet(object.linkTitle) ? String(object.linkTitle) : undefined,
            linkAuthor: isSet(object.linkAuthor) ? String(object.linkAuthor) : undefined,
            numComments: isSet(object.numComments) ? Number(object.numComments) : undefined,
            over18: isSet(object.over18) ? Boolean(object.over18) : undefined,
            linkPermalink: isSet(object.linkPermalink) ? String(object.linkPermalink) : undefined,
            quarantine: isSet(object.quarantine) ? Boolean(object.quarantine) : undefined,
            linkUrl: isSet(object.linkUrl) ? String(object.linkUrl) : undefined,
            selftext: isSet(object.selftext) ? String(object.selftext) : undefined,
            selftextHtml: isSet(object.selftextHtml) ? String(object.selftextHtml) : undefined,
            thumbnail: isSet(object.thumbnail) ? String(object.thumbnail) : undefined,
            thumbnailWidth: isSet(object.thumbnailWidth) ? Number(object.thumbnailWidth) : undefined,
            thumbnailHeight: isSet(object.thumbnailHeight) ? Number(object.thumbnailHeight) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            modPermissions: Array.isArray(object?.modPermissions) ? object.modPermissions.map((e) => String(e)) : [],
            count: isSet(object.count) ? Number(object.count) : undefined,
            children: Array.isArray(object.children) ? [...object.children] : undefined,
            replyList: isSet(object.replyList) ? Listing.fromJSON(object.replyList) : undefined,
            hidden: isSet(object.hidden) ? Boolean(object.hidden) : undefined,
            linkFlairBackgroundColor: isSet(object.linkFlairBackgroundColor)
                ? String(object.linkFlairBackgroundColor)
                : undefined,
            linkFlairCssClass: isSet(object.linkFlairCssClass) ? String(object.linkFlairCssClass) : undefined,
            linkFlairRichtext: Array.isArray(object?.linkFlairRichtext)
                ? object.linkFlairRichtext.map((e) => RedditObject_LinkFlairRichText.fromJSON(e))
                : [],
            linkFlairTemplateId: isSet(object.linkFlairTemplateId) ? String(object.linkFlairTemplateId) : undefined,
            linkFlairText: isSet(object.linkFlairText) ? String(object.linkFlairText) : undefined,
            linkFlairTextColor: isSet(object.linkFlairTextColor) ? String(object.linkFlairTextColor) : undefined,
            linkFlairType: isSet(object.linkFlairType) ? String(object.linkFlairType) : undefined,
            secureMedia: isSet(object.secureMedia) ? RedditObject_SecureMedia.fromJSON(object.secureMedia) : undefined,
            spoiler: isSet(object.spoiler) ? Boolean(object.spoiler) : false,
            modReports: Array.isArray(object?.modReports) ? object.modReports.map((e) => [...e]) : [],
            userReports: Array.isArray(object?.userReports) ? object.userReports.map((e) => [...e]) : [],
            removedBy: isSet(object.removedBy) ? String(object.removedBy) : undefined,
            removedByCategory: isSet(object.removedByCategory) ? String(object.removedByCategory) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.allAwardings) {
            obj.allAwardings = message.allAwardings.map((e) => e ? Any.toJSON(e) : undefined);
        }
        else {
            obj.allAwardings = [];
        }
        message.approved !== undefined && (obj.approved = message.approved);
        message.approvedAtUtc !== undefined && (obj.approvedAtUtc = message.approvedAtUtc);
        message.approvedBy !== undefined && (obj.approvedBy = message.approvedBy);
        message.archived !== undefined && (obj.archived = message.archived);
        message.associatedAward !== undefined && (obj.associatedAward = message.associatedAward);
        message.author !== undefined && (obj.author = message.author);
        message.authorFlairBackgroundColor !== undefined &&
            (obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor);
        message.authorFlairCssClass !== undefined && (obj.authorFlairCssClass = message.authorFlairCssClass);
        if (message.authorFlairRichtext) {
            obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => e ? RedditObject_AuthorFlairRichText.toJSON(e) : undefined);
        }
        else {
            obj.authorFlairRichtext = [];
        }
        message.authorFlairTemplateId !== undefined && (obj.authorFlairTemplateId = message.authorFlairTemplateId);
        message.authorFlairText !== undefined && (obj.authorFlairText = message.authorFlairText);
        message.authorFlairTextColor !== undefined && (obj.authorFlairTextColor = message.authorFlairTextColor);
        message.authorFlairType !== undefined && (obj.authorFlairType = message.authorFlairType);
        message.authorFullname !== undefined && (obj.authorFullname = message.authorFullname);
        message.authorIsBlocked !== undefined && (obj.authorIsBlocked = message.authorIsBlocked);
        message.authorPatreonFlair !== undefined && (obj.authorPatreonFlair = message.authorPatreonFlair);
        message.authorPremium !== undefined && (obj.authorPremium = message.authorPremium);
        if (message.awarders) {
            obj.awarders = message.awarders.map((e) => e);
        }
        else {
            obj.awarders = [];
        }
        message.bannedAtUtc !== undefined && (obj.bannedAtUtc = message.bannedAtUtc);
        message.bannedBy !== undefined && (obj.bannedBy = message.bannedBy);
        message.body !== undefined && (obj.body = message.body);
        message.bodyHtml !== undefined && (obj.bodyHtml = message.bodyHtml);
        message.canGild !== undefined && (obj.canGild = message.canGild);
        message.canModPost !== undefined && (obj.canModPost = message.canModPost);
        message.collapsed !== undefined && (obj.collapsed = message.collapsed);
        message.collapsedBecauseCrowdControl !== undefined &&
            (obj.collapsedBecauseCrowdControl = message.collapsedBecauseCrowdControl);
        message.collapsedReason !== undefined && (obj.collapsedReason = message.collapsedReason);
        message.collapsedReasonCode !== undefined && (obj.collapsedReasonCode = message.collapsedReasonCode);
        message.commentType !== undefined && (obj.commentType = message.commentType);
        message.controversiality !== undefined && (obj.controversiality = message.controversiality);
        message.created !== undefined && (obj.created = message.created);
        message.createdUtc !== undefined && (obj.createdUtc = message.createdUtc);
        message.distinguished !== undefined && (obj.distinguished = message.distinguished);
        message.downs !== undefined && (obj.downs = message.downs);
        message.edited !== undefined && (obj.edited = message.edited);
        message.gilded !== undefined && (obj.gilded = message.gilded);
        message.gildings !== undefined && (obj.gildings = message.gildings ? Any.toJSON(message.gildings) : undefined);
        message.id !== undefined && (obj.id = message.id);
        message.ignoreReports !== undefined && (obj.ignoreReports = message.ignoreReports);
        message.isSubmitter !== undefined && (obj.isSubmitter = message.isSubmitter);
        message.likes !== undefined && (obj.likes = message.likes);
        message.linkId !== undefined && (obj.linkId = message.linkId);
        message.locked !== undefined && (obj.locked = message.locked);
        message.modNote !== undefined && (obj.modNote = message.modNote);
        message.modReasonBy !== undefined && (obj.modReasonBy = message.modReasonBy);
        message.modReasonTitle !== undefined && (obj.modReasonTitle = message.modReasonTitle);
        message.name !== undefined && (obj.name = message.name);
        message.noFollow !== undefined && (obj.noFollow = message.noFollow);
        message.numReports !== undefined && (obj.numReports = message.numReports);
        message.parentId !== undefined && (obj.parentId = message.parentId);
        message.permalink !== undefined && (obj.permalink = message.permalink);
        message.removalReason !== undefined && (obj.removalReason = message.removalReason);
        message.removed !== undefined && (obj.removed = message.removed);
        message.replies !== undefined && (obj.replies = message.replies);
        message.reportReasons !== undefined && (obj.reportReasons = message.reportReasons);
        message.rteMode !== undefined && (obj.rteMode = message.rteMode);
        message.saved !== undefined && (obj.saved = message.saved);
        message.score !== undefined && (obj.score = message.score);
        message.scoreHidden !== undefined && (obj.scoreHidden = message.scoreHidden);
        message.sendReplies !== undefined && (obj.sendReplies = message.sendReplies);
        message.spam !== undefined && (obj.spam = message.spam);
        message.stickied !== undefined && (obj.stickied = message.stickied);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.subredditId !== undefined && (obj.subredditId = message.subredditId);
        message.subredditNamePrefixed !== undefined && (obj.subredditNamePrefixed = message.subredditNamePrefixed);
        message.subredditType !== undefined && (obj.subredditType = message.subredditType);
        message.topAwardedType !== undefined && (obj.topAwardedType = message.topAwardedType);
        message.totalAwardsReceived !== undefined && (obj.totalAwardsReceived = message.totalAwardsReceived);
        if (message.treatmentTags) {
            obj.treatmentTags = message.treatmentTags.map((e) => e ? Any.toJSON(e) : undefined);
        }
        else {
            obj.treatmentTags = [];
        }
        message.unrepliableReason !== undefined && (obj.unrepliableReason = message.unrepliableReason);
        message.ups !== undefined && (obj.ups = message.ups);
        message.depth !== undefined && (obj.depth = message.depth);
        message.linkTitle !== undefined && (obj.linkTitle = message.linkTitle);
        message.linkAuthor !== undefined && (obj.linkAuthor = message.linkAuthor);
        message.numComments !== undefined && (obj.numComments = message.numComments);
        message.over18 !== undefined && (obj.over18 = message.over18);
        message.linkPermalink !== undefined && (obj.linkPermalink = message.linkPermalink);
        message.quarantine !== undefined && (obj.quarantine = message.quarantine);
        message.linkUrl !== undefined && (obj.linkUrl = message.linkUrl);
        message.selftext !== undefined && (obj.selftext = message.selftext);
        message.selftextHtml !== undefined && (obj.selftextHtml = message.selftextHtml);
        message.thumbnail !== undefined && (obj.thumbnail = message.thumbnail);
        message.thumbnailWidth !== undefined && (obj.thumbnailWidth = message.thumbnailWidth);
        message.thumbnailHeight !== undefined && (obj.thumbnailHeight = message.thumbnailHeight);
        message.title !== undefined && (obj.title = message.title);
        message.url !== undefined && (obj.url = message.url);
        message.displayName !== undefined && (obj.displayName = message.displayName);
        if (message.modPermissions) {
            obj.modPermissions = message.modPermissions.map((e) => e);
        }
        else {
            obj.modPermissions = [];
        }
        message.count !== undefined && (obj.count = message.count);
        message.children !== undefined && (obj.children = message.children);
        message.replyList !== undefined &&
            (obj.replyList = message.replyList ? Listing.toJSON(message.replyList) : undefined);
        message.hidden !== undefined && (obj.hidden = message.hidden);
        message.linkFlairBackgroundColor !== undefined && (obj.linkFlairBackgroundColor = message.linkFlairBackgroundColor);
        message.linkFlairCssClass !== undefined && (obj.linkFlairCssClass = message.linkFlairCssClass);
        if (message.linkFlairRichtext) {
            obj.linkFlairRichtext = message.linkFlairRichtext.map((e) => e ? RedditObject_LinkFlairRichText.toJSON(e) : undefined);
        }
        else {
            obj.linkFlairRichtext = [];
        }
        message.linkFlairTemplateId !== undefined && (obj.linkFlairTemplateId = message.linkFlairTemplateId);
        message.linkFlairText !== undefined && (obj.linkFlairText = message.linkFlairText);
        message.linkFlairTextColor !== undefined && (obj.linkFlairTextColor = message.linkFlairTextColor);
        message.linkFlairType !== undefined && (obj.linkFlairType = message.linkFlairType);
        message.secureMedia !== undefined &&
            (obj.secureMedia = message.secureMedia ? RedditObject_SecureMedia.toJSON(message.secureMedia) : undefined);
        message.spoiler !== undefined && (obj.spoiler = message.spoiler);
        if (message.modReports) {
            obj.modReports = message.modReports.map((e) => e);
        }
        else {
            obj.modReports = [];
        }
        if (message.userReports) {
            obj.userReports = message.userReports.map((e) => e);
        }
        else {
            obj.userReports = [];
        }
        message.removedBy !== undefined && (obj.removedBy = message.removedBy);
        message.removedByCategory !== undefined && (obj.removedByCategory = message.removedByCategory);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedditObject();
        message.allAwardings = object.allAwardings?.map((e) => Any.fromPartial(e)) || [];
        message.approved = object.approved ?? undefined;
        message.approvedAtUtc = object.approvedAtUtc ?? undefined;
        message.approvedBy = object.approvedBy ?? undefined;
        message.archived = object.archived ?? undefined;
        message.associatedAward = object.associatedAward ?? undefined;
        message.author = object.author ?? undefined;
        message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? undefined;
        message.authorFlairCssClass = object.authorFlairCssClass ?? undefined;
        message.authorFlairRichtext =
            object.authorFlairRichtext?.map((e) => RedditObject_AuthorFlairRichText.fromPartial(e)) || [];
        message.authorFlairTemplateId = object.authorFlairTemplateId ?? undefined;
        message.authorFlairText = object.authorFlairText ?? undefined;
        message.authorFlairTextColor = object.authorFlairTextColor ?? undefined;
        message.authorFlairType = object.authorFlairType ?? undefined;
        message.authorFullname = object.authorFullname ?? undefined;
        message.authorIsBlocked = object.authorIsBlocked ?? undefined;
        message.authorPatreonFlair = object.authorPatreonFlair ?? undefined;
        message.authorPremium = object.authorPremium ?? undefined;
        message.awarders = object.awarders?.map((e) => e) || [];
        message.bannedAtUtc = object.bannedAtUtc ?? undefined;
        message.bannedBy = object.bannedBy ?? undefined;
        message.body = object.body ?? undefined;
        message.bodyHtml = object.bodyHtml ?? undefined;
        message.canGild = object.canGild ?? undefined;
        message.canModPost = object.canModPost ?? undefined;
        message.collapsed = object.collapsed ?? undefined;
        message.collapsedBecauseCrowdControl = object.collapsedBecauseCrowdControl ?? undefined;
        message.collapsedReason = object.collapsedReason ?? undefined;
        message.collapsedReasonCode = object.collapsedReasonCode ?? undefined;
        message.commentType = object.commentType ?? undefined;
        message.controversiality = object.controversiality ?? undefined;
        message.created = object.created ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.distinguished = object.distinguished ?? undefined;
        message.downs = object.downs ?? undefined;
        message.edited = object.edited ?? undefined;
        message.gilded = object.gilded ?? undefined;
        message.gildings = (object.gildings !== undefined && object.gildings !== null)
            ? Any.fromPartial(object.gildings)
            : undefined;
        message.id = object.id ?? undefined;
        message.ignoreReports = object.ignoreReports ?? undefined;
        message.isSubmitter = object.isSubmitter ?? undefined;
        message.likes = object.likes ?? undefined;
        message.linkId = object.linkId ?? undefined;
        message.locked = object.locked ?? undefined;
        message.modNote = object.modNote ?? undefined;
        message.modReasonBy = object.modReasonBy ?? undefined;
        message.modReasonTitle = object.modReasonTitle ?? undefined;
        message.name = object.name ?? undefined;
        message.noFollow = object.noFollow ?? undefined;
        message.numReports = object.numReports ?? undefined;
        message.parentId = object.parentId ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.removalReason = object.removalReason ?? undefined;
        message.removed = object.removed ?? undefined;
        message.replies = object.replies ?? undefined;
        message.reportReasons = object.reportReasons ?? undefined;
        message.rteMode = object.rteMode ?? undefined;
        message.saved = object.saved ?? undefined;
        message.score = object.score ?? undefined;
        message.scoreHidden = object.scoreHidden ?? undefined;
        message.sendReplies = object.sendReplies ?? undefined;
        message.spam = object.spam ?? undefined;
        message.stickied = object.stickied ?? undefined;
        message.subreddit = object.subreddit ?? undefined;
        message.subredditId = object.subredditId ?? undefined;
        message.subredditNamePrefixed = object.subredditNamePrefixed ?? undefined;
        message.subredditType = object.subredditType ?? undefined;
        message.topAwardedType = object.topAwardedType ?? undefined;
        message.totalAwardsReceived = object.totalAwardsReceived ?? undefined;
        message.treatmentTags = object.treatmentTags?.map((e) => Any.fromPartial(e)) || [];
        message.unrepliableReason = object.unrepliableReason ?? undefined;
        message.ups = object.ups ?? undefined;
        message.depth = object.depth ?? undefined;
        message.linkTitle = object.linkTitle ?? undefined;
        message.linkAuthor = object.linkAuthor ?? undefined;
        message.numComments = object.numComments ?? undefined;
        message.over18 = object.over18 ?? undefined;
        message.linkPermalink = object.linkPermalink ?? undefined;
        message.quarantine = object.quarantine ?? undefined;
        message.linkUrl = object.linkUrl ?? undefined;
        message.selftext = object.selftext ?? undefined;
        message.selftextHtml = object.selftextHtml ?? undefined;
        message.thumbnail = object.thumbnail ?? undefined;
        message.thumbnailWidth = object.thumbnailWidth ?? undefined;
        message.thumbnailHeight = object.thumbnailHeight ?? undefined;
        message.title = object.title ?? undefined;
        message.url = object.url ?? undefined;
        message.displayName = object.displayName ?? undefined;
        message.modPermissions = object.modPermissions?.map((e) => e) || [];
        message.count = object.count ?? undefined;
        message.children = object.children ?? undefined;
        message.replyList = (object.replyList !== undefined && object.replyList !== null)
            ? Listing.fromPartial(object.replyList)
            : undefined;
        message.hidden = object.hidden ?? undefined;
        message.linkFlairBackgroundColor = object.linkFlairBackgroundColor ?? undefined;
        message.linkFlairCssClass = object.linkFlairCssClass ?? undefined;
        message.linkFlairRichtext = object.linkFlairRichtext?.map((e) => RedditObject_LinkFlairRichText.fromPartial(e)) ||
            [];
        message.linkFlairTemplateId = object.linkFlairTemplateId ?? undefined;
        message.linkFlairText = object.linkFlairText ?? undefined;
        message.linkFlairTextColor = object.linkFlairTextColor ?? undefined;
        message.linkFlairType = object.linkFlairType ?? undefined;
        message.secureMedia = (object.secureMedia !== undefined && object.secureMedia !== null)
            ? RedditObject_SecureMedia.fromPartial(object.secureMedia)
            : undefined;
        message.spoiler = object.spoiler ?? false;
        message.modReports = object.modReports?.map((e) => e) || [];
        message.userReports = object.userReports?.map((e) => e) || [];
        message.removedBy = object.removedBy ?? undefined;
        message.removedByCategory = object.removedByCategory ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.RedditObject", RedditObject);
function createBaseRedditObject_OEmbed() {
    return {
        type: "",
        title: undefined,
        providerName: undefined,
        providerUrl: undefined,
        version: "",
        thumbnailWidth: undefined,
        thumbnailHeight: undefined,
        thumbnailUrl: undefined,
        html: "",
        height: undefined,
        width: undefined,
        authorUrl: undefined,
        authorName: undefined,
    };
}
export const RedditObject_OEmbed = {
    $type: "devvit.plugin.redditapi.common.RedditObject.OEmbed",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.title !== undefined) {
            writer.uint32(18).string(message.title);
        }
        if (message.providerName !== undefined) {
            writer.uint32(26).string(message.providerName);
        }
        if (message.providerUrl !== undefined) {
            writer.uint32(34).string(message.providerUrl);
        }
        if (message.version !== "") {
            writer.uint32(42).string(message.version);
        }
        if (message.thumbnailWidth !== undefined) {
            Int32Value.encode({ value: message.thumbnailWidth }, writer.uint32(50).fork()).ldelim();
        }
        if (message.thumbnailHeight !== undefined) {
            Int32Value.encode({ value: message.thumbnailHeight }, writer.uint32(58).fork()).ldelim();
        }
        if (message.thumbnailUrl !== undefined) {
            writer.uint32(66).string(message.thumbnailUrl);
        }
        if (message.html !== "") {
            writer.uint32(74).string(message.html);
        }
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(82).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(90).fork()).ldelim();
        }
        if (message.authorUrl !== undefined) {
            writer.uint32(98).string(message.authorUrl);
        }
        if (message.authorName !== undefined) {
            writer.uint32(106).string(message.authorName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedditObject_OEmbed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                case 3:
                    message.providerName = reader.string();
                    break;
                case 4:
                    message.providerUrl = reader.string();
                    break;
                case 5:
                    message.version = reader.string();
                    break;
                case 6:
                    message.thumbnailWidth = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.thumbnailHeight = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.thumbnailUrl = reader.string();
                    break;
                case 9:
                    message.html = reader.string();
                    break;
                case 10:
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.authorUrl = reader.string();
                    break;
                case 13:
                    message.authorName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? String(object.type) : "",
            title: isSet(object.title) ? String(object.title) : undefined,
            providerName: isSet(object.providerName) ? String(object.providerName) : undefined,
            providerUrl: isSet(object.providerUrl) ? String(object.providerUrl) : undefined,
            version: isSet(object.version) ? String(object.version) : "",
            thumbnailWidth: isSet(object.thumbnailWidth) ? Number(object.thumbnailWidth) : undefined,
            thumbnailHeight: isSet(object.thumbnailHeight) ? Number(object.thumbnailHeight) : undefined,
            thumbnailUrl: isSet(object.thumbnailUrl) ? String(object.thumbnailUrl) : undefined,
            html: isSet(object.html) ? String(object.html) : "",
            height: isSet(object.height) ? Number(object.height) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
            authorUrl: isSet(object.authorUrl) ? String(object.authorUrl) : undefined,
            authorName: isSet(object.authorName) ? String(object.authorName) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type);
        message.title !== undefined && (obj.title = message.title);
        message.providerName !== undefined && (obj.providerName = message.providerName);
        message.providerUrl !== undefined && (obj.providerUrl = message.providerUrl);
        message.version !== undefined && (obj.version = message.version);
        message.thumbnailWidth !== undefined && (obj.thumbnailWidth = message.thumbnailWidth);
        message.thumbnailHeight !== undefined && (obj.thumbnailHeight = message.thumbnailHeight);
        message.thumbnailUrl !== undefined && (obj.thumbnailUrl = message.thumbnailUrl);
        message.html !== undefined && (obj.html = message.html);
        message.height !== undefined && (obj.height = message.height);
        message.width !== undefined && (obj.width = message.width);
        message.authorUrl !== undefined && (obj.authorUrl = message.authorUrl);
        message.authorName !== undefined && (obj.authorName = message.authorName);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedditObject_OEmbed();
        message.type = object.type ?? "";
        message.title = object.title ?? undefined;
        message.providerName = object.providerName ?? undefined;
        message.providerUrl = object.providerUrl ?? undefined;
        message.version = object.version ?? "";
        message.thumbnailWidth = object.thumbnailWidth ?? undefined;
        message.thumbnailHeight = object.thumbnailHeight ?? undefined;
        message.thumbnailUrl = object.thumbnailUrl ?? undefined;
        message.html = object.html ?? "";
        message.height = object.height ?? undefined;
        message.width = object.width ?? undefined;
        message.authorUrl = object.authorUrl ?? undefined;
        message.authorName = object.authorName ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.RedditObject.OEmbed", RedditObject_OEmbed);
function createBaseRedditObject_RedditVideo() {
    return {
        bitrateKbps: undefined,
        dashUrl: undefined,
        duration: undefined,
        fallbackUrl: undefined,
        height: undefined,
        hlsUrl: undefined,
        isGif: undefined,
        scrubberMediaUrl: undefined,
        transcodingStatus: undefined,
        width: undefined,
    };
}
export const RedditObject_RedditVideo = {
    $type: "devvit.plugin.redditapi.common.RedditObject.RedditVideo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.bitrateKbps !== undefined) {
            Int32Value.encode({ value: message.bitrateKbps }, writer.uint32(10).fork()).ldelim();
        }
        if (message.dashUrl !== undefined) {
            StringValue.encode({ value: message.dashUrl }, writer.uint32(18).fork()).ldelim();
        }
        if (message.duration !== undefined) {
            Int32Value.encode({ value: message.duration }, writer.uint32(26).fork()).ldelim();
        }
        if (message.fallbackUrl !== undefined) {
            StringValue.encode({ value: message.fallbackUrl }, writer.uint32(34).fork()).ldelim();
        }
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(42).fork()).ldelim();
        }
        if (message.hlsUrl !== undefined) {
            StringValue.encode({ value: message.hlsUrl }, writer.uint32(50).fork()).ldelim();
        }
        if (message.isGif !== undefined) {
            BoolValue.encode({ value: message.isGif }, writer.uint32(58).fork()).ldelim();
        }
        if (message.scrubberMediaUrl !== undefined) {
            StringValue.encode({ value: message.scrubberMediaUrl }, writer.uint32(66).fork()).ldelim();
        }
        if (message.transcodingStatus !== undefined) {
            StringValue.encode({ value: message.transcodingStatus }, writer.uint32(74).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedditObject_RedditVideo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bitrateKbps = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.dashUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.duration = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.fallbackUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.hlsUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.isGif = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.scrubberMediaUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.transcodingStatus = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bitrateKbps: isSet(object.bitrateKbps) ? Number(object.bitrateKbps) : undefined,
            dashUrl: isSet(object.dashUrl) ? String(object.dashUrl) : undefined,
            duration: isSet(object.duration) ? Number(object.duration) : undefined,
            fallbackUrl: isSet(object.fallbackUrl) ? String(object.fallbackUrl) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
            hlsUrl: isSet(object.hlsUrl) ? String(object.hlsUrl) : undefined,
            isGif: isSet(object.isGif) ? Boolean(object.isGif) : undefined,
            scrubberMediaUrl: isSet(object.scrubberMediaUrl) ? String(object.scrubberMediaUrl) : undefined,
            transcodingStatus: isSet(object.transcodingStatus) ? String(object.transcodingStatus) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.bitrateKbps !== undefined && (obj.bitrateKbps = message.bitrateKbps);
        message.dashUrl !== undefined && (obj.dashUrl = message.dashUrl);
        message.duration !== undefined && (obj.duration = message.duration);
        message.fallbackUrl !== undefined && (obj.fallbackUrl = message.fallbackUrl);
        message.height !== undefined && (obj.height = message.height);
        message.hlsUrl !== undefined && (obj.hlsUrl = message.hlsUrl);
        message.isGif !== undefined && (obj.isGif = message.isGif);
        message.scrubberMediaUrl !== undefined && (obj.scrubberMediaUrl = message.scrubberMediaUrl);
        message.transcodingStatus !== undefined && (obj.transcodingStatus = message.transcodingStatus);
        message.width !== undefined && (obj.width = message.width);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedditObject_RedditVideo();
        message.bitrateKbps = object.bitrateKbps ?? undefined;
        message.dashUrl = object.dashUrl ?? undefined;
        message.duration = object.duration ?? undefined;
        message.fallbackUrl = object.fallbackUrl ?? undefined;
        message.height = object.height ?? undefined;
        message.hlsUrl = object.hlsUrl ?? undefined;
        message.isGif = object.isGif ?? undefined;
        message.scrubberMediaUrl = object.scrubberMediaUrl ?? undefined;
        message.transcodingStatus = object.transcodingStatus ?? undefined;
        message.width = object.width ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.RedditObject.RedditVideo", RedditObject_RedditVideo);
function createBaseRedditObject_AuthorFlairRichText() {
    return { e: undefined, t: undefined, a: undefined, u: undefined };
}
export const RedditObject_AuthorFlairRichText = {
    $type: "devvit.plugin.redditapi.common.RedditObject.AuthorFlairRichText",
    encode(message, writer = _m0.Writer.create()) {
        if (message.e !== undefined) {
            StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
        }
        if (message.t !== undefined) {
            StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
        }
        if (message.a !== undefined) {
            StringValue.encode({ value: message.a }, writer.uint32(26).fork()).ldelim();
        }
        if (message.u !== undefined) {
            StringValue.encode({ value: message.u }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedditObject_AuthorFlairRichText();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.e = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.t = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.a = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.u = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            e: isSet(object.e) ? String(object.e) : undefined,
            t: isSet(object.t) ? String(object.t) : undefined,
            a: isSet(object.a) ? String(object.a) : undefined,
            u: isSet(object.u) ? String(object.u) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.e !== undefined && (obj.e = message.e);
        message.t !== undefined && (obj.t = message.t);
        message.a !== undefined && (obj.a = message.a);
        message.u !== undefined && (obj.u = message.u);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedditObject_AuthorFlairRichText();
        message.e = object.e ?? undefined;
        message.t = object.t ?? undefined;
        message.a = object.a ?? undefined;
        message.u = object.u ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.RedditObject.AuthorFlairRichText", RedditObject_AuthorFlairRichText);
function createBaseRedditObject_LinkFlairRichText() {
    return { e: undefined, t: undefined, a: undefined, u: undefined };
}
export const RedditObject_LinkFlairRichText = {
    $type: "devvit.plugin.redditapi.common.RedditObject.LinkFlairRichText",
    encode(message, writer = _m0.Writer.create()) {
        if (message.e !== undefined) {
            StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
        }
        if (message.t !== undefined) {
            StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
        }
        if (message.a !== undefined) {
            StringValue.encode({ value: message.a }, writer.uint32(26).fork()).ldelim();
        }
        if (message.u !== undefined) {
            StringValue.encode({ value: message.u }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedditObject_LinkFlairRichText();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.e = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.t = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.a = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.u = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            e: isSet(object.e) ? String(object.e) : undefined,
            t: isSet(object.t) ? String(object.t) : undefined,
            a: isSet(object.a) ? String(object.a) : undefined,
            u: isSet(object.u) ? String(object.u) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.e !== undefined && (obj.e = message.e);
        message.t !== undefined && (obj.t = message.t);
        message.a !== undefined && (obj.a = message.a);
        message.u !== undefined && (obj.u = message.u);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedditObject_LinkFlairRichText();
        message.e = object.e ?? undefined;
        message.t = object.t ?? undefined;
        message.a = object.a ?? undefined;
        message.u = object.u ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.RedditObject.LinkFlairRichText", RedditObject_LinkFlairRichText);
function createBaseRedditObject_SecureMedia() {
    return { type: "", oembed: undefined, redditVideo: undefined };
}
export const RedditObject_SecureMedia = {
    $type: "devvit.plugin.redditapi.common.RedditObject.SecureMedia",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.oembed !== undefined) {
            RedditObject_OEmbed.encode(message.oembed, writer.uint32(18).fork()).ldelim();
        }
        if (message.redditVideo !== undefined) {
            RedditObject_RedditVideo.encode(message.redditVideo, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedditObject_SecureMedia();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.oembed = RedditObject_OEmbed.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.redditVideo = RedditObject_RedditVideo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? String(object.type) : "",
            oembed: isSet(object.oembed) ? RedditObject_OEmbed.fromJSON(object.oembed) : undefined,
            redditVideo: isSet(object.redditVideo) ? RedditObject_RedditVideo.fromJSON(object.redditVideo) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type);
        message.oembed !== undefined &&
            (obj.oembed = message.oembed ? RedditObject_OEmbed.toJSON(message.oembed) : undefined);
        message.redditVideo !== undefined &&
            (obj.redditVideo = message.redditVideo ? RedditObject_RedditVideo.toJSON(message.redditVideo) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedditObject_SecureMedia();
        message.type = object.type ?? "";
        message.oembed = (object.oembed !== undefined && object.oembed !== null)
            ? RedditObject_OEmbed.fromPartial(object.oembed)
            : undefined;
        message.redditVideo = (object.redditVideo !== undefined && object.redditVideo !== null)
            ? RedditObject_RedditVideo.fromPartial(object.redditVideo)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.RedditObject.SecureMedia", RedditObject_SecureMedia);
function createBaseSubredditObject() {
    return {
        defaultSet: undefined,
        userIsContributor: undefined,
        bannerImg: undefined,
        restrictPosting: undefined,
        userIsBanned: undefined,
        freeFormReports: undefined,
        communityIcon: undefined,
        showMedia: undefined,
        iconColor: undefined,
        displayName: undefined,
        headerImg: undefined,
        title: undefined,
        coins: undefined,
        previousNames: [],
        over18: undefined,
        iconSize: [],
        primaryColor: undefined,
        iconImg: undefined,
        description: undefined,
        submitLinkLabel: undefined,
        headerSize: undefined,
        restrictCommenting: undefined,
        subscribers: undefined,
        submitTextLabel: undefined,
        isDefaultIcon: undefined,
        linkFlairPosition: undefined,
        displayNamePrefixed: undefined,
        keyColor: undefined,
        name: undefined,
        isDefaultBanner: undefined,
        url: undefined,
        quarantine: undefined,
        bannerSize: [],
        userIsModerator: undefined,
        acceptFollowers: undefined,
        publicDescription: undefined,
        linkFlairEnabled: undefined,
        disableContributorRequests: undefined,
        subredditType: undefined,
        userIsSubscriber: undefined,
        publicDescriptionHtml: undefined,
        id: undefined,
        userIsMuted: false,
    };
}
export const SubredditObject = {
    $type: "devvit.plugin.redditapi.common.SubredditObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.defaultSet !== undefined) {
            BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
        }
        if (message.userIsContributor !== undefined) {
            BoolValue.encode({ value: message.userIsContributor }, writer.uint32(18).fork()).ldelim();
        }
        if (message.bannerImg !== undefined) {
            StringValue.encode({ value: message.bannerImg }, writer.uint32(26).fork()).ldelim();
        }
        if (message.restrictPosting !== undefined) {
            BoolValue.encode({ value: message.restrictPosting }, writer.uint32(34).fork()).ldelim();
        }
        if (message.userIsBanned !== undefined) {
            BoolValue.encode({ value: message.userIsBanned }, writer.uint32(42).fork()).ldelim();
        }
        if (message.freeFormReports !== undefined) {
            BoolValue.encode({ value: message.freeFormReports }, writer.uint32(50).fork()).ldelim();
        }
        if (message.communityIcon !== undefined) {
            StringValue.encode({ value: message.communityIcon }, writer.uint32(58).fork()).ldelim();
        }
        if (message.showMedia !== undefined) {
            BoolValue.encode({ value: message.showMedia }, writer.uint32(66).fork()).ldelim();
        }
        if (message.iconColor !== undefined) {
            StringValue.encode({ value: message.iconColor }, writer.uint32(74).fork()).ldelim();
        }
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(90).fork()).ldelim();
        }
        if (message.headerImg !== undefined) {
            StringValue.encode({ value: message.headerImg }, writer.uint32(98).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(106).fork()).ldelim();
        }
        if (message.coins !== undefined) {
            Int64Value.encode({ value: message.coins }, writer.uint32(114).fork()).ldelim();
        }
        for (const v of message.previousNames) {
            StringValue.encode({ value: v }, writer.uint32(122).fork()).ldelim();
        }
        if (message.over18 !== undefined) {
            BoolValue.encode({ value: message.over18 }, writer.uint32(130).fork()).ldelim();
        }
        for (const v of message.iconSize) {
            Int32Value.encode({ value: v }, writer.uint32(138).fork()).ldelim();
        }
        if (message.primaryColor !== undefined) {
            StringValue.encode({ value: message.primaryColor }, writer.uint32(146).fork()).ldelim();
        }
        if (message.iconImg !== undefined) {
            StringValue.encode({ value: message.iconImg }, writer.uint32(154).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(162).fork()).ldelim();
        }
        if (message.submitLinkLabel !== undefined) {
            StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(170).fork()).ldelim();
        }
        if (message.headerSize !== undefined) {
            StringValue.encode({ value: message.headerSize }, writer.uint32(178).fork()).ldelim();
        }
        if (message.restrictCommenting !== undefined) {
            BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(186).fork()).ldelim();
        }
        if (message.subscribers !== undefined) {
            Int64Value.encode({ value: message.subscribers }, writer.uint32(194).fork()).ldelim();
        }
        if (message.submitTextLabel !== undefined) {
            StringValue.encode({ value: message.submitTextLabel }, writer.uint32(202).fork()).ldelim();
        }
        if (message.isDefaultIcon !== undefined) {
            BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(210).fork()).ldelim();
        }
        if (message.linkFlairPosition !== undefined) {
            StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(218).fork()).ldelim();
        }
        if (message.displayNamePrefixed !== undefined) {
            StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(226).fork()).ldelim();
        }
        if (message.keyColor !== undefined) {
            StringValue.encode({ value: message.keyColor }, writer.uint32(234).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(242).fork()).ldelim();
        }
        if (message.isDefaultBanner !== undefined) {
            BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(250).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(258).fork()).ldelim();
        }
        if (message.quarantine !== undefined) {
            BoolValue.encode({ value: message.quarantine }, writer.uint32(266).fork()).ldelim();
        }
        for (const v of message.bannerSize) {
            Int32Value.encode({ value: v }, writer.uint32(274).fork()).ldelim();
        }
        if (message.userIsModerator !== undefined) {
            BoolValue.encode({ value: message.userIsModerator }, writer.uint32(282).fork()).ldelim();
        }
        if (message.acceptFollowers !== undefined) {
            BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(290).fork()).ldelim();
        }
        if (message.publicDescription !== undefined) {
            StringValue.encode({ value: message.publicDescription }, writer.uint32(298).fork()).ldelim();
        }
        if (message.linkFlairEnabled !== undefined) {
            BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(306).fork()).ldelim();
        }
        if (message.disableContributorRequests !== undefined) {
            BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(314).fork()).ldelim();
        }
        if (message.subredditType !== undefined) {
            StringValue.encode({ value: message.subredditType }, writer.uint32(322).fork()).ldelim();
        }
        if (message.userIsSubscriber !== undefined) {
            BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(330).fork()).ldelim();
        }
        if (message.publicDescriptionHtml !== undefined) {
            StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(338).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(346).fork()).ldelim();
        }
        if (message.userIsMuted === true) {
            writer.uint32(352).bool(message.userIsMuted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.iconColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.headerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.coins = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 16:
                    message.over18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
                    break;
                case 18:
                    message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.iconImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.headerSize = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 26:
                    message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 27:
                    message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 28:
                    message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 29:
                    message.keyColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 30:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 31:
                    message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 32:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 33:
                    message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 34:
                    message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
                    break;
                case 35:
                    message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 36:
                    message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 37:
                    message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 38:
                    message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 39:
                    message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 40:
                    message.subredditType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 41:
                    message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 42:
                    message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 43:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 44:
                    message.userIsMuted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultSet: isSet(object.defaultSet) ? Boolean(object.defaultSet) : undefined,
            userIsContributor: isSet(object.userIsContributor) ? Boolean(object.userIsContributor) : undefined,
            bannerImg: isSet(object.bannerImg) ? String(object.bannerImg) : undefined,
            restrictPosting: isSet(object.restrictPosting) ? Boolean(object.restrictPosting) : undefined,
            userIsBanned: isSet(object.userIsBanned) ? Boolean(object.userIsBanned) : undefined,
            freeFormReports: isSet(object.freeFormReports) ? Boolean(object.freeFormReports) : undefined,
            communityIcon: isSet(object.communityIcon) ? String(object.communityIcon) : undefined,
            showMedia: isSet(object.showMedia) ? Boolean(object.showMedia) : undefined,
            iconColor: isSet(object.iconColor) ? String(object.iconColor) : undefined,
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            headerImg: isSet(object.headerImg) ? String(object.headerImg) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            coins: isSet(object.coins) ? Number(object.coins) : undefined,
            previousNames: Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
            over18: isSet(object.over18) ? Boolean(object.over18) : undefined,
            iconSize: Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
            primaryColor: isSet(object.primaryColor) ? String(object.primaryColor) : undefined,
            iconImg: isSet(object.iconImg) ? String(object.iconImg) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            submitLinkLabel: isSet(object.submitLinkLabel) ? String(object.submitLinkLabel) : undefined,
            headerSize: isSet(object.headerSize) ? String(object.headerSize) : undefined,
            restrictCommenting: isSet(object.restrictCommenting) ? Boolean(object.restrictCommenting) : undefined,
            subscribers: isSet(object.subscribers) ? Number(object.subscribers) : undefined,
            submitTextLabel: isSet(object.submitTextLabel) ? String(object.submitTextLabel) : undefined,
            isDefaultIcon: isSet(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : undefined,
            linkFlairPosition: isSet(object.linkFlairPosition) ? String(object.linkFlairPosition) : undefined,
            displayNamePrefixed: isSet(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : undefined,
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            isDefaultBanner: isSet(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            quarantine: isSet(object.quarantine) ? Boolean(object.quarantine) : undefined,
            bannerSize: Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
            userIsModerator: isSet(object.userIsModerator) ? Boolean(object.userIsModerator) : undefined,
            acceptFollowers: isSet(object.acceptFollowers) ? Boolean(object.acceptFollowers) : undefined,
            publicDescription: isSet(object.publicDescription) ? String(object.publicDescription) : undefined,
            linkFlairEnabled: isSet(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : undefined,
            disableContributorRequests: isSet(object.disableContributorRequests)
                ? Boolean(object.disableContributorRequests)
                : undefined,
            subredditType: isSet(object.subredditType) ? String(object.subredditType) : undefined,
            userIsSubscriber: isSet(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : undefined,
            publicDescriptionHtml: isSet(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            userIsMuted: isSet(object.userIsMuted) ? Boolean(object.userIsMuted) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.defaultSet !== undefined && (obj.defaultSet = message.defaultSet);
        message.userIsContributor !== undefined && (obj.userIsContributor = message.userIsContributor);
        message.bannerImg !== undefined && (obj.bannerImg = message.bannerImg);
        message.restrictPosting !== undefined && (obj.restrictPosting = message.restrictPosting);
        message.userIsBanned !== undefined && (obj.userIsBanned = message.userIsBanned);
        message.freeFormReports !== undefined && (obj.freeFormReports = message.freeFormReports);
        message.communityIcon !== undefined && (obj.communityIcon = message.communityIcon);
        message.showMedia !== undefined && (obj.showMedia = message.showMedia);
        message.iconColor !== undefined && (obj.iconColor = message.iconColor);
        message.displayName !== undefined && (obj.displayName = message.displayName);
        message.headerImg !== undefined && (obj.headerImg = message.headerImg);
        message.title !== undefined && (obj.title = message.title);
        message.coins !== undefined && (obj.coins = message.coins);
        if (message.previousNames) {
            obj.previousNames = message.previousNames.map((e) => e);
        }
        else {
            obj.previousNames = [];
        }
        message.over18 !== undefined && (obj.over18 = message.over18);
        if (message.iconSize) {
            obj.iconSize = message.iconSize.map((e) => e);
        }
        else {
            obj.iconSize = [];
        }
        message.primaryColor !== undefined && (obj.primaryColor = message.primaryColor);
        message.iconImg !== undefined && (obj.iconImg = message.iconImg);
        message.description !== undefined && (obj.description = message.description);
        message.submitLinkLabel !== undefined && (obj.submitLinkLabel = message.submitLinkLabel);
        message.headerSize !== undefined && (obj.headerSize = message.headerSize);
        message.restrictCommenting !== undefined && (obj.restrictCommenting = message.restrictCommenting);
        message.subscribers !== undefined && (obj.subscribers = message.subscribers);
        message.submitTextLabel !== undefined && (obj.submitTextLabel = message.submitTextLabel);
        message.isDefaultIcon !== undefined && (obj.isDefaultIcon = message.isDefaultIcon);
        message.linkFlairPosition !== undefined && (obj.linkFlairPosition = message.linkFlairPosition);
        message.displayNamePrefixed !== undefined && (obj.displayNamePrefixed = message.displayNamePrefixed);
        message.keyColor !== undefined && (obj.keyColor = message.keyColor);
        message.name !== undefined && (obj.name = message.name);
        message.isDefaultBanner !== undefined && (obj.isDefaultBanner = message.isDefaultBanner);
        message.url !== undefined && (obj.url = message.url);
        message.quarantine !== undefined && (obj.quarantine = message.quarantine);
        if (message.bannerSize) {
            obj.bannerSize = message.bannerSize.map((e) => e);
        }
        else {
            obj.bannerSize = [];
        }
        message.userIsModerator !== undefined && (obj.userIsModerator = message.userIsModerator);
        message.acceptFollowers !== undefined && (obj.acceptFollowers = message.acceptFollowers);
        message.publicDescription !== undefined && (obj.publicDescription = message.publicDescription);
        message.linkFlairEnabled !== undefined && (obj.linkFlairEnabled = message.linkFlairEnabled);
        message.disableContributorRequests !== undefined &&
            (obj.disableContributorRequests = message.disableContributorRequests);
        message.subredditType !== undefined && (obj.subredditType = message.subredditType);
        message.userIsSubscriber !== undefined && (obj.userIsSubscriber = message.userIsSubscriber);
        message.publicDescriptionHtml !== undefined && (obj.publicDescriptionHtml = message.publicDescriptionHtml);
        message.id !== undefined && (obj.id = message.id);
        message.userIsMuted !== undefined && (obj.userIsMuted = message.userIsMuted);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditObject();
        message.defaultSet = object.defaultSet ?? undefined;
        message.userIsContributor = object.userIsContributor ?? undefined;
        message.bannerImg = object.bannerImg ?? undefined;
        message.restrictPosting = object.restrictPosting ?? undefined;
        message.userIsBanned = object.userIsBanned ?? undefined;
        message.freeFormReports = object.freeFormReports ?? undefined;
        message.communityIcon = object.communityIcon ?? undefined;
        message.showMedia = object.showMedia ?? undefined;
        message.iconColor = object.iconColor ?? undefined;
        message.displayName = object.displayName ?? undefined;
        message.headerImg = object.headerImg ?? undefined;
        message.title = object.title ?? undefined;
        message.coins = object.coins ?? undefined;
        message.previousNames = object.previousNames?.map((e) => e) || [];
        message.over18 = object.over18 ?? undefined;
        message.iconSize = object.iconSize?.map((e) => e) || [];
        message.primaryColor = object.primaryColor ?? undefined;
        message.iconImg = object.iconImg ?? undefined;
        message.description = object.description ?? undefined;
        message.submitLinkLabel = object.submitLinkLabel ?? undefined;
        message.headerSize = object.headerSize ?? undefined;
        message.restrictCommenting = object.restrictCommenting ?? undefined;
        message.subscribers = object.subscribers ?? undefined;
        message.submitTextLabel = object.submitTextLabel ?? undefined;
        message.isDefaultIcon = object.isDefaultIcon ?? undefined;
        message.linkFlairPosition = object.linkFlairPosition ?? undefined;
        message.displayNamePrefixed = object.displayNamePrefixed ?? undefined;
        message.keyColor = object.keyColor ?? undefined;
        message.name = object.name ?? undefined;
        message.isDefaultBanner = object.isDefaultBanner ?? undefined;
        message.url = object.url ?? undefined;
        message.quarantine = object.quarantine ?? undefined;
        message.bannerSize = object.bannerSize?.map((e) => e) || [];
        message.userIsModerator = object.userIsModerator ?? undefined;
        message.acceptFollowers = object.acceptFollowers ?? undefined;
        message.publicDescription = object.publicDescription ?? undefined;
        message.linkFlairEnabled = object.linkFlairEnabled ?? undefined;
        message.disableContributorRequests = object.disableContributorRequests ?? undefined;
        message.subredditType = object.subredditType ?? undefined;
        message.userIsSubscriber = object.userIsSubscriber ?? undefined;
        message.publicDescriptionHtml = object.publicDescriptionHtml ?? undefined;
        message.id = object.id ?? undefined;
        message.userIsMuted = object.userIsMuted ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.SubredditObject", SubredditObject);
function createBaseJsonStatus() {
    return { json: undefined };
}
export const JsonStatus = {
    $type: "devvit.plugin.redditapi.common.JsonStatus",
    encode(message, writer = _m0.Writer.create()) {
        if (message.json !== undefined) {
            JsonStatus_JsonErrorType.encode(message.json, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 4:
                    message.json = JsonStatus_JsonErrorType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { json: isSet(object.json) ? JsonStatus_JsonErrorType.fromJSON(object.json) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.json !== undefined && (obj.json = message.json ? JsonStatus_JsonErrorType.toJSON(message.json) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseJsonStatus();
        message.json = (object.json !== undefined && object.json !== null)
            ? JsonStatus_JsonErrorType.fromPartial(object.json)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonStatus", JsonStatus);
function createBaseJsonStatus_JsonErrorType() {
    return { errors: [] };
}
export const JsonStatus_JsonErrorType = {
    $type: "devvit.plugin.redditapi.common.JsonStatus.JsonErrorType",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.errors) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonStatus_JsonErrorType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.errors.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { errors: Array.isArray(object?.errors) ? object.errors.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.errors) {
            obj.errors = message.errors.map((e) => e);
        }
        else {
            obj.errors = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseJsonStatus_JsonErrorType();
        message.errors = object.errors?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonStatus.JsonErrorType", JsonStatus_JsonErrorType);
function createBaseWrappedUserObject() {
    return { id: undefined, data: undefined };
}
export const WrappedUserObject = {
    $type: "devvit.plugin.redditapi.common.WrappedUserObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            User.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWrappedUserObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = User.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : undefined,
            data: isSet(object.data) ? User.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.data !== undefined && (obj.data = message.data ? User.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWrappedUserObject();
        message.id = object.id ?? undefined;
        message.data = (object.data !== undefined && object.data !== null) ? User.fromPartial(object.data) : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.WrappedUserObject", WrappedUserObject);
function isSet(value) {
    return value !== null && value !== undefined;
}
