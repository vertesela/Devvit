/**
 * #newmodmail_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Any } from '../../../../google/protobuf/any.js';
import { BoolValue, Int32Value, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
function createBaseConversationData() {
    return {
        isAuto: undefined,
        participant: undefined,
        objIds: [],
        isRepliable: undefined,
        lastUserUpdate: undefined,
        isInternal: undefined,
        lastModUpdate: undefined,
        authors: [],
        lastUpdated: undefined,
        legacyFirstMessageId: undefined,
        state: undefined,
        conversationType: undefined,
        lastUnread: undefined,
        owner: undefined,
        subject: undefined,
        id: undefined,
        isHighlighted: undefined,
        numMessages: undefined,
        modActions: {},
    };
}
export const ConversationData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isAuto !== undefined) {
            BoolValue.encode({ value: message.isAuto }, writer.uint32(10).fork()).ldelim();
        }
        if (message.participant !== undefined) {
            Participant.encode(message.participant, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.objIds) {
            ConversationData_ObjId.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.isRepliable !== undefined) {
            BoolValue.encode({ value: message.isRepliable }, writer.uint32(34).fork()).ldelim();
        }
        if (message.lastUserUpdate !== undefined) {
            StringValue.encode({ value: message.lastUserUpdate }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isInternal !== undefined) {
            BoolValue.encode({ value: message.isInternal }, writer.uint32(50).fork()).ldelim();
        }
        if (message.lastModUpdate !== undefined) {
            StringValue.encode({ value: message.lastModUpdate }, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.authors) {
            Participant.encode(v, writer.uint32(66).fork()).ldelim();
        }
        if (message.lastUpdated !== undefined) {
            StringValue.encode({ value: message.lastUpdated }, writer.uint32(74).fork()).ldelim();
        }
        if (message.legacyFirstMessageId !== undefined) {
            StringValue.encode({ value: message.legacyFirstMessageId }, writer.uint32(82).fork()).ldelim();
        }
        if (message.state !== undefined) {
            Int32Value.encode({ value: message.state }, writer.uint32(90).fork()).ldelim();
        }
        if (message.conversationType !== undefined) {
            StringValue.encode({ value: message.conversationType }, writer.uint32(98).fork()).ldelim();
        }
        if (message.lastUnread !== undefined) {
            StringValue.encode({ value: message.lastUnread }, writer.uint32(106).fork()).ldelim();
        }
        if (message.owner !== undefined) {
            ConversationData_Owner.encode(message.owner, writer.uint32(114).fork()).ldelim();
        }
        if (message.subject !== undefined) {
            StringValue.encode({ value: message.subject }, writer.uint32(122).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(130).fork()).ldelim();
        }
        if (message.isHighlighted !== undefined) {
            BoolValue.encode({ value: message.isHighlighted }, writer.uint32(138).fork()).ldelim();
        }
        if (message.numMessages !== undefined) {
            Int64Value.encode({ value: message.numMessages }, writer.uint32(146).fork()).ldelim();
        }
        Object.entries(message.modActions).forEach(([key, value]) => {
            ConversationData_ModActionsEntry.encode({ key: key, value }, writer.uint32(154).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isAuto = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.participant = Participant.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.objIds.push(ConversationData_ObjId.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.isRepliable = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.lastUserUpdate = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.isInternal = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.lastModUpdate = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.authors.push(Participant.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.lastUpdated = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.legacyFirstMessageId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.state = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.conversationType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.lastUnread = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.owner = ConversationData_Owner.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.subject = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.isHighlighted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.numMessages = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    const entry19 = ConversationData_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry19.value !== undefined) {
                        message.modActions[entry19.key] = entry19.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isAuto: isSet(object.isAuto) ? Boolean(object.isAuto) : undefined,
            participant: isSet(object.participant) ? Participant.fromJSON(object.participant) : undefined,
            objIds: Array.isArray(object?.objIds) ? object.objIds.map((e) => ConversationData_ObjId.fromJSON(e)) : [],
            isRepliable: isSet(object.isRepliable) ? Boolean(object.isRepliable) : undefined,
            lastUserUpdate: isSet(object.lastUserUpdate) ? String(object.lastUserUpdate) : undefined,
            isInternal: isSet(object.isInternal) ? Boolean(object.isInternal) : undefined,
            lastModUpdate: isSet(object.lastModUpdate) ? String(object.lastModUpdate) : undefined,
            authors: Array.isArray(object?.authors) ? object.authors.map((e) => Participant.fromJSON(e)) : [],
            lastUpdated: isSet(object.lastUpdated) ? String(object.lastUpdated) : undefined,
            legacyFirstMessageId: isSet(object.legacyFirstMessageId) ? String(object.legacyFirstMessageId) : undefined,
            state: isSet(object.state) ? Number(object.state) : undefined,
            conversationType: isSet(object.conversationType) ? String(object.conversationType) : undefined,
            lastUnread: isSet(object.lastUnread) ? String(object.lastUnread) : undefined,
            owner: isSet(object.owner) ? ConversationData_Owner.fromJSON(object.owner) : undefined,
            subject: isSet(object.subject) ? String(object.subject) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            isHighlighted: isSet(object.isHighlighted) ? Boolean(object.isHighlighted) : undefined,
            numMessages: isSet(object.numMessages) ? Number(object.numMessages) : undefined,
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.isAuto !== undefined && (obj.isAuto = message.isAuto);
        message.participant !== undefined &&
            (obj.participant = message.participant ? Participant.toJSON(message.participant) : undefined);
        if (message.objIds) {
            obj.objIds = message.objIds.map((e) => e ? ConversationData_ObjId.toJSON(e) : undefined);
        }
        else {
            obj.objIds = [];
        }
        message.isRepliable !== undefined && (obj.isRepliable = message.isRepliable);
        message.lastUserUpdate !== undefined && (obj.lastUserUpdate = message.lastUserUpdate);
        message.isInternal !== undefined && (obj.isInternal = message.isInternal);
        message.lastModUpdate !== undefined && (obj.lastModUpdate = message.lastModUpdate);
        if (message.authors) {
            obj.authors = message.authors.map((e) => e ? Participant.toJSON(e) : undefined);
        }
        else {
            obj.authors = [];
        }
        message.lastUpdated !== undefined && (obj.lastUpdated = message.lastUpdated);
        message.legacyFirstMessageId !== undefined && (obj.legacyFirstMessageId = message.legacyFirstMessageId);
        message.state !== undefined && (obj.state = message.state);
        message.conversationType !== undefined && (obj.conversationType = message.conversationType);
        message.lastUnread !== undefined && (obj.lastUnread = message.lastUnread);
        message.owner !== undefined &&
            (obj.owner = message.owner ? ConversationData_Owner.toJSON(message.owner) : undefined);
        message.subject !== undefined && (obj.subject = message.subject);
        message.id !== undefined && (obj.id = message.id);
        message.isHighlighted !== undefined && (obj.isHighlighted = message.isHighlighted);
        message.numMessages !== undefined && (obj.numMessages = message.numMessages);
        obj.modActions = {};
        if (message.modActions) {
            Object.entries(message.modActions).forEach(([k, v]) => {
                obj.modActions[k] = ModActionData.toJSON(v);
            });
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationData();
        message.isAuto = object.isAuto ?? undefined;
        message.participant = (object.participant !== undefined && object.participant !== null)
            ? Participant.fromPartial(object.participant)
            : undefined;
        message.objIds = object.objIds?.map((e) => ConversationData_ObjId.fromPartial(e)) || [];
        message.isRepliable = object.isRepliable ?? undefined;
        message.lastUserUpdate = object.lastUserUpdate ?? undefined;
        message.isInternal = object.isInternal ?? undefined;
        message.lastModUpdate = object.lastModUpdate ?? undefined;
        message.authors = object.authors?.map((e) => Participant.fromPartial(e)) || [];
        message.lastUpdated = object.lastUpdated ?? undefined;
        message.legacyFirstMessageId = object.legacyFirstMessageId ?? undefined;
        message.state = object.state ?? undefined;
        message.conversationType = object.conversationType ?? undefined;
        message.lastUnread = object.lastUnread ?? undefined;
        message.owner = (object.owner !== undefined && object.owner !== null)
            ? ConversationData_Owner.fromPartial(object.owner)
            : undefined;
        message.subject = object.subject ?? undefined;
        message.id = object.id ?? undefined;
        message.isHighlighted = object.isHighlighted ?? undefined;
        message.numMessages = object.numMessages ?? undefined;
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationData", ConversationData);
function createBaseConversationData_ObjId() {
    return { id: undefined, key: undefined };
}
export const ConversationData_ObjId = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ObjId",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
        }
        if (message.key !== undefined) {
            StringValue.encode({ value: message.key }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationData_ObjId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.key = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : undefined,
            key: isSet(object.key) ? String(object.key) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.key !== undefined && (obj.key = message.key);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationData_ObjId();
        message.id = object.id ?? undefined;
        message.key = object.key ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationData.ObjId", ConversationData_ObjId);
function createBaseConversationData_Owner() {
    return { displayName: undefined, type: undefined, id: undefined };
}
export const ConversationData_Owner = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData.Owner",
    encode(message, writer = _m0.Writer.create()) {
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(10).fork()).ldelim();
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(18).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationData_Owner();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            type: isSet(object.type) ? String(object.type) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.displayName !== undefined && (obj.displayName = message.displayName);
        message.type !== undefined && (obj.type = message.type);
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationData_Owner();
        message.displayName = object.displayName ?? undefined;
        message.type = object.type ?? undefined;
        message.id = object.id ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationData.Owner", ConversationData_Owner);
function createBaseConversationData_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const ConversationData_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationData_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ModActionData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? ModActionData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationData_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationData.ModActionsEntry", ConversationData_ModActionsEntry);
function createBaseMessageData() {
    return {
        body: undefined,
        author: undefined,
        isInternal: undefined,
        date: undefined,
        bodyMarkdown: undefined,
        id: undefined,
        participatingAs: undefined,
    };
}
export const MessageData = {
    $type: "devvit.plugin.redditapi.newmodmail.MessageData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.body !== undefined) {
            StringValue.encode({ value: message.body }, writer.uint32(10).fork()).ldelim();
        }
        if (message.author !== undefined) {
            Participant.encode(message.author, writer.uint32(18).fork()).ldelim();
        }
        if (message.isInternal !== undefined) {
            BoolValue.encode({ value: message.isInternal }, writer.uint32(26).fork()).ldelim();
        }
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(34).fork()).ldelim();
        }
        if (message.bodyMarkdown !== undefined) {
            StringValue.encode({ value: message.bodyMarkdown }, writer.uint32(42).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(50).fork()).ldelim();
        }
        if (message.participatingAs !== undefined) {
            StringValue.encode({ value: message.participatingAs }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.body = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.author = Participant.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.isInternal = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.bodyMarkdown = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.participatingAs = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            body: isSet(object.body) ? String(object.body) : undefined,
            author: isSet(object.author) ? Participant.fromJSON(object.author) : undefined,
            isInternal: isSet(object.isInternal) ? Boolean(object.isInternal) : undefined,
            date: isSet(object.date) ? String(object.date) : undefined,
            bodyMarkdown: isSet(object.bodyMarkdown) ? String(object.bodyMarkdown) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            participatingAs: isSet(object.participatingAs) ? String(object.participatingAs) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.body !== undefined && (obj.body = message.body);
        message.author !== undefined && (obj.author = message.author ? Participant.toJSON(message.author) : undefined);
        message.isInternal !== undefined && (obj.isInternal = message.isInternal);
        message.date !== undefined && (obj.date = message.date);
        message.bodyMarkdown !== undefined && (obj.bodyMarkdown = message.bodyMarkdown);
        message.id !== undefined && (obj.id = message.id);
        message.participatingAs !== undefined && (obj.participatingAs = message.participatingAs);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMessageData();
        message.body = object.body ?? undefined;
        message.author = (object.author !== undefined && object.author !== null)
            ? Participant.fromPartial(object.author)
            : undefined;
        message.isInternal = object.isInternal ?? undefined;
        message.date = object.date ?? undefined;
        message.bodyMarkdown = object.bodyMarkdown ?? undefined;
        message.id = object.id ?? undefined;
        message.participatingAs = object.participatingAs ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MessageData", MessageData);
function createBaseConversationUserData() {
    return {
        recentComments: {},
        muteStatus: undefined,
        name: undefined,
        created: undefined,
        banStatus: undefined,
        isSuspended: undefined,
        approveStatus: undefined,
        isShadowBanned: undefined,
        recentPosts: {},
        recentConvos: {},
        id: undefined,
    };
}
export const ConversationUserData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.recentComments).forEach(([key, value]) => {
            ConversationUserData_RecentCommentsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        if (message.muteStatus !== undefined) {
            ConversationUserData_MuteStatus.encode(message.muteStatus, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
        }
        if (message.created !== undefined) {
            StringValue.encode({ value: message.created }, writer.uint32(34).fork()).ldelim();
        }
        if (message.banStatus !== undefined) {
            ConversationUserData_BanStatus.encode(message.banStatus, writer.uint32(42).fork()).ldelim();
        }
        if (message.isSuspended !== undefined) {
            BoolValue.encode({ value: message.isSuspended }, writer.uint32(50).fork()).ldelim();
        }
        if (message.approveStatus !== undefined) {
            ConversationUserData_ApproveStatus.encode(message.approveStatus, writer.uint32(58).fork()).ldelim();
        }
        if (message.isShadowBanned !== undefined) {
            BoolValue.encode({ value: message.isShadowBanned }, writer.uint32(66).fork()).ldelim();
        }
        Object.entries(message.recentPosts).forEach(([key, value]) => {
            ConversationUserData_RecentPostsEntry.encode({ key: key, value }, writer.uint32(74).fork()).ldelim();
        });
        Object.entries(message.recentConvos).forEach(([key, value]) => {
            ConversationUserData_RecentConvosEntry.encode({ key: key, value }, writer.uint32(82).fork()).ldelim();
        });
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = ConversationUserData_RecentCommentsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.recentComments[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    message.muteStatus = ConversationUserData_MuteStatus.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.created = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.banStatus = ConversationUserData_BanStatus.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.isSuspended = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.approveStatus = ConversationUserData_ApproveStatus.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.isShadowBanned = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    const entry9 = ConversationUserData_RecentPostsEntry.decode(reader, reader.uint32());
                    if (entry9.value !== undefined) {
                        message.recentPosts[entry9.key] = entry9.value;
                    }
                    break;
                case 10:
                    const entry10 = ConversationUserData_RecentConvosEntry.decode(reader, reader.uint32());
                    if (entry10.value !== undefined) {
                        message.recentConvos[entry10.key] = entry10.value;
                    }
                    break;
                case 11:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            recentComments: isObject(object.recentComments)
                ? Object.entries(object.recentComments).reduce((acc, [key, value]) => {
                    acc[key] = ConversationUserData_CommentData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            muteStatus: isSet(object.muteStatus) ? ConversationUserData_MuteStatus.fromJSON(object.muteStatus) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            created: isSet(object.created) ? String(object.created) : undefined,
            banStatus: isSet(object.banStatus) ? ConversationUserData_BanStatus.fromJSON(object.banStatus) : undefined,
            isSuspended: isSet(object.isSuspended) ? Boolean(object.isSuspended) : undefined,
            approveStatus: isSet(object.approveStatus)
                ? ConversationUserData_ApproveStatus.fromJSON(object.approveStatus)
                : undefined,
            isShadowBanned: isSet(object.isShadowBanned) ? Boolean(object.isShadowBanned) : undefined,
            recentPosts: isObject(object.recentPosts)
                ? Object.entries(object.recentPosts).reduce((acc, [key, value]) => {
                    acc[key] = ConversationUserData_PostData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            recentConvos: isObject(object.recentConvos)
                ? Object.entries(object.recentConvos).reduce((acc, [key, value]) => {
                    acc[key] = ConversationUserData_ConvoData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            id: isSet(object.id) ? String(object.id) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        obj.recentComments = {};
        if (message.recentComments) {
            Object.entries(message.recentComments).forEach(([k, v]) => {
                obj.recentComments[k] = ConversationUserData_CommentData.toJSON(v);
            });
        }
        message.muteStatus !== undefined &&
            (obj.muteStatus = message.muteStatus ? ConversationUserData_MuteStatus.toJSON(message.muteStatus) : undefined);
        message.name !== undefined && (obj.name = message.name);
        message.created !== undefined && (obj.created = message.created);
        message.banStatus !== undefined &&
            (obj.banStatus = message.banStatus ? ConversationUserData_BanStatus.toJSON(message.banStatus) : undefined);
        message.isSuspended !== undefined && (obj.isSuspended = message.isSuspended);
        message.approveStatus !== undefined && (obj.approveStatus = message.approveStatus
            ? ConversationUserData_ApproveStatus.toJSON(message.approveStatus)
            : undefined);
        message.isShadowBanned !== undefined && (obj.isShadowBanned = message.isShadowBanned);
        obj.recentPosts = {};
        if (message.recentPosts) {
            Object.entries(message.recentPosts).forEach(([k, v]) => {
                obj.recentPosts[k] = ConversationUserData_PostData.toJSON(v);
            });
        }
        obj.recentConvos = {};
        if (message.recentConvos) {
            Object.entries(message.recentConvos).forEach(([k, v]) => {
                obj.recentConvos[k] = ConversationUserData_ConvoData.toJSON(v);
            });
        }
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData();
        message.recentComments = Object.entries(object.recentComments ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ConversationUserData_CommentData.fromPartial(value);
            }
            return acc;
        }, {});
        message.muteStatus = (object.muteStatus !== undefined && object.muteStatus !== null)
            ? ConversationUserData_MuteStatus.fromPartial(object.muteStatus)
            : undefined;
        message.name = object.name ?? undefined;
        message.created = object.created ?? undefined;
        message.banStatus = (object.banStatus !== undefined && object.banStatus !== null)
            ? ConversationUserData_BanStatus.fromPartial(object.banStatus)
            : undefined;
        message.isSuspended = object.isSuspended ?? undefined;
        message.approveStatus = (object.approveStatus !== undefined && object.approveStatus !== null)
            ? ConversationUserData_ApproveStatus.fromPartial(object.approveStatus)
            : undefined;
        message.isShadowBanned = object.isShadowBanned ?? undefined;
        message.recentPosts = Object.entries(object.recentPosts ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ConversationUserData_PostData.fromPartial(value);
            }
            return acc;
        }, {});
        message.recentConvos = Object.entries(object.recentConvos ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ConversationUserData_ConvoData.fromPartial(value);
            }
            return acc;
        }, {});
        message.id = object.id ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData", ConversationUserData);
function createBaseConversationUserData_CommentData() {
    return { comment: undefined, date: undefined, permalink: undefined, title: undefined };
}
export const ConversationUserData_CommentData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.CommentData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.comment !== undefined) {
            StringValue.encode({ value: message.comment }, writer.uint32(10).fork()).ldelim();
        }
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(18).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(26).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_CommentData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.comment = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            comment: isSet(object.comment) ? String(object.comment) : undefined,
            date: isSet(object.date) ? String(object.date) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.comment !== undefined && (obj.comment = message.comment);
        message.date !== undefined && (obj.date = message.date);
        message.permalink !== undefined && (obj.permalink = message.permalink);
        message.title !== undefined && (obj.title = message.title);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_CommentData();
        message.comment = object.comment ?? undefined;
        message.date = object.date ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.title = object.title ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.CommentData", ConversationUserData_CommentData);
function createBaseConversationUserData_MuteStatus() {
    return { muteCount: undefined, isMuted: undefined, endDate: undefined, reason: undefined };
}
export const ConversationUserData_MuteStatus = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.MuteStatus",
    encode(message, writer = _m0.Writer.create()) {
        if (message.muteCount !== undefined) {
            Int64Value.encode({ value: message.muteCount }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isMuted !== undefined) {
            BoolValue.encode({ value: message.isMuted }, writer.uint32(18).fork()).ldelim();
        }
        if (message.endDate !== undefined) {
            StringValue.encode({ value: message.endDate }, writer.uint32(26).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_MuteStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.muteCount = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.isMuted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.endDate = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            muteCount: isSet(object.muteCount) ? Number(object.muteCount) : undefined,
            isMuted: isSet(object.isMuted) ? Boolean(object.isMuted) : undefined,
            endDate: isSet(object.endDate) ? String(object.endDate) : undefined,
            reason: isSet(object.reason) ? String(object.reason) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.muteCount !== undefined && (obj.muteCount = message.muteCount);
        message.isMuted !== undefined && (obj.isMuted = message.isMuted);
        message.endDate !== undefined && (obj.endDate = message.endDate);
        message.reason !== undefined && (obj.reason = message.reason);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_MuteStatus();
        message.muteCount = object.muteCount ?? undefined;
        message.isMuted = object.isMuted ?? undefined;
        message.endDate = object.endDate ?? undefined;
        message.reason = object.reason ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.MuteStatus", ConversationUserData_MuteStatus);
function createBaseConversationUserData_BanStatus() {
    return { isBanned: undefined, isPermanent: undefined, endDate: undefined, reason: undefined };
}
export const ConversationUserData_BanStatus = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.BanStatus",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isBanned !== undefined) {
            BoolValue.encode({ value: message.isBanned }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isPermanent !== undefined) {
            BoolValue.encode({ value: message.isPermanent }, writer.uint32(18).fork()).ldelim();
        }
        if (message.endDate !== undefined) {
            StringValue.encode({ value: message.endDate }, writer.uint32(26).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_BanStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isBanned = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.isPermanent = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.endDate = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isBanned: isSet(object.isBanned) ? Boolean(object.isBanned) : undefined,
            isPermanent: isSet(object.isPermanent) ? Boolean(object.isPermanent) : undefined,
            endDate: isSet(object.endDate) ? String(object.endDate) : undefined,
            reason: isSet(object.reason) ? String(object.reason) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.isBanned !== undefined && (obj.isBanned = message.isBanned);
        message.isPermanent !== undefined && (obj.isPermanent = message.isPermanent);
        message.endDate !== undefined && (obj.endDate = message.endDate);
        message.reason !== undefined && (obj.reason = message.reason);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_BanStatus();
        message.isBanned = object.isBanned ?? undefined;
        message.isPermanent = object.isPermanent ?? undefined;
        message.endDate = object.endDate ?? undefined;
        message.reason = object.reason ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.BanStatus", ConversationUserData_BanStatus);
function createBaseConversationUserData_ApproveStatus() {
    return { isApproved: undefined };
}
export const ConversationUserData_ApproveStatus = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ApproveStatus",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isApproved !== undefined) {
            BoolValue.encode({ value: message.isApproved }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_ApproveStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isApproved = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { isApproved: isSet(object.isApproved) ? Boolean(object.isApproved) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.isApproved !== undefined && (obj.isApproved = message.isApproved);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_ApproveStatus();
        message.isApproved = object.isApproved ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.ApproveStatus", ConversationUserData_ApproveStatus);
function createBaseConversationUserData_PostData() {
    return { date: undefined, permalink: undefined, title: undefined };
}
export const ConversationUserData_PostData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.PostData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(18).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_PostData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            date: isSet(object.date) ? String(object.date) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.date !== undefined && (obj.date = message.date);
        message.permalink !== undefined && (obj.permalink = message.permalink);
        message.title !== undefined && (obj.title = message.title);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_PostData();
        message.date = object.date ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.title = object.title ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.PostData", ConversationUserData_PostData);
function createBaseConversationUserData_ConvoData() {
    return { date: undefined, permalink: undefined, id: undefined, subject: undefined };
}
export const ConversationUserData_ConvoData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ConvoData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(18).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
        }
        if (message.subject !== undefined) {
            StringValue.encode({ value: message.subject }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_ConvoData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.subject = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            date: isSet(object.date) ? String(object.date) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            subject: isSet(object.subject) ? String(object.subject) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.date !== undefined && (obj.date = message.date);
        message.permalink !== undefined && (obj.permalink = message.permalink);
        message.id !== undefined && (obj.id = message.id);
        message.subject !== undefined && (obj.subject = message.subject);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_ConvoData();
        message.date = object.date ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.id = object.id ?? undefined;
        message.subject = object.subject ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.ConvoData", ConversationUserData_ConvoData);
function createBaseConversationUserData_RecentCommentsEntry() {
    return { key: "", value: undefined };
}
export const ConversationUserData_RecentCommentsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentCommentsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ConversationUserData_CommentData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_RecentCommentsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ConversationUserData_CommentData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ConversationUserData_CommentData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined &&
            (obj.value = message.value ? ConversationUserData_CommentData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_RecentCommentsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ConversationUserData_CommentData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentCommentsEntry", ConversationUserData_RecentCommentsEntry);
function createBaseConversationUserData_RecentPostsEntry() {
    return { key: "", value: undefined };
}
export const ConversationUserData_RecentPostsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentPostsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ConversationUserData_PostData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_RecentPostsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ConversationUserData_PostData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ConversationUserData_PostData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined &&
            (obj.value = message.value ? ConversationUserData_PostData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_RecentPostsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ConversationUserData_PostData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentPostsEntry", ConversationUserData_RecentPostsEntry);
function createBaseConversationUserData_RecentConvosEntry() {
    return { key: "", value: undefined };
}
export const ConversationUserData_RecentConvosEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentConvosEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ConversationUserData_ConvoData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_RecentConvosEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ConversationUserData_ConvoData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ConversationUserData_ConvoData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined &&
            (obj.value = message.value ? ConversationUserData_ConvoData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_RecentConvosEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ConversationUserData_ConvoData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentConvosEntry", ConversationUserData_RecentConvosEntry);
function createBaseParticipant() {
    return {
        isMod: undefined,
        isAdmin: undefined,
        name: undefined,
        isOp: undefined,
        isParticipant: undefined,
        isApproved: undefined,
        isHidden: undefined,
        id: undefined,
        isDeleted: undefined,
    };
}
export const Participant = {
    $type: "devvit.plugin.redditapi.newmodmail.Participant",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isMod !== undefined) {
            BoolValue.encode({ value: message.isMod }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isAdmin !== undefined) {
            BoolValue.encode({ value: message.isAdmin }, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
        }
        if (message.isOp !== undefined) {
            BoolValue.encode({ value: message.isOp }, writer.uint32(34).fork()).ldelim();
        }
        if (message.isParticipant !== undefined) {
            BoolValue.encode({ value: message.isParticipant }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isApproved !== undefined) {
            BoolValue.encode({ value: message.isApproved }, writer.uint32(50).fork()).ldelim();
        }
        if (message.isHidden !== undefined) {
            BoolValue.encode({ value: message.isHidden }, writer.uint32(58).fork()).ldelim();
        }
        if (message.id !== undefined) {
            Int64Value.encode({ value: message.id }, writer.uint32(66).fork()).ldelim();
        }
        if (message.isDeleted !== undefined) {
            BoolValue.encode({ value: message.isDeleted }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParticipant();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isMod = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.isAdmin = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.isOp = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.isParticipant = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.isApproved = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.isHidden = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.id = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isMod: isSet(object.isMod) ? Boolean(object.isMod) : undefined,
            isAdmin: isSet(object.isAdmin) ? Boolean(object.isAdmin) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            isOp: isSet(object.isOp) ? Boolean(object.isOp) : undefined,
            isParticipant: isSet(object.isParticipant) ? Boolean(object.isParticipant) : undefined,
            isApproved: isSet(object.isApproved) ? Boolean(object.isApproved) : undefined,
            isHidden: isSet(object.isHidden) ? Boolean(object.isHidden) : undefined,
            id: isSet(object.id) ? Number(object.id) : undefined,
            isDeleted: isSet(object.isDeleted) ? Boolean(object.isDeleted) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.isMod !== undefined && (obj.isMod = message.isMod);
        message.isAdmin !== undefined && (obj.isAdmin = message.isAdmin);
        message.name !== undefined && (obj.name = message.name);
        message.isOp !== undefined && (obj.isOp = message.isOp);
        message.isParticipant !== undefined && (obj.isParticipant = message.isParticipant);
        message.isApproved !== undefined && (obj.isApproved = message.isApproved);
        message.isHidden !== undefined && (obj.isHidden = message.isHidden);
        message.id !== undefined && (obj.id = message.id);
        message.isDeleted !== undefined && (obj.isDeleted = message.isDeleted);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseParticipant();
        message.isMod = object.isMod ?? undefined;
        message.isAdmin = object.isAdmin ?? undefined;
        message.name = object.name ?? undefined;
        message.isOp = object.isOp ?? undefined;
        message.isParticipant = object.isParticipant ?? undefined;
        message.isApproved = object.isApproved ?? undefined;
        message.isHidden = object.isHidden ?? undefined;
        message.id = object.id ?? undefined;
        message.isDeleted = object.isDeleted ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.Participant", Participant);
function createBaseModActionData() {
    return { date: undefined, actionTypeId: undefined, id: undefined, author: undefined };
}
export const ModActionData = {
    $type: "devvit.plugin.redditapi.newmodmail.ModActionData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
        }
        if (message.actionTypeId !== undefined) {
            Int32Value.encode({ value: message.actionTypeId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
        }
        if (message.author !== undefined) {
            ModActionData_ModActionAuthor.encode(message.author, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModActionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.actionTypeId = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.author = ModActionData_ModActionAuthor.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            date: isSet(object.date) ? String(object.date) : undefined,
            actionTypeId: isSet(object.actionTypeId) ? Number(object.actionTypeId) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            author: isSet(object.author) ? ModActionData_ModActionAuthor.fromJSON(object.author) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.date !== undefined && (obj.date = message.date);
        message.actionTypeId !== undefined && (obj.actionTypeId = message.actionTypeId);
        message.id !== undefined && (obj.id = message.id);
        message.author !== undefined &&
            (obj.author = message.author ? ModActionData_ModActionAuthor.toJSON(message.author) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseModActionData();
        message.date = object.date ?? undefined;
        message.actionTypeId = object.actionTypeId ?? undefined;
        message.id = object.id ?? undefined;
        message.author = (object.author !== undefined && object.author !== null)
            ? ModActionData_ModActionAuthor.fromPartial(object.author)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ModActionData", ModActionData);
function createBaseModActionData_ModActionAuthor() {
    return {
        isMod: undefined,
        isAdmin: undefined,
        name: undefined,
        isHidden: undefined,
        id: undefined,
        isDeleted: undefined,
    };
}
export const ModActionData_ModActionAuthor = {
    $type: "devvit.plugin.redditapi.newmodmail.ModActionData.ModActionAuthor",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isMod !== undefined) {
            BoolValue.encode({ value: message.isMod }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isAdmin !== undefined) {
            BoolValue.encode({ value: message.isAdmin }, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
        }
        if (message.isHidden !== undefined) {
            BoolValue.encode({ value: message.isHidden }, writer.uint32(34).fork()).ldelim();
        }
        if (message.id !== undefined) {
            Int64Value.encode({ value: message.id }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isDeleted !== undefined) {
            BoolValue.encode({ value: message.isDeleted }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModActionData_ModActionAuthor();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isMod = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.isAdmin = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.isHidden = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.id = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isMod: isSet(object.isMod) ? Boolean(object.isMod) : undefined,
            isAdmin: isSet(object.isAdmin) ? Boolean(object.isAdmin) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            isHidden: isSet(object.isHidden) ? Boolean(object.isHidden) : undefined,
            id: isSet(object.id) ? Number(object.id) : undefined,
            isDeleted: isSet(object.isDeleted) ? Boolean(object.isDeleted) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.isMod !== undefined && (obj.isMod = message.isMod);
        message.isAdmin !== undefined && (obj.isAdmin = message.isAdmin);
        message.name !== undefined && (obj.name = message.name);
        message.isHidden !== undefined && (obj.isHidden = message.isHidden);
        message.id !== undefined && (obj.id = message.id);
        message.isDeleted !== undefined && (obj.isDeleted = message.isDeleted);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseModActionData_ModActionAuthor();
        message.isMod = object.isMod ?? undefined;
        message.isAdmin = object.isAdmin ?? undefined;
        message.name = object.name ?? undefined;
        message.isHidden = object.isHidden ?? undefined;
        message.id = object.id ?? undefined;
        message.isDeleted = object.isDeleted ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ModActionData.ModActionAuthor", ModActionData_ModActionAuthor);
function createBaseBulkReadConversationsRequest() {
    return { entity: "", state: "" };
}
export const BulkReadConversationsRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.entity !== "") {
            writer.uint32(10).string(message.entity);
        }
        if (message.state !== "") {
            writer.uint32(18).string(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBulkReadConversationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entity = reader.string();
                    break;
                case 2:
                    message.state = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            entity: isSet(object.entity) ? String(object.entity) : "",
            state: isSet(object.state) ? String(object.state) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.entity !== undefined && (obj.entity = message.entity);
        message.state !== undefined && (obj.state = message.state);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBulkReadConversationsRequest();
        message.entity = object.entity ?? "";
        message.state = object.state ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.BulkReadConversationsRequest", BulkReadConversationsRequest);
function createBaseGetConversationsRequest() {
    return { after: undefined, entity: undefined, limit: undefined, sort: undefined, state: undefined };
}
export const GetConversationsRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.entity !== undefined) {
            StringValue.encode({ value: message.entity }, writer.uint32(18).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int32Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(34).fork()).ldelim();
        }
        if (message.state !== undefined) {
            StringValue.encode({ value: message.state }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.entity = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.limit = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.state = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            entity: isSet(object.entity) ? String(object.entity) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            state: isSet(object.state) ? String(object.state) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.entity !== undefined && (obj.entity = message.entity);
        message.limit !== undefined && (obj.limit = message.limit);
        message.sort !== undefined && (obj.sort = message.sort);
        message.state !== undefined && (obj.state = message.state);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetConversationsRequest();
        message.after = object.after ?? undefined;
        message.entity = object.entity ?? undefined;
        message.limit = object.limit ?? undefined;
        message.sort = object.sort ?? undefined;
        message.state = object.state ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationsRequest", GetConversationsRequest);
function createBaseCreateConversationRequest() {
    return { body: "", isAuthorHidden: false, srName: "", subject: "", to: undefined };
}
export const CreateConversationRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.body !== "") {
            writer.uint32(10).string(message.body);
        }
        if (message.isAuthorHidden === true) {
            writer.uint32(16).bool(message.isAuthorHidden);
        }
        if (message.srName !== "") {
            writer.uint32(26).string(message.srName);
        }
        if (message.subject !== "") {
            writer.uint32(34).string(message.subject);
        }
        if (message.to !== undefined) {
            StringValue.encode({ value: message.to }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.body = reader.string();
                    break;
                case 2:
                    message.isAuthorHidden = reader.bool();
                    break;
                case 3:
                    message.srName = reader.string();
                    break;
                case 4:
                    message.subject = reader.string();
                    break;
                case 5:
                    message.to = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            body: isSet(object.body) ? String(object.body) : "",
            isAuthorHidden: isSet(object.isAuthorHidden) ? Boolean(object.isAuthorHidden) : false,
            srName: isSet(object.srName) ? String(object.srName) : "",
            subject: isSet(object.subject) ? String(object.subject) : "",
            to: isSet(object.to) ? String(object.to) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.body !== undefined && (obj.body = message.body);
        message.isAuthorHidden !== undefined && (obj.isAuthorHidden = message.isAuthorHidden);
        message.srName !== undefined && (obj.srName = message.srName);
        message.subject !== undefined && (obj.subject = message.subject);
        message.to !== undefined && (obj.to = message.to);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateConversationRequest();
        message.body = object.body ?? "";
        message.isAuthorHidden = object.isAuthorHidden ?? false;
        message.srName = object.srName ?? "";
        message.subject = object.subject ?? "";
        message.to = object.to ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationRequest", CreateConversationRequest);
function createBaseGetConversationRequest() {
    return { conversationId: "", markRead: false };
}
export const GetConversationRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationId !== "") {
            writer.uint32(10).string(message.conversationId);
        }
        if (message.markRead === true) {
            writer.uint32(16).bool(message.markRead);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversationId = reader.string();
                    break;
                case 2:
                    message.markRead = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversationId: isSet(object.conversationId) ? String(object.conversationId) : "",
            markRead: isSet(object.markRead) ? Boolean(object.markRead) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversationId !== undefined && (obj.conversationId = message.conversationId);
        message.markRead !== undefined && (obj.markRead = message.markRead);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetConversationRequest();
        message.conversationId = object.conversationId ?? "";
        message.markRead = object.markRead ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationRequest", GetConversationRequest);
function createBaseCreateConversationMessageRequest() {
    return { body: "", isAuthorHidden: false, isInternal: false, conversationId: "" };
}
export const CreateConversationMessageRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.body !== "") {
            writer.uint32(10).string(message.body);
        }
        if (message.isAuthorHidden === true) {
            writer.uint32(16).bool(message.isAuthorHidden);
        }
        if (message.isInternal === true) {
            writer.uint32(24).bool(message.isInternal);
        }
        if (message.conversationId !== "") {
            writer.uint32(34).string(message.conversationId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationMessageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.body = reader.string();
                    break;
                case 2:
                    message.isAuthorHidden = reader.bool();
                    break;
                case 3:
                    message.isInternal = reader.bool();
                    break;
                case 4:
                    message.conversationId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            body: isSet(object.body) ? String(object.body) : "",
            isAuthorHidden: isSet(object.isAuthorHidden) ? Boolean(object.isAuthorHidden) : false,
            isInternal: isSet(object.isInternal) ? Boolean(object.isInternal) : false,
            conversationId: isSet(object.conversationId) ? String(object.conversationId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.body !== undefined && (obj.body = message.body);
        message.isAuthorHidden !== undefined && (obj.isAuthorHidden = message.isAuthorHidden);
        message.isInternal !== undefined && (obj.isInternal = message.isInternal);
        message.conversationId !== undefined && (obj.conversationId = message.conversationId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateConversationMessageRequest();
        message.body = object.body ?? "";
        message.isAuthorHidden = object.isAuthorHidden ?? false;
        message.isInternal = object.isInternal ?? false;
        message.conversationId = object.conversationId ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationMessageRequest", CreateConversationMessageRequest);
function createBaseBasicConversationRequest() {
    return { conversationId: "" };
}
export const BasicConversationRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationId !== "") {
            writer.uint32(10).string(message.conversationId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicConversationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversationId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { conversationId: isSet(object.conversationId) ? String(object.conversationId) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.conversationId !== undefined && (obj.conversationId = message.conversationId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBasicConversationRequest();
        message.conversationId = object.conversationId ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.BasicConversationRequest", BasicConversationRequest);
function createBaseBasicConversationsRequest() {
    return { conversationIds: "" };
}
export const BasicConversationsRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.BasicConversationsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationIds !== "") {
            writer.uint32(10).string(message.conversationIds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicConversationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversationIds = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { conversationIds: isSet(object.conversationIds) ? String(object.conversationIds) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.conversationIds !== undefined && (obj.conversationIds = message.conversationIds);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBasicConversationsRequest();
        message.conversationIds = object.conversationIds ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.BasicConversationsRequest", BasicConversationsRequest);
function createBaseMuteConversationRequest() {
    return { conversationId: "", numHours: 0 };
}
export const MuteConversationRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationId !== "") {
            writer.uint32(10).string(message.conversationId);
        }
        if (message.numHours !== 0) {
            writer.uint32(16).int32(message.numHours);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteConversationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversationId = reader.string();
                    break;
                case 2:
                    message.numHours = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversationId: isSet(object.conversationId) ? String(object.conversationId) : "",
            numHours: isSet(object.numHours) ? Number(object.numHours) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversationId !== undefined && (obj.conversationId = message.conversationId);
        message.numHours !== undefined && (obj.numHours = Math.round(message.numHours));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMuteConversationRequest();
        message.conversationId = object.conversationId ?? "";
        message.numHours = object.numHours ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MuteConversationRequest", MuteConversationRequest);
function createBaseTempBanRequest() {
    return { conversationId: "", duration: 0 };
}
export const TempBanRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationId !== "") {
            writer.uint32(10).string(message.conversationId);
        }
        if (message.duration !== 0) {
            writer.uint32(16).int32(message.duration);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTempBanRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversationId = reader.string();
                    break;
                case 2:
                    message.duration = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversationId: isSet(object.conversationId) ? String(object.conversationId) : "",
            duration: isSet(object.duration) ? Number(object.duration) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversationId !== undefined && (obj.conversationId = message.conversationId);
        message.duration !== undefined && (obj.duration = Math.round(message.duration));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTempBanRequest();
        message.conversationId = object.conversationId ?? "";
        message.duration = object.duration ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.TempBanRequest", TempBanRequest);
function createBaseBulkReadConversationsResponse() {
    return { conversationIds: [] };
}
export const BulkReadConversationsResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.conversationIds) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBulkReadConversationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversationIds.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversationIds: Array.isArray(object?.conversationIds) ? object.conversationIds.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversationIds) {
            obj.conversationIds = message.conversationIds.map((e) => e);
        }
        else {
            obj.conversationIds = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBulkReadConversationsResponse();
        message.conversationIds = object.conversationIds?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.BulkReadConversationsResponse", BulkReadConversationsResponse);
function createBaseGetConversationsResponse() {
    return { conversations: {}, messages: {}, viewerId: undefined, conversationIds: [] };
}
export const GetConversationsResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.conversations).forEach(([key, value]) => {
            GetConversationsResponse_ConversationsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        Object.entries(message.messages).forEach(([key, value]) => {
            GetConversationsResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.viewerId !== undefined) {
            StringValue.encode({ value: message.viewerId }, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.conversationIds) {
            StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = GetConversationsResponse_ConversationsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.conversations[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    const entry2 = GetConversationsResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.viewerId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.conversationIds.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isObject(object.conversations)
                ? Object.entries(object.conversations).reduce((acc, [key, value]) => {
                    acc[key] = ConversationData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            viewerId: isSet(object.viewerId) ? String(object.viewerId) : undefined,
            conversationIds: Array.isArray(object?.conversationIds) ? object.conversationIds.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        obj.conversations = {};
        if (message.conversations) {
            Object.entries(message.conversations).forEach(([k, v]) => {
                obj.conversations[k] = ConversationData.toJSON(v);
            });
        }
        obj.messages = {};
        if (message.messages) {
            Object.entries(message.messages).forEach(([k, v]) => {
                obj.messages[k] = MessageData.toJSON(v);
            });
        }
        message.viewerId !== undefined && (obj.viewerId = message.viewerId);
        if (message.conversationIds) {
            obj.conversationIds = message.conversationIds.map((e) => e);
        }
        else {
            obj.conversationIds = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetConversationsResponse();
        message.conversations = Object.entries(object.conversations ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ConversationData.fromPartial(value);
            }
            return acc;
        }, {});
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.viewerId = object.viewerId ?? undefined;
        message.conversationIds = object.conversationIds?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationsResponse", GetConversationsResponse);
function createBaseGetConversationsResponse_ConversationsEntry() {
    return { key: "", value: undefined };
}
export const GetConversationsResponse_ConversationsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.ConversationsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ConversationData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationsResponse_ConversationsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ConversationData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ConversationData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? ConversationData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetConversationsResponse_ConversationsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ConversationData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationsResponse.ConversationsEntry", GetConversationsResponse_ConversationsEntry);
function createBaseGetConversationsResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const GetConversationsResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationsResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = MessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? MessageData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetConversationsResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationsResponse.MessagesEntry", GetConversationsResponse_MessagesEntry);
function createBaseCreateConversationResponse() {
    return {
        conversation: undefined,
        messages: {},
        modActions: {},
        fields: [],
        reason: undefined,
        message: undefined,
        explanation: undefined,
        user: undefined,
    };
}
export const CreateConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            CreateConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.modActions).forEach(([key, value]) => {
            CreateConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        for (const v of message.fields) {
            StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(42).fork()).ldelim();
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(50).fork()).ldelim();
        }
        if (message.explanation !== undefined) {
            StringValue.encode({ value: message.explanation }, writer.uint32(58).fork()).ldelim();
        }
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = CreateConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    const entry3 = CreateConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.modActions[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.fields.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 5:
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.explanation = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            fields: Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
            reason: isSet(object.reason) ? String(object.reason) : undefined,
            message: isSet(object.message) ? String(object.message) : undefined,
            explanation: isSet(object.explanation) ? String(object.explanation) : undefined,
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversation !== undefined &&
            (obj.conversation = message.conversation ? ConversationData.toJSON(message.conversation) : undefined);
        obj.messages = {};
        if (message.messages) {
            Object.entries(message.messages).forEach(([k, v]) => {
                obj.messages[k] = MessageData.toJSON(v);
            });
        }
        obj.modActions = {};
        if (message.modActions) {
            Object.entries(message.modActions).forEach(([k, v]) => {
                obj.modActions[k] = ModActionData.toJSON(v);
            });
        }
        if (message.fields) {
            obj.fields = message.fields.map((e) => e);
        }
        else {
            obj.fields = [];
        }
        message.reason !== undefined && (obj.reason = message.reason);
        message.message !== undefined && (obj.message = message.message);
        message.explanation !== undefined && (obj.explanation = message.explanation);
        message.user !== undefined && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateConversationResponse();
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.fields = object.fields?.map((e) => e) || [];
        message.reason = object.reason ?? undefined;
        message.message = object.message ?? undefined;
        message.explanation = object.explanation ?? undefined;
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationResponse", CreateConversationResponse);
function createBaseCreateConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const CreateConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = MessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? MessageData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationResponse.MessagesEntry", CreateConversationResponse_MessagesEntry);
function createBaseCreateConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const CreateConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ModActionData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? ModActionData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationResponse.ModActionsEntry", CreateConversationResponse_ModActionsEntry);
function createBaseGetConversationResponse() {
    return { conversation: undefined, messages: {}, modActions: {}, participantSubreddit: undefined, user: undefined };
}
export const GetConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            GetConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.modActions).forEach(([key, value]) => {
            GetConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.participantSubreddit !== undefined) {
            Any.encode(message.participantSubreddit, writer.uint32(34).fork()).ldelim();
        }
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = GetConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    const entry3 = GetConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.modActions[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.participantSubreddit = Any.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            participantSubreddit: isSet(object.participantSubreddit) ? Any.fromJSON(object.participantSubreddit) : undefined,
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversation !== undefined &&
            (obj.conversation = message.conversation ? ConversationData.toJSON(message.conversation) : undefined);
        obj.messages = {};
        if (message.messages) {
            Object.entries(message.messages).forEach(([k, v]) => {
                obj.messages[k] = MessageData.toJSON(v);
            });
        }
        obj.modActions = {};
        if (message.modActions) {
            Object.entries(message.modActions).forEach(([k, v]) => {
                obj.modActions[k] = ModActionData.toJSON(v);
            });
        }
        message.participantSubreddit !== undefined &&
            (obj.participantSubreddit = message.participantSubreddit ? Any.toJSON(message.participantSubreddit) : undefined);
        message.user !== undefined && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetConversationResponse();
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.participantSubreddit = (object.participantSubreddit !== undefined && object.participantSubreddit !== null)
            ? Any.fromPartial(object.participantSubreddit)
            : undefined;
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationResponse", GetConversationResponse);
function createBaseGetConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const GetConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = MessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? MessageData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationResponse.MessagesEntry", GetConversationResponse_MessagesEntry);
function createBaseGetConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const GetConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ModActionData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? ModActionData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationResponse.ModActionsEntry", GetConversationResponse_ModActionsEntry);
function createBaseCreateConversationMessageResponse() {
    return { conversation: undefined, messages: {}, user: undefined };
}
export const CreateConversationMessageResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            CreateConversationMessageResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork())
                .ldelim();
        });
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationMessageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = CreateConversationMessageResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversation !== undefined &&
            (obj.conversation = message.conversation ? ConversationData.toJSON(message.conversation) : undefined);
        obj.messages = {};
        if (message.messages) {
            Object.entries(message.messages).forEach(([k, v]) => {
                obj.messages[k] = MessageData.toJSON(v);
            });
        }
        message.user !== undefined && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateConversationMessageResponse();
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse", CreateConversationMessageResponse);
function createBaseCreateConversationMessageResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const CreateConversationMessageResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationMessageResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = MessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? MessageData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCreateConversationMessageResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse.MessagesEntry", CreateConversationMessageResponse_MessagesEntry);
function createBaseApproveConversationResponse() {
    return {
        conversations: undefined,
        messages: {},
        user: undefined,
        modActions: {},
        fields: [],
        reason: undefined,
        message: undefined,
        explanation: undefined,
    };
}
export const ApproveConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            ApproveConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
        }
        Object.entries(message.modActions).forEach(([key, value]) => {
            ApproveConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        for (const v of message.fields) {
            StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
        }
        if (message.explanation !== undefined) {
            StringValue.encode({ value: message.explanation }, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApproveConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = ApproveConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    break;
                case 4:
                    const entry4 = ApproveConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.modActions[entry4.key] = entry4.value;
                    }
                    break;
                case 5:
                    message.fields.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 6:
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.explanation = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            fields: Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
            reason: isSet(object.reason) ? String(object.reason) : undefined,
            message: isSet(object.message) ? String(object.message) : undefined,
            explanation: isSet(object.explanation) ? String(object.explanation) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversations !== undefined &&
            (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : undefined);
        obj.messages = {};
        if (message.messages) {
            Object.entries(message.messages).forEach(([k, v]) => {
                obj.messages[k] = MessageData.toJSON(v);
            });
        }
        message.user !== undefined && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : undefined);
        obj.modActions = {};
        if (message.modActions) {
            Object.entries(message.modActions).forEach(([k, v]) => {
                obj.modActions[k] = ModActionData.toJSON(v);
            });
        }
        if (message.fields) {
            obj.fields = message.fields.map((e) => e);
        }
        else {
            obj.fields = [];
        }
        message.reason !== undefined && (obj.reason = message.reason);
        message.message !== undefined && (obj.message = message.message);
        message.explanation !== undefined && (obj.explanation = message.explanation);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseApproveConversationResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.fields = object.fields?.map((e) => e) || [];
        message.reason = object.reason ?? undefined;
        message.message = object.message ?? undefined;
        message.explanation = object.explanation ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ApproveConversationResponse", ApproveConversationResponse);
function createBaseApproveConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const ApproveConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApproveConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = MessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? MessageData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseApproveConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.MessagesEntry", ApproveConversationResponse_MessagesEntry);
function createBaseApproveConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const ApproveConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApproveConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ModActionData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? ModActionData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseApproveConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.ModActionsEntry", ApproveConversationResponse_ModActionsEntry);
function createBaseArchiveConversationResponse() {
    return { conversations: undefined, messages: {}, modActions: {}, conversation: undefined };
}
export const ArchiveConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            ArchiveConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.modActions).forEach(([key, value]) => {
            ArchiveConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseArchiveConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = ArchiveConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    const entry3 = ArchiveConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.modActions[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversations !== undefined &&
            (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : undefined);
        obj.messages = {};
        if (message.messages) {
            Object.entries(message.messages).forEach(([k, v]) => {
                obj.messages[k] = MessageData.toJSON(v);
            });
        }
        obj.modActions = {};
        if (message.modActions) {
            Object.entries(message.modActions).forEach(([k, v]) => {
                obj.modActions[k] = ModActionData.toJSON(v);
            });
        }
        message.conversation !== undefined &&
            (obj.conversation = message.conversation ? ConversationData.toJSON(message.conversation) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseArchiveConversationResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse", ArchiveConversationResponse);
function createBaseArchiveConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const ArchiveConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseArchiveConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = MessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? MessageData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseArchiveConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.MessagesEntry", ArchiveConversationResponse_MessagesEntry);
function createBaseArchiveConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const ArchiveConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseArchiveConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ModActionData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? ModActionData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseArchiveConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.ModActionsEntry", ArchiveConversationResponse_ModActionsEntry);
function createBaseHighlightConversationResponse() {
    return { conversations: undefined, messages: {}, modActions: {}, conversation: undefined };
}
export const HighlightConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            HighlightConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.modActions).forEach(([key, value]) => {
            HighlightConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(26).fork())
                .ldelim();
        });
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHighlightConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = HighlightConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    const entry3 = HighlightConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.modActions[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversations !== undefined &&
            (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : undefined);
        obj.messages = {};
        if (message.messages) {
            Object.entries(message.messages).forEach(([k, v]) => {
                obj.messages[k] = MessageData.toJSON(v);
            });
        }
        obj.modActions = {};
        if (message.modActions) {
            Object.entries(message.modActions).forEach(([k, v]) => {
                obj.modActions[k] = ModActionData.toJSON(v);
            });
        }
        message.conversation !== undefined &&
            (obj.conversation = message.conversation ? ConversationData.toJSON(message.conversation) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHighlightConversationResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.HighlightConversationResponse", HighlightConversationResponse);
function createBaseHighlightConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const HighlightConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHighlightConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = MessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? MessageData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHighlightConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.MessagesEntry", HighlightConversationResponse_MessagesEntry);
function createBaseHighlightConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const HighlightConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHighlightConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ModActionData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? ModActionData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHighlightConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.ModActionsEntry", HighlightConversationResponse_ModActionsEntry);
function createBaseMuteConversationResponse() {
    return { conversations: undefined, messages: {}, user: undefined, modActions: {} };
}
export const MuteConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            MuteConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
        }
        Object.entries(message.modActions).forEach(([key, value]) => {
            MuteConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = MuteConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    break;
                case 4:
                    const entry4 = MuteConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.modActions[entry4.key] = entry4.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversations !== undefined &&
            (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : undefined);
        obj.messages = {};
        if (message.messages) {
            Object.entries(message.messages).forEach(([k, v]) => {
                obj.messages[k] = MessageData.toJSON(v);
            });
        }
        message.user !== undefined && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : undefined);
        obj.modActions = {};
        if (message.modActions) {
            Object.entries(message.modActions).forEach(([k, v]) => {
                obj.modActions[k] = ModActionData.toJSON(v);
            });
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMuteConversationResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MuteConversationResponse", MuteConversationResponse);
function createBaseMuteConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const MuteConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = MessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? MessageData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMuteConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MuteConversationResponse.MessagesEntry", MuteConversationResponse_MessagesEntry);
function createBaseMuteConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const MuteConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ModActionData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? ModActionData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMuteConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MuteConversationResponse.ModActionsEntry", MuteConversationResponse_ModActionsEntry);
function createBaseTempBanResponse() {
    return {
        conversations: undefined,
        messages: {},
        user: undefined,
        modActions: {},
        fields: [],
        reason: undefined,
        message: undefined,
    };
}
export const TempBanResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            TempBanResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
        }
        Object.entries(message.modActions).forEach(([key, value]) => {
            TempBanResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        for (const v of message.fields) {
            StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTempBanResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = TempBanResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    break;
                case 4:
                    const entry4 = TempBanResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.modActions[entry4.key] = entry4.value;
                    }
                    break;
                case 5:
                    message.fields.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 6:
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            fields: Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
            reason: isSet(object.reason) ? String(object.reason) : undefined,
            message: isSet(object.message) ? String(object.message) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.conversations !== undefined &&
            (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : undefined);
        obj.messages = {};
        if (message.messages) {
            Object.entries(message.messages).forEach(([k, v]) => {
                obj.messages[k] = MessageData.toJSON(v);
            });
        }
        message.user !== undefined && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : undefined);
        obj.modActions = {};
        if (message.modActions) {
            Object.entries(message.modActions).forEach(([k, v]) => {
                obj.modActions[k] = ModActionData.toJSON(v);
            });
        }
        if (message.fields) {
            obj.fields = message.fields.map((e) => e);
        }
        else {
            obj.fields = [];
        }
        message.reason !== undefined && (obj.reason = message.reason);
        message.message !== undefined && (obj.message = message.message);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTempBanResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.fields = object.fields?.map((e) => e) || [];
        message.reason = object.reason ?? undefined;
        message.message = object.message ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.TempBanResponse", TempBanResponse);
function createBaseTempBanResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const TempBanResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTempBanResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = MessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? MessageData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTempBanResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.TempBanResponse.MessagesEntry", TempBanResponse_MessagesEntry);
function createBaseTempBanResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const TempBanResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTempBanResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = ModActionData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? ModActionData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTempBanResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.TempBanResponse.ModActionsEntry", TempBanResponse_ModActionsEntry);
function createBaseSubredditsResponse() {
    return { subreddits: {} };
}
export const SubredditsResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.subreddits).forEach(([key, value]) => {
            SubredditsResponse_SubredditsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = SubredditsResponse_SubredditsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.subreddits[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddits: isObject(object.subreddits)
                ? Object.entries(object.subreddits).reduce((acc, [key, value]) => {
                    acc[key] = SubredditsResponse_SubredditData.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        obj.subreddits = {};
        if (message.subreddits) {
            Object.entries(message.subreddits).forEach(([k, v]) => {
                obj.subreddits[k] = SubredditsResponse_SubredditData.toJSON(v);
            });
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditsResponse();
        message.subreddits = Object.entries(object.subreddits ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SubredditsResponse_SubredditData.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.SubredditsResponse", SubredditsResponse);
function createBaseSubredditsResponse_SubredditData() {
    return {
        communityIcon: undefined,
        keyColor: undefined,
        displayName: undefined,
        name: undefined,
        subscribers: undefined,
        primaryColor: undefined,
        id: undefined,
        lastUpdated: undefined,
        icon: undefined,
    };
}
export const SubredditsResponse_SubredditData = {
    $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.communityIcon !== undefined) {
            StringValue.encode({ value: message.communityIcon }, writer.uint32(10).fork()).ldelim();
        }
        if (message.keyColor !== undefined) {
            StringValue.encode({ value: message.keyColor }, writer.uint32(18).fork()).ldelim();
        }
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
        }
        if (message.subscribers !== undefined) {
            Int32Value.encode({ value: message.subscribers }, writer.uint32(42).fork()).ldelim();
        }
        if (message.primaryColor !== undefined) {
            StringValue.encode({ value: message.primaryColor }, writer.uint32(50).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
        }
        if (message.lastUpdated !== undefined) {
            StringValue.encode({ value: message.lastUpdated }, writer.uint32(66).fork()).ldelim();
        }
        if (message.icon !== undefined) {
            StringValue.encode({ value: message.icon }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsResponse_SubredditData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.keyColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.subscribers = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.lastUpdated = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.icon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            communityIcon: isSet(object.communityIcon) ? String(object.communityIcon) : undefined,
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : undefined,
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            subscribers: isSet(object.subscribers) ? Number(object.subscribers) : undefined,
            primaryColor: isSet(object.primaryColor) ? String(object.primaryColor) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            lastUpdated: isSet(object.lastUpdated) ? String(object.lastUpdated) : undefined,
            icon: isSet(object.icon) ? String(object.icon) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.communityIcon !== undefined && (obj.communityIcon = message.communityIcon);
        message.keyColor !== undefined && (obj.keyColor = message.keyColor);
        message.displayName !== undefined && (obj.displayName = message.displayName);
        message.name !== undefined && (obj.name = message.name);
        message.subscribers !== undefined && (obj.subscribers = message.subscribers);
        message.primaryColor !== undefined && (obj.primaryColor = message.primaryColor);
        message.id !== undefined && (obj.id = message.id);
        message.lastUpdated !== undefined && (obj.lastUpdated = message.lastUpdated);
        message.icon !== undefined && (obj.icon = message.icon);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditsResponse_SubredditData();
        message.communityIcon = object.communityIcon ?? undefined;
        message.keyColor = object.keyColor ?? undefined;
        message.displayName = object.displayName ?? undefined;
        message.name = object.name ?? undefined;
        message.subscribers = object.subscribers ?? undefined;
        message.primaryColor = object.primaryColor ?? undefined;
        message.id = object.id ?? undefined;
        message.lastUpdated = object.lastUpdated ?? undefined;
        message.icon = object.icon ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditData", SubredditsResponse_SubredditData);
function createBaseSubredditsResponse_SubredditsEntry() {
    return { key: "", value: undefined };
}
export const SubredditsResponse_SubredditsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SubredditsResponse_SubredditData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsResponse_SubredditsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = SubredditsResponse_SubredditData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? SubredditsResponse_SubredditData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined &&
            (obj.value = message.value ? SubredditsResponse_SubredditData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditsResponse_SubredditsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SubredditsResponse_SubredditData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditsEntry", SubredditsResponse_SubredditsEntry);
function createBaseUnreadCountResponse() {
    return {
        archived: undefined,
        appeals: undefined,
        highlighted: undefined,
        notifications: undefined,
        joinRequests: undefined,
        filtered: undefined,
        new: undefined,
        inprogress: undefined,
        mod: undefined,
    };
}
export const UnreadCountResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.UnreadCountResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.archived !== undefined) {
            Int32Value.encode({ value: message.archived }, writer.uint32(10).fork()).ldelim();
        }
        if (message.appeals !== undefined) {
            Int32Value.encode({ value: message.appeals }, writer.uint32(18).fork()).ldelim();
        }
        if (message.highlighted !== undefined) {
            Int32Value.encode({ value: message.highlighted }, writer.uint32(26).fork()).ldelim();
        }
        if (message.notifications !== undefined) {
            Int32Value.encode({ value: message.notifications }, writer.uint32(34).fork()).ldelim();
        }
        if (message.joinRequests !== undefined) {
            Int32Value.encode({ value: message.joinRequests }, writer.uint32(42).fork()).ldelim();
        }
        if (message.filtered !== undefined) {
            Int32Value.encode({ value: message.filtered }, writer.uint32(50).fork()).ldelim();
        }
        if (message.new !== undefined) {
            Int32Value.encode({ value: message.new }, writer.uint32(58).fork()).ldelim();
        }
        if (message.inprogress !== undefined) {
            Int32Value.encode({ value: message.inprogress }, writer.uint32(66).fork()).ldelim();
        }
        if (message.mod !== undefined) {
            Int32Value.encode({ value: message.mod }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnreadCountResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.archived = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.appeals = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.highlighted = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.notifications = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.joinRequests = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.filtered = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.new = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.inprogress = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.mod = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            archived: isSet(object.archived) ? Number(object.archived) : undefined,
            appeals: isSet(object.appeals) ? Number(object.appeals) : undefined,
            highlighted: isSet(object.highlighted) ? Number(object.highlighted) : undefined,
            notifications: isSet(object.notifications) ? Number(object.notifications) : undefined,
            joinRequests: isSet(object.joinRequests) ? Number(object.joinRequests) : undefined,
            filtered: isSet(object.filtered) ? Number(object.filtered) : undefined,
            new: isSet(object.new) ? Number(object.new) : undefined,
            inprogress: isSet(object.inprogress) ? Number(object.inprogress) : undefined,
            mod: isSet(object.mod) ? Number(object.mod) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.archived !== undefined && (obj.archived = message.archived);
        message.appeals !== undefined && (obj.appeals = message.appeals);
        message.highlighted !== undefined && (obj.highlighted = message.highlighted);
        message.notifications !== undefined && (obj.notifications = message.notifications);
        message.joinRequests !== undefined && (obj.joinRequests = message.joinRequests);
        message.filtered !== undefined && (obj.filtered = message.filtered);
        message.new !== undefined && (obj.new = message.new);
        message.inprogress !== undefined && (obj.inprogress = message.inprogress);
        message.mod !== undefined && (obj.mod = message.mod);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUnreadCountResponse();
        message.archived = object.archived ?? undefined;
        message.appeals = object.appeals ?? undefined;
        message.highlighted = object.highlighted ?? undefined;
        message.notifications = object.notifications ?? undefined;
        message.joinRequests = object.joinRequests ?? undefined;
        message.filtered = object.filtered ?? undefined;
        message.new = object.new ?? undefined;
        message.inprogress = object.inprogress ?? undefined;
        message.mod = object.mod ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.UnreadCountResponse", UnreadCountResponse);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
