/**
 * #modnote_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
function createBaseDeleteNotesRequest() {
    return { subreddit: "", noteId: "", user: "" };
}
export const DeleteNotesRequest = {
    $type: "devvit.plugin.redditapi.modnote.DeleteNotesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.noteId !== "") {
            writer.uint32(18).string(message.noteId);
        }
        if (message.user !== "") {
            writer.uint32(26).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteNotesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.noteId = reader.string();
                    break;
                case 3:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            noteId: isSet(object.noteId) ? String(object.noteId) : "",
            user: isSet(object.user) ? String(object.user) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.noteId !== undefined && (obj.noteId = message.noteId);
        message.user !== undefined && (obj.user = message.user);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDeleteNotesRequest();
        message.subreddit = object.subreddit ?? "";
        message.noteId = object.noteId ?? "";
        message.user = object.user ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.DeleteNotesRequest", DeleteNotesRequest);
function createBaseGetNotesRequest() {
    return { subreddit: "", before: undefined, filter: undefined, limit: undefined, user: "" };
}
export const GetNotesRequest = {
    $type: "devvit.plugin.redditapi.modnote.GetNotesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.filter !== undefined) {
            StringValue.encode({ value: message.filter }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.user !== "") {
            writer.uint32(42).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetNotesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.filter = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            before: isSet(object.before) ? String(object.before) : undefined,
            filter: isSet(object.filter) ? String(object.filter) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            user: isSet(object.user) ? String(object.user) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.before !== undefined && (obj.before = message.before);
        message.filter !== undefined && (obj.filter = message.filter);
        message.limit !== undefined && (obj.limit = message.limit);
        message.user !== undefined && (obj.user = message.user);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetNotesRequest();
        message.subreddit = object.subreddit ?? "";
        message.before = object.before ?? undefined;
        message.filter = object.filter ?? undefined;
        message.limit = object.limit ?? undefined;
        message.user = object.user ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.GetNotesRequest", GetNotesRequest);
function createBasePostNotesRequest() {
    return { subreddit: "", label: "", note: "", redditId: undefined, user: "" };
}
export const PostNotesRequest = {
    $type: "devvit.plugin.redditapi.modnote.PostNotesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.label !== "") {
            writer.uint32(18).string(message.label);
        }
        if (message.note !== "") {
            writer.uint32(26).string(message.note);
        }
        if (message.redditId !== undefined) {
            StringValue.encode({ value: message.redditId }, writer.uint32(34).fork()).ldelim();
        }
        if (message.user !== "") {
            writer.uint32(42).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostNotesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.label = reader.string();
                    break;
                case 3:
                    message.note = reader.string();
                    break;
                case 4:
                    message.redditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            label: isSet(object.label) ? String(object.label) : "",
            note: isSet(object.note) ? String(object.note) : "",
            redditId: isSet(object.redditId) ? String(object.redditId) : undefined,
            user: isSet(object.user) ? String(object.user) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.label !== undefined && (obj.label = message.label);
        message.note !== undefined && (obj.note = message.note);
        message.redditId !== undefined && (obj.redditId = message.redditId);
        message.user !== undefined && (obj.user = message.user);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePostNotesRequest();
        message.subreddit = object.subreddit ?? "";
        message.label = object.label ?? "";
        message.note = object.note ?? "";
        message.redditId = object.redditId ?? undefined;
        message.user = object.user ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.PostNotesRequest", PostNotesRequest);
function createBaseRecentNotesRequest() {
    return { subreddits: "", users: "" };
}
export const RecentNotesRequest = {
    $type: "devvit.plugin.redditapi.modnote.RecentNotesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddits !== "") {
            writer.uint32(10).string(message.subreddits);
        }
        if (message.users !== "") {
            writer.uint32(18).string(message.users);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecentNotesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddits = reader.string();
                    break;
                case 2:
                    message.users = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddits: isSet(object.subreddits) ? String(object.subreddits) : "",
            users: isSet(object.users) ? String(object.users) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddits !== undefined && (obj.subreddits = message.subreddits);
        message.users !== undefined && (obj.users = message.users);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRecentNotesRequest();
        message.subreddits = object.subreddits ?? "";
        message.users = object.users ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.RecentNotesRequest", RecentNotesRequest);
function createBasePostRemovalNoteRequest() {
    return { itemIds: [], reasonId: "", modNote: undefined };
}
export const PostRemovalNoteRequest = {
    $type: "devvit.plugin.redditapi.modnote.PostRemovalNoteRequest",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.itemIds) {
            writer.uint32(10).string(v);
        }
        if (message.reasonId !== "") {
            writer.uint32(18).string(message.reasonId);
        }
        if (message.modNote !== undefined) {
            StringValue.encode({ value: message.modNote }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostRemovalNoteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemIds.push(reader.string());
                    break;
                case 2:
                    message.reasonId = reader.string();
                    break;
                case 3:
                    message.modNote = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            itemIds: Array.isArray(object?.itemIds) ? object.itemIds.map((e) => String(e)) : [],
            reasonId: isSet(object.reasonId) ? String(object.reasonId) : "",
            modNote: isSet(object.modNote) ? String(object.modNote) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.itemIds) {
            obj.itemIds = message.itemIds.map((e) => e);
        }
        else {
            obj.itemIds = [];
        }
        message.reasonId !== undefined && (obj.reasonId = message.reasonId);
        message.modNote !== undefined && (obj.modNote = message.modNote);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePostRemovalNoteRequest();
        message.itemIds = object.itemIds?.map((e) => e) || [];
        message.reasonId = object.reasonId ?? "";
        message.modNote = object.modNote ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.PostRemovalNoteRequest", PostRemovalNoteRequest);
function createBaseModNotesResponse() {
    return { modNotes: [], startCursor: undefined, endCursor: undefined, hasNextPage: undefined };
}
export const ModNotesResponse = {
    $type: "devvit.plugin.redditapi.modnote.ModNotesResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.modNotes) {
            ModNoteObject.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.startCursor !== undefined) {
            StringValue.encode({ value: message.startCursor }, writer.uint32(18).fork()).ldelim();
        }
        if (message.endCursor !== undefined) {
            StringValue.encode({ value: message.endCursor }, writer.uint32(26).fork()).ldelim();
        }
        if (message.hasNextPage !== undefined) {
            BoolValue.encode({ value: message.hasNextPage }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModNotesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.modNotes.push(ModNoteObject.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.startCursor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.endCursor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.hasNextPage = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            modNotes: Array.isArray(object?.modNotes) ? object.modNotes.map((e) => ModNoteObject.fromJSON(e)) : [],
            startCursor: isSet(object.startCursor) ? String(object.startCursor) : undefined,
            endCursor: isSet(object.endCursor) ? String(object.endCursor) : undefined,
            hasNextPage: isSet(object.hasNextPage) ? Boolean(object.hasNextPage) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.modNotes) {
            obj.modNotes = message.modNotes.map((e) => e ? ModNoteObject.toJSON(e) : undefined);
        }
        else {
            obj.modNotes = [];
        }
        message.startCursor !== undefined && (obj.startCursor = message.startCursor);
        message.endCursor !== undefined && (obj.endCursor = message.endCursor);
        message.hasNextPage !== undefined && (obj.hasNextPage = message.hasNextPage);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseModNotesResponse();
        message.modNotes = object.modNotes?.map((e) => ModNoteObject.fromPartial(e)) || [];
        message.startCursor = object.startCursor ?? undefined;
        message.endCursor = object.endCursor ?? undefined;
        message.hasNextPage = object.hasNextPage ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.ModNotesResponse", ModNotesResponse);
function createBaseDeleteNotesResponse() {
    return { deleted: undefined };
}
export const DeleteNotesResponse = {
    $type: "devvit.plugin.redditapi.modnote.DeleteNotesResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.deleted !== undefined) {
            BoolValue.encode({ value: message.deleted }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteNotesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.deleted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { deleted: isSet(object.deleted) ? Boolean(object.deleted) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.deleted !== undefined && (obj.deleted = message.deleted);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDeleteNotesResponse();
        message.deleted = object.deleted ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.DeleteNotesResponse", DeleteNotesResponse);
function createBaseModNoteObject() {
    return {
        subredditId: undefined,
        operatorId: undefined,
        modActionData: undefined,
        userNoteData: undefined,
        subreddit: undefined,
        user: undefined,
        operator: undefined,
        id: undefined,
        userId: undefined,
        createdAt: undefined,
        cursor: undefined,
        type: undefined,
    };
}
export const ModNoteObject = {
    $type: "devvit.plugin.redditapi.modnote.ModNoteObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.operatorId !== undefined) {
            StringValue.encode({ value: message.operatorId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.modActionData !== undefined) {
            ModNoteObject_ModActionData.encode(message.modActionData, writer.uint32(26).fork()).ldelim();
        }
        if (message.userNoteData !== undefined) {
            ModNoteObject_UserNoteData.encode(message.userNoteData, writer.uint32(34).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.user !== undefined) {
            StringValue.encode({ value: message.user }, writer.uint32(50).fork()).ldelim();
        }
        if (message.operator !== undefined) {
            StringValue.encode({ value: message.operator }, writer.uint32(58).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(66).fork()).ldelim();
        }
        if (message.userId !== undefined) {
            StringValue.encode({ value: message.userId }, writer.uint32(74).fork()).ldelim();
        }
        if (message.createdAt !== undefined) {
            Int64Value.encode({ value: message.createdAt }, writer.uint32(82).fork()).ldelim();
        }
        if (message.cursor !== undefined) {
            StringValue.encode({ value: message.cursor }, writer.uint32(90).fork()).ldelim();
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(98).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModNoteObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.operatorId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.modActionData = ModNoteObject_ModActionData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.userNoteData = ModNoteObject_UserNoteData.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.user = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.operator = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.userId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.createdAt = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.cursor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            operatorId: isSet(object.operatorId) ? String(object.operatorId) : undefined,
            modActionData: isSet(object.modActionData)
                ? ModNoteObject_ModActionData.fromJSON(object.modActionData)
                : undefined,
            userNoteData: isSet(object.userNoteData) ? ModNoteObject_UserNoteData.fromJSON(object.userNoteData) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            user: isSet(object.user) ? String(object.user) : undefined,
            operator: isSet(object.operator) ? String(object.operator) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            userId: isSet(object.userId) ? String(object.userId) : undefined,
            createdAt: isSet(object.createdAt) ? Number(object.createdAt) : undefined,
            cursor: isSet(object.cursor) ? String(object.cursor) : undefined,
            type: isSet(object.type) ? String(object.type) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subredditId !== undefined && (obj.subredditId = message.subredditId);
        message.operatorId !== undefined && (obj.operatorId = message.operatorId);
        message.modActionData !== undefined &&
            (obj.modActionData = message.modActionData
                ? ModNoteObject_ModActionData.toJSON(message.modActionData)
                : undefined);
        message.userNoteData !== undefined &&
            (obj.userNoteData = message.userNoteData ? ModNoteObject_UserNoteData.toJSON(message.userNoteData) : undefined);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.user !== undefined && (obj.user = message.user);
        message.operator !== undefined && (obj.operator = message.operator);
        message.id !== undefined && (obj.id = message.id);
        message.userId !== undefined && (obj.userId = message.userId);
        message.createdAt !== undefined && (obj.createdAt = message.createdAt);
        message.cursor !== undefined && (obj.cursor = message.cursor);
        message.type !== undefined && (obj.type = message.type);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseModNoteObject();
        message.subredditId = object.subredditId ?? undefined;
        message.operatorId = object.operatorId ?? undefined;
        message.modActionData = (object.modActionData !== undefined && object.modActionData !== null)
            ? ModNoteObject_ModActionData.fromPartial(object.modActionData)
            : undefined;
        message.userNoteData = (object.userNoteData !== undefined && object.userNoteData !== null)
            ? ModNoteObject_UserNoteData.fromPartial(object.userNoteData)
            : undefined;
        message.subreddit = object.subreddit ?? undefined;
        message.user = object.user ?? undefined;
        message.operator = object.operator ?? undefined;
        message.id = object.id ?? undefined;
        message.userId = object.userId ?? undefined;
        message.createdAt = object.createdAt ?? undefined;
        message.cursor = object.cursor ?? undefined;
        message.type = object.type ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.ModNoteObject", ModNoteObject);
function createBaseModNoteObject_ModActionData() {
    return { action: undefined, redditId: undefined, details: undefined, description: undefined };
}
export const ModNoteObject_ModActionData = {
    $type: "devvit.plugin.redditapi.modnote.ModNoteObject.ModActionData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.action !== undefined) {
            StringValue.encode({ value: message.action }, writer.uint32(10).fork()).ldelim();
        }
        if (message.redditId !== undefined) {
            StringValue.encode({ value: message.redditId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.details !== undefined) {
            StringValue.encode({ value: message.details }, writer.uint32(26).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModNoteObject_ModActionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.action = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.redditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.details = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            action: isSet(object.action) ? String(object.action) : undefined,
            redditId: isSet(object.redditId) ? String(object.redditId) : undefined,
            details: isSet(object.details) ? String(object.details) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.action !== undefined && (obj.action = message.action);
        message.redditId !== undefined && (obj.redditId = message.redditId);
        message.details !== undefined && (obj.details = message.details);
        message.description !== undefined && (obj.description = message.description);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseModNoteObject_ModActionData();
        message.action = object.action ?? undefined;
        message.redditId = object.redditId ?? undefined;
        message.details = object.details ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.ModNoteObject.ModActionData", ModNoteObject_ModActionData);
function createBaseModNoteObject_UserNoteData() {
    return { note: undefined, redditId: undefined, label: undefined };
}
export const ModNoteObject_UserNoteData = {
    $type: "devvit.plugin.redditapi.modnote.ModNoteObject.UserNoteData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.note !== undefined) {
            StringValue.encode({ value: message.note }, writer.uint32(10).fork()).ldelim();
        }
        if (message.redditId !== undefined) {
            StringValue.encode({ value: message.redditId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.label !== undefined) {
            StringValue.encode({ value: message.label }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModNoteObject_UserNoteData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.note = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.redditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.label = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            note: isSet(object.note) ? String(object.note) : undefined,
            redditId: isSet(object.redditId) ? String(object.redditId) : undefined,
            label: isSet(object.label) ? String(object.label) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.note !== undefined && (obj.note = message.note);
        message.redditId !== undefined && (obj.redditId = message.redditId);
        message.label !== undefined && (obj.label = message.label);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseModNoteObject_UserNoteData();
        message.note = object.note ?? undefined;
        message.redditId = object.redditId ?? undefined;
        message.label = object.label ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.ModNoteObject.UserNoteData", ModNoteObject_UserNoteData);
function createBasePostModNotesResponse() {
    return { created: undefined };
}
export const PostModNotesResponse = {
    $type: "devvit.plugin.redditapi.modnote.PostModNotesResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.created !== undefined) {
            ModNoteObject.encode(message.created, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostModNotesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.created = ModNoteObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { created: isSet(object.created) ? ModNoteObject.fromJSON(object.created) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.created !== undefined &&
            (obj.created = message.created ? ModNoteObject.toJSON(message.created) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePostModNotesResponse();
        message.created = (object.created !== undefined && object.created !== null)
            ? ModNoteObject.fromPartial(object.created)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.PostModNotesResponse", PostModNotesResponse);
function isSet(value) {
    return value !== null && value !== undefined;
}
