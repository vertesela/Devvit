/**
 * #listings_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { Listing } from '../common/common_msg.js';
function createBaseGetBestRequest() {
    return { after: undefined, before: undefined, count: undefined, limit: undefined, show: undefined };
}
export const GetBestRequest = {
    $type: "devvit.plugin.redditapi.listings.GetBestRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetBestRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.count !== undefined && (obj.count = message.count);
        message.limit !== undefined && (obj.limit = message.limit);
        message.show !== undefined && (obj.show = message.show);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetBestRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetBestRequest", GetBestRequest);
function createBaseGetSortRequest() {
    return {
        subreddit: undefined,
        sort: "",
        after: undefined,
        before: undefined,
        limit: undefined,
        count: undefined,
        show: undefined,
        t: undefined,
    };
}
export const GetSortRequest = {
    $type: "devvit.plugin.redditapi.listings.GetSortRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
        }
        if (message.sort !== "") {
            writer.uint32(18).string(message.sort);
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(34).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
        }
        if (message.t !== undefined) {
            StringValue.encode({ value: message.t }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSortRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.sort = reader.string();
                    break;
                case 3:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.t = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : "",
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            t: isSet(object.t) ? String(object.t) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.sort !== undefined && (obj.sort = message.sort);
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.limit !== undefined && (obj.limit = message.limit);
        message.count !== undefined && (obj.count = message.count);
        message.show !== undefined && (obj.show = message.show);
        message.t !== undefined && (obj.t = message.t);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetSortRequest();
        message.subreddit = object.subreddit ?? undefined;
        message.sort = object.sort ?? "";
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.limit = object.limit ?? undefined;
        message.count = object.count ?? undefined;
        message.show = object.show ?? undefined;
        message.t = object.t ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetSortRequest", GetSortRequest);
function createBaseGetCommentsRequest() {
    return {
        article: "",
        comment: undefined,
        context: undefined,
        depth: undefined,
        limit: undefined,
        sort: undefined,
        threaded: undefined,
        truncate: undefined,
    };
}
export const GetCommentsRequest = {
    $type: "devvit.plugin.redditapi.listings.GetCommentsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.article !== "") {
            writer.uint32(10).string(message.article);
        }
        if (message.comment !== undefined) {
            StringValue.encode({ value: message.comment }, writer.uint32(18).fork()).ldelim();
        }
        if (message.context !== undefined) {
            Int64Value.encode({ value: message.context }, writer.uint32(26).fork()).ldelim();
        }
        if (message.depth !== undefined) {
            Int64Value.encode({ value: message.depth }, writer.uint32(34).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(50).fork()).ldelim();
        }
        if (message.threaded !== undefined) {
            BoolValue.encode({ value: message.threaded }, writer.uint32(58).fork()).ldelim();
        }
        if (message.truncate !== undefined) {
            Int64Value.encode({ value: message.truncate }, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetCommentsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.article = reader.string();
                    break;
                case 2:
                    message.comment = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.context = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.depth = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.threaded = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.truncate = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            article: isSet(object.article) ? String(object.article) : "",
            comment: isSet(object.comment) ? String(object.comment) : undefined,
            context: isSet(object.context) ? Number(object.context) : undefined,
            depth: isSet(object.depth) ? Number(object.depth) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            threaded: isSet(object.threaded) ? Boolean(object.threaded) : undefined,
            truncate: isSet(object.truncate) ? Number(object.truncate) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.article !== undefined && (obj.article = message.article);
        message.comment !== undefined && (obj.comment = message.comment);
        message.context !== undefined && (obj.context = message.context);
        message.depth !== undefined && (obj.depth = message.depth);
        message.limit !== undefined && (obj.limit = message.limit);
        message.sort !== undefined && (obj.sort = message.sort);
        message.threaded !== undefined && (obj.threaded = message.threaded);
        message.truncate !== undefined && (obj.truncate = message.truncate);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetCommentsRequest();
        message.article = object.article ?? "";
        message.comment = object.comment ?? undefined;
        message.context = object.context ?? undefined;
        message.depth = object.depth ?? undefined;
        message.limit = object.limit ?? undefined;
        message.sort = object.sort ?? undefined;
        message.threaded = object.threaded ?? undefined;
        message.truncate = object.truncate ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetCommentsRequest", GetCommentsRequest);
function createBaseGetByIdRequest() {
    return { postIds: "" };
}
export const GetByIdRequest = {
    $type: "devvit.plugin.redditapi.listings.GetByIdRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.postIds !== "") {
            writer.uint32(10).string(message.postIds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetByIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.postIds = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { postIds: isSet(object.postIds) ? String(object.postIds) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.postIds !== undefined && (obj.postIds = message.postIds);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetByIdRequest();
        message.postIds = object.postIds ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetByIdRequest", GetByIdRequest);
function createBaseGetDuplicatesRequest() {
    return {
        article: "",
        before: undefined,
        after: undefined,
        limit: undefined,
        sort: undefined,
        sr: undefined,
        count: undefined,
        crosspostsOnly: undefined,
        show: undefined,
    };
}
export const GetDuplicatesRequest = {
    $type: "devvit.plugin.redditapi.listings.GetDuplicatesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.article !== "") {
            writer.uint32(10).string(message.article);
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(42).fork()).ldelim();
        }
        if (message.sr !== undefined) {
            StringValue.encode({ value: message.sr }, writer.uint32(50).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(58).fork()).ldelim();
        }
        if (message.crosspostsOnly !== undefined) {
            BoolValue.encode({ value: message.crosspostsOnly }, writer.uint32(66).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetDuplicatesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.article = reader.string();
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.sr = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.crosspostsOnly = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            article: isSet(object.article) ? String(object.article) : "",
            before: isSet(object.before) ? String(object.before) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            sr: isSet(object.sr) ? String(object.sr) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            crosspostsOnly: isSet(object.crosspostsOnly) ? Boolean(object.crosspostsOnly) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.article !== undefined && (obj.article = message.article);
        message.before !== undefined && (obj.before = message.before);
        message.after !== undefined && (obj.after = message.after);
        message.limit !== undefined && (obj.limit = message.limit);
        message.sort !== undefined && (obj.sort = message.sort);
        message.sr !== undefined && (obj.sr = message.sr);
        message.count !== undefined && (obj.count = message.count);
        message.crosspostsOnly !== undefined && (obj.crosspostsOnly = message.crosspostsOnly);
        message.show !== undefined && (obj.show = message.show);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetDuplicatesRequest();
        message.article = object.article ?? "";
        message.before = object.before ?? undefined;
        message.after = object.after ?? undefined;
        message.limit = object.limit ?? undefined;
        message.sort = object.sort ?? undefined;
        message.sr = object.sr ?? undefined;
        message.count = object.count ?? undefined;
        message.crosspostsOnly = object.crosspostsOnly ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetDuplicatesRequest", GetDuplicatesRequest);
function createBaseGetHotRequest() {
    return {
        subreddit: undefined,
        before: undefined,
        after: undefined,
        limit: undefined,
        count: undefined,
        show: undefined,
        g: undefined,
    };
}
export const GetHotRequest = {
    $type: "devvit.plugin.redditapi.listings.GetHotRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
        }
        if (message.g !== undefined) {
            StringValue.encode({ value: message.g }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetHotRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.g = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            g: isSet(object.g) ? String(object.g) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.before !== undefined && (obj.before = message.before);
        message.after !== undefined && (obj.after = message.after);
        message.limit !== undefined && (obj.limit = message.limit);
        message.count !== undefined && (obj.count = message.count);
        message.show !== undefined && (obj.show = message.show);
        message.g !== undefined && (obj.g = message.g);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetHotRequest();
        message.subreddit = object.subreddit ?? undefined;
        message.before = object.before ?? undefined;
        message.after = object.after ?? undefined;
        message.limit = object.limit ?? undefined;
        message.count = object.count ?? undefined;
        message.show = object.show ?? undefined;
        message.g = object.g ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetHotRequest", GetHotRequest);
function createBaseGetNewRequest() {
    return {
        subreddit: undefined,
        before: undefined,
        after: undefined,
        limit: undefined,
        count: undefined,
        show: undefined,
    };
}
export const GetNewRequest = {
    $type: "devvit.plugin.redditapi.listings.GetNewRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetNewRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.before !== undefined && (obj.before = message.before);
        message.after !== undefined && (obj.after = message.after);
        message.limit !== undefined && (obj.limit = message.limit);
        message.count !== undefined && (obj.count = message.count);
        message.show !== undefined && (obj.show = message.show);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetNewRequest();
        message.subreddit = object.subreddit ?? undefined;
        message.before = object.before ?? undefined;
        message.after = object.after ?? undefined;
        message.limit = object.limit ?? undefined;
        message.count = object.count ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetNewRequest", GetNewRequest);
function createBaseGetRisingRequest() {
    return {
        subreddit: undefined,
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        show: undefined,
    };
}
export const GetRisingRequest = {
    $type: "devvit.plugin.redditapi.listings.GetRisingRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(34).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetRisingRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.count !== undefined && (obj.count = message.count);
        message.limit !== undefined && (obj.limit = message.limit);
        message.show !== undefined && (obj.show = message.show);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetRisingRequest();
        message.subreddit = object.subreddit ?? undefined;
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetRisingRequest", GetRisingRequest);
function createBaseListingResponse() {
    return { listings: [] };
}
export const ListingResponse = {
    $type: "devvit.plugin.redditapi.listings.ListingResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.listings) {
            Listing.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListingResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.listings.push(Listing.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { listings: Array.isArray(object?.listings) ? object.listings.map((e) => Listing.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.listings) {
            obj.listings = message.listings.map((e) => e ? Listing.toJSON(e) : undefined);
        }
        else {
            obj.listings = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseListingResponse();
        message.listings = object.listings?.map((e) => Listing.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.ListingResponse", ListingResponse);
function isSet(value) {
    return value !== null && value !== undefined;
}
