/**
 * #common.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int32Value, Int64Value, StringValue } from '../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../typeRegistry.js';
export var BanInfo_BanInfoAction;
(function (BanInfo_BanInfoAction) {
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["UNKNOWN"] = 0] = "UNKNOWN";
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["SPAM"] = 1] = "SPAM";
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["FILTER"] = 2] = "FILTER";
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["REMOVE"] = 3] = "REMOVE";
    BanInfo_BanInfoAction[BanInfo_BanInfoAction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BanInfo_BanInfoAction || (BanInfo_BanInfoAction = {}));
export function banInfo_BanInfoActionFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return BanInfo_BanInfoAction.UNKNOWN;
        case 1:
        case "SPAM":
            return BanInfo_BanInfoAction.SPAM;
        case 2:
        case "FILTER":
            return BanInfo_BanInfoAction.FILTER;
        case 3:
        case "REMOVE":
            return BanInfo_BanInfoAction.REMOVE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BanInfo_BanInfoAction.UNRECOGNIZED;
    }
}
export function banInfo_BanInfoActionToJSON(object) {
    switch (object) {
        case BanInfo_BanInfoAction.UNKNOWN:
            return 0;
        case BanInfo_BanInfoAction.SPAM:
            return 1;
        case BanInfo_BanInfoAction.FILTER:
            return 2;
        case BanInfo_BanInfoAction.REMOVE:
            return 3;
        case BanInfo_BanInfoAction.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseAuthorFlairRichText() {
    return { e: undefined, t: undefined };
}
export const AuthorFlairRichText = {
    $type: "devvit.reddit.AuthorFlairRichText",
    encode(message, writer = _m0.Writer.create()) {
        if (message.e !== undefined) {
            StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
        }
        if (message.t !== undefined) {
            StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthorFlairRichText();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.e = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.t = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { e: isSet(object.e) ? String(object.e) : undefined, t: isSet(object.t) ? String(object.t) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.e !== undefined && (obj.e = message.e);
        message.t !== undefined && (obj.t = message.t);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAuthorFlairRichText();
        message.e = object.e ?? undefined;
        message.t = object.t ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.AuthorFlairRichText", AuthorFlairRichText);
function createBaseAwarding() {
    return {
        awardSubType: undefined,
        awardType: undefined,
        awardingsRequiredToGrantBenefits: undefined,
        coinPrice: undefined,
        coinReward: undefined,
        count: undefined,
        daysOfDripExtension: undefined,
        daysOfPremium: undefined,
        description: undefined,
        endDate: undefined,
        giverCoinReward: undefined,
        iconFormat: undefined,
        iconHeight: undefined,
        iconUrl: undefined,
        iconWidth: undefined,
        id: undefined,
        isEnabled: undefined,
        isNew: undefined,
        name: undefined,
        pennyDonate: undefined,
        pennyPrice: undefined,
        resizedIcons: [],
        resizedStaticIcons: [],
        startDate: undefined,
        staticIconHeight: undefined,
        staticIconUrl: undefined,
        staticIconWidth: undefined,
        stickyDurationSeconds: undefined,
        subredditCoinReward: undefined,
        subredditId: undefined,
        tiersByRequiredAwardings: undefined,
    };
}
export const Awarding = {
    $type: "devvit.reddit.Awarding",
    encode(message, writer = _m0.Writer.create()) {
        if (message.awardSubType !== undefined) {
            StringValue.encode({ value: message.awardSubType }, writer.uint32(10).fork()).ldelim();
        }
        if (message.awardType !== undefined) {
            StringValue.encode({ value: message.awardType }, writer.uint32(18).fork()).ldelim();
        }
        if (message.awardingsRequiredToGrantBenefits !== undefined) {
            Int32Value.encode({ value: message.awardingsRequiredToGrantBenefits }, writer.uint32(26).fork()).ldelim();
        }
        if (message.coinPrice !== undefined) {
            Int64Value.encode({ value: message.coinPrice }, writer.uint32(34).fork()).ldelim();
        }
        if (message.coinReward !== undefined) {
            Int64Value.encode({ value: message.coinReward }, writer.uint32(42).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int32Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
        }
        if (message.daysOfDripExtension !== undefined) {
            Int32Value.encode({ value: message.daysOfDripExtension }, writer.uint32(58).fork()).ldelim();
        }
        if (message.daysOfPremium !== undefined) {
            Int32Value.encode({ value: message.daysOfPremium }, writer.uint32(66).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(74).fork()).ldelim();
        }
        if (message.endDate !== undefined) {
            StringValue.encode({ value: message.endDate }, writer.uint32(82).fork()).ldelim();
        }
        if (message.giverCoinReward !== undefined) {
            Int32Value.encode({ value: message.giverCoinReward }, writer.uint32(90).fork()).ldelim();
        }
        if (message.iconFormat !== undefined) {
            StringValue.encode({ value: message.iconFormat }, writer.uint32(98).fork()).ldelim();
        }
        if (message.iconHeight !== undefined) {
            Int32Value.encode({ value: message.iconHeight }, writer.uint32(106).fork()).ldelim();
        }
        if (message.iconUrl !== undefined) {
            StringValue.encode({ value: message.iconUrl }, writer.uint32(114).fork()).ldelim();
        }
        if (message.iconWidth !== undefined) {
            Int32Value.encode({ value: message.iconWidth }, writer.uint32(122).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(130).fork()).ldelim();
        }
        if (message.isEnabled !== undefined) {
            BoolValue.encode({ value: message.isEnabled }, writer.uint32(138).fork()).ldelim();
        }
        if (message.isNew !== undefined) {
            BoolValue.encode({ value: message.isNew }, writer.uint32(146).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(154).fork()).ldelim();
        }
        if (message.pennyDonate !== undefined) {
            Int32Value.encode({ value: message.pennyDonate }, writer.uint32(162).fork()).ldelim();
        }
        if (message.pennyPrice !== undefined) {
            Int32Value.encode({ value: message.pennyPrice }, writer.uint32(170).fork()).ldelim();
        }
        for (const v of message.resizedIcons) {
            Awarding_Icon.encode(v, writer.uint32(178).fork()).ldelim();
        }
        for (const v of message.resizedStaticIcons) {
            Awarding_Icon.encode(v, writer.uint32(186).fork()).ldelim();
        }
        if (message.startDate !== undefined) {
            StringValue.encode({ value: message.startDate }, writer.uint32(194).fork()).ldelim();
        }
        if (message.staticIconHeight !== undefined) {
            Int32Value.encode({ value: message.staticIconHeight }, writer.uint32(202).fork()).ldelim();
        }
        if (message.staticIconUrl !== undefined) {
            StringValue.encode({ value: message.staticIconUrl }, writer.uint32(210).fork()).ldelim();
        }
        if (message.staticIconWidth !== undefined) {
            Int32Value.encode({ value: message.staticIconWidth }, writer.uint32(218).fork()).ldelim();
        }
        if (message.stickyDurationSeconds !== undefined) {
            Int64Value.encode({ value: message.stickyDurationSeconds }, writer.uint32(226).fork()).ldelim();
        }
        if (message.subredditCoinReward !== undefined) {
            Int64Value.encode({ value: message.subredditCoinReward }, writer.uint32(234).fork()).ldelim();
        }
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(242).fork()).ldelim();
        }
        if (message.tiersByRequiredAwardings !== undefined) {
            StringValue.encode({ value: message.tiersByRequiredAwardings }, writer.uint32(250).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAwarding();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.awardSubType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.awardType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.awardingsRequiredToGrantBenefits = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.coinPrice = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.coinReward = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.count = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.daysOfDripExtension = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.daysOfPremium = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.endDate = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.giverCoinReward = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.iconFormat = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.iconHeight = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.iconUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.iconWidth = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.isEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.isNew = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.pennyDonate = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.pennyPrice = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.resizedIcons.push(Awarding_Icon.decode(reader, reader.uint32()));
                    break;
                case 23:
                    message.resizedStaticIcons.push(Awarding_Icon.decode(reader, reader.uint32()));
                    break;
                case 24:
                    message.startDate = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.staticIconHeight = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 26:
                    message.staticIconUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 27:
                    message.staticIconWidth = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 28:
                    message.stickyDurationSeconds = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 29:
                    message.subredditCoinReward = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 30:
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 31:
                    message.tiersByRequiredAwardings = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            awardSubType: isSet(object.awardSubType) ? String(object.awardSubType) : undefined,
            awardType: isSet(object.awardType) ? String(object.awardType) : undefined,
            awardingsRequiredToGrantBenefits: isSet(object.awardingsRequiredToGrantBenefits)
                ? Number(object.awardingsRequiredToGrantBenefits)
                : undefined,
            coinPrice: isSet(object.coinPrice) ? Number(object.coinPrice) : undefined,
            coinReward: isSet(object.coinReward) ? Number(object.coinReward) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            daysOfDripExtension: isSet(object.daysOfDripExtension) ? Number(object.daysOfDripExtension) : undefined,
            daysOfPremium: isSet(object.daysOfPremium) ? Number(object.daysOfPremium) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            endDate: isSet(object.endDate) ? String(object.endDate) : undefined,
            giverCoinReward: isSet(object.giverCoinReward) ? Number(object.giverCoinReward) : undefined,
            iconFormat: isSet(object.iconFormat) ? String(object.iconFormat) : undefined,
            iconHeight: isSet(object.iconHeight) ? Number(object.iconHeight) : undefined,
            iconUrl: isSet(object.iconUrl) ? String(object.iconUrl) : undefined,
            iconWidth: isSet(object.iconWidth) ? Number(object.iconWidth) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            isEnabled: isSet(object.isEnabled) ? Boolean(object.isEnabled) : undefined,
            isNew: isSet(object.isNew) ? Boolean(object.isNew) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            pennyDonate: isSet(object.pennyDonate) ? Number(object.pennyDonate) : undefined,
            pennyPrice: isSet(object.pennyPrice) ? Number(object.pennyPrice) : undefined,
            resizedIcons: Array.isArray(object?.resizedIcons)
                ? object.resizedIcons.map((e) => Awarding_Icon.fromJSON(e))
                : [],
            resizedStaticIcons: Array.isArray(object?.resizedStaticIcons)
                ? object.resizedStaticIcons.map((e) => Awarding_Icon.fromJSON(e))
                : [],
            startDate: isSet(object.startDate) ? String(object.startDate) : undefined,
            staticIconHeight: isSet(object.staticIconHeight) ? Number(object.staticIconHeight) : undefined,
            staticIconUrl: isSet(object.staticIconUrl) ? String(object.staticIconUrl) : undefined,
            staticIconWidth: isSet(object.staticIconWidth) ? Number(object.staticIconWidth) : undefined,
            stickyDurationSeconds: isSet(object.stickyDurationSeconds) ? Number(object.stickyDurationSeconds) : undefined,
            subredditCoinReward: isSet(object.subredditCoinReward) ? Number(object.subredditCoinReward) : undefined,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            tiersByRequiredAwardings: isSet(object.tiersByRequiredAwardings)
                ? String(object.tiersByRequiredAwardings)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.awardSubType !== undefined && (obj.awardSubType = message.awardSubType);
        message.awardType !== undefined && (obj.awardType = message.awardType);
        message.awardingsRequiredToGrantBenefits !== undefined &&
            (obj.awardingsRequiredToGrantBenefits = message.awardingsRequiredToGrantBenefits);
        message.coinPrice !== undefined && (obj.coinPrice = message.coinPrice);
        message.coinReward !== undefined && (obj.coinReward = message.coinReward);
        message.count !== undefined && (obj.count = message.count);
        message.daysOfDripExtension !== undefined && (obj.daysOfDripExtension = message.daysOfDripExtension);
        message.daysOfPremium !== undefined && (obj.daysOfPremium = message.daysOfPremium);
        message.description !== undefined && (obj.description = message.description);
        message.endDate !== undefined && (obj.endDate = message.endDate);
        message.giverCoinReward !== undefined && (obj.giverCoinReward = message.giverCoinReward);
        message.iconFormat !== undefined && (obj.iconFormat = message.iconFormat);
        message.iconHeight !== undefined && (obj.iconHeight = message.iconHeight);
        message.iconUrl !== undefined && (obj.iconUrl = message.iconUrl);
        message.iconWidth !== undefined && (obj.iconWidth = message.iconWidth);
        message.id !== undefined && (obj.id = message.id);
        message.isEnabled !== undefined && (obj.isEnabled = message.isEnabled);
        message.isNew !== undefined && (obj.isNew = message.isNew);
        message.name !== undefined && (obj.name = message.name);
        message.pennyDonate !== undefined && (obj.pennyDonate = message.pennyDonate);
        message.pennyPrice !== undefined && (obj.pennyPrice = message.pennyPrice);
        if (message.resizedIcons) {
            obj.resizedIcons = message.resizedIcons.map((e) => e ? Awarding_Icon.toJSON(e) : undefined);
        }
        else {
            obj.resizedIcons = [];
        }
        if (message.resizedStaticIcons) {
            obj.resizedStaticIcons = message.resizedStaticIcons.map((e) => e ? Awarding_Icon.toJSON(e) : undefined);
        }
        else {
            obj.resizedStaticIcons = [];
        }
        message.startDate !== undefined && (obj.startDate = message.startDate);
        message.staticIconHeight !== undefined && (obj.staticIconHeight = message.staticIconHeight);
        message.staticIconUrl !== undefined && (obj.staticIconUrl = message.staticIconUrl);
        message.staticIconWidth !== undefined && (obj.staticIconWidth = message.staticIconWidth);
        message.stickyDurationSeconds !== undefined && (obj.stickyDurationSeconds = message.stickyDurationSeconds);
        message.subredditCoinReward !== undefined && (obj.subredditCoinReward = message.subredditCoinReward);
        message.subredditId !== undefined && (obj.subredditId = message.subredditId);
        message.tiersByRequiredAwardings !== undefined && (obj.tiersByRequiredAwardings = message.tiersByRequiredAwardings);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAwarding();
        message.awardSubType = object.awardSubType ?? undefined;
        message.awardType = object.awardType ?? undefined;
        message.awardingsRequiredToGrantBenefits = object.awardingsRequiredToGrantBenefits ?? undefined;
        message.coinPrice = object.coinPrice ?? undefined;
        message.coinReward = object.coinReward ?? undefined;
        message.count = object.count ?? undefined;
        message.daysOfDripExtension = object.daysOfDripExtension ?? undefined;
        message.daysOfPremium = object.daysOfPremium ?? undefined;
        message.description = object.description ?? undefined;
        message.endDate = object.endDate ?? undefined;
        message.giverCoinReward = object.giverCoinReward ?? undefined;
        message.iconFormat = object.iconFormat ?? undefined;
        message.iconHeight = object.iconHeight ?? undefined;
        message.iconUrl = object.iconUrl ?? undefined;
        message.iconWidth = object.iconWidth ?? undefined;
        message.id = object.id ?? undefined;
        message.isEnabled = object.isEnabled ?? undefined;
        message.isNew = object.isNew ?? undefined;
        message.name = object.name ?? undefined;
        message.pennyDonate = object.pennyDonate ?? undefined;
        message.pennyPrice = object.pennyPrice ?? undefined;
        message.resizedIcons = object.resizedIcons?.map((e) => Awarding_Icon.fromPartial(e)) || [];
        message.resizedStaticIcons = object.resizedStaticIcons?.map((e) => Awarding_Icon.fromPartial(e)) || [];
        message.startDate = object.startDate ?? undefined;
        message.staticIconHeight = object.staticIconHeight ?? undefined;
        message.staticIconUrl = object.staticIconUrl ?? undefined;
        message.staticIconWidth = object.staticIconWidth ?? undefined;
        message.stickyDurationSeconds = object.stickyDurationSeconds ?? undefined;
        message.subredditCoinReward = object.subredditCoinReward ?? undefined;
        message.subredditId = object.subredditId ?? undefined;
        message.tiersByRequiredAwardings = object.tiersByRequiredAwardings ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.Awarding", Awarding);
function createBaseAwarding_Icon() {
    return { height: undefined, url: undefined, width: undefined };
}
export const Awarding_Icon = {
    $type: "devvit.reddit.Awarding.Icon",
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(10).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAwarding_Icon();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet(object.height) ? Number(object.height) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.height !== undefined && (obj.height = message.height);
        message.url !== undefined && (obj.url = message.url);
        message.width !== undefined && (obj.width = message.width);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAwarding_Icon();
        message.height = object.height ?? undefined;
        message.url = object.url ?? undefined;
        message.width = object.width ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.Awarding.Icon", Awarding_Icon);
function createBaseCommentContributionSettings() {
    return { allowedMediaTypes: [] };
}
export const CommentContributionSettings = {
    $type: "devvit.reddit.CommentContributionSettings",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.allowedMediaTypes) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommentContributionSettings();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.allowedMediaTypes.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            allowedMediaTypes: Array.isArray(object?.allowedMediaTypes)
                ? object.allowedMediaTypes.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.allowedMediaTypes) {
            obj.allowedMediaTypes = message.allowedMediaTypes.map((e) => e);
        }
        else {
            obj.allowedMediaTypes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCommentContributionSettings();
        message.allowedMediaTypes = object.allowedMediaTypes?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.CommentContributionSettings", CommentContributionSettings);
function createBaseGildings() {
    return { gid1: undefined, gid2: undefined, gid3: undefined };
}
export const Gildings = {
    $type: "devvit.reddit.Gildings",
    encode(message, writer = _m0.Writer.create()) {
        if (message.gid1 !== undefined) {
            Int32Value.encode({ value: message.gid1 }, writer.uint32(10).fork()).ldelim();
        }
        if (message.gid2 !== undefined) {
            Int32Value.encode({ value: message.gid2 }, writer.uint32(18).fork()).ldelim();
        }
        if (message.gid3 !== undefined) {
            Int32Value.encode({ value: message.gid3 }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGildings();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gid1 = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.gid2 = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.gid3 = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            gid1: isSet(object.gid1) ? Number(object.gid1) : undefined,
            gid2: isSet(object.gid2) ? Number(object.gid2) : undefined,
            gid3: isSet(object.gid3) ? Number(object.gid3) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.gid1 !== undefined && (obj.gid1 = message.gid1);
        message.gid2 !== undefined && (obj.gid2 = message.gid2);
        message.gid3 !== undefined && (obj.gid3 = message.gid3);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGildings();
        message.gid1 = object.gid1 ?? undefined;
        message.gid2 = object.gid2 ?? undefined;
        message.gid3 = object.gid3 ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.Gildings", Gildings);
function createBaseMediaEmbed() {
    return {
        content: undefined,
        width: undefined,
        height: undefined,
        sandbox: undefined,
        scrolling: undefined,
        publicThumbnailUrl: undefined,
    };
}
export const MediaEmbed = {
    $type: "devvit.reddit.MediaEmbed",
    encode(message, writer = _m0.Writer.create()) {
        if (message.content !== undefined) {
            StringValue.encode({ value: message.content }, writer.uint32(10).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(26).fork()).ldelim();
        }
        if (message.sandbox !== undefined) {
            BoolValue.encode({ value: message.sandbox }, writer.uint32(34).fork()).ldelim();
        }
        if (message.scrolling !== undefined) {
            BoolValue.encode({ value: message.scrolling }, writer.uint32(42).fork()).ldelim();
        }
        if (message.publicThumbnailUrl !== undefined) {
            StringValue.encode({ value: message.publicThumbnailUrl }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMediaEmbed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.content = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.sandbox = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.scrolling = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.publicThumbnailUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            content: isSet(object.content) ? String(object.content) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
            sandbox: isSet(object.sandbox) ? Boolean(object.sandbox) : undefined,
            scrolling: isSet(object.scrolling) ? Boolean(object.scrolling) : undefined,
            publicThumbnailUrl: isSet(object.publicThumbnailUrl) ? String(object.publicThumbnailUrl) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.content !== undefined && (obj.content = message.content);
        message.width !== undefined && (obj.width = message.width);
        message.height !== undefined && (obj.height = message.height);
        message.sandbox !== undefined && (obj.sandbox = message.sandbox);
        message.scrolling !== undefined && (obj.scrolling = message.scrolling);
        message.publicThumbnailUrl !== undefined && (obj.publicThumbnailUrl = message.publicThumbnailUrl);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMediaEmbed();
        message.content = object.content ?? undefined;
        message.width = object.width ?? undefined;
        message.height = object.height ?? undefined;
        message.sandbox = object.sandbox ?? undefined;
        message.scrolling = object.scrolling ?? undefined;
        message.publicThumbnailUrl = object.publicThumbnailUrl ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.MediaEmbed", MediaEmbed);
function createBaseUserFlairRichtext() {
    return { e: undefined, t: undefined };
}
export const UserFlairRichtext = {
    $type: "devvit.reddit.UserFlairRichtext",
    encode(message, writer = _m0.Writer.create()) {
        if (message.e !== undefined) {
            StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
        }
        if (message.t !== undefined) {
            StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserFlairRichtext();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.e = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.t = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { e: isSet(object.e) ? String(object.e) : undefined, t: isSet(object.t) ? String(object.t) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.e !== undefined && (obj.e = message.e);
        message.t !== undefined && (obj.t = message.t);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUserFlairRichtext();
        message.e = object.e ?? undefined;
        message.t = object.t ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.UserFlairRichtext", UserFlairRichtext);
function createBaseBanInfo() {
    return {
        auto: undefined,
        bannedAt: undefined,
        banner: undefined,
        moderatorBanned: undefined,
        note: undefined,
        unbanner: undefined,
        unbannedAt: undefined,
        resetUsed: undefined,
        reasonId: undefined,
        reasonTitle: undefined,
        reasonMessage: undefined,
        reasonBy: undefined,
        modNote: undefined,
        banAllTriggered: undefined,
        subredditMessage: undefined,
        removeAction: 0,
    };
}
export const BanInfo = {
    $type: "devvit.reddit.BanInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.auto !== undefined) {
            BoolValue.encode({ value: message.auto }, writer.uint32(10).fork()).ldelim();
        }
        if (message.bannedAt !== undefined) {
            Int32Value.encode({ value: message.bannedAt }, writer.uint32(18).fork()).ldelim();
        }
        if (message.banner !== undefined) {
            StringValue.encode({ value: message.banner }, writer.uint32(26).fork()).ldelim();
        }
        if (message.moderatorBanned !== undefined) {
            BoolValue.encode({ value: message.moderatorBanned }, writer.uint32(34).fork()).ldelim();
        }
        if (message.note !== undefined) {
            StringValue.encode({ value: message.note }, writer.uint32(42).fork()).ldelim();
        }
        if (message.unbanner !== undefined) {
            StringValue.encode({ value: message.unbanner }, writer.uint32(50).fork()).ldelim();
        }
        if (message.unbannedAt !== undefined) {
            Int32Value.encode({ value: message.unbannedAt }, writer.uint32(58).fork()).ldelim();
        }
        if (message.resetUsed !== undefined) {
            BoolValue.encode({ value: message.resetUsed }, writer.uint32(66).fork()).ldelim();
        }
        if (message.reasonId !== undefined) {
            StringValue.encode({ value: message.reasonId }, writer.uint32(74).fork()).ldelim();
        }
        if (message.reasonTitle !== undefined) {
            StringValue.encode({ value: message.reasonTitle }, writer.uint32(82).fork()).ldelim();
        }
        if (message.reasonMessage !== undefined) {
            StringValue.encode({ value: message.reasonMessage }, writer.uint32(90).fork()).ldelim();
        }
        if (message.reasonBy !== undefined) {
            StringValue.encode({ value: message.reasonBy }, writer.uint32(98).fork()).ldelim();
        }
        if (message.modNote !== undefined) {
            StringValue.encode({ value: message.modNote }, writer.uint32(106).fork()).ldelim();
        }
        if (message.banAllTriggered !== undefined) {
            BoolValue.encode({ value: message.banAllTriggered }, writer.uint32(114).fork()).ldelim();
        }
        if (message.subredditMessage !== undefined) {
            StringValue.encode({ value: message.subredditMessage }, writer.uint32(122).fork()).ldelim();
        }
        if (message.removeAction !== 0) {
            writer.uint32(128).int32(message.removeAction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBanInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.auto = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.bannedAt = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.banner = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.moderatorBanned = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.note = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.unbanner = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.unbannedAt = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.resetUsed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.reasonId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.reasonTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.reasonMessage = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.reasonBy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.modNote = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.banAllTriggered = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.subredditMessage = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.removeAction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            auto: isSet(object.auto) ? Boolean(object.auto) : undefined,
            bannedAt: isSet(object.bannedAt) ? Number(object.bannedAt) : undefined,
            banner: isSet(object.banner) ? String(object.banner) : undefined,
            moderatorBanned: isSet(object.moderatorBanned) ? Boolean(object.moderatorBanned) : undefined,
            note: isSet(object.note) ? String(object.note) : undefined,
            unbanner: isSet(object.unbanner) ? String(object.unbanner) : undefined,
            unbannedAt: isSet(object.unbannedAt) ? Number(object.unbannedAt) : undefined,
            resetUsed: isSet(object.resetUsed) ? Boolean(object.resetUsed) : undefined,
            reasonId: isSet(object.reasonId) ? String(object.reasonId) : undefined,
            reasonTitle: isSet(object.reasonTitle) ? String(object.reasonTitle) : undefined,
            reasonMessage: isSet(object.reasonMessage) ? String(object.reasonMessage) : undefined,
            reasonBy: isSet(object.reasonBy) ? String(object.reasonBy) : undefined,
            modNote: isSet(object.modNote) ? String(object.modNote) : undefined,
            banAllTriggered: isSet(object.banAllTriggered) ? Boolean(object.banAllTriggered) : undefined,
            subredditMessage: isSet(object.subredditMessage) ? String(object.subredditMessage) : undefined,
            removeAction: isSet(object.removeAction) ? banInfo_BanInfoActionFromJSON(object.removeAction) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.auto !== undefined && (obj.auto = message.auto);
        message.bannedAt !== undefined && (obj.bannedAt = message.bannedAt);
        message.banner !== undefined && (obj.banner = message.banner);
        message.moderatorBanned !== undefined && (obj.moderatorBanned = message.moderatorBanned);
        message.note !== undefined && (obj.note = message.note);
        message.unbanner !== undefined && (obj.unbanner = message.unbanner);
        message.unbannedAt !== undefined && (obj.unbannedAt = message.unbannedAt);
        message.resetUsed !== undefined && (obj.resetUsed = message.resetUsed);
        message.reasonId !== undefined && (obj.reasonId = message.reasonId);
        message.reasonTitle !== undefined && (obj.reasonTitle = message.reasonTitle);
        message.reasonMessage !== undefined && (obj.reasonMessage = message.reasonMessage);
        message.reasonBy !== undefined && (obj.reasonBy = message.reasonBy);
        message.modNote !== undefined && (obj.modNote = message.modNote);
        message.banAllTriggered !== undefined && (obj.banAllTriggered = message.banAllTriggered);
        message.subredditMessage !== undefined && (obj.subredditMessage = message.subredditMessage);
        message.removeAction !== undefined && (obj.removeAction = banInfo_BanInfoActionToJSON(message.removeAction));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBanInfo();
        message.auto = object.auto ?? undefined;
        message.bannedAt = object.bannedAt ?? undefined;
        message.banner = object.banner ?? undefined;
        message.moderatorBanned = object.moderatorBanned ?? undefined;
        message.note = object.note ?? undefined;
        message.unbanner = object.unbanner ?? undefined;
        message.unbannedAt = object.unbannedAt ?? undefined;
        message.resetUsed = object.resetUsed ?? undefined;
        message.reasonId = object.reasonId ?? undefined;
        message.reasonTitle = object.reasonTitle ?? undefined;
        message.reasonMessage = object.reasonMessage ?? undefined;
        message.reasonBy = object.reasonBy ?? undefined;
        message.modNote = object.modNote ?? undefined;
        message.banAllTriggered = object.banAllTriggered ?? undefined;
        message.subredditMessage = object.subredditMessage ?? undefined;
        message.removeAction = object.removeAction ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.BanInfo", BanInfo);
function isSet(value) {
    return value !== null && value !== undefined;
}
