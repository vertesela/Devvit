/**
 * #post_guidance.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
export var DiscussionType;
(function (DiscussionType) {
    DiscussionType[DiscussionType["NULL_VALUE"] = 0] = "NULL_VALUE";
    DiscussionType[DiscussionType["CHAT"] = 1] = "CHAT";
    DiscussionType[DiscussionType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DiscussionType || (DiscussionType = {}));
export function discussionTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "NULL_VALUE":
            return DiscussionType.NULL_VALUE;
        case 1:
        case "CHAT":
            return DiscussionType.CHAT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DiscussionType.UNRECOGNIZED;
    }
}
export function discussionTypeToJSON(object) {
    switch (object) {
        case DiscussionType.NULL_VALUE:
            return 0;
        case DiscussionType.CHAT:
            return 1;
        case DiscussionType.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var PostType;
(function (PostType) {
    PostType[PostType["UNKNOWN"] = 0] = "UNKNOWN";
    PostType[PostType["LINK"] = 1] = "LINK";
    PostType[PostType["TEXT"] = 2] = "TEXT";
    PostType[PostType["LINK_TEXT"] = 3] = "LINK_TEXT";
    PostType[PostType["MEDIA_UPLOAD"] = 4] = "MEDIA_UPLOAD";
    PostType[PostType["POLL"] = 5] = "POLL";
    PostType[PostType["CROSSPOST"] = 6] = "CROSSPOST";
    PostType[PostType["GALLERY"] = 7] = "GALLERY";
    PostType[PostType["IMAGE"] = 9] = "IMAGE";
    PostType[PostType["VIDEO"] = 10] = "VIDEO";
    PostType[PostType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PostType || (PostType = {}));
export function postTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return PostType.UNKNOWN;
        case 1:
        case "LINK":
            return PostType.LINK;
        case 2:
        case "TEXT":
            return PostType.TEXT;
        case 3:
        case "LINK_TEXT":
            return PostType.LINK_TEXT;
        case 4:
        case "MEDIA_UPLOAD":
            return PostType.MEDIA_UPLOAD;
        case 5:
        case "POLL":
            return PostType.POLL;
        case 6:
        case "CROSSPOST":
            return PostType.CROSSPOST;
        case 7:
        case "GALLERY":
            return PostType.GALLERY;
        case 9:
        case "IMAGE":
            return PostType.IMAGE;
        case 10:
        case "VIDEO":
            return PostType.VIDEO;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PostType.UNRECOGNIZED;
    }
}
export function postTypeToJSON(object) {
    switch (object) {
        case PostType.UNKNOWN:
            return 0;
        case PostType.LINK:
            return 1;
        case PostType.TEXT:
            return 2;
        case PostType.LINK_TEXT:
            return 3;
        case PostType.MEDIA_UPLOAD:
            return 4;
        case PostType.POLL:
            return 5;
        case PostType.CROSSPOST:
            return 6;
        case PostType.GALLERY:
            return 7;
        case PostType.IMAGE:
            return 9;
        case PostType.VIDEO:
            return 10;
        case PostType.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var MediaType;
(function (MediaType) {
    MediaType[MediaType["MEDIA_UNKNOWN"] = 0] = "MEDIA_UNKNOWN";
    MediaType[MediaType["MEDIA_IMAGE"] = 1] = "MEDIA_IMAGE";
    MediaType[MediaType["MEDIA_VIDEO"] = 2] = "MEDIA_VIDEO";
    MediaType[MediaType["MEDIA_VIDEOGIF"] = 3] = "MEDIA_VIDEOGIF";
    MediaType[MediaType["MEDIA_STREAMING"] = 4] = "MEDIA_STREAMING";
    MediaType[MediaType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaType || (MediaType = {}));
export function mediaTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "MEDIA_UNKNOWN":
            return MediaType.MEDIA_UNKNOWN;
        case 1:
        case "MEDIA_IMAGE":
            return MediaType.MEDIA_IMAGE;
        case 2:
        case "MEDIA_VIDEO":
            return MediaType.MEDIA_VIDEO;
        case 3:
        case "MEDIA_VIDEOGIF":
            return MediaType.MEDIA_VIDEOGIF;
        case 4:
        case "MEDIA_STREAMING":
            return MediaType.MEDIA_STREAMING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return MediaType.UNRECOGNIZED;
    }
}
export function mediaTypeToJSON(object) {
    switch (object) {
        case MediaType.MEDIA_UNKNOWN:
            return 0;
        case MediaType.MEDIA_IMAGE:
            return 1;
        case MediaType.MEDIA_VIDEO:
            return 2;
        case MediaType.MEDIA_VIDEOGIF:
            return 3;
        case MediaType.MEDIA_STREAMING:
            return 4;
        case MediaType.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBasePostContent() {
    return {
        url: undefined,
        body: undefined,
        isRtjson: undefined,
        crosspostLinkId: undefined,
        mediaType: 0,
        isUserUpload: undefined,
        galleryItems: [],
    };
}
export const PostContent = {
    $type: "devvit.reddit.post_guidance.v1alpha.PostContent",
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(10).fork()).ldelim();
        }
        if (message.body !== undefined) {
            StringValue.encode({ value: message.body }, writer.uint32(18).fork()).ldelim();
        }
        if (message.isRtjson !== undefined) {
            BoolValue.encode({ value: message.isRtjson }, writer.uint32(26).fork()).ldelim();
        }
        if (message.crosspostLinkId !== undefined) {
            StringValue.encode({ value: message.crosspostLinkId }, writer.uint32(34).fork()).ldelim();
        }
        if (message.mediaType !== 0) {
            writer.uint32(40).int32(message.mediaType);
        }
        if (message.isUserUpload !== undefined) {
            BoolValue.encode({ value: message.isUserUpload }, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.galleryItems) {
            GalleryItem.encode(v, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostContent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.body = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.isRtjson = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.crosspostLinkId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.mediaType = reader.int32();
                    break;
                case 6:
                    message.isUserUpload = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.galleryItems.push(GalleryItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            url: isSet(object.url) ? String(object.url) : undefined,
            body: isSet(object.body) ? String(object.body) : undefined,
            isRtjson: isSet(object.isRtjson) ? Boolean(object.isRtjson) : undefined,
            crosspostLinkId: isSet(object.crosspostLinkId) ? String(object.crosspostLinkId) : undefined,
            mediaType: isSet(object.mediaType) ? mediaTypeFromJSON(object.mediaType) : 0,
            isUserUpload: isSet(object.isUserUpload) ? Boolean(object.isUserUpload) : undefined,
            galleryItems: Array.isArray(object?.galleryItems)
                ? object.galleryItems.map((e) => GalleryItem.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        message.body !== undefined && (obj.body = message.body);
        message.isRtjson !== undefined && (obj.isRtjson = message.isRtjson);
        message.crosspostLinkId !== undefined && (obj.crosspostLinkId = message.crosspostLinkId);
        message.mediaType !== undefined && (obj.mediaType = mediaTypeToJSON(message.mediaType));
        message.isUserUpload !== undefined && (obj.isUserUpload = message.isUserUpload);
        if (message.galleryItems) {
            obj.galleryItems = message.galleryItems.map((e) => e ? GalleryItem.toJSON(e) : undefined);
        }
        else {
            obj.galleryItems = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBasePostContent();
        message.url = object.url ?? undefined;
        message.body = object.body ?? undefined;
        message.isRtjson = object.isRtjson ?? undefined;
        message.crosspostLinkId = object.crosspostLinkId ?? undefined;
        message.mediaType = object.mediaType ?? 0;
        message.isUserUpload = object.isUserUpload ?? undefined;
        message.galleryItems = object.galleryItems?.map((e) => GalleryItem.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.PostContent", PostContent);
function createBasePostMetadata() {
    return {
        title: undefined,
        subredditId: undefined,
        userId: undefined,
        postType: 0,
        isLocked: undefined,
        isNsfw: undefined,
        isOriginalContent: undefined,
        isReceivingReplies: undefined,
        isSpoiler: undefined,
        isUnlisted: undefined,
        flairId: undefined,
        flairText: undefined,
        eventStart: undefined,
        eventEnd: undefined,
        discussionType: 0,
        collectionId: undefined,
        ip: undefined,
        isPromoted: undefined,
    };
}
export const PostMetadata = {
    $type: "devvit.reddit.post_guidance.v1alpha.PostMetadata",
    encode(message, writer = _m0.Writer.create()) {
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(10).fork()).ldelim();
        }
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.userId !== undefined) {
            StringValue.encode({ value: message.userId }, writer.uint32(26).fork()).ldelim();
        }
        if (message.postType !== 0) {
            writer.uint32(32).int32(message.postType);
        }
        if (message.isLocked !== undefined) {
            BoolValue.encode({ value: message.isLocked }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isNsfw !== undefined) {
            BoolValue.encode({ value: message.isNsfw }, writer.uint32(50).fork()).ldelim();
        }
        if (message.isOriginalContent !== undefined) {
            BoolValue.encode({ value: message.isOriginalContent }, writer.uint32(58).fork()).ldelim();
        }
        if (message.isReceivingReplies !== undefined) {
            BoolValue.encode({ value: message.isReceivingReplies }, writer.uint32(66).fork()).ldelim();
        }
        if (message.isSpoiler !== undefined) {
            BoolValue.encode({ value: message.isSpoiler }, writer.uint32(74).fork()).ldelim();
        }
        if (message.isUnlisted !== undefined) {
            BoolValue.encode({ value: message.isUnlisted }, writer.uint32(82).fork()).ldelim();
        }
        if (message.flairId !== undefined) {
            StringValue.encode({ value: message.flairId }, writer.uint32(90).fork()).ldelim();
        }
        if (message.flairText !== undefined) {
            StringValue.encode({ value: message.flairText }, writer.uint32(98).fork()).ldelim();
        }
        if (message.eventStart !== undefined) {
            Int64Value.encode({ value: message.eventStart }, writer.uint32(106).fork()).ldelim();
        }
        if (message.eventEnd !== undefined) {
            Int64Value.encode({ value: message.eventEnd }, writer.uint32(114).fork()).ldelim();
        }
        if (message.discussionType !== 0) {
            writer.uint32(120).int32(message.discussionType);
        }
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(130).fork()).ldelim();
        }
        if (message.ip !== undefined) {
            StringValue.encode({ value: message.ip }, writer.uint32(138).fork()).ldelim();
        }
        if (message.isPromoted !== undefined) {
            BoolValue.encode({ value: message.isPromoted }, writer.uint32(146).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.userId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.postType = reader.int32();
                    break;
                case 5:
                    message.isLocked = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.isOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.isReceivingReplies = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.isSpoiler = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.isUnlisted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.flairId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.flairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.eventStart = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.eventEnd = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.discussionType = reader.int32();
                    break;
                case 16:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.ip = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.isPromoted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet(object.title) ? String(object.title) : undefined,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            userId: isSet(object.userId) ? String(object.userId) : undefined,
            postType: isSet(object.postType) ? postTypeFromJSON(object.postType) : 0,
            isLocked: isSet(object.isLocked) ? Boolean(object.isLocked) : undefined,
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : undefined,
            isOriginalContent: isSet(object.isOriginalContent) ? Boolean(object.isOriginalContent) : undefined,
            isReceivingReplies: isSet(object.isReceivingReplies) ? Boolean(object.isReceivingReplies) : undefined,
            isSpoiler: isSet(object.isSpoiler) ? Boolean(object.isSpoiler) : undefined,
            isUnlisted: isSet(object.isUnlisted) ? Boolean(object.isUnlisted) : undefined,
            flairId: isSet(object.flairId) ? String(object.flairId) : undefined,
            flairText: isSet(object.flairText) ? String(object.flairText) : undefined,
            eventStart: isSet(object.eventStart) ? Number(object.eventStart) : undefined,
            eventEnd: isSet(object.eventEnd) ? Number(object.eventEnd) : undefined,
            discussionType: isSet(object.discussionType) ? discussionTypeFromJSON(object.discussionType) : 0,
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            ip: isSet(object.ip) ? String(object.ip) : undefined,
            isPromoted: isSet(object.isPromoted) ? Boolean(object.isPromoted) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.subredditId !== undefined && (obj.subredditId = message.subredditId);
        message.userId !== undefined && (obj.userId = message.userId);
        message.postType !== undefined && (obj.postType = postTypeToJSON(message.postType));
        message.isLocked !== undefined && (obj.isLocked = message.isLocked);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        message.isOriginalContent !== undefined && (obj.isOriginalContent = message.isOriginalContent);
        message.isReceivingReplies !== undefined && (obj.isReceivingReplies = message.isReceivingReplies);
        message.isSpoiler !== undefined && (obj.isSpoiler = message.isSpoiler);
        message.isUnlisted !== undefined && (obj.isUnlisted = message.isUnlisted);
        message.flairId !== undefined && (obj.flairId = message.flairId);
        message.flairText !== undefined && (obj.flairText = message.flairText);
        message.eventStart !== undefined && (obj.eventStart = message.eventStart);
        message.eventEnd !== undefined && (obj.eventEnd = message.eventEnd);
        message.discussionType !== undefined && (obj.discussionType = discussionTypeToJSON(message.discussionType));
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.ip !== undefined && (obj.ip = message.ip);
        message.isPromoted !== undefined && (obj.isPromoted = message.isPromoted);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePostMetadata();
        message.title = object.title ?? undefined;
        message.subredditId = object.subredditId ?? undefined;
        message.userId = object.userId ?? undefined;
        message.postType = object.postType ?? 0;
        message.isLocked = object.isLocked ?? undefined;
        message.isNsfw = object.isNsfw ?? undefined;
        message.isOriginalContent = object.isOriginalContent ?? undefined;
        message.isReceivingReplies = object.isReceivingReplies ?? undefined;
        message.isSpoiler = object.isSpoiler ?? undefined;
        message.isUnlisted = object.isUnlisted ?? undefined;
        message.flairId = object.flairId ?? undefined;
        message.flairText = object.flairText ?? undefined;
        message.eventStart = object.eventStart ?? undefined;
        message.eventEnd = object.eventEnd ?? undefined;
        message.discussionType = object.discussionType ?? 0;
        message.collectionId = object.collectionId ?? undefined;
        message.ip = object.ip ?? undefined;
        message.isPromoted = object.isPromoted ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.PostMetadata", PostMetadata);
function createBaseGalleryItem() {
    return {
        id: undefined,
        mediaId: undefined,
        caption: undefined,
        outboundUrl: undefined,
        isDeleted: undefined,
        callToAction: undefined,
        displayUrl: undefined,
        product: undefined,
    };
}
export const GalleryItem = {
    $type: "devvit.reddit.post_guidance.v1alpha.GalleryItem",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
        }
        if (message.mediaId !== undefined) {
            StringValue.encode({ value: message.mediaId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.caption !== undefined) {
            StringValue.encode({ value: message.caption }, writer.uint32(26).fork()).ldelim();
        }
        if (message.outboundUrl !== undefined) {
            StringValue.encode({ value: message.outboundUrl }, writer.uint32(34).fork()).ldelim();
        }
        if (message.isDeleted !== undefined) {
            BoolValue.encode({ value: message.isDeleted }, writer.uint32(42).fork()).ldelim();
        }
        if (message.callToAction !== undefined) {
            StringValue.encode({ value: message.callToAction }, writer.uint32(50).fork()).ldelim();
        }
        if (message.displayUrl !== undefined) {
            StringValue.encode({ value: message.displayUrl }, writer.uint32(58).fork()).ldelim();
        }
        if (message.product !== undefined) {
            Product.encode(message.product, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGalleryItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.mediaId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.caption = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.outboundUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.callToAction = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.displayUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.product = Product.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : undefined,
            mediaId: isSet(object.mediaId) ? String(object.mediaId) : undefined,
            caption: isSet(object.caption) ? String(object.caption) : undefined,
            outboundUrl: isSet(object.outboundUrl) ? String(object.outboundUrl) : undefined,
            isDeleted: isSet(object.isDeleted) ? Boolean(object.isDeleted) : undefined,
            callToAction: isSet(object.callToAction) ? String(object.callToAction) : undefined,
            displayUrl: isSet(object.displayUrl) ? String(object.displayUrl) : undefined,
            product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.mediaId !== undefined && (obj.mediaId = message.mediaId);
        message.caption !== undefined && (obj.caption = message.caption);
        message.outboundUrl !== undefined && (obj.outboundUrl = message.outboundUrl);
        message.isDeleted !== undefined && (obj.isDeleted = message.isDeleted);
        message.callToAction !== undefined && (obj.callToAction = message.callToAction);
        message.displayUrl !== undefined && (obj.displayUrl = message.displayUrl);
        message.product !== undefined && (obj.product = message.product ? Product.toJSON(message.product) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGalleryItem();
        message.id = object.id ?? undefined;
        message.mediaId = object.mediaId ?? undefined;
        message.caption = object.caption ?? undefined;
        message.outboundUrl = object.outboundUrl ?? undefined;
        message.isDeleted = object.isDeleted ?? undefined;
        message.callToAction = object.callToAction ?? undefined;
        message.displayUrl = object.displayUrl ?? undefined;
        message.product = (object.product !== undefined && object.product !== null)
            ? Product.fromPartial(object.product)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.GalleryItem", GalleryItem);
function createBaseProduct() {
    return { title: undefined, price: undefined, description: undefined };
}
export const Product = {
    $type: "devvit.reddit.post_guidance.v1alpha.Product",
    encode(message, writer = _m0.Writer.create()) {
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(10).fork()).ldelim();
        }
        if (message.price !== undefined) {
            StringValue.encode({ value: message.price }, writer.uint32(18).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProduct();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.price = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet(object.title) ? String(object.title) : undefined,
            price: isSet(object.price) ? String(object.price) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.price !== undefined && (obj.price = message.price);
        message.description !== undefined && (obj.description = message.description);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseProduct();
        message.title = object.title ?? undefined;
        message.price = object.price ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.Product", Product);
function createBaseValidatePostRequirementsRequest() {
    return { postContent: undefined, postMetadata: undefined };
}
export const ValidatePostRequirementsRequest = {
    $type: "devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.postContent !== undefined) {
            PostContent.encode(message.postContent, writer.uint32(10).fork()).ldelim();
        }
        if (message.postMetadata !== undefined) {
            PostMetadata.encode(message.postMetadata, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatePostRequirementsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.postContent = PostContent.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.postMetadata = PostMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            postContent: isSet(object.postContent) ? PostContent.fromJSON(object.postContent) : undefined,
            postMetadata: isSet(object.postMetadata) ? PostMetadata.fromJSON(object.postMetadata) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.postContent !== undefined &&
            (obj.postContent = message.postContent ? PostContent.toJSON(message.postContent) : undefined);
        message.postMetadata !== undefined &&
            (obj.postMetadata = message.postMetadata ? PostMetadata.toJSON(message.postMetadata) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseValidatePostRequirementsRequest();
        message.postContent = (object.postContent !== undefined && object.postContent !== null)
            ? PostContent.fromPartial(object.postContent)
            : undefined;
        message.postMetadata = (object.postMetadata !== undefined && object.postMetadata !== null)
            ? PostMetadata.fromPartial(object.postMetadata)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsRequest", ValidatePostRequirementsRequest);
function createBaseValidationError() {
    return { reason: undefined, field: undefined, shortName: undefined };
}
export const ValidationError = {
    $type: "devvit.reddit.post_guidance.v1alpha.ValidationError",
    encode(message, writer = _m0.Writer.create()) {
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(10).fork()).ldelim();
        }
        if (message.field !== undefined) {
            StringValue.encode({ value: message.field }, writer.uint32(18).fork()).ldelim();
        }
        if (message.shortName !== undefined) {
            StringValue.encode({ value: message.shortName }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidationError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.field = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.shortName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            reason: isSet(object.reason) ? String(object.reason) : undefined,
            field: isSet(object.field) ? String(object.field) : undefined,
            shortName: isSet(object.shortName) ? String(object.shortName) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.reason !== undefined && (obj.reason = message.reason);
        message.field !== undefined && (obj.field = message.field);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseValidationError();
        message.reason = object.reason ?? undefined;
        message.field = object.field ?? undefined;
        message.shortName = object.shortName ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.ValidationError", ValidationError);
function createBaseValidatePostRequirementsResponse() {
    return { errors: [] };
}
export const ValidatePostRequirementsResponse = {
    $type: "devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.errors) {
            ValidationError.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatePostRequirementsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.errors.push(ValidationError.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { errors: Array.isArray(object?.errors) ? object.errors.map((e) => ValidationError.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.errors) {
            obj.errors = message.errors.map((e) => e ? ValidationError.toJSON(e) : undefined);
        }
        else {
            obj.errors = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseValidatePostRequirementsResponse();
        message.errors = object.errors?.map((e) => ValidationError.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsResponse", ValidatePostRequirementsResponse);
export class PostGuidanceClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.reddit.post_guidance.v1alpha.PostGuidance";
        this.rpc = rpc;
        this.GetPostGuidance = this.GetPostGuidance.bind(this);
    }
    GetPostGuidance(request) {
        const data = ValidatePostRequirementsRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "GetPostGuidance", data);
        return promise.then((data) => ValidatePostRequirementsResponse.decode(new _m0.Reader(data)));
    }
}
export const PostGuidanceDefinition = {
    name: "PostGuidance",
    fullName: "devvit.reddit.post_guidance.v1alpha.PostGuidance",
    methods: {
        getPostGuidance: {
            name: "GetPostGuidance",
            requestType: ValidatePostRequirementsRequest,
            requestStream: false,
            responseType: ValidatePostRequirementsResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
