/**
 * #custom_actions.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Struct } from '../../../../google/protobuf/struct.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { Effect } from '../../../ui/effects/v1alpha/effect.js';
import { thingTypeFromJSON, thingTypeToJSON } from '../../thing_type.js';
function createBaseCustomAction() {
    return { actionId: "", label: "", shortDescription: "", menus: undefined, options: undefined };
}
export const CustomAction = {
    $type: "devvit.reddit.custom_actions.v2alpha.CustomAction",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actionId !== "") {
            writer.uint32(10).string(message.actionId);
        }
        if (message.label !== "") {
            writer.uint32(18).string(message.label);
        }
        if (message.shortDescription !== "") {
            writer.uint32(26).string(message.shortDescription);
        }
        if (message.menus !== undefined) {
            CustomAction_Menus.encode(message.menus, writer.uint32(34).fork()).ldelim();
        }
        if (message.options !== undefined) {
            CustomAction_Options.encode(message.options, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCustomAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actionId = reader.string();
                    break;
                case 2:
                    message.label = reader.string();
                    break;
                case 3:
                    message.shortDescription = reader.string();
                    break;
                case 4:
                    message.menus = CustomAction_Menus.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.options = CustomAction_Options.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actionId: isSet(object.actionId) ? String(object.actionId) : "",
            label: isSet(object.label) ? String(object.label) : "",
            shortDescription: isSet(object.shortDescription) ? String(object.shortDescription) : "",
            menus: isSet(object.menus) ? CustomAction_Menus.fromJSON(object.menus) : undefined,
            options: isSet(object.options) ? CustomAction_Options.fromJSON(object.options) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.actionId !== undefined && (obj.actionId = message.actionId);
        message.label !== undefined && (obj.label = message.label);
        message.shortDescription !== undefined && (obj.shortDescription = message.shortDescription);
        message.menus !== undefined && (obj.menus = message.menus ? CustomAction_Menus.toJSON(message.menus) : undefined);
        message.options !== undefined &&
            (obj.options = message.options ? CustomAction_Options.toJSON(message.options) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCustomAction();
        message.actionId = object.actionId ?? "";
        message.label = object.label ?? "";
        message.shortDescription = object.shortDescription ?? "";
        message.menus = (object.menus !== undefined && object.menus !== null)
            ? CustomAction_Menus.fromPartial(object.menus)
            : undefined;
        message.options = (object.options !== undefined && object.options !== null)
            ? CustomAction_Options.fromPartial(object.options)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.CustomAction", CustomAction);
function createBaseCustomAction_Menus() {
    return { subreddit: undefined, post: undefined, comment: undefined };
}
export const CustomAction_Menus = {
    $type: "devvit.reddit.custom_actions.v2alpha.CustomAction.Menus",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== undefined) {
            writer.uint32(8).bool(message.subreddit);
        }
        if (message.post !== undefined) {
            writer.uint32(16).bool(message.post);
        }
        if (message.comment !== undefined) {
            writer.uint32(24).bool(message.comment);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCustomAction_Menus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.bool();
                    break;
                case 2:
                    message.post = reader.bool();
                    break;
                case 3:
                    message.comment = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? Boolean(object.subreddit) : undefined,
            post: isSet(object.post) ? Boolean(object.post) : undefined,
            comment: isSet(object.comment) ? Boolean(object.comment) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.post !== undefined && (obj.post = message.post);
        message.comment !== undefined && (obj.comment = message.comment);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCustomAction_Menus();
        message.subreddit = object.subreddit ?? undefined;
        message.post = object.post ?? undefined;
        message.comment = object.comment ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.CustomAction.Menus", CustomAction_Menus);
function createBaseCustomAction_Options() {
    return { modTool: undefined, icon: undefined };
}
export const CustomAction_Options = {
    $type: "devvit.reddit.custom_actions.v2alpha.CustomAction.Options",
    encode(message, writer = _m0.Writer.create()) {
        if (message.modTool !== undefined) {
            writer.uint32(8).bool(message.modTool);
        }
        if (message.icon !== undefined) {
            writer.uint32(18).string(message.icon);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCustomAction_Options();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.modTool = reader.bool();
                    break;
                case 2:
                    message.icon = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            modTool: isSet(object.modTool) ? Boolean(object.modTool) : undefined,
            icon: isSet(object.icon) ? String(object.icon) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.modTool !== undefined && (obj.modTool = message.modTool);
        message.icon !== undefined && (obj.icon = message.icon);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCustomAction_Options();
        message.modTool = object.modTool ?? undefined;
        message.icon = object.icon ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.CustomAction.Options", CustomAction_Options);
function createBaseGetActionsRequest() {
    return {};
}
export const GetActionsRequest = {
    $type: "devvit.reddit.custom_actions.v2alpha.GetActionsRequest",
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetActionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseGetActionsRequest();
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.GetActionsRequest", GetActionsRequest);
function createBaseGetActionsResponse() {
    return { actions: [] };
}
export const GetActionsResponse = {
    $type: "devvit.reddit.custom_actions.v2alpha.GetActionsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actions) {
            CustomAction.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetActionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(CustomAction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { actions: Array.isArray(object?.actions) ? object.actions.map((e) => CustomAction.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.actions) {
            obj.actions = message.actions.map((e) => e ? CustomAction.toJSON(e) : undefined);
        }
        else {
            obj.actions = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetActionsResponse();
        message.actions = object.actions?.map((e) => CustomAction.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.GetActionsResponse", GetActionsResponse);
function createBaseOnActionRequest() {
    return { actionId: "", thingType: 0, thingId: "" };
}
export const OnActionRequest = {
    $type: "devvit.reddit.custom_actions.v2alpha.OnActionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actionId !== "") {
            writer.uint32(10).string(message.actionId);
        }
        if (message.thingType !== 0) {
            writer.uint32(16).int32(message.thingType);
        }
        if (message.thingId !== "") {
            writer.uint32(26).string(message.thingId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOnActionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actionId = reader.string();
                    break;
                case 2:
                    message.thingType = reader.int32();
                    break;
                case 3:
                    message.thingId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actionId: isSet(object.actionId) ? String(object.actionId) : "",
            thingType: isSet(object.thingType) ? thingTypeFromJSON(object.thingType) : 0,
            thingId: isSet(object.thingId) ? String(object.thingId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.actionId !== undefined && (obj.actionId = message.actionId);
        message.thingType !== undefined && (obj.thingType = thingTypeToJSON(message.thingType));
        message.thingId !== undefined && (obj.thingId = message.thingId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseOnActionRequest();
        message.actionId = object.actionId ?? "";
        message.thingType = object.thingType ?? 0;
        message.thingId = object.thingId ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.OnActionRequest", OnActionRequest);
function createBaseOnActionResponse() {
    return { state: undefined, effects: [] };
}
export const OnActionResponse = {
    $type: "devvit.reddit.custom_actions.v2alpha.OnActionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.state !== undefined) {
            Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.effects) {
            Effect.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOnActionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.effects.push(Effect.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            state: isObject(object.state) ? object.state : undefined,
            effects: Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.state !== undefined && (obj.state = message.state);
        if (message.effects) {
            obj.effects = message.effects.map((e) => e ? Effect.toJSON(e) : undefined);
        }
        else {
            obj.effects = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseOnActionResponse();
        message.state = object.state ?? undefined;
        message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.OnActionResponse", OnActionResponse);
export class CustomActionsClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.reddit.custom_actions.v2alpha.CustomActions";
        this.rpc = rpc;
        this.GetActions = this.GetActions.bind(this);
        this.OnAction = this.OnAction.bind(this);
    }
    GetActions(request) {
        const data = GetActionsRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "GetActions", data);
        return promise.then((data) => GetActionsResponse.decode(new _m0.Reader(data)));
    }
    OnAction(request) {
        const data = OnActionRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "OnAction", data);
        return promise.then((data) => OnActionResponse.decode(new _m0.Reader(data)));
    }
}
export const CustomActionsDefinition = {
    name: "CustomActions",
    fullName: "devvit.reddit.custom_actions.v2alpha.CustomActions",
    methods: {
        getActions: {
            name: "GetActions",
            requestType: GetActionsRequest,
            requestStream: false,
            responseType: GetActionsResponse,
            responseStream: false,
            options: {},
        },
        onAction: {
            name: "OnAction",
            requestType: OnActionRequest,
            requestStream: false,
            responseType: OnActionResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
