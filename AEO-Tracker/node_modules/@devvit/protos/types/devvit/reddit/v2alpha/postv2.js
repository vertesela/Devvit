/**
 * #postv2.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import Long from "long";
import _m0 from 'protobufjs/minimal.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
import { LinkFlairV2, UserFlairV2 } from './flair.js';
export var CrowdControlLevel;
(function (CrowdControlLevel) {
    CrowdControlLevel[CrowdControlLevel["OFF"] = 0] = "OFF";
    CrowdControlLevel[CrowdControlLevel["LENIENT"] = 1] = "LENIENT";
    CrowdControlLevel[CrowdControlLevel["MEDIUM"] = 2] = "MEDIUM";
    CrowdControlLevel[CrowdControlLevel["STRICT"] = 3] = "STRICT";
    CrowdControlLevel[CrowdControlLevel["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CrowdControlLevel || (CrowdControlLevel = {}));
export function crowdControlLevelFromJSON(object) {
    switch (object) {
        case 0:
        case "OFF":
            return CrowdControlLevel.OFF;
        case 1:
        case "LENIENT":
            return CrowdControlLevel.LENIENT;
        case 2:
        case "MEDIUM":
            return CrowdControlLevel.MEDIUM;
        case 3:
        case "STRICT":
            return CrowdControlLevel.STRICT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return CrowdControlLevel.UNRECOGNIZED;
    }
}
export function crowdControlLevelToJSON(object) {
    switch (object) {
        case CrowdControlLevel.OFF:
            return 0;
        case CrowdControlLevel.LENIENT:
            return 1;
        case CrowdControlLevel.MEDIUM:
            return 2;
        case CrowdControlLevel.STRICT:
            return 3;
        case CrowdControlLevel.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var DistinguishType;
(function (DistinguishType) {
    DistinguishType[DistinguishType["NULL_VALUE"] = 0] = "NULL_VALUE";
    DistinguishType[DistinguishType["ADMIN"] = 1] = "ADMIN";
    DistinguishType[DistinguishType["GOLD"] = 2] = "GOLD";
    DistinguishType[DistinguishType["GOLD_AUTO"] = 3] = "GOLD_AUTO";
    DistinguishType[DistinguishType["YES"] = 4] = "YES";
    DistinguishType[DistinguishType["SPECIAL"] = 5] = "SPECIAL";
    DistinguishType[DistinguishType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DistinguishType || (DistinguishType = {}));
export function distinguishTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "NULL_VALUE":
            return DistinguishType.NULL_VALUE;
        case 1:
        case "ADMIN":
            return DistinguishType.ADMIN;
        case 2:
        case "GOLD":
            return DistinguishType.GOLD;
        case 3:
        case "GOLD_AUTO":
            return DistinguishType.GOLD_AUTO;
        case 4:
        case "YES":
            return DistinguishType.YES;
        case 5:
        case "SPECIAL":
            return DistinguishType.SPECIAL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DistinguishType.UNRECOGNIZED;
    }
}
export function distinguishTypeToJSON(object) {
    switch (object) {
        case DistinguishType.NULL_VALUE:
            return 0;
        case DistinguishType.ADMIN:
            return 1;
        case DistinguishType.GOLD:
            return 2;
        case DistinguishType.GOLD_AUTO:
            return 3;
        case DistinguishType.YES:
            return 4;
        case DistinguishType.SPECIAL:
            return 5;
        case DistinguishType.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBasePostV2() {
    return {
        id: "",
        title: "",
        selftext: "",
        nsfw: false,
        authorId: "",
        crowdControlLevel: 0,
        numReports: 0,
        isGallery: false,
        isMeta: false,
        createdAt: 0,
        isApproved: false,
        isArchived: false,
        distinguished: 0,
        ignoreReports: false,
        isSelf: false,
        isVideo: false,
        isLocked: false,
        isSpoiler: false,
        subredditId: "",
        upvotes: 0,
        downvotes: 0,
        url: "",
        isSticky: false,
        linkFlair: undefined,
        authorFlair: undefined,
        spam: false,
        deleted: false,
        languageCode: "",
        updatedAt: 0,
        gildings: 0,
        score: 0,
        numComments: 0,
        thumbnail: "",
        media: undefined,
        crosspostParentId: "",
        permalink: "",
        isPoll: false,
        isPromoted: false,
        isMultiMedia: false,
    };
}
export const PostV2 = {
    $type: "devvit.reddit.v2alpha.PostV2",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.title !== "") {
            writer.uint32(18).string(message.title);
        }
        if (message.selftext !== "") {
            writer.uint32(26).string(message.selftext);
        }
        if (message.nsfw === true) {
            writer.uint32(32).bool(message.nsfw);
        }
        if (message.authorId !== "") {
            writer.uint32(42).string(message.authorId);
        }
        if (message.crowdControlLevel !== 0) {
            writer.uint32(48).int32(message.crowdControlLevel);
        }
        if (message.numReports !== 0) {
            writer.uint32(56).int32(message.numReports);
        }
        if (message.isGallery === true) {
            writer.uint32(64).bool(message.isGallery);
        }
        if (message.isMeta === true) {
            writer.uint32(72).bool(message.isMeta);
        }
        if (message.createdAt !== 0) {
            writer.uint32(80).int64(message.createdAt);
        }
        if (message.isApproved === true) {
            writer.uint32(88).bool(message.isApproved);
        }
        if (message.isArchived === true) {
            writer.uint32(96).bool(message.isArchived);
        }
        if (message.distinguished !== 0) {
            writer.uint32(104).int32(message.distinguished);
        }
        if (message.ignoreReports === true) {
            writer.uint32(112).bool(message.ignoreReports);
        }
        if (message.isSelf === true) {
            writer.uint32(120).bool(message.isSelf);
        }
        if (message.isVideo === true) {
            writer.uint32(128).bool(message.isVideo);
        }
        if (message.isLocked === true) {
            writer.uint32(136).bool(message.isLocked);
        }
        if (message.isSpoiler === true) {
            writer.uint32(144).bool(message.isSpoiler);
        }
        if (message.subredditId !== "") {
            writer.uint32(154).string(message.subredditId);
        }
        if (message.upvotes !== 0) {
            writer.uint32(160).int32(message.upvotes);
        }
        if (message.downvotes !== 0) {
            writer.uint32(168).int32(message.downvotes);
        }
        if (message.url !== "") {
            writer.uint32(178).string(message.url);
        }
        if (message.isSticky === true) {
            writer.uint32(184).bool(message.isSticky);
        }
        if (message.linkFlair !== undefined) {
            LinkFlairV2.encode(message.linkFlair, writer.uint32(194).fork()).ldelim();
        }
        if (message.authorFlair !== undefined) {
            UserFlairV2.encode(message.authorFlair, writer.uint32(202).fork()).ldelim();
        }
        if (message.spam === true) {
            writer.uint32(208).bool(message.spam);
        }
        if (message.deleted === true) {
            writer.uint32(216).bool(message.deleted);
        }
        if (message.languageCode !== "") {
            writer.uint32(226).string(message.languageCode);
        }
        if (message.updatedAt !== 0) {
            writer.uint32(232).int64(message.updatedAt);
        }
        if (message.gildings !== 0) {
            writer.uint32(240).int32(message.gildings);
        }
        if (message.score !== 0) {
            writer.uint32(248).int32(message.score);
        }
        if (message.numComments !== 0) {
            writer.uint32(256).int32(message.numComments);
        }
        if (message.thumbnail !== "") {
            writer.uint32(266).string(message.thumbnail);
        }
        if (message.media !== undefined) {
            MediaObject.encode(message.media, writer.uint32(274).fork()).ldelim();
        }
        if (message.crosspostParentId !== "") {
            writer.uint32(282).string(message.crosspostParentId);
        }
        if (message.permalink !== "") {
            writer.uint32(290).string(message.permalink);
        }
        if (message.isPoll === true) {
            writer.uint32(296).bool(message.isPoll);
        }
        if (message.isPromoted === true) {
            writer.uint32(304).bool(message.isPromoted);
        }
        if (message.isMultiMedia === true) {
            writer.uint32(312).bool(message.isMultiMedia);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                case 3:
                    message.selftext = reader.string();
                    break;
                case 4:
                    message.nsfw = reader.bool();
                    break;
                case 5:
                    message.authorId = reader.string();
                    break;
                case 6:
                    message.crowdControlLevel = reader.int32();
                    break;
                case 7:
                    message.numReports = reader.int32();
                    break;
                case 8:
                    message.isGallery = reader.bool();
                    break;
                case 9:
                    message.isMeta = reader.bool();
                    break;
                case 10:
                    message.createdAt = longToNumber(reader.int64());
                    break;
                case 11:
                    message.isApproved = reader.bool();
                    break;
                case 12:
                    message.isArchived = reader.bool();
                    break;
                case 13:
                    message.distinguished = reader.int32();
                    break;
                case 14:
                    message.ignoreReports = reader.bool();
                    break;
                case 15:
                    message.isSelf = reader.bool();
                    break;
                case 16:
                    message.isVideo = reader.bool();
                    break;
                case 17:
                    message.isLocked = reader.bool();
                    break;
                case 18:
                    message.isSpoiler = reader.bool();
                    break;
                case 19:
                    message.subredditId = reader.string();
                    break;
                case 20:
                    message.upvotes = reader.int32();
                    break;
                case 21:
                    message.downvotes = reader.int32();
                    break;
                case 22:
                    message.url = reader.string();
                    break;
                case 23:
                    message.isSticky = reader.bool();
                    break;
                case 24:
                    message.linkFlair = LinkFlairV2.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.authorFlair = UserFlairV2.decode(reader, reader.uint32());
                    break;
                case 26:
                    message.spam = reader.bool();
                    break;
                case 27:
                    message.deleted = reader.bool();
                    break;
                case 28:
                    message.languageCode = reader.string();
                    break;
                case 29:
                    message.updatedAt = longToNumber(reader.int64());
                    break;
                case 30:
                    message.gildings = reader.int32();
                    break;
                case 31:
                    message.score = reader.int32();
                    break;
                case 32:
                    message.numComments = reader.int32();
                    break;
                case 33:
                    message.thumbnail = reader.string();
                    break;
                case 34:
                    message.media = MediaObject.decode(reader, reader.uint32());
                    break;
                case 35:
                    message.crosspostParentId = reader.string();
                    break;
                case 36:
                    message.permalink = reader.string();
                    break;
                case 37:
                    message.isPoll = reader.bool();
                    break;
                case 38:
                    message.isPromoted = reader.bool();
                    break;
                case 39:
                    message.isMultiMedia = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            title: isSet(object.title) ? String(object.title) : "",
            selftext: isSet(object.selftext) ? String(object.selftext) : "",
            nsfw: isSet(object.nsfw) ? Boolean(object.nsfw) : false,
            authorId: isSet(object.authorId) ? String(object.authorId) : "",
            crowdControlLevel: isSet(object.crowdControlLevel) ? crowdControlLevelFromJSON(object.crowdControlLevel) : 0,
            numReports: isSet(object.numReports) ? Number(object.numReports) : 0,
            isGallery: isSet(object.isGallery) ? Boolean(object.isGallery) : false,
            isMeta: isSet(object.isMeta) ? Boolean(object.isMeta) : false,
            createdAt: isSet(object.createdAt) ? Number(object.createdAt) : 0,
            isApproved: isSet(object.isApproved) ? Boolean(object.isApproved) : false,
            isArchived: isSet(object.isArchived) ? Boolean(object.isArchived) : false,
            distinguished: isSet(object.distinguished) ? distinguishTypeFromJSON(object.distinguished) : 0,
            ignoreReports: isSet(object.ignoreReports) ? Boolean(object.ignoreReports) : false,
            isSelf: isSet(object.isSelf) ? Boolean(object.isSelf) : false,
            isVideo: isSet(object.isVideo) ? Boolean(object.isVideo) : false,
            isLocked: isSet(object.isLocked) ? Boolean(object.isLocked) : false,
            isSpoiler: isSet(object.isSpoiler) ? Boolean(object.isSpoiler) : false,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : "",
            upvotes: isSet(object.upvotes) ? Number(object.upvotes) : 0,
            downvotes: isSet(object.downvotes) ? Number(object.downvotes) : 0,
            url: isSet(object.url) ? String(object.url) : "",
            isSticky: isSet(object.isSticky) ? Boolean(object.isSticky) : false,
            linkFlair: isSet(object.linkFlair) ? LinkFlairV2.fromJSON(object.linkFlair) : undefined,
            authorFlair: isSet(object.authorFlair) ? UserFlairV2.fromJSON(object.authorFlair) : undefined,
            spam: isSet(object.spam) ? Boolean(object.spam) : false,
            deleted: isSet(object.deleted) ? Boolean(object.deleted) : false,
            languageCode: isSet(object.languageCode) ? String(object.languageCode) : "",
            updatedAt: isSet(object.updatedAt) ? Number(object.updatedAt) : 0,
            gildings: isSet(object.gildings) ? Number(object.gildings) : 0,
            score: isSet(object.score) ? Number(object.score) : 0,
            numComments: isSet(object.numComments) ? Number(object.numComments) : 0,
            thumbnail: isSet(object.thumbnail) ? String(object.thumbnail) : "",
            media: isSet(object.media) ? MediaObject.fromJSON(object.media) : undefined,
            crosspostParentId: isSet(object.crosspostParentId) ? String(object.crosspostParentId) : "",
            permalink: isSet(object.permalink) ? String(object.permalink) : "",
            isPoll: isSet(object.isPoll) ? Boolean(object.isPoll) : false,
            isPromoted: isSet(object.isPromoted) ? Boolean(object.isPromoted) : false,
            isMultiMedia: isSet(object.isMultiMedia) ? Boolean(object.isMultiMedia) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.title !== undefined && (obj.title = message.title);
        message.selftext !== undefined && (obj.selftext = message.selftext);
        message.nsfw !== undefined && (obj.nsfw = message.nsfw);
        message.authorId !== undefined && (obj.authorId = message.authorId);
        message.crowdControlLevel !== undefined &&
            (obj.crowdControlLevel = crowdControlLevelToJSON(message.crowdControlLevel));
        message.numReports !== undefined && (obj.numReports = Math.round(message.numReports));
        message.isGallery !== undefined && (obj.isGallery = message.isGallery);
        message.isMeta !== undefined && (obj.isMeta = message.isMeta);
        message.createdAt !== undefined && (obj.createdAt = Math.round(message.createdAt));
        message.isApproved !== undefined && (obj.isApproved = message.isApproved);
        message.isArchived !== undefined && (obj.isArchived = message.isArchived);
        message.distinguished !== undefined && (obj.distinguished = distinguishTypeToJSON(message.distinguished));
        message.ignoreReports !== undefined && (obj.ignoreReports = message.ignoreReports);
        message.isSelf !== undefined && (obj.isSelf = message.isSelf);
        message.isVideo !== undefined && (obj.isVideo = message.isVideo);
        message.isLocked !== undefined && (obj.isLocked = message.isLocked);
        message.isSpoiler !== undefined && (obj.isSpoiler = message.isSpoiler);
        message.subredditId !== undefined && (obj.subredditId = message.subredditId);
        message.upvotes !== undefined && (obj.upvotes = Math.round(message.upvotes));
        message.downvotes !== undefined && (obj.downvotes = Math.round(message.downvotes));
        message.url !== undefined && (obj.url = message.url);
        message.isSticky !== undefined && (obj.isSticky = message.isSticky);
        message.linkFlair !== undefined &&
            (obj.linkFlair = message.linkFlair ? LinkFlairV2.toJSON(message.linkFlair) : undefined);
        message.authorFlair !== undefined &&
            (obj.authorFlair = message.authorFlair ? UserFlairV2.toJSON(message.authorFlair) : undefined);
        message.spam !== undefined && (obj.spam = message.spam);
        message.deleted !== undefined && (obj.deleted = message.deleted);
        message.languageCode !== undefined && (obj.languageCode = message.languageCode);
        message.updatedAt !== undefined && (obj.updatedAt = Math.round(message.updatedAt));
        message.gildings !== undefined && (obj.gildings = Math.round(message.gildings));
        message.score !== undefined && (obj.score = Math.round(message.score));
        message.numComments !== undefined && (obj.numComments = Math.round(message.numComments));
        message.thumbnail !== undefined && (obj.thumbnail = message.thumbnail);
        message.media !== undefined && (obj.media = message.media ? MediaObject.toJSON(message.media) : undefined);
        message.crosspostParentId !== undefined && (obj.crosspostParentId = message.crosspostParentId);
        message.permalink !== undefined && (obj.permalink = message.permalink);
        message.isPoll !== undefined && (obj.isPoll = message.isPoll);
        message.isPromoted !== undefined && (obj.isPromoted = message.isPromoted);
        message.isMultiMedia !== undefined && (obj.isMultiMedia = message.isMultiMedia);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePostV2();
        message.id = object.id ?? "";
        message.title = object.title ?? "";
        message.selftext = object.selftext ?? "";
        message.nsfw = object.nsfw ?? false;
        message.authorId = object.authorId ?? "";
        message.crowdControlLevel = object.crowdControlLevel ?? 0;
        message.numReports = object.numReports ?? 0;
        message.isGallery = object.isGallery ?? false;
        message.isMeta = object.isMeta ?? false;
        message.createdAt = object.createdAt ?? 0;
        message.isApproved = object.isApproved ?? false;
        message.isArchived = object.isArchived ?? false;
        message.distinguished = object.distinguished ?? 0;
        message.ignoreReports = object.ignoreReports ?? false;
        message.isSelf = object.isSelf ?? false;
        message.isVideo = object.isVideo ?? false;
        message.isLocked = object.isLocked ?? false;
        message.isSpoiler = object.isSpoiler ?? false;
        message.subredditId = object.subredditId ?? "";
        message.upvotes = object.upvotes ?? 0;
        message.downvotes = object.downvotes ?? 0;
        message.url = object.url ?? "";
        message.isSticky = object.isSticky ?? false;
        message.linkFlair = (object.linkFlair !== undefined && object.linkFlair !== null)
            ? LinkFlairV2.fromPartial(object.linkFlair)
            : undefined;
        message.authorFlair = (object.authorFlair !== undefined && object.authorFlair !== null)
            ? UserFlairV2.fromPartial(object.authorFlair)
            : undefined;
        message.spam = object.spam ?? false;
        message.deleted = object.deleted ?? false;
        message.languageCode = object.languageCode ?? "";
        message.updatedAt = object.updatedAt ?? 0;
        message.gildings = object.gildings ?? 0;
        message.score = object.score ?? 0;
        message.numComments = object.numComments ?? 0;
        message.thumbnail = object.thumbnail ?? "";
        message.media = (object.media !== undefined && object.media !== null)
            ? MediaObject.fromPartial(object.media)
            : undefined;
        message.crosspostParentId = object.crosspostParentId ?? "";
        message.permalink = object.permalink ?? "";
        message.isPoll = object.isPoll ?? false;
        message.isPromoted = object.isPromoted ?? false;
        message.isMultiMedia = object.isMultiMedia ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.v2alpha.PostV2", PostV2);
function createBaseOembed() {
    return {
        type: "",
        version: "",
        title: "",
        description: "",
        authorName: "",
        authorUrl: "",
        providerName: "",
        providerUrl: "",
        thumbnailUrl: "",
        thumbnailWidth: 0,
        thumbnailHeight: 0,
        html: "",
        width: 0,
        height: 0,
    };
}
export const Oembed = {
    $type: "devvit.reddit.v2alpha.Oembed",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        if (message.title !== "") {
            writer.uint32(26).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(34).string(message.description);
        }
        if (message.authorName !== "") {
            writer.uint32(42).string(message.authorName);
        }
        if (message.authorUrl !== "") {
            writer.uint32(50).string(message.authorUrl);
        }
        if (message.providerName !== "") {
            writer.uint32(58).string(message.providerName);
        }
        if (message.providerUrl !== "") {
            writer.uint32(66).string(message.providerUrl);
        }
        if (message.thumbnailUrl !== "") {
            writer.uint32(74).string(message.thumbnailUrl);
        }
        if (message.thumbnailWidth !== 0) {
            writer.uint32(80).int32(message.thumbnailWidth);
        }
        if (message.thumbnailHeight !== 0) {
            writer.uint32(88).int32(message.thumbnailHeight);
        }
        if (message.html !== "") {
            writer.uint32(98).string(message.html);
        }
        if (message.width !== 0) {
            writer.uint32(104).int32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(112).int32(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOembed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                case 3:
                    message.title = reader.string();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    message.authorName = reader.string();
                    break;
                case 6:
                    message.authorUrl = reader.string();
                    break;
                case 7:
                    message.providerName = reader.string();
                    break;
                case 8:
                    message.providerUrl = reader.string();
                    break;
                case 9:
                    message.thumbnailUrl = reader.string();
                    break;
                case 10:
                    message.thumbnailWidth = reader.int32();
                    break;
                case 11:
                    message.thumbnailHeight = reader.int32();
                    break;
                case 12:
                    message.html = reader.string();
                    break;
                case 13:
                    message.width = reader.int32();
                    break;
                case 14:
                    message.height = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? String(object.type) : "",
            version: isSet(object.version) ? String(object.version) : "",
            title: isSet(object.title) ? String(object.title) : "",
            description: isSet(object.description) ? String(object.description) : "",
            authorName: isSet(object.authorName) ? String(object.authorName) : "",
            authorUrl: isSet(object.authorUrl) ? String(object.authorUrl) : "",
            providerName: isSet(object.providerName) ? String(object.providerName) : "",
            providerUrl: isSet(object.providerUrl) ? String(object.providerUrl) : "",
            thumbnailUrl: isSet(object.thumbnailUrl) ? String(object.thumbnailUrl) : "",
            thumbnailWidth: isSet(object.thumbnailWidth) ? Number(object.thumbnailWidth) : 0,
            thumbnailHeight: isSet(object.thumbnailHeight) ? Number(object.thumbnailHeight) : 0,
            html: isSet(object.html) ? String(object.html) : "",
            width: isSet(object.width) ? Number(object.width) : 0,
            height: isSet(object.height) ? Number(object.height) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type);
        message.version !== undefined && (obj.version = message.version);
        message.title !== undefined && (obj.title = message.title);
        message.description !== undefined && (obj.description = message.description);
        message.authorName !== undefined && (obj.authorName = message.authorName);
        message.authorUrl !== undefined && (obj.authorUrl = message.authorUrl);
        message.providerName !== undefined && (obj.providerName = message.providerName);
        message.providerUrl !== undefined && (obj.providerUrl = message.providerUrl);
        message.thumbnailUrl !== undefined && (obj.thumbnailUrl = message.thumbnailUrl);
        message.thumbnailWidth !== undefined && (obj.thumbnailWidth = Math.round(message.thumbnailWidth));
        message.thumbnailHeight !== undefined && (obj.thumbnailHeight = Math.round(message.thumbnailHeight));
        message.html !== undefined && (obj.html = message.html);
        message.width !== undefined && (obj.width = Math.round(message.width));
        message.height !== undefined && (obj.height = Math.round(message.height));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseOembed();
        message.type = object.type ?? "";
        message.version = object.version ?? "";
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.authorName = object.authorName ?? "";
        message.authorUrl = object.authorUrl ?? "";
        message.providerName = object.providerName ?? "";
        message.providerUrl = object.providerUrl ?? "";
        message.thumbnailUrl = object.thumbnailUrl ?? "";
        message.thumbnailWidth = object.thumbnailWidth ?? 0;
        message.thumbnailHeight = object.thumbnailHeight ?? 0;
        message.html = object.html ?? "";
        message.width = object.width ?? 0;
        message.height = object.height ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.v2alpha.Oembed", Oembed);
function createBaseRedditVideo() {
    return {
        bitrateKbps: 0,
        fallbackUrl: "",
        height: 0,
        width: 0,
        scrubberMediaUrl: "",
        dashUrl: "",
        duration: 0,
        hlsUrl: "",
        isGif: false,
        transcodingStatus: "",
    };
}
export const RedditVideo = {
    $type: "devvit.reddit.v2alpha.RedditVideo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.bitrateKbps !== 0) {
            writer.uint32(8).int32(message.bitrateKbps);
        }
        if (message.fallbackUrl !== "") {
            writer.uint32(18).string(message.fallbackUrl);
        }
        if (message.height !== 0) {
            writer.uint32(24).int32(message.height);
        }
        if (message.width !== 0) {
            writer.uint32(32).int32(message.width);
        }
        if (message.scrubberMediaUrl !== "") {
            writer.uint32(42).string(message.scrubberMediaUrl);
        }
        if (message.dashUrl !== "") {
            writer.uint32(50).string(message.dashUrl);
        }
        if (message.duration !== 0) {
            writer.uint32(56).int64(message.duration);
        }
        if (message.hlsUrl !== "") {
            writer.uint32(66).string(message.hlsUrl);
        }
        if (message.isGif === true) {
            writer.uint32(72).bool(message.isGif);
        }
        if (message.transcodingStatus !== "") {
            writer.uint32(82).string(message.transcodingStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedditVideo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bitrateKbps = reader.int32();
                    break;
                case 2:
                    message.fallbackUrl = reader.string();
                    break;
                case 3:
                    message.height = reader.int32();
                    break;
                case 4:
                    message.width = reader.int32();
                    break;
                case 5:
                    message.scrubberMediaUrl = reader.string();
                    break;
                case 6:
                    message.dashUrl = reader.string();
                    break;
                case 7:
                    message.duration = longToNumber(reader.int64());
                    break;
                case 8:
                    message.hlsUrl = reader.string();
                    break;
                case 9:
                    message.isGif = reader.bool();
                    break;
                case 10:
                    message.transcodingStatus = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bitrateKbps: isSet(object.bitrateKbps) ? Number(object.bitrateKbps) : 0,
            fallbackUrl: isSet(object.fallbackUrl) ? String(object.fallbackUrl) : "",
            height: isSet(object.height) ? Number(object.height) : 0,
            width: isSet(object.width) ? Number(object.width) : 0,
            scrubberMediaUrl: isSet(object.scrubberMediaUrl) ? String(object.scrubberMediaUrl) : "",
            dashUrl: isSet(object.dashUrl) ? String(object.dashUrl) : "",
            duration: isSet(object.duration) ? Number(object.duration) : 0,
            hlsUrl: isSet(object.hlsUrl) ? String(object.hlsUrl) : "",
            isGif: isSet(object.isGif) ? Boolean(object.isGif) : false,
            transcodingStatus: isSet(object.transcodingStatus) ? String(object.transcodingStatus) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.bitrateKbps !== undefined && (obj.bitrateKbps = Math.round(message.bitrateKbps));
        message.fallbackUrl !== undefined && (obj.fallbackUrl = message.fallbackUrl);
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.width !== undefined && (obj.width = Math.round(message.width));
        message.scrubberMediaUrl !== undefined && (obj.scrubberMediaUrl = message.scrubberMediaUrl);
        message.dashUrl !== undefined && (obj.dashUrl = message.dashUrl);
        message.duration !== undefined && (obj.duration = Math.round(message.duration));
        message.hlsUrl !== undefined && (obj.hlsUrl = message.hlsUrl);
        message.isGif !== undefined && (obj.isGif = message.isGif);
        message.transcodingStatus !== undefined && (obj.transcodingStatus = message.transcodingStatus);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRedditVideo();
        message.bitrateKbps = object.bitrateKbps ?? 0;
        message.fallbackUrl = object.fallbackUrl ?? "";
        message.height = object.height ?? 0;
        message.width = object.width ?? 0;
        message.scrubberMediaUrl = object.scrubberMediaUrl ?? "";
        message.dashUrl = object.dashUrl ?? "";
        message.duration = object.duration ?? 0;
        message.hlsUrl = object.hlsUrl ?? "";
        message.isGif = object.isGif ?? false;
        message.transcodingStatus = object.transcodingStatus ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.v2alpha.RedditVideo", RedditVideo);
function createBaseMediaObject() {
    return { type: "", oembed: undefined, redditVideo: undefined };
}
export const MediaObject = {
    $type: "devvit.reddit.v2alpha.MediaObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.oembed !== undefined) {
            Oembed.encode(message.oembed, writer.uint32(18).fork()).ldelim();
        }
        if (message.redditVideo !== undefined) {
            RedditVideo.encode(message.redditVideo, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMediaObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.oembed = Oembed.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.redditVideo = RedditVideo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? String(object.type) : "",
            oembed: isSet(object.oembed) ? Oembed.fromJSON(object.oembed) : undefined,
            redditVideo: isSet(object.redditVideo) ? RedditVideo.fromJSON(object.redditVideo) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type);
        message.oembed !== undefined && (obj.oembed = message.oembed ? Oembed.toJSON(message.oembed) : undefined);
        message.redditVideo !== undefined &&
            (obj.redditVideo = message.redditVideo ? RedditVideo.toJSON(message.redditVideo) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMediaObject();
        message.type = object.type ?? "";
        message.oembed = (object.oembed !== undefined && object.oembed !== null)
            ? Oembed.fromPartial(object.oembed)
            : undefined;
        message.redditVideo = (object.redditVideo !== undefined && object.redditVideo !== null)
            ? RedditVideo.fromPartial(object.redditVideo)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.v2alpha.MediaObject", MediaObject);
var globalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
