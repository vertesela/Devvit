/**
 * #commentv2.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import Long from "long";
import _m0 from 'protobufjs/minimal.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
function createBaseCommentV2() {
    return {
        id: "",
        parentId: "",
        body: "",
        author: "",
        numReports: 0,
        collapsedBecauseCrowdControl: false,
        spam: false,
        deleted: false,
        createdAt: 0,
        upvotes: 0,
        downvotes: 0,
        languageCode: "",
        lastModifiedAt: 0,
        gilded: false,
        score: 0,
        permalink: "",
        hasMedia: false,
        postId: "",
        subredditId: "",
    };
}
export const CommentV2 = {
    $type: "devvit.reddit.v2alpha.CommentV2",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.parentId !== "") {
            writer.uint32(18).string(message.parentId);
        }
        if (message.body !== "") {
            writer.uint32(26).string(message.body);
        }
        if (message.author !== "") {
            writer.uint32(34).string(message.author);
        }
        if (message.numReports !== 0) {
            writer.uint32(40).int32(message.numReports);
        }
        if (message.collapsedBecauseCrowdControl === true) {
            writer.uint32(48).bool(message.collapsedBecauseCrowdControl);
        }
        if (message.spam === true) {
            writer.uint32(56).bool(message.spam);
        }
        if (message.deleted === true) {
            writer.uint32(64).bool(message.deleted);
        }
        if (message.createdAt !== 0) {
            writer.uint32(72).int64(message.createdAt);
        }
        if (message.upvotes !== 0) {
            writer.uint32(80).int32(message.upvotes);
        }
        if (message.downvotes !== 0) {
            writer.uint32(88).int32(message.downvotes);
        }
        if (message.languageCode !== "") {
            writer.uint32(98).string(message.languageCode);
        }
        if (message.lastModifiedAt !== 0) {
            writer.uint32(104).int64(message.lastModifiedAt);
        }
        if (message.gilded === true) {
            writer.uint32(112).bool(message.gilded);
        }
        if (message.score !== 0) {
            writer.uint32(120).int32(message.score);
        }
        if (message.permalink !== "") {
            writer.uint32(130).string(message.permalink);
        }
        if (message.hasMedia === true) {
            writer.uint32(136).bool(message.hasMedia);
        }
        if (message.postId !== "") {
            writer.uint32(146).string(message.postId);
        }
        if (message.subredditId !== "") {
            writer.uint32(154).string(message.subredditId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommentV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.parentId = reader.string();
                    break;
                case 3:
                    message.body = reader.string();
                    break;
                case 4:
                    message.author = reader.string();
                    break;
                case 5:
                    message.numReports = reader.int32();
                    break;
                case 6:
                    message.collapsedBecauseCrowdControl = reader.bool();
                    break;
                case 7:
                    message.spam = reader.bool();
                    break;
                case 8:
                    message.deleted = reader.bool();
                    break;
                case 9:
                    message.createdAt = longToNumber(reader.int64());
                    break;
                case 10:
                    message.upvotes = reader.int32();
                    break;
                case 11:
                    message.downvotes = reader.int32();
                    break;
                case 12:
                    message.languageCode = reader.string();
                    break;
                case 13:
                    message.lastModifiedAt = longToNumber(reader.int64());
                    break;
                case 14:
                    message.gilded = reader.bool();
                    break;
                case 15:
                    message.score = reader.int32();
                    break;
                case 16:
                    message.permalink = reader.string();
                    break;
                case 17:
                    message.hasMedia = reader.bool();
                    break;
                case 18:
                    message.postId = reader.string();
                    break;
                case 19:
                    message.subredditId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            parentId: isSet(object.parentId) ? String(object.parentId) : "",
            body: isSet(object.body) ? String(object.body) : "",
            author: isSet(object.author) ? String(object.author) : "",
            numReports: isSet(object.numReports) ? Number(object.numReports) : 0,
            collapsedBecauseCrowdControl: isSet(object.collapsedBecauseCrowdControl)
                ? Boolean(object.collapsedBecauseCrowdControl)
                : false,
            spam: isSet(object.spam) ? Boolean(object.spam) : false,
            deleted: isSet(object.deleted) ? Boolean(object.deleted) : false,
            createdAt: isSet(object.createdAt) ? Number(object.createdAt) : 0,
            upvotes: isSet(object.upvotes) ? Number(object.upvotes) : 0,
            downvotes: isSet(object.downvotes) ? Number(object.downvotes) : 0,
            languageCode: isSet(object.languageCode) ? String(object.languageCode) : "",
            lastModifiedAt: isSet(object.lastModifiedAt) ? Number(object.lastModifiedAt) : 0,
            gilded: isSet(object.gilded) ? Boolean(object.gilded) : false,
            score: isSet(object.score) ? Number(object.score) : 0,
            permalink: isSet(object.permalink) ? String(object.permalink) : "",
            hasMedia: isSet(object.hasMedia) ? Boolean(object.hasMedia) : false,
            postId: isSet(object.postId) ? String(object.postId) : "",
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.parentId !== undefined && (obj.parentId = message.parentId);
        message.body !== undefined && (obj.body = message.body);
        message.author !== undefined && (obj.author = message.author);
        message.numReports !== undefined && (obj.numReports = Math.round(message.numReports));
        message.collapsedBecauseCrowdControl !== undefined &&
            (obj.collapsedBecauseCrowdControl = message.collapsedBecauseCrowdControl);
        message.spam !== undefined && (obj.spam = message.spam);
        message.deleted !== undefined && (obj.deleted = message.deleted);
        message.createdAt !== undefined && (obj.createdAt = Math.round(message.createdAt));
        message.upvotes !== undefined && (obj.upvotes = Math.round(message.upvotes));
        message.downvotes !== undefined && (obj.downvotes = Math.round(message.downvotes));
        message.languageCode !== undefined && (obj.languageCode = message.languageCode);
        message.lastModifiedAt !== undefined && (obj.lastModifiedAt = Math.round(message.lastModifiedAt));
        message.gilded !== undefined && (obj.gilded = message.gilded);
        message.score !== undefined && (obj.score = Math.round(message.score));
        message.permalink !== undefined && (obj.permalink = message.permalink);
        message.hasMedia !== undefined && (obj.hasMedia = message.hasMedia);
        message.postId !== undefined && (obj.postId = message.postId);
        message.subredditId !== undefined && (obj.subredditId = message.subredditId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCommentV2();
        message.id = object.id ?? "";
        message.parentId = object.parentId ?? "";
        message.body = object.body ?? "";
        message.author = object.author ?? "";
        message.numReports = object.numReports ?? 0;
        message.collapsedBecauseCrowdControl = object.collapsedBecauseCrowdControl ?? false;
        message.spam = object.spam ?? false;
        message.deleted = object.deleted ?? false;
        message.createdAt = object.createdAt ?? 0;
        message.upvotes = object.upvotes ?? 0;
        message.downvotes = object.downvotes ?? 0;
        message.languageCode = object.languageCode ?? "";
        message.lastModifiedAt = object.lastModifiedAt ?? 0;
        message.gilded = object.gilded ?? false;
        message.score = object.score ?? 0;
        message.permalink = object.permalink ?? "";
        message.hasMedia = object.hasMedia ?? false;
        message.postId = object.postId ?? "";
        message.subredditId = object.subredditId ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.reddit.v2alpha.CommentV2", CommentV2);
var globalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
