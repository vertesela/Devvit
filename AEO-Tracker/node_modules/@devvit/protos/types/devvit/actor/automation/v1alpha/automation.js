/**
 * #automation.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { Comment } from '../../../reddit/comment.js';
import { Post } from '../../../reddit/post.js';
import { Subreddit } from '../../../reddit/subreddit.js';
import { User } from '../../../reddit/user.js';
import { StepDescription, StepReport } from './step.js';
import { Trigger } from './trigger.js';
/** The status of an automation */
export var AutomationStatus;
(function (AutomationStatus) {
    /** INSTALLED - Installed, but not actively executing on a trigger */
    AutomationStatus[AutomationStatus["INSTALLED"] = 0] = "INSTALLED";
    /** ENABLED - Installed and executing on a trigger */
    AutomationStatus[AutomationStatus["ENABLED"] = 1] = "ENABLED";
    /** DISABLED - Disabled by admins, does not run and cannot be re-enabled without admin approval. This is used if an automation is causing problems or is in violation of our policies. */
    AutomationStatus[AutomationStatus["DISABLED"] = 2] = "DISABLED";
    AutomationStatus[AutomationStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AutomationStatus || (AutomationStatus = {}));
export function automationStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "INSTALLED":
            return AutomationStatus.INSTALLED;
        case 1:
        case "ENABLED":
            return AutomationStatus.ENABLED;
        case 2:
        case "DISABLED":
            return AutomationStatus.DISABLED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AutomationStatus.UNRECOGNIZED;
    }
}
export function automationStatusToJSON(object) {
    switch (object) {
        case AutomationStatus.INSTALLED:
            return 0;
        case AutomationStatus.ENABLED:
            return 1;
        case AutomationStatus.DISABLED:
            return 2;
        case AutomationStatus.UNRECOGNIZED:
        default:
            return -1;
    }
}
/** Whether or not automation is sharable */
export var AutomationVisibility;
(function (AutomationVisibility) {
    /** PRIVATE - Only visible to mods of the installed subreddit */
    AutomationVisibility[AutomationVisibility["PRIVATE"] = 0] = "PRIVATE";
    /** PUBLIC - Published for sharing */
    AutomationVisibility[AutomationVisibility["PUBLIC"] = 1] = "PUBLIC";
    AutomationVisibility[AutomationVisibility["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AutomationVisibility || (AutomationVisibility = {}));
export function automationVisibilityFromJSON(object) {
    switch (object) {
        case 0:
        case "PRIVATE":
            return AutomationVisibility.PRIVATE;
        case 1:
        case "PUBLIC":
            return AutomationVisibility.PUBLIC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AutomationVisibility.UNRECOGNIZED;
    }
}
export function automationVisibilityToJSON(object) {
    switch (object) {
        case AutomationVisibility.PRIVATE:
            return 0;
        case AutomationVisibility.PUBLIC:
            return 1;
        case AutomationVisibility.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseAutomation() {
    return { id: "", name: "", description: "", status: 0, visibility: 0, trigger: undefined, steps: [] };
}
export const Automation = {
    $type: "devvit.actor.automation.v1alpha.Automation",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.status !== 0) {
            writer.uint32(32).int32(message.status);
        }
        if (message.visibility !== 0) {
            writer.uint32(40).int32(message.visibility);
        }
        if (message.trigger !== undefined) {
            Trigger.encode(message.trigger, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.steps) {
            StepDescription.encode(v, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAutomation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                case 5:
                    message.visibility = reader.int32();
                    break;
                case 6:
                    message.trigger = Trigger.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.steps.push(StepDescription.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            name: isSet(object.name) ? String(object.name) : "",
            description: isSet(object.description) ? String(object.description) : "",
            status: isSet(object.status) ? automationStatusFromJSON(object.status) : 0,
            visibility: isSet(object.visibility) ? automationVisibilityFromJSON(object.visibility) : 0,
            trigger: isSet(object.trigger) ? Trigger.fromJSON(object.trigger) : undefined,
            steps: Array.isArray(object?.steps) ? object.steps.map((e) => StepDescription.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined && (obj.description = message.description);
        message.status !== undefined && (obj.status = automationStatusToJSON(message.status));
        message.visibility !== undefined && (obj.visibility = automationVisibilityToJSON(message.visibility));
        message.trigger !== undefined && (obj.trigger = message.trigger ? Trigger.toJSON(message.trigger) : undefined);
        if (message.steps) {
            obj.steps = message.steps.map((e) => e ? StepDescription.toJSON(e) : undefined);
        }
        else {
            obj.steps = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAutomation();
        message.id = object.id ?? "";
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.status = object.status ?? 0;
        message.visibility = object.visibility ?? 0;
        message.trigger = (object.trigger !== undefined && object.trigger !== null)
            ? Trigger.fromPartial(object.trigger)
            : undefined;
        message.steps = object.steps?.map((e) => StepDescription.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.Automation", Automation);
function createBaseAutomationResult() {
    return { id: "", steps: [] };
}
export const AutomationResult = {
    $type: "devvit.actor.automation.v1alpha.AutomationResult",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        for (const v of message.steps) {
            StepReport.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAutomationResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.steps.push(StepReport.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            steps: Array.isArray(object?.steps) ? object.steps.map((e) => StepReport.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        if (message.steps) {
            obj.steps = message.steps.map((e) => e ? StepReport.toJSON(e) : undefined);
        }
        else {
            obj.steps = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAutomationResult();
        message.id = object.id ?? "";
        message.steps = object.steps?.map((e) => StepReport.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.AutomationResult", AutomationResult);
function createBaseAutomationInvocation() {
    return { id: "", automation: undefined, comment: undefined, post: undefined, user: undefined, subreddit: undefined };
}
export const AutomationInvocation = {
    $type: "devvit.actor.automation.v1alpha.AutomationInvocation",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.automation !== undefined) {
            Automation.encode(message.automation, writer.uint32(18).fork()).ldelim();
        }
        if (message.comment !== undefined) {
            Comment.encode(message.comment, writer.uint32(26).fork()).ldelim();
        }
        if (message.post !== undefined) {
            Post.encode(message.post, writer.uint32(34).fork()).ldelim();
        }
        if (message.user !== undefined) {
            User.encode(message.user, writer.uint32(42).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            Subreddit.encode(message.subreddit, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAutomationInvocation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.automation = Automation.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.comment = Comment.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.post = Post.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.user = User.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.subreddit = Subreddit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            automation: isSet(object.automation) ? Automation.fromJSON(object.automation) : undefined,
            comment: isSet(object.comment) ? Comment.fromJSON(object.comment) : undefined,
            post: isSet(object.post) ? Post.fromJSON(object.post) : undefined,
            user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
            subreddit: isSet(object.subreddit) ? Subreddit.fromJSON(object.subreddit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.automation !== undefined &&
            (obj.automation = message.automation ? Automation.toJSON(message.automation) : undefined);
        message.comment !== undefined && (obj.comment = message.comment ? Comment.toJSON(message.comment) : undefined);
        message.post !== undefined && (obj.post = message.post ? Post.toJSON(message.post) : undefined);
        message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
        message.subreddit !== undefined &&
            (obj.subreddit = message.subreddit ? Subreddit.toJSON(message.subreddit) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAutomationInvocation();
        message.id = object.id ?? "";
        message.automation = (object.automation !== undefined && object.automation !== null)
            ? Automation.fromPartial(object.automation)
            : undefined;
        message.comment = (object.comment !== undefined && object.comment !== null)
            ? Comment.fromPartial(object.comment)
            : undefined;
        message.post = (object.post !== undefined && object.post !== null) ? Post.fromPartial(object.post) : undefined;
        message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
        message.subreddit = (object.subreddit !== undefined && object.subreddit !== null)
            ? Subreddit.fromPartial(object.subreddit)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.AutomationInvocation", AutomationInvocation);
export class AutomationEngineClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.actor.automation.v1alpha.AutomationEngine";
        this.rpc = rpc;
        this.Evaluate = this.Evaluate.bind(this);
    }
    Evaluate(request) {
        const data = AutomationInvocation.encode(request).finish();
        const promise = this.rpc.request(this.service, "Evaluate", data);
        return promise.then((data) => AutomationResult.decode(new _m0.Reader(data)));
    }
}
export const AutomationEngineDefinition = {
    name: "AutomationEngine",
    fullName: "devvit.actor.automation.v1alpha.AutomationEngine",
    methods: {
        /** Evaluates a workflow by invoking defined actor steps and gathering results */
        evaluate: {
            name: "Evaluate",
            requestType: AutomationInvocation,
            requestStream: false,
            responseType: AutomationResult,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
