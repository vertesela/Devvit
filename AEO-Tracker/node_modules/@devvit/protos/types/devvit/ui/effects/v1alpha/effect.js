/**
 * #effect.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { NavigateToUrlEffect } from './navigate_to_url.js';
import { RealtimeSubscriptionsEffect } from './realtime_subscriptions.js';
import { ReloadPartEffect } from './reload_part.js';
import { RerenderEffect } from './rerender_ui.js';
import { SendEventEffect } from './send_event.js';
import { ShowFormEffect } from './show_form.js';
import { ShowToastEffect } from './show_toast.js';
export var EffectType;
(function (EffectType) {
    /** EFFECT_REALTIME_SUB - Notify client to synchronize its realtime subscriptions */
    EffectType[EffectType["EFFECT_REALTIME_SUB"] = 0] = "EFFECT_REALTIME_SUB";
    /** EFFECT_RERENDER_UI - Trigger a re-render for apps that have visible UI */
    EffectType[EffectType["EFFECT_RERENDER_UI"] = 1] = "EFFECT_RERENDER_UI";
    /** EFFECT_RELOAD_PART - Notify the client that parts of a subreddit, post, or comment should be reloaded */
    EffectType[EffectType["EFFECT_RELOAD_PART"] = 2] = "EFFECT_RELOAD_PART";
    /** EFFECT_SHOW_FORM - Display a user input form */
    EffectType[EffectType["EFFECT_SHOW_FORM"] = 3] = "EFFECT_SHOW_FORM";
    /** EFFECT_SHOW_TOAST - Display a transient toast message */
    EffectType[EffectType["EFFECT_SHOW_TOAST"] = 4] = "EFFECT_SHOW_TOAST";
    /** EFFECT_NAVIGATE_TO_URL - Notify the client to navigate to a URL */
    EffectType[EffectType["EFFECT_NAVIGATE_TO_URL"] = 5] = "EFFECT_NAVIGATE_TO_URL";
    /** EFFECT_SEND_EVENT - Notify the client to send a synthetic event */
    EffectType[EffectType["EFFECT_SEND_EVENT"] = 6] = "EFFECT_SEND_EVENT";
    EffectType[EffectType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EffectType || (EffectType = {}));
export function effectTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "EFFECT_REALTIME_SUB":
            return EffectType.EFFECT_REALTIME_SUB;
        case 1:
        case "EFFECT_RERENDER_UI":
            return EffectType.EFFECT_RERENDER_UI;
        case 2:
        case "EFFECT_RELOAD_PART":
            return EffectType.EFFECT_RELOAD_PART;
        case 3:
        case "EFFECT_SHOW_FORM":
            return EffectType.EFFECT_SHOW_FORM;
        case 4:
        case "EFFECT_SHOW_TOAST":
            return EffectType.EFFECT_SHOW_TOAST;
        case 5:
        case "EFFECT_NAVIGATE_TO_URL":
            return EffectType.EFFECT_NAVIGATE_TO_URL;
        case 6:
        case "EFFECT_SEND_EVENT":
            return EffectType.EFFECT_SEND_EVENT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return EffectType.UNRECOGNIZED;
    }
}
export function effectTypeToJSON(object) {
    switch (object) {
        case EffectType.EFFECT_REALTIME_SUB:
            return 0;
        case EffectType.EFFECT_RERENDER_UI:
            return 1;
        case EffectType.EFFECT_RELOAD_PART:
            return 2;
        case EffectType.EFFECT_SHOW_FORM:
            return 3;
        case EffectType.EFFECT_SHOW_TOAST:
            return 4;
        case EffectType.EFFECT_NAVIGATE_TO_URL:
            return 5;
        case EffectType.EFFECT_SEND_EVENT:
            return 6;
        case EffectType.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseEffect() {
    return {
        realtimeSubscriptions: undefined,
        rerenderUi: undefined,
        reloadPart: undefined,
        showForm: undefined,
        showToast: undefined,
        navigateToUrl: undefined,
        sendEvent: undefined,
        type: 0,
    };
}
export const Effect = {
    $type: "devvit.ui.effects.v1alpha.Effect",
    encode(message, writer = _m0.Writer.create()) {
        if (message.realtimeSubscriptions !== undefined) {
            RealtimeSubscriptionsEffect.encode(message.realtimeSubscriptions, writer.uint32(10).fork()).ldelim();
        }
        if (message.rerenderUi !== undefined) {
            RerenderEffect.encode(message.rerenderUi, writer.uint32(18).fork()).ldelim();
        }
        if (message.reloadPart !== undefined) {
            ReloadPartEffect.encode(message.reloadPart, writer.uint32(26).fork()).ldelim();
        }
        if (message.showForm !== undefined) {
            ShowFormEffect.encode(message.showForm, writer.uint32(34).fork()).ldelim();
        }
        if (message.showToast !== undefined) {
            ShowToastEffect.encode(message.showToast, writer.uint32(42).fork()).ldelim();
        }
        if (message.navigateToUrl !== undefined) {
            NavigateToUrlEffect.encode(message.navigateToUrl, writer.uint32(50).fork()).ldelim();
        }
        if (message.sendEvent !== undefined) {
            SendEventEffect.encode(message.sendEvent, writer.uint32(66).fork()).ldelim();
        }
        if (message.type !== 0) {
            writer.uint32(56).int32(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEffect();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.realtimeSubscriptions = RealtimeSubscriptionsEffect.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.rerenderUi = RerenderEffect.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.reloadPart = ReloadPartEffect.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.showForm = ShowFormEffect.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.showToast = ShowToastEffect.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.navigateToUrl = NavigateToUrlEffect.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.sendEvent = SendEventEffect.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            realtimeSubscriptions: isSet(object.realtimeSubscriptions)
                ? RealtimeSubscriptionsEffect.fromJSON(object.realtimeSubscriptions)
                : undefined,
            rerenderUi: isSet(object.rerenderUi) ? RerenderEffect.fromJSON(object.rerenderUi) : undefined,
            reloadPart: isSet(object.reloadPart) ? ReloadPartEffect.fromJSON(object.reloadPart) : undefined,
            showForm: isSet(object.showForm) ? ShowFormEffect.fromJSON(object.showForm) : undefined,
            showToast: isSet(object.showToast) ? ShowToastEffect.fromJSON(object.showToast) : undefined,
            navigateToUrl: isSet(object.navigateToUrl) ? NavigateToUrlEffect.fromJSON(object.navigateToUrl) : undefined,
            sendEvent: isSet(object.sendEvent) ? SendEventEffect.fromJSON(object.sendEvent) : undefined,
            type: isSet(object.type) ? effectTypeFromJSON(object.type) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.realtimeSubscriptions !== undefined && (obj.realtimeSubscriptions = message.realtimeSubscriptions
            ? RealtimeSubscriptionsEffect.toJSON(message.realtimeSubscriptions)
            : undefined);
        message.rerenderUi !== undefined &&
            (obj.rerenderUi = message.rerenderUi ? RerenderEffect.toJSON(message.rerenderUi) : undefined);
        message.reloadPart !== undefined &&
            (obj.reloadPart = message.reloadPart ? ReloadPartEffect.toJSON(message.reloadPart) : undefined);
        message.showForm !== undefined &&
            (obj.showForm = message.showForm ? ShowFormEffect.toJSON(message.showForm) : undefined);
        message.showToast !== undefined &&
            (obj.showToast = message.showToast ? ShowToastEffect.toJSON(message.showToast) : undefined);
        message.navigateToUrl !== undefined &&
            (obj.navigateToUrl = message.navigateToUrl ? NavigateToUrlEffect.toJSON(message.navigateToUrl) : undefined);
        message.sendEvent !== undefined &&
            (obj.sendEvent = message.sendEvent ? SendEventEffect.toJSON(message.sendEvent) : undefined);
        message.type !== undefined && (obj.type = effectTypeToJSON(message.type));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseEffect();
        message.realtimeSubscriptions =
            (object.realtimeSubscriptions !== undefined && object.realtimeSubscriptions !== null)
                ? RealtimeSubscriptionsEffect.fromPartial(object.realtimeSubscriptions)
                : undefined;
        message.rerenderUi = (object.rerenderUi !== undefined && object.rerenderUi !== null)
            ? RerenderEffect.fromPartial(object.rerenderUi)
            : undefined;
        message.reloadPart = (object.reloadPart !== undefined && object.reloadPart !== null)
            ? ReloadPartEffect.fromPartial(object.reloadPart)
            : undefined;
        message.showForm = (object.showForm !== undefined && object.showForm !== null)
            ? ShowFormEffect.fromPartial(object.showForm)
            : undefined;
        message.showToast = (object.showToast !== undefined && object.showToast !== null)
            ? ShowToastEffect.fromPartial(object.showToast)
            : undefined;
        message.navigateToUrl = (object.navigateToUrl !== undefined && object.navigateToUrl !== null)
            ? NavigateToUrlEffect.fromPartial(object.navigateToUrl)
            : undefined;
        message.sendEvent = (object.sendEvent !== undefined && object.sendEvent !== null)
            ? SendEventEffect.fromPartial(object.sendEvent)
            : undefined;
        message.type = object.type ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.Effect", Effect);
function isSet(value) {
    return value !== null && value !== undefined;
}
