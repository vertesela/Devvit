/**
 * #attributes.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Struct } from '../../../../google/protobuf/struct.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { blockActionTypeFromJSON, blockActionTypeToJSON, blockBorderWidthFromJSON, blockBorderWidthToJSON, blockHorizontalAlignmentFromJSON, blockHorizontalAlignmentToJSON, blockSizeUnitFromJSON, blockSizeUnitToJSON, blockVerticalAlignmentFromJSON, blockVerticalAlignmentToJSON, } from './enums.js';
function createBaseBlockAlignment() {
    return { vertical: undefined, horizontal: undefined };
}
export const BlockAlignment = {
    $type: "devvit.ui.block_kit.v1beta.BlockAlignment",
    encode(message, writer = _m0.Writer.create()) {
        if (message.vertical !== undefined) {
            writer.uint32(8).int32(message.vertical);
        }
        if (message.horizontal !== undefined) {
            writer.uint32(16).int32(message.horizontal);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockAlignment();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vertical = reader.int32();
                    break;
                case 2:
                    message.horizontal = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vertical: isSet(object.vertical) ? blockVerticalAlignmentFromJSON(object.vertical) : undefined,
            horizontal: isSet(object.horizontal) ? blockHorizontalAlignmentFromJSON(object.horizontal) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.vertical !== undefined &&
            (obj.vertical = message.vertical !== undefined ? blockVerticalAlignmentToJSON(message.vertical) : undefined);
        message.horizontal !== undefined && (obj.horizontal = message.horizontal !== undefined
            ? blockHorizontalAlignmentToJSON(message.horizontal)
            : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockAlignment();
        message.vertical = object.vertical ?? undefined;
        message.horizontal = object.horizontal ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockAlignment", BlockAlignment);
function createBaseBlockBorder() {
    return { color: undefined, width: undefined, colors: undefined };
}
export const BlockBorder = {
    $type: "devvit.ui.block_kit.v1beta.BlockBorder",
    encode(message, writer = _m0.Writer.create()) {
        if (message.color !== undefined) {
            writer.uint32(10).string(message.color);
        }
        if (message.width !== undefined) {
            writer.uint32(16).int32(message.width);
        }
        if (message.colors !== undefined) {
            BlockColor.encode(message.colors, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockBorder();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.color = reader.string();
                    break;
                case 2:
                    message.width = reader.int32();
                    break;
                case 3:
                    message.colors = BlockColor.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            color: isSet(object.color) ? String(object.color) : undefined,
            width: isSet(object.width) ? blockBorderWidthFromJSON(object.width) : undefined,
            colors: isSet(object.colors) ? BlockColor.fromJSON(object.colors) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.color !== undefined && (obj.color = message.color);
        message.width !== undefined &&
            (obj.width = message.width !== undefined ? blockBorderWidthToJSON(message.width) : undefined);
        message.colors !== undefined && (obj.colors = message.colors ? BlockColor.toJSON(message.colors) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockBorder();
        message.color = object.color ?? undefined;
        message.width = object.width ?? undefined;
        message.colors = (object.colors !== undefined && object.colors !== null)
            ? BlockColor.fromPartial(object.colors)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockBorder", BlockBorder);
function createBaseBlockSizes() {
    return { grow: undefined, width: undefined, height: undefined };
}
export const BlockSizes = {
    $type: "devvit.ui.block_kit.v1beta.BlockSizes",
    encode(message, writer = _m0.Writer.create()) {
        if (message.grow !== undefined) {
            writer.uint32(8).bool(message.grow);
        }
        if (message.width !== undefined) {
            BlockSizes_Dimension.encode(message.width, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== undefined) {
            BlockSizes_Dimension.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockSizes();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.grow = reader.bool();
                    break;
                case 2:
                    message.width = BlockSizes_Dimension.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.height = BlockSizes_Dimension.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            grow: isSet(object.grow) ? Boolean(object.grow) : undefined,
            width: isSet(object.width) ? BlockSizes_Dimension.fromJSON(object.width) : undefined,
            height: isSet(object.height) ? BlockSizes_Dimension.fromJSON(object.height) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.grow !== undefined && (obj.grow = message.grow);
        message.width !== undefined && (obj.width = message.width ? BlockSizes_Dimension.toJSON(message.width) : undefined);
        message.height !== undefined &&
            (obj.height = message.height ? BlockSizes_Dimension.toJSON(message.height) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockSizes();
        message.grow = object.grow ?? undefined;
        message.width = (object.width !== undefined && object.width !== null)
            ? BlockSizes_Dimension.fromPartial(object.width)
            : undefined;
        message.height = (object.height !== undefined && object.height !== null)
            ? BlockSizes_Dimension.fromPartial(object.height)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockSizes", BlockSizes);
function createBaseBlockSizes_Dimension() {
    return { value: undefined, min: undefined, max: undefined };
}
export const BlockSizes_Dimension = {
    $type: "devvit.ui.block_kit.v1beta.BlockSizes.Dimension",
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== undefined) {
            BlockSizes_Dimension_Value.encode(message.value, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== undefined) {
            BlockSizes_Dimension_Value.encode(message.min, writer.uint32(18).fork()).ldelim();
        }
        if (message.max !== undefined) {
            BlockSizes_Dimension_Value.encode(message.max, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockSizes_Dimension();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = BlockSizes_Dimension_Value.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.min = BlockSizes_Dimension_Value.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.max = BlockSizes_Dimension_Value.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? BlockSizes_Dimension_Value.fromJSON(object.value) : undefined,
            min: isSet(object.min) ? BlockSizes_Dimension_Value.fromJSON(object.min) : undefined,
            max: isSet(object.max) ? BlockSizes_Dimension_Value.fromJSON(object.max) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined &&
            (obj.value = message.value ? BlockSizes_Dimension_Value.toJSON(message.value) : undefined);
        message.min !== undefined && (obj.min = message.min ? BlockSizes_Dimension_Value.toJSON(message.min) : undefined);
        message.max !== undefined && (obj.max = message.max ? BlockSizes_Dimension_Value.toJSON(message.max) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockSizes_Dimension();
        message.value = (object.value !== undefined && object.value !== null)
            ? BlockSizes_Dimension_Value.fromPartial(object.value)
            : undefined;
        message.min = (object.min !== undefined && object.min !== null)
            ? BlockSizes_Dimension_Value.fromPartial(object.min)
            : undefined;
        message.max = (object.max !== undefined && object.max !== null)
            ? BlockSizes_Dimension_Value.fromPartial(object.max)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockSizes.Dimension", BlockSizes_Dimension);
function createBaseBlockSizes_Dimension_Value() {
    return { value: 0, unit: 0 };
}
export const BlockSizes_Dimension_Value = {
    $type: "devvit.ui.block_kit.v1beta.BlockSizes.Dimension.Value",
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== 0) {
            writer.uint32(13).float(message.value);
        }
        if (message.unit !== 0) {
            writer.uint32(16).int32(message.unit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockSizes_Dimension_Value();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.float();
                    break;
                case 2:
                    message.unit = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? Number(object.value) : 0,
            unit: isSet(object.unit) ? blockSizeUnitFromJSON(object.unit) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.unit !== undefined && (obj.unit = blockSizeUnitToJSON(message.unit));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockSizes_Dimension_Value();
        message.value = object.value ?? 0;
        message.unit = object.unit ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockSizes.Dimension.Value", BlockSizes_Dimension_Value);
function createBaseBlockSize() {
    return { grow: undefined, width: undefined, widthUnit: undefined, height: undefined, heightUnit: undefined };
}
export const BlockSize = {
    $type: "devvit.ui.block_kit.v1beta.BlockSize",
    encode(message, writer = _m0.Writer.create()) {
        if (message.grow !== undefined) {
            writer.uint32(8).bool(message.grow);
        }
        if (message.width !== undefined) {
            writer.uint32(21).float(message.width);
        }
        if (message.widthUnit !== undefined) {
            writer.uint32(32).int32(message.widthUnit);
        }
        if (message.height !== undefined) {
            writer.uint32(29).float(message.height);
        }
        if (message.heightUnit !== undefined) {
            writer.uint32(40).int32(message.heightUnit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockSize();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.grow = reader.bool();
                    break;
                case 2:
                    message.width = reader.float();
                    break;
                case 4:
                    message.widthUnit = reader.int32();
                    break;
                case 3:
                    message.height = reader.float();
                    break;
                case 5:
                    message.heightUnit = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            grow: isSet(object.grow) ? Boolean(object.grow) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
            widthUnit: isSet(object.widthUnit) ? blockSizeUnitFromJSON(object.widthUnit) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
            heightUnit: isSet(object.heightUnit) ? blockSizeUnitFromJSON(object.heightUnit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.grow !== undefined && (obj.grow = message.grow);
        message.width !== undefined && (obj.width = message.width);
        message.widthUnit !== undefined &&
            (obj.widthUnit = message.widthUnit !== undefined ? blockSizeUnitToJSON(message.widthUnit) : undefined);
        message.height !== undefined && (obj.height = message.height);
        message.heightUnit !== undefined &&
            (obj.heightUnit = message.heightUnit !== undefined ? blockSizeUnitToJSON(message.heightUnit) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockSize();
        message.grow = object.grow ?? undefined;
        message.width = object.width ?? undefined;
        message.widthUnit = object.widthUnit ?? undefined;
        message.height = object.height ?? undefined;
        message.heightUnit = object.heightUnit ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockSize", BlockSize);
function createBaseBlockAction() {
    return { type: 0, id: "", data: undefined };
}
export const BlockAction = {
    $type: "devvit.ui.block_kit.v1beta.BlockAction",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.data !== undefined) {
            Struct.encode(Struct.wrap(message.data), writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? blockActionTypeFromJSON(object.type) : 0,
            id: isSet(object.id) ? String(object.id) : "",
            data: isObject(object.data) ? object.data : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = blockActionTypeToJSON(message.type));
        message.id !== undefined && (obj.id = message.id);
        message.data !== undefined && (obj.data = message.data);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockAction();
        message.type = object.type ?? 0;
        message.id = object.id ?? "";
        message.data = object.data ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockAction", BlockAction);
function createBaseBlockColor() {
    return { light: undefined, dark: undefined };
}
export const BlockColor = {
    $type: "devvit.ui.block_kit.v1beta.BlockColor",
    encode(message, writer = _m0.Writer.create()) {
        if (message.light !== undefined) {
            writer.uint32(10).string(message.light);
        }
        if (message.dark !== undefined) {
            writer.uint32(18).string(message.dark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockColor();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.light = reader.string();
                    break;
                case 2:
                    message.dark = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            light: isSet(object.light) ? String(object.light) : undefined,
            dark: isSet(object.dark) ? String(object.dark) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.light !== undefined && (obj.light = message.light);
        message.dark !== undefined && (obj.dark = message.dark);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockColor();
        message.light = object.light ?? undefined;
        message.dark = object.dark ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockColor", BlockColor);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
