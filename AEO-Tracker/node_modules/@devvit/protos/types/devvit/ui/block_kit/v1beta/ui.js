/**
 * #ui.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Struct } from '../../../../google/protobuf/struct.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { Effect } from '../../effects/v1alpha/effect.js';
import { UIEvent } from '../../events/v1alpha/event.js';
import { Block } from './block.js';
function createBaseUIRequest() {
    return { props: undefined, state: undefined, events: [], options: undefined };
}
export const UIRequest = {
    $type: "devvit.ui.block_kit.v1beta.UIRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.props !== undefined) {
            Struct.encode(Struct.wrap(message.props), writer.uint32(10).fork()).ldelim();
        }
        if (message.state !== undefined) {
            Struct.encode(Struct.wrap(message.state), writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.events) {
            UIEvent.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.options !== undefined) {
            UIOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUIRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.props = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.events.push(UIEvent.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.options = UIOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            props: isObject(object.props) ? object.props : undefined,
            state: isObject(object.state) ? object.state : undefined,
            events: Array.isArray(object?.events) ? object.events.map((e) => UIEvent.fromJSON(e)) : [],
            options: isSet(object.options) ? UIOptions.fromJSON(object.options) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.props !== undefined && (obj.props = message.props);
        message.state !== undefined && (obj.state = message.state);
        if (message.events) {
            obj.events = message.events.map((e) => e ? UIEvent.toJSON(e) : undefined);
        }
        else {
            obj.events = [];
        }
        message.options !== undefined && (obj.options = message.options ? UIOptions.toJSON(message.options) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUIRequest();
        message.props = object.props ?? undefined;
        message.state = object.state ?? undefined;
        message.events = object.events?.map((e) => UIEvent.fromPartial(e)) || [];
        message.options = (object.options !== undefined && object.options !== null)
            ? UIOptions.fromPartial(object.options)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.UIRequest", UIRequest);
function createBaseUIOptions() {
    return { noRender: undefined };
}
export const UIOptions = {
    $type: "devvit.ui.block_kit.v1beta.UIOptions",
    encode(message, writer = _m0.Writer.create()) {
        if (message.noRender !== undefined) {
            writer.uint32(8).bool(message.noRender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUIOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.noRender = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { noRender: isSet(object.noRender) ? Boolean(object.noRender) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.noRender !== undefined && (obj.noRender = message.noRender);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUIOptions();
        message.noRender = object.noRender ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.UIOptions", UIOptions);
function createBaseUIResponse() {
    return { state: undefined, effects: [], blocks: undefined };
}
export const UIResponse = {
    $type: "devvit.ui.block_kit.v1beta.UIResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.state !== undefined) {
            Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.effects) {
            Effect.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.blocks !== undefined) {
            Block.encode(message.blocks, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUIResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.effects.push(Effect.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.blocks = Block.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            state: isObject(object.state) ? object.state : undefined,
            effects: Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : [],
            blocks: isSet(object.blocks) ? Block.fromJSON(object.blocks) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.state !== undefined && (obj.state = message.state);
        if (message.effects) {
            obj.effects = message.effects.map((e) => e ? Effect.toJSON(e) : undefined);
        }
        else {
            obj.effects = [];
        }
        message.blocks !== undefined && (obj.blocks = message.blocks ? Block.toJSON(message.blocks) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUIResponse();
        message.state = object.state ?? undefined;
        message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
        message.blocks = (object.blocks !== undefined && object.blocks !== null)
            ? Block.fromPartial(object.blocks)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.UIResponse", UIResponse);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
