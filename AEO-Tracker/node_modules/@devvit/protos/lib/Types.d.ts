import type { Observable } from 'rxjs';
import type { Strings } from '../types/devvit/runtime/runtime_common.js';
import { SerializableServiceDefinition } from '../types/devvit/runtime/serializable.js';
import { type MessageType } from '../types/typeRegistry.js';
/** Optional RPC metadata passed with every request. */
export type Metadata = {
    [key: string]: Strings;
};
export declare const Definition: {
    toSerializable(definition: Readonly<Definition> | Readonly<SerializableServiceDefinition>): Readonly<SerializableServiceDefinition>;
    /**
     * To maintain our backwards/forwards compatibility, this should always return the subset of the service
     * definition that exists in the type registry, and not e.g. throw errors if the type registry is missing.
     */
    fromSerializable(def: Readonly<SerializableServiceDefinition>): Definition;
};
export type Definition = {
    /**
     * The period-delimited Protobuf package name + Protobuf service name. Eg,
     * "devvit.plugin.logger.Logger" which corresponds to the "Logger" service in
     * the "devvit.plugin.logger" package.
     */
    fullName: string;
    /**
     * The type of type provided. = Eg, "devvit.plugin.logger.Logger". This
     * name is unique per `Definition`. Eg, there is only one
     * "devvit.plugin.gl.GLRenderer", not one for WebGL v1 and one for v2. Two (or
     * more) implementations may exist however.
     *
     * The key is the method.name in **camelCase, not PascalCase**. Eg, "log" or
     * loadActor.
     */
    methods: {
        [methodName: string]: MethodDefinition;
    };
    /**
     * The Protobuf service name. This is the last period-delimited field of
     * `fullName`. Eg, "Logger".
     */
    name: string;
};
export type MethodDefinition = {
    /** The name of the method in PascalCase. Eg, "Log" or "LoadActor". */
    name: string;
    requestType: MessageType;
    requestStream: boolean;
    responseType: MessageType;
    responseStream: boolean;
};
/**
 * Common denominator remote procedure call interface. Some services only
 * require a partial implementation.
 */
export type Rpc = {
    /** Make a unary request */
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
    /** Make a request that returns a server stream */
    serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
    /** Make a request where the client will stream the request */
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
    /** Make a request where both the request and the response is streaming */
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
};
//# sourceMappingURL=Types.d.ts.map