var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Watcher_instances, _Watcher_disableExternDevvitProtos, _Watcher_typeChecker, _Watcher_path, _Watcher_observable, _Watcher_disposedNotifier, _Watcher_disposeWatcher, _Watcher_namespace, _Watcher_init, _Watcher_onBuildEnd, _ESBuildPack_bundleWatchers, _ESBuildPack_namespace, _ESBuildPack_disableExternDevvitProtos, _ESBuildPack_typeChecker;
import { CompileLog, CompileResponse, Minify } from '@devvit/protos';
import { dangerouslyGetBundleActor } from '@devvit/runtimes/common/bundle/BundleModule.js';
import { Config } from '@devvit/runtimes/common/bundle/Config.js';
import { newBuildInfoDependencies } from '@devvit/runtimes/lib/BuildInfoUtil.js';
import { NonNull, assertNonNull } from '@devvit/shared-types/NonNull.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import esbuild from 'esbuild';
import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import glob from 'tiny-glob';
import { getModuleEntrypoint } from '../lib/BuildPack.js';
import { mergeCompileRes, prefixBuildResultLogs } from './utils.js';
const FAKE_FACTORY = {
    // TODO: remove use of any below
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Build() { },
};
export class Watcher {
    /**
     * The default behavior is to externalize @devvit/protos. Set
     * disableExternDevvitProtos to bundle this large dependency.
     */
    constructor(namespace, path, actorSpec, options) {
        _Watcher_instances.add(this);
        _Watcher_disableExternDevvitProtos.set(this, void 0);
        _Watcher_typeChecker.set(this, void 0);
        _Watcher_path.set(this, void 0);
        /**
         * the actual emitter of updates
         */
        _Watcher_observable.set(this, void 0);
        /**
         * subscribers to this.observable will continue subscribing until this notifier emits a values
         */
        _Watcher_disposedNotifier.set(this, new Subject());
        /**
         * will be asynchronously set as buildResult.stop after calling esbuild.build
         */
        _Watcher_disposeWatcher.set(this, void 0);
        _Watcher_namespace.set(this, void 0);
        __classPrivateFieldSet(this, _Watcher_namespace, namespace, "f");
        __classPrivateFieldSet(this, _Watcher_path, path, "f");
        __classPrivateFieldSet(this, _Watcher_disableExternDevvitProtos, options?.disableExternDevvitProtos ?? false, "f");
        __classPrivateFieldSet(this, _Watcher_typeChecker, options?.typeChecker, "f");
        //  observers of this will be subscribed until this.disposedNotifier emits a value
        const sourceObservable = new Observable().pipe(takeUntil(__classPrivateFieldGet(this, _Watcher_disposedNotifier, "f")));
        // our observable is a BehaviorSubject used to multicast the source observer
        __classPrivateFieldSet(this, _Watcher_observable, new BehaviorSubject(CompileResponse.fromPartial({})), "f");
        // multi-casts (shares) here
        sourceObservable.subscribe(__classPrivateFieldGet(this, _Watcher_observable, "f"));
        // #init handles errors.
        void __classPrivateFieldGet(this, _Watcher_instances, "m", _Watcher_init).call(this, actorSpec);
    }
    getObservable() {
        return __classPrivateFieldGet(this, _Watcher_observable, "f");
    }
    async dispose() {
        await __classPrivateFieldGet(this, _Watcher_disposeWatcher, "f")?.call(this);
        // cancels all subscriptions after emitting value due to "takeUntil"
        __classPrivateFieldGet(this, _Watcher_disposedNotifier, "f").next();
        // clean up self
        __classPrivateFieldGet(this, _Watcher_disposedNotifier, "f").complete();
    }
}
_Watcher_disableExternDevvitProtos = new WeakMap(), _Watcher_typeChecker = new WeakMap(), _Watcher_path = new WeakMap(), _Watcher_observable = new WeakMap(), _Watcher_disposedNotifier = new WeakMap(), _Watcher_disposeWatcher = new WeakMap(), _Watcher_namespace = new WeakMap(), _Watcher_instances = new WeakSet(), _Watcher_init = async function _Watcher_init(actorSpec) {
    const ctx = await esbuild.context({
        ...esbuildConfig(__classPrivateFieldGet(this, _Watcher_disableExternDevvitProtos, "f")),
        entryPoints: [getModuleEntrypoint(__classPrivateFieldGet(this, _Watcher_path, "f"))],
        minify: false,
        sourcemap: 'inline',
        // esbuild now supports hooks through the onEnd callback in the build API.
        plugins: [
            {
                name: 'optionally-type-check-and-publish-compile-result-on-build-end',
                setup: (build) => {
                    build.onEnd(async (result) => {
                        await __classPrivateFieldGet(this, _Watcher_instances, "m", _Watcher_onBuildEnd).call(this, actorSpec, result);
                    });
                },
            },
        ],
    });
    if (__classPrivateFieldGet(this, _Watcher_observable, "f").isStopped) {
        // Disposed while await-ing and prior to setting disposeWatcher.
        await ctx.dispose();
        return;
    }
    __classPrivateFieldSet(this, _Watcher_disposeWatcher, async () => {
        await ctx.dispose();
    }, "f");
    await ctx.watch();
}, _Watcher_onBuildEnd = 
/**
 * @description The callback function for esbuild's onEnd hook. This is called after esbuild has finished building.
 */
async function _Watcher_onBuildEnd(actorSpec, esbuildResult) {
    const esbuildCompileRes = await esbuildResultToCompileResponse(__classPrivateFieldGet(this, _Watcher_namespace, "f"), actorSpec, esbuildResult);
    if (!__classPrivateFieldGet(this, _Watcher_typeChecker, "f") || (await hasTsxFiles(__classPrivateFieldGet(this, _Watcher_path, "f")))) {
        console.warn('Type checking is disabled.');
        __classPrivateFieldGet(this, _Watcher_observable, "f").next(esbuildCompileRes);
        return;
    }
    const typeCheckCompileRes = await __classPrivateFieldGet(this, _Watcher_typeChecker, "f").check({
        filename: __classPrivateFieldGet(this, _Watcher_path, "f"),
    });
    __classPrivateFieldGet(this, _Watcher_observable, "f").next(mergeCompileRes(esbuildCompileRes, typeCheckCompileRes));
};
export class ESBuildPack {
    /**
     * The default behavior is to externalize @devvit/protos. Set
     * disableExternDevvitProtos to bundle this large dependency.
     */
    constructor(namespace, options) {
        /**
         * @property {Map} bundleUpdateEmitters [note] A BehaviorSubject implements the Observable interface. Any observer who subscribes to a behavior subject will receive the last emitted value
         * @see https://rxjs.dev/guide/subject
         */
        _ESBuildPack_bundleWatchers.set(this, new Map());
        _ESBuildPack_namespace.set(this, void 0);
        // EsbuildPack options
        _ESBuildPack_disableExternDevvitProtos.set(this, void 0);
        // type chcecking will be disabled if typeChecker is undefined
        _ESBuildPack_typeChecker.set(this, void 0);
        __classPrivateFieldSet(this, _ESBuildPack_namespace, namespace, "f");
        __classPrivateFieldSet(this, _ESBuildPack_disableExternDevvitProtos, options?.disableExternDevvitProtos ?? false, "f");
        __classPrivateFieldSet(this, _ESBuildPack_typeChecker, options?.typeChecker, "f");
    }
    async Compile({ filename, minify, info }, _metadata) {
        if (filename == null) {
            // TODO: implement virtualFileSystem
            throw new Error('Bundling virtual file system not implemented yet');
        }
        assertNonNull(info, "Expected 'info' of CompileParams to be non-null");
        const entrypoint = getModuleEntrypoint(filename);
        let bundleResult;
        // TODO: include source-maps. See DX-60.
        try {
            bundleResult = await esbuild.build({
                ...esbuildConfig(__classPrivateFieldGet(this, _ESBuildPack_disableExternDevvitProtos, "f")),
                entryPoints: [entrypoint],
                metafile: true,
                sourcemap: false,
                sourcesContent: false,
                minify: minify === Minify.ALL,
                treeShaking: true,
            });
        }
        catch (err) {
            return isEsbuildResult(err)
                ? await esbuildResultToCompileResponse(__classPrivateFieldGet(this, _ESBuildPack_namespace, "f"), info, err)
                : unknownToErrorCompileResponse('Compilation', err);
        }
        const esbuildCompileResult = await esbuildResultToCompileResponse(__classPrivateFieldGet(this, _ESBuildPack_namespace, "f"), info, bundleResult);
        if (!__classPrivateFieldGet(this, _ESBuildPack_typeChecker, "f") || (await hasTsxFiles(filename))) {
            console.warn('Type checking is disabled.');
            return esbuildCompileResult;
        }
        const typeCheckingResult = await __classPrivateFieldGet(this, _ESBuildPack_typeChecker, "f").check({ filename });
        return mergeCompileRes(esbuildCompileResult, typeCheckingResult);
    }
    async dispose() {
        await Promise.all(Array.from(__classPrivateFieldGet(this, _ESBuildPack_bundleWatchers, "f").values()).map((watcher) => watcher.dispose()));
    }
    Watch({ filename, info }, _metadata) {
        assertNonNull(filename, "Expected 'filename' of CompileParams to be non-null");
        assertNonNull(info, "Expected 'info' of CompileParams to be non-null");
        if (!__classPrivateFieldGet(this, _ESBuildPack_bundleWatchers, "f").has(filename)) {
            const watcher = new Watcher(__classPrivateFieldGet(this, _ESBuildPack_namespace, "f"), filename, info, {
                disableExternDevvitProtos: __classPrivateFieldGet(this, _ESBuildPack_disableExternDevvitProtos, "f"),
                typeChecker: __classPrivateFieldGet(this, _ESBuildPack_typeChecker, "f"),
            });
            __classPrivateFieldGet(this, _ESBuildPack_bundleWatchers, "f").set(filename, watcher);
            return watcher.getObservable();
        }
        return NonNull(__classPrivateFieldGet(this, _ESBuildPack_bundleWatchers, "f").get(filename)).getObservable();
    }
}
_ESBuildPack_bundleWatchers = new WeakMap(), _ESBuildPack_namespace = new WeakMap(), _ESBuildPack_disableExternDevvitProtos = new WeakMap(), _ESBuildPack_typeChecker = new WeakMap();
// TODO: Complete way to determine dependencies from module's config.ts or config.yaml. See DX-61
// TODO: Owner should come from project root's config file
async function esbuildResultToCompileResponse(namespace, actorSpec, buildResult) {
    prefixBuildResultLogs(buildResult, 'esbuild');
    if ((buildResult.outputFiles?.length ?? 0) > 1) {
        throw new Error('There should only be one bundle after build');
    }
    assertNonNull(actorSpec, 'Expected actorSpec to be non-null');
    const errors = buildResult.errors.map(esbuildMessageToBuildLog);
    const warnings = buildResult.warnings.map(esbuildMessageToBuildLog);
    const code = buildResult.outputFiles?.[0]?.text;
    if (code == null)
        return CompileResponse.fromPartial({ errors, warnings });
    let dependencies;
    try {
        const ActorClass = await dangerouslyGetBundleActor(code);
        dependencies = await makeDependencySpec(namespace, actorSpec, ActorClass);
    }
    catch (err) {
        return unknownToErrorCompileResponse('Evaluation', err);
    }
    return CompileResponse.fromPartial({
        bundle: {
            code,
            dependencies,
            buildInfo: { created: new Date(), dependencies: newBuildInfoDependencies() },
        },
        errors,
        warnings,
    });
}
async function makeDependencySpec(namespace, actorSpec, ActorClass) {
    const config = new Config(FAKE_FACTORY, actorSpec, {});
    new ActorClass(config);
    return config.export(namespace);
}
/** Stringifies val as a BuildLog error in a CompileResponse. */
function unknownToErrorCompileResponse(phase, val) {
    return CompileResponse.fromPartial({
        errors: [{ text: `${phase} failure: ${StringUtil.caughtToString(val)}` }],
    });
}
function esbuildMessageToBuildLog(msg) {
    return CompileLog.fromPartial({
        text: msg.text,
        ...(msg.location != null && {
            detail: {
                column: msg.location.column,
                filename: msg.location.file,
                line: msg.location.line,
                suggestion: msg.location.suggestion,
                text: msg.location.lineText,
            },
        }),
    });
}
function isEsbuildResult(err) {
    return err instanceof Object && 'errors' in err && 'warnings' in err;
}
function esbuildConfig(disableExternDevvitProtos) {
    return {
        // Recursively inline any imported dependencies.
        bundle: true,
        // Split the @devvit/protos from the LinkedBundle. This means apps assume
        // @devvit/protos is available for import at execution time.
        external: disableExternDevvitProtos ? [] : ['@devvit/protos'],
        // to-do: uncomment once runtime is split aware and deployed everywhere.
        // external: ['@devvit/protos'],
        // Both format and target are intended to align to
        // @devvit/runtimes/package.json's build scripts for bootstrap compatibility.
        format: 'cjs',
        // Use our own built-in `Blocks.createElement` for JSX calls instead
        // of defaulting to `React.createElement`.
        // This should be automatic since its configured in TSConfig, so this
        // is to keep things explicit.
        // See https://esbuild.github.io/api/#jsx-fragment
        jsxFactory: 'Devvit.createElement',
        jsxFragment: 'Devvit.Fragment',
        // Do not show any console output. Warnings and errors are reported in the
        // response.
        logLevel: 'silent',
        target: 'es2020',
        // Write to in-memory buffers.
        write: false,
    };
}
async function hasTsxFiles(dir) {
    return await glob('**/*.tsx', { cwd: dir }).then((files) => files.length > 0);
}
