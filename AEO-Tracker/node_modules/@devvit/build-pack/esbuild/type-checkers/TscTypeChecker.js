import { CompileLogLineDetail } from '@devvit/protos';
import tsc from 'typescript';
import { getModuleEntrypoint } from '../../lib/BuildPack.js';
import { prefixBuildResultLogs } from '../utils.js';
// TODO: [DX-2214] We should make this the same as the tsconfig dumped into template projects
// to make sure that their IDE diagnostics match the ones we get from our compiler.
const BASE_TS_CONFIG = {
    // we'll allow it since we do checkJS: true
    allowJs: true,
    checkJs: true,
    allowSyntheticDefaultImports: true,
    composite: false,
    declaration: true,
    declarationMap: true,
    downlevelIteration: true,
    esModuleInterop: true,
    exactOptionalPropertyTypes: false,
    experimentalDecorators: true,
    forceConsistentCasingInFileNames: true,
    inlineSources: false,
    isolatedModules: true,
    jsx: tsc.JsxEmit.React,
    jsxFactory: 'Devvit.createElement',
    jsxFragmentFactory: 'Devvit.Fragment',
    lib: ['lib.es2020.core.d.ts', 'lib.webworker.d.ts'],
    module: tsc.ModuleKind.NodeNext,
    moduleResolution: tsc.ModuleResolutionKind.NodeNext,
    noImplicitOverride: true,
    noImplicitAny: false,
    noUnusedLocals: false,
    noUnusedParameters: false,
    preserveWatchOutput: true,
    resolveJsonModule: true,
    strict: true,
    target: tsc.ScriptTarget.ES2020,
    skipLibCheck: true,
    noEmitOnError: true,
};
/**
 * @description TscBuildPack is a BuildPack that uses the TypeScript compiler to type check TypeScript files.
 * Please note that this BuildPack does not produce any output files. It is meant to be used in conjunction with
 * another BuildPack that produces output files.
 */
export class TscTypeChecker {
    async check(request) {
        const { filename } = request;
        if (filename == null) {
            throw new Error('Bundling virtual file system not implemented yet. Please provide a filename as the compilation entrypoint.');
        }
        const entrypoint = getModuleEntrypoint(filename);
        const program = tsc.createProgram([entrypoint], BASE_TS_CONFIG);
        const emitResult = program.emit();
        return tscTypeCheckResultToCompileResponse(emitResult);
    }
}
function oneBase(num) {
    return num + 1;
}
export function tscTypeCheckResultToCompileResponse(emitResult) {
    const errors = [];
    const warnings = [];
    emitResult.diagnostics.forEach((diagnostic) => {
        if (diagnostic.file != null) {
            const text = tsc.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
            const detail = CompileLogLineDetail.fromPartial({
                filename: diagnostic.file.fileName,
                text: diagnostic.messageText.toString(),
                suggestion: '', // there is an API for this, but it's not exposed in specific diagnostic messages
            });
            if (diagnostic.start != null) {
                detail.line = oneBase(diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start).line);
                detail.column = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start).character;
            }
            const compileLog = {
                detail,
                text,
            };
            if (diagnostic.category === tsc.DiagnosticCategory.Error) {
                errors.push(compileLog);
            }
            else if (diagnostic.category === tsc.DiagnosticCategory.Warning) {
                warnings.push(compileLog);
            }
        }
    });
    return prefixBuildResultLogs({
        errors,
        warnings,
    }, 'tsc');
}
