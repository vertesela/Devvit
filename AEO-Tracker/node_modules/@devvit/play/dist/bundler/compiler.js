import * as tsvfs from '@typescript/vfs';
import ts from 'typescript';
import tsd from './tsd.json' assert { type: 'json' };
export const appEntrypointFilename = '/src/main.tsx';
export function newTSEnv() {
    const system = tsvfs.createSystem(new Map());
    const env = tsvfs.createVirtualTypeScriptEnvironment(system, [], ts, compilerOpts());
    for (const [name, data] of virtualFiles().entries())
        env.createFile(name, data);
    return env;
}
export function compile(env) {
    const src = env.languageService.getEmitOutput(appEntrypointFilename).outputFiles[0]
        ?.text ?? '';
    // Adapt bundle CommonJS output to format expected by runtime-lite.
    return src.replace(/^"use strict";/, '"use strict"; module.exports = {}; const {exports} = module;');
}
export function getSource(env) {
    return env.getSourceFile(appEntrypointFilename)?.text ?? '';
}
export function setSource(env, src) {
    env.updateFile(appEntrypointFilename, src || ' '); // empty strings trigger file deletion!
}
function virtualFiles() {
    return new Map([
        ...Object.entries(tsd),
        [appEntrypointFilename, ' '] // empty files are immediately deleted!
    ]);
}
function compilerOpts() {
    // Match config used in production apps.
    return {
        jsx: ts.JsxEmit.React,
        jsxFactory: 'Devvit.createElement',
        jsxFragmentFactory: 'Devvit.Fragment',
        lib: ['ES2020', 'WebWorker'],
        module: ts.ModuleKind.CommonJS,
        // Maximize friendly type checking.
        noImplicitOverride: true,
        strict: true,
        // Provided types are already checked.
        skipLibCheck: true,
        skipDefaultLibCheck: true,
        // Improve `debugger` support.
        inlineSources: true,
        inlineSourceMap: true,
        target: ts.ScriptTarget.ES2020
    };
}
//# sourceMappingURL=compiler.js.map