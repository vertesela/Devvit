var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _PlayEditor_editor;
import { EditorSelection } from '@codemirror/state';
import { EditorView } from 'codemirror';
import { LitElement, css, html } from 'lit';
import { customElement, eventOptions, property, query, queryAssignedElements } from 'lit/decorators.js';
import { unindent } from '../../../utils/unindent.js';
import { Bubble } from '../../bubble.js';
import { newEditorState } from './editor-state.js';
/** @slot - Optional template. */
let PlayEditor = class PlayEditor extends LitElement {
    constructor() {
        super(...arguments);
        _PlayEditor_editor.set(this, void 0);
    }
    /**
     * @arg line One-based index.
     * @arg char Zero-based index.
     */
    openLine(line, char) {
        const info = __classPrivateFieldGet(this, _PlayEditor_editor, "f").state.doc.line(line);
        const selection = EditorSelection.create([
            EditorSelection.cursor(info.from + char)
        ]);
        __classPrivateFieldGet(this, _PlayEditor_editor, "f").dispatch({ selection: selection, scrollIntoView: true });
        __classPrivateFieldGet(this, _PlayEditor_editor, "f").focus();
    }
    setSrc(src) {
        __classPrivateFieldGet(this, _PlayEditor_editor, "f").dispatch({
            changes: { from: 0, to: __classPrivateFieldGet(this, _PlayEditor_editor, "f").state.doc.length, insert: src }
        });
    }
    firstUpdated() {
        const init = newEditorState(this.env, this.src ?? '');
        __classPrivateFieldSet(this, _PlayEditor_editor, new EditorView({
            dispatch: transaction => {
                __classPrivateFieldGet(this, _PlayEditor_editor, "f").update([transaction]);
                if (transaction.docChanged) {
                    const src = transaction.state.doc.sliceString(0);
                    this.dispatchEvent(Bubble('edit', src));
                }
            },
            parent: this._root,
            state: init
        }), "f");
    }
    render() {
        return html `
      <div class="editor"></div>
      <slot @slotchange=${this._onSlotChange}></slot>
    `;
    }
    _onSlotChange() {
        // If <script> exists, get the program inside.
        let src = this._scripts[0]?.innerText;
        if (src == null)
            return;
        src = unindent(src ?? '');
        this.dispatchEvent(Bubble('edit-template', src));
    }
};
_PlayEditor_editor = new WeakMap();
PlayEditor.styles = css `
    .editor {
      height: 100%;
      width: 100%;
    }
    .cm-editor {
      height: 100%;
      overflow: hidden;
    }
  `;
__decorate([
    property({ attribute: false })
], PlayEditor.prototype, "env", void 0);
__decorate([
    property()
], PlayEditor.prototype, "src", void 0);
__decorate([
    query('div')
], PlayEditor.prototype, "_root", void 0);
__decorate([
    queryAssignedElements({
        flatten: true,
        selector: 'script[type="application/devvit"]'
    })
], PlayEditor.prototype, "_scripts", void 0);
__decorate([
    eventOptions({ once: true })
], PlayEditor.prototype, "_onSlotChange", null);
PlayEditor = __decorate([
    customElement('play-editor')
], PlayEditor);
export { PlayEditor };
//# sourceMappingURL=play-editor.js.map