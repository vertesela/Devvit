var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DevServerPlugin_instances, _DevServerPlugin_watchersByProject, _DevServerPlugin_actorsWatched, _DevServerPlugin_builder, _DevServerPlugin_projectUpdateObservables, _DevServerPlugin_latestActorBundles, _DevServerPlugin_disposedNotifier, _DevServerPlugin_defaultProjectDirectory, _DevServerPlugin_buildProblems, _DevServerPlugin_getActorInfo, _DevServerPlugin_addActorWatcherIfNeeded, _DevServerPlugin_processBuildResponse, _DevServerPlugin_init, _DevServerPlugin_anyBuildProblems, _DevServerPlugin_initProjectWatcherFor, _DevServerPlugin_initProjectUpdateSubjectFor, _DevServerPlugin_rebuild, _DevServerPlugin_getProjectUpdateSubjectFor, _DevServerPlugin_getWatcherForDir, _DevServerPlugin_getTestCasePath, _DevServerPlugin_getPathToActor;
/**
 * DevServer Plugin
 *
 * This plugin implements the devvit/plugin/devserver::DevServerPlugin interface
 *
 * @packageDocumentation
 */
import { BehaviorSubject, from, Observable, Subject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import { existsSync, promises as fs } from 'fs';
import path from 'path';
import { TscTypeChecker } from '@devvit/build-pack';
import { ESBuildPack } from '@devvit/build-pack/esbuild/ESBuildPack.js';
import { DefaultBuilder } from '@devvit/builders/Builder.js';
import { InMemoryResolver } from '@devvit/linkers/resolver.js';
import { AssetResolverDefinition, ClockDefinition, CompileParams, Definition, Empty, FlairDefinition, GraphQLDefinition, HTTPDefinition, InspectorDescription, InspectorDescriptions, KVStoreDefinition, LinksAndCommentsDefinition, ListingsDefinition, LoggerDefinition, MediaServiceDefinition, ModerationDefinition, ModlogDefinition, ModNoteDefinition, NewModmailDefinition, PostCollectionsDefinition, PrivateMessagesDefinition, ProjectBuildProblems, ProjectUpdateResponse, RealtimeDefinition, RedditAPIV2Definition, RedisAPIDefinition, SchedulerDefinition, SettingsDefinition, StreamBrokerDefinition, SubredditsDefinition, TestCasesList, UsersDefinition, WidgetsDefinition, WikiDefinition, } from '@devvit/protos';
import { childHostname, LOCAL_HOSTNAME, REDDIT_API_CNAME, resolvePluginDefinitionHostname, resolveSystemHostname, } from '@devvit/runtimes/lib/HostnameUtil.js';
import { ACTOR_SRC_DIR, ACTOR_SRC_PRIMARY_ENTRY_POINT, ACTOR_SRC_PRIMARY_ENTRY_POINT_JSX, ACTOR_SRC_PRIMARY_NAME, ACTORS_DIR_LEGACY, } from '@devvit/shared-types/constants.js';
import { NonNull } from '@devvit/shared-types/NonNull.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import ProjectWatcher from './project-watcher.js';
const TEST_CASES_FILE = 'testCases.json';
const plugins = Object.freeze([
    ClockDefinition,
    HTTPDefinition,
    KVStoreDefinition,
    RedisAPIDefinition,
    RedditAPIV2Definition,
    LoggerDefinition,
    SchedulerDefinition,
    ModlogDefinition,
    StreamBrokerDefinition,
    RealtimeDefinition,
    SettingsDefinition,
    AssetResolverDefinition,
    MediaServiceDefinition,
].map(Definition.toSerializable));
const redditapi = [
    FlairDefinition,
    GraphQLDefinition,
    LinksAndCommentsDefinition,
    ListingsDefinition,
    ModerationDefinition,
    ModNoteDefinition,
    NewModmailDefinition,
    PrivateMessagesDefinition,
    SubredditsDefinition,
    PostCollectionsDefinition,
    UsersDefinition,
    WidgetsDefinition,
    WikiDefinition,
];
class DevServerPlugin {
    /**
     * The default behavior is to externalize @devvit/protos. Set
     * disableExternDevvitProtos to bundle this large dependency.
     */
    constructor(defaultProjectDir, namespace, disableExternDevvitProtos) {
        _DevServerPlugin_instances.add(this);
        /**
         * Keep a reference to all the project watchers we have. Make one watcher
         * per project. Watcher is responsible for file updates and performing the
         * `ListProject` call.
         */
        _DevServerPlugin_watchersByProject.set(this, new Map());
        /**
         * Actors under Builder.Watch().
         * The corresponding BehaviorSubject caches the latest published updates for
         * that actor.
         */
        _DevServerPlugin_actorsWatched.set(this, new Map());
        _DevServerPlugin_builder.set(this, void 0);
        /**
         * The BehaviorSubject will cache the latest published ProjectUpdateResponse value.
         * With this, when the browser refreshes and a new connection to `NotifyBundleUpdates`
         * is established, we can conveniently push them the latest update using the cached
         * value immediately upon subscription without any additional work
         */
        _DevServerPlugin_projectUpdateObservables.set(this, new Map());
        _DevServerPlugin_latestActorBundles.set(this, new Map());
        /**
         * @property subscribers to this.observable will continue subscribing until this notifier emits a values
         */
        _DevServerPlugin_disposedNotifier.set(this, new Subject());
        _DevServerPlugin_defaultProjectDirectory.set(this, void 0);
        _DevServerPlugin_buildProblems.set(this, {});
        const descriptions = plugins.map((definition) => InspectorDescription.fromPartial({
            hostname: resolvePluginDefinitionHostname(definition, namespace),
            provides: [{ ...definition, methods: Object.values(definition.methods) }],
        }));
        // add redditapi categories to descriptions
        descriptions.push(...redditapi.map((definition) => {
            const ssd = Definition.toSerializable(definition);
            const categoryHostname = childHostname(ssd.name, {
                hostname: resolveSystemHostname(REDDIT_API_CNAME, namespace),
            });
            return InspectorDescription.fromPartial({
                hostname: categoryHostname,
                provides: [{ ...ssd, methods: Object.values(ssd.methods) }],
            });
        }));
        const resolver = new InMemoryResolver(InspectorDescriptions.fromPartial({ descriptions }));
        const builder = new DefaultBuilder(new ESBuildPack(namespace, { disableExternDevvitProtos, typeChecker: new TscTypeChecker() }), resolver);
        __classPrivateFieldSet(this, _DevServerPlugin_defaultProjectDirectory, defaultProjectDir, "f");
        __classPrivateFieldSet(this, _DevServerPlugin_builder, builder, "f");
    }
    async dispose() {
        __classPrivateFieldGet(this, _DevServerPlugin_disposedNotifier, "f").next();
        __classPrivateFieldGet(this, _DevServerPlugin_disposedNotifier, "f").complete();
        await Promise.all([...__classPrivateFieldGet(this, _DevServerPlugin_watchersByProject, "f").values()].map((watcher) => watcher.dispose()));
        __classPrivateFieldGet(this, _DevServerPlugin_projectUpdateObservables, "f").forEach((s) => s.complete());
        __classPrivateFieldGet(this, _DevServerPlugin_projectUpdateObservables, "f").clear();
        __classPrivateFieldGet(this, _DevServerPlugin_actorsWatched, "f").forEach((s) => s.complete());
        __classPrivateFieldGet(this, _DevServerPlugin_actorsWatched, "f").clear();
        await __classPrivateFieldGet(this, _DevServerPlugin_builder, "f").dispose();
    }
    async ListProject(request) {
        const projectDir = request.projectRootDirectory || __classPrivateFieldGet(this, _DevServerPlugin_defaultProjectDirectory, "f");
        __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_init).call(this, projectDir);
        const projectList = await __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getWatcherForDir).call(this, projectDir).listProject();
        projectList.buildProblems = __classPrivateFieldGet(this, _DevServerPlugin_buildProblems, "f");
        return projectList;
    }
    NotifyBundleUpdates(request) {
        const projectDir = request.projectRootDirectory || __classPrivateFieldGet(this, _DevServerPlugin_defaultProjectDirectory, "f");
        __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_init).call(this, projectDir);
        return __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getProjectUpdateSubjectFor).call(this, projectDir);
    }
    async GetTestCases(request) {
        const testCasesPath = await __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getTestCasePath).call(this, request.actorName);
        let testCases = [];
        if (existsSync(testCasesPath)) {
            const testCasesFileContents = await fs.readFile(testCasesPath, 'utf-8');
            testCases = JSON.parse(testCasesFileContents).map((testCase) => {
                return {
                    ...testCase,
                    testInput: JSON.stringify(testCase.testInput),
                };
            });
        } // else send an empty map, since there aren't any test cases yet
        return TestCasesList.fromPartial({ actorName: request.actorName, testCases });
    }
    async UpdateTestCases(request) {
        const testCasesPath = await __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getTestCasePath).call(this, request.actorName);
        const testCasesContent = JSON.stringify(request.testCases.map((testCase) => {
            return {
                ...testCase,
                testInput: JSON.parse(testCase.testInput),
            };
        }), null, 2);
        await fs.writeFile(testCasesPath, testCasesContent);
        return Empty.fromPartial({});
    }
}
_DevServerPlugin_watchersByProject = new WeakMap(), _DevServerPlugin_actorsWatched = new WeakMap(), _DevServerPlugin_builder = new WeakMap(), _DevServerPlugin_projectUpdateObservables = new WeakMap(), _DevServerPlugin_latestActorBundles = new WeakMap(), _DevServerPlugin_disposedNotifier = new WeakMap(), _DevServerPlugin_defaultProjectDirectory = new WeakMap(), _DevServerPlugin_buildProblems = new WeakMap(), _DevServerPlugin_instances = new WeakSet(), _DevServerPlugin_getActorInfo = function _DevServerPlugin_getActorInfo(file, projectDir) {
    if (file.path === ACTOR_SRC_PRIMARY_ENTRY_POINT ||
        file.path === ACTOR_SRC_PRIMARY_ENTRY_POINT_JSX) {
        return {
            file,
            actorPath: path.join(projectDir, ACTOR_SRC_DIR),
            relativeActorPath: path.join(ACTOR_SRC_DIR, ACTOR_SRC_PRIMARY_NAME),
            actorName: ACTOR_SRC_PRIMARY_NAME,
            isLegacyApp: false,
        };
    }
    if (file.isDirectory) {
        const parts = file.path.split(path.sep);
        if (parts[0] === ACTORS_DIR_LEGACY && parts.length > 1) {
            const actorName = parts[1];
            const relativeActorPath = path.join(ACTORS_DIR_LEGACY, actorName);
            return {
                file,
                actorPath: path.join(projectDir, relativeActorPath),
                relativeActorPath,
                actorName,
                isLegacyApp: true,
            };
        }
    }
    return null;
}, _DevServerPlugin_addActorWatcherIfNeeded = async function _DevServerPlugin_addActorWatcherIfNeeded(file, projectDir) {
    const actorInfo = __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getActorInfo).call(this, file, projectDir);
    if (!actorInfo) {
        return;
    }
    if (__classPrivateFieldGet(this, _DevServerPlugin_actorsWatched, "f").has(actorInfo.actorPath)) {
        return;
    }
    // use a map to pipe raw stream of BuildResponse to a formatted stream of ProjectUpdateResponse
    const processedBuildResponseObservable = __classPrivateFieldGet(this, _DevServerPlugin_builder, "f")
        .Watch(newCompileParams(actorInfo))
        .pipe(mergeMap((response) => __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_processBuildResponse).call(this, projectDir, actorInfo, response)));
    // used for caching latest actor specific updates
    const actorUpdateSubject = new BehaviorSubject(ProjectUpdateResponse.fromPartial({ projectRootDirectory: actorInfo.actorPath }));
    // reuse the project-specific BehaviorSubject for broadcasting
    const projectUpdateSubject = __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getProjectUpdateSubjectFor).call(this, projectDir);
    processedBuildResponseObservable.subscribe(actorUpdateSubject);
    processedBuildResponseObservable.subscribe(projectUpdateSubject);
    __classPrivateFieldGet(this, _DevServerPlugin_actorsWatched, "f").set(actorInfo.actorPath, actorUpdateSubject);
}, _DevServerPlugin_processBuildResponse = 
/**
 * transforms a BuildResponse into a ProjectUpdateResponse
 */
async function _DevServerPlugin_processBuildResponse(projectDir, actorInfo, response) {
    const updateResponse = ProjectUpdateResponse.fromPartial({
        projectRootDirectory: projectDir,
        linkedBundle: response.bundle,
        actorPath: actorInfo.relativeActorPath,
    });
    __classPrivateFieldGet(this, _DevServerPlugin_buildProblems, "f")[actorInfo.actorName] = ProjectBuildProblems.fromPartial({
        warnings: response.warnings,
        errors: response.errors,
    });
    updateResponse.buildProblems = __classPrivateFieldGet(this, _DevServerPlugin_buildProblems, "f");
    __classPrivateFieldGet(this, _DevServerPlugin_latestActorBundles, "f").set(actorInfo.actorPath, updateResponse);
    if (response.errors.length === 0) {
        // An actor build has completed successfully. Rebuild all previously failed
        // builds in case they failed due to missing dependencies. Rebuilding any
        // linker dependency does not trigger a rebuild of what depends on it unless
        // it has outstanding build errors.
        //
        // In more detail, the current linker resolution strategy is "keep trying
        // until the resolver is populated with all the actors and it works." This
        // may be improved by separating building into a compile pass, a resolve
        // pass, and then a final linking pass.
        for (const [, buildProblems] of Object.entries(__classPrivateFieldGet(this, _DevServerPlugin_buildProblems, "f"))) {
            if (buildProblems.errors.length === 0)
                continue;
            // This build failed previously. Try again.
            await __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_rebuild).call(this, projectDir, actorInfo);
        }
    }
    return updateResponse;
}, _DevServerPlugin_init = function _DevServerPlugin_init(projectDir) {
    if (__classPrivateFieldGet(this, _DevServerPlugin_projectUpdateObservables, "f").has(projectDir) && __classPrivateFieldGet(this, _DevServerPlugin_watchersByProject, "f").has(projectDir)) {
        console.log('already initialized for project: ' + projectDir);
        return;
    }
    __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_initProjectUpdateSubjectFor).call(this, projectDir);
    __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_initProjectWatcherFor).call(this, projectDir);
}, _DevServerPlugin_anyBuildProblems = function _DevServerPlugin_anyBuildProblems(buildProblems) {
    for (const [, projectBuildProblems] of Object.entries(buildProblems)) {
        if (projectBuildProblems.errors && projectBuildProblems.errors.length > 0) {
            return true;
        }
    }
    return false;
}, _DevServerPlugin_initProjectWatcherFor = function _DevServerPlugin_initProjectWatcherFor(projectDir) {
    if (__classPrivateFieldGet(this, _DevServerPlugin_watchersByProject, "f").has(projectDir)) {
        return;
    }
    const watcher = __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getWatcherForDir).call(this, projectDir); // creates if not exist
    const projectUpdateSubject = __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getProjectUpdateSubjectFor).call(this, projectDir); // creates if not exists too
    // Only emit updates if the linked bundle has changed or there are build problems.  This is so
    // the behaviorsubject doesn't cache a useless update.
    watcher.watchProject().subscribe((update) => {
        if (update.linkedBundle || __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_anyBuildProblems).call(this, update.buildProblems)) {
            projectUpdateSubject.next(update);
        }
    });
    watcher.watchProject().subscribe((update) => {
        if (!update.file) {
            return;
        }
        return from(__classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_addActorWatcherIfNeeded).call(this, update.file, update.projectRootDirectory));
    });
    watcher
        .listProject()
        .then(async (projectList) => {
        for (const file of projectList.projectFileSystem?.files ?? []) {
            await __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_addActorWatcherIfNeeded).call(this, file, projectDir);
        }
    })
        .catch((err) => console.error(`Could not list project: ${StringUtil.caughtToString(err)}`));
}, _DevServerPlugin_initProjectUpdateSubjectFor = function _DevServerPlugin_initProjectUpdateSubjectFor(projectDir) {
    console.log('initializing subject');
    if (__classPrivateFieldGet(this, _DevServerPlugin_projectUpdateObservables, "f").has(projectDir)) {
        return;
    }
    // we'll use update subject to combine file-system updates and bundle updates
    const updateSubject = new BehaviorSubject(ProjectUpdateResponse.fromPartial({ projectRootDirectory: projectDir }));
    //  observers of this will be subscribed until this.disposedNotifier emits a value
    const disposableObserver = new Observable().pipe(takeUntil(__classPrivateFieldGet(this, _DevServerPlugin_disposedNotifier, "f")));
    disposableObserver.subscribe(updateSubject);
    __classPrivateFieldGet(this, _DevServerPlugin_projectUpdateObservables, "f").set(projectDir, updateSubject);
}, _DevServerPlugin_rebuild = 
/**
 * Manually rebuilds an actor path.  Called when a dependency for a previously failed bundle is
 * ready and the failed bundle should be retried.
 */
async function _DevServerPlugin_rebuild(projectDir, actorInfo) {
    const response = await __classPrivateFieldGet(this, _DevServerPlugin_builder, "f").Build(newCompileParams(actorInfo));
    const processedResponse = await __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_processBuildResponse).call(this, projectDir, actorInfo, response);
    __classPrivateFieldGet(this, _DevServerPlugin_actorsWatched, "f").get(actorInfo.actorPath)?.next(processedResponse);
    __classPrivateFieldGet(this, _DevServerPlugin_projectUpdateObservables, "f").get(projectDir)?.next(processedResponse);
}, _DevServerPlugin_getProjectUpdateSubjectFor = function _DevServerPlugin_getProjectUpdateSubjectFor(projectDir) {
    if (!__classPrivateFieldGet(this, _DevServerPlugin_projectUpdateObservables, "f").has(projectDir)) {
        __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_initProjectUpdateSubjectFor).call(this, projectDir);
    }
    return NonNull(__classPrivateFieldGet(this, _DevServerPlugin_projectUpdateObservables, "f").get(projectDir));
}, _DevServerPlugin_getWatcherForDir = function _DevServerPlugin_getWatcherForDir(directory) {
    let watcher = __classPrivateFieldGet(this, _DevServerPlugin_watchersByProject, "f").get(directory);
    if (!watcher) {
        watcher = new ProjectWatcher(directory);
        __classPrivateFieldGet(this, _DevServerPlugin_watchersByProject, "f").set(directory, watcher);
    }
    return watcher;
}, _DevServerPlugin_getTestCasePath = async function _DevServerPlugin_getTestCasePath(actorName) {
    const projectDir = __classPrivateFieldGet(this, _DevServerPlugin_defaultProjectDirectory, "f");
    const actorPath = await __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getPathToActor).call(this, projectDir, actorName);
    if (!actorPath) {
        throw new Error(`Actor "${actorName}" not found.Make sure you're using the full name?`);
    }
    return path.join(actorPath, TEST_CASES_FILE);
}, _DevServerPlugin_getPathToActor = async function _DevServerPlugin_getPathToActor(projectDir, fullName) {
    const projectList = await __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getWatcherForDir).call(this, projectDir).listProject();
    const files = projectList.projectFileSystem?.files;
    for (const file of files || []) {
        const actorInfo = __classPrivateFieldGet(this, _DevServerPlugin_instances, "m", _DevServerPlugin_getActorInfo).call(this, file, projectDir);
        if (!actorInfo || !actorInfo.actorPath.endsWith(file.path)) {
            continue;
        }
        const latest = __classPrivateFieldGet(this, _DevServerPlugin_actorsWatched, "f").get(actorInfo.actorPath)?.getValue();
        if (latest?.linkedBundle) {
            for (const ssd of latest.linkedBundle.provides) {
                if (ssd.fullName === fullName) {
                    return latest.linkedBundle.hostname.replace(`.${LOCAL_HOSTNAME}`, '');
                }
            }
        }
    }
    return null;
};
export default DevServerPlugin;
function newCompileParams(actorInfo) {
    if (!actorInfo.isLegacyApp) {
        return CompileParams.fromPartial({
            filename: actorInfo.actorPath,
            info: { name: ACTOR_SRC_PRIMARY_NAME, owner: 'snoo', version: '0.0.0' },
        });
    }
    const pathParts = actorInfo.actorPath.split(path.sep);
    const actorName = NonNull(pathParts.at(-1));
    return CompileParams.fromPartial({
        filename: actorInfo.actorPath,
        info: { name: actorName, owner: 'snoo', version: '0.0.0' },
    });
}
