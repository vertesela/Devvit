var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ProjectWatcher_instances, _ProjectWatcher_watcher, _ProjectWatcher_watcherReady, _ProjectWatcher_bundleUpdateSubscribers, _ProjectWatcher_pathPrefix, _ProjectWatcher_watchedFilesAsBuilderFS;
/**
 *
 * Project watcher module provides utilities for watching a local project
 *
 * Can be pointed at a directory and watches it for local changes.
 * When first instantiated fires events for all the actors and plugins found in a local
 * project.
 *
 *
 * @packageDocumentation
 */
import { assert } from 'node:console';
import { File } from '@devvit/protos';
import { Observable } from 'rxjs';
import chokidar from 'chokidar';
import { ProjectListingResponse, ProjectUpdateResponse } from '@devvit/protos';
import path from 'path';
const CHANGE_POPS_FILE_PATH = new Set(['unlink', 'unlinkDir']);
const CHANGE_IS_DIRECTORY = new Set(['addDir', ...CHANGE_POPS_FILE_PATH]);
const SYSTEM_ROOT = path.parse(process.cwd()).root; // C:\ on Windows, / everywhere else
// This is chokidar's default, but want to expose this as the source of truth
export const WATCHER_INTERVAL = 100;
class ProjectWatcher {
    async dispose() {
        __classPrivateFieldGet(this, _ProjectWatcher_bundleUpdateSubscribers, "f").forEach((sub) => sub.complete());
        __classPrivateFieldGet(this, _ProjectWatcher_watcher, "f").removeAllListeners();
        await __classPrivateFieldGet(this, _ProjectWatcher_watcher, "f").close();
    }
    constructor(projectDirectory) {
        _ProjectWatcher_instances.add(this);
        this.projectDirectory = projectDirectory;
        _ProjectWatcher_watcher.set(this, void 0);
        _ProjectWatcher_watcherReady.set(this, void 0);
        _ProjectWatcher_bundleUpdateSubscribers.set(this, new Set());
        _ProjectWatcher_pathPrefix.set(this, void 0);
        this.listProject = async () => {
            await __classPrivateFieldGet(this, _ProjectWatcher_watcherReady, "f");
            const watchedFiles = __classPrivateFieldGet(this, _ProjectWatcher_watcher, "f").getWatched();
            return ProjectListingResponse.fromPartial({
                projectRootDirectory: this.projectDirectory,
                projectFileSystem: {
                    files: __classPrivateFieldGet(this, _ProjectWatcher_instances, "m", _ProjectWatcher_watchedFilesAsBuilderFS).call(this, watchedFiles),
                },
            });
        };
        assert(projectDirectory !== SYSTEM_ROOT);
        __classPrivateFieldSet(this, _ProjectWatcher_pathPrefix, path.resolve(projectDirectory), "f");
        __classPrivateFieldSet(this, _ProjectWatcher_watcher, chokidar.watch(projectDirectory, {
            ignored: /((^|[/\\])\..)|(node_modules)/, // ignore dotfiles
            ignoreInitial: true,
            interval: WATCHER_INTERVAL,
        }), "f");
        __classPrivateFieldGet(this, _ProjectWatcher_watcher, "f").on('all', (change, updatedPath) => {
            const relativePath = path.relative(projectDirectory, updatedPath);
            const isDirectory = CHANGE_IS_DIRECTORY.has(change);
            if (relativePath === '') {
                return; // skip no-op updates about the projectDirectory
            }
            const update = ProjectUpdateResponse.fromPartial({
                projectRootDirectory: this.projectDirectory,
                file: {
                    path: relativePath,
                    content: '',
                    isDirectory,
                },
            });
            __classPrivateFieldGet(this, _ProjectWatcher_bundleUpdateSubscribers, "f").forEach((sub) => sub.next(update));
        });
        // Use a promise to register that chokidar has finished scanning
        // the project and has its internal mapping setup (used for listing project)
        let onWatchReady;
        __classPrivateFieldSet(this, _ProjectWatcher_watcherReady, new Promise((resolve) => (onWatchReady = resolve)), "f");
        __classPrivateFieldGet(this, _ProjectWatcher_watcher, "f").on('ready', () => {
            onWatchReady();
        });
    }
    watchProject() {
        return new Observable((subscriber) => {
            __classPrivateFieldGet(this, _ProjectWatcher_bundleUpdateSubscribers, "f").add(subscriber);
            return (() => {
                __classPrivateFieldGet(this, _ProjectWatcher_bundleUpdateSubscribers, "f").delete(subscriber);
            });
        });
    }
    relativePath(filePath) {
        return filePath.replace(__classPrivateFieldGet(this, _ProjectWatcher_pathPrefix, "f"), '').replace(/^[/\\]/g, '');
    }
}
_ProjectWatcher_watcher = new WeakMap(), _ProjectWatcher_watcherReady = new WeakMap(), _ProjectWatcher_bundleUpdateSubscribers = new WeakMap(), _ProjectWatcher_pathPrefix = new WeakMap(), _ProjectWatcher_instances = new WeakSet(), _ProjectWatcher_watchedFilesAsBuilderFS = function _ProjectWatcher_watchedFilesAsBuilderFS(watched) {
    const files = [];
    for (const dir in watched) {
        // skip paths above that chokidar is also watching (depends slightly on linux vs mac)
        if (dir.startsWith(__classPrivateFieldGet(this, _ProjectWatcher_pathPrefix, "f")) && dir !== __classPrivateFieldGet(this, _ProjectWatcher_pathPrefix, "f")) {
            files.push(File.fromPartial({
                path: this.relativePath(dir),
                content: '',
                isDirectory: true,
            }));
        }
        const dirFiles = watched[dir];
        for (const file of dirFiles) {
            const filePath = path.join(dir, file);
            // skip nested directories as they'll be added from top-level key
            if (watched[filePath]) {
                continue;
            }
            files.push(File.fromPartial({
                path: this.relativePath(filePath),
                content: '',
                isDirectory: false,
            }));
        }
    }
    // TODO: I should have implemented DFS here but instead am sorting by paths
    files.sort((a, b) => a.path.localeCompare(b.path));
    const dyIndex = files.findIndex((f) => f.path === 'devvit.yaml');
    if (dyIndex > 0) {
        const devvitYaml = files.splice(dyIndex, 1);
        files.unshift(devvitYaml[0]);
    }
    return files;
};
export default ProjectWatcher;
