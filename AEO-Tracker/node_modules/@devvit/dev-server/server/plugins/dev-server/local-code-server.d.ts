/// <reference types="node" resolution-mode="require"/>
import http from 'node:http';
export type LocalCodeServerConfig<T> = {
    /** The port to use for the server. If 0 or not given, a random available port will be chosen. */
    port?: number;
    /**
     *  The state string to use with the server. All requests will be ignored unless this state is
     *  provided as a query param. If omitted, a random state string will be generated.
     */
    state?: string;
    /**
     * Called when the server is listening. This is useful if you're using a random port and need to
     * know what port and/or state was chosen.
     * @param info Information about the server, including the port and state string.
     */
    serverListeningCallback?: (info: LocalCodeServerCallbackInfo) => void;
    /**
     * Handle a request to the server. This is called when the user visits the server URL. This will
     * only be called if the `state` was correct, so you don't need to check it yourself.
     * @param queryParams Query params from the request
     * @param resp The response object, if you want to write a custom response
     * @returns {<T> | false} false if the code was invalid & we should keep trying, otherwise
     *   whatever you want to return
     * @throws Error if there was an error of some kind, and the server should be shut down
     */
    requestHandler: (queryParams: Record<string, string | string[] | undefined>, resp: http.ServerResponse) => Promise<T | false>;
};
export type LocalCodeServerCallbackInfo = {
    port: number;
    state: string;
};
export declare function localCodeServer<T>(config: LocalCodeServerConfig<T>): Promise<T>;
//# sourceMappingURL=local-code-server.d.ts.map