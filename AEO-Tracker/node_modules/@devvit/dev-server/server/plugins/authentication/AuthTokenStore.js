var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AuthTokenStore_instances, _AuthTokenStore_dotDevvitDir, _AuthTokenStore_tokenFileWatcher, _AuthTokenStore_tokenFileUpdatesObservable, _AuthTokenStore_tokenLocation_get, _AuthTokenStore_initTokenFileWatcher;
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import chokidar from 'chokidar';
import fsp, { mkdir, readFile } from 'fs/promises';
import os from 'node:os';
import path from 'node:path';
import { ReplaySubject } from 'rxjs';
import { isFile } from '../../io/file-util.js';
import { StoredToken } from './StoredToken.js';
export const WATCHER_INTERVAL = 1000;
export class AuthTokenStore {
    async dispose() {
        await __classPrivateFieldGet(this, _AuthTokenStore_tokenFileWatcher, "f")?.close();
    }
    get updates() {
        if (!this.fileWatcherInitd) {
            __classPrivateFieldGet(this, _AuthTokenStore_instances, "m", _AuthTokenStore_initTokenFileWatcher).call(this);
        }
        return __classPrivateFieldGet(this, _AuthTokenStore_tokenFileUpdatesObservable, "f").pipe();
    }
    get fileWatcherInitd() {
        return __classPrivateFieldGet(this, _AuthTokenStore_tokenFileWatcher, "f") !== undefined && __classPrivateFieldGet(this, _AuthTokenStore_tokenFileUpdatesObservable, "f") !== undefined;
    }
    constructor(dotDevvitDir = path.join(os.homedir(), '.devvit')) {
        _AuthTokenStore_instances.add(this);
        _AuthTokenStore_dotDevvitDir.set(this, void 0);
        _AuthTokenStore_tokenFileWatcher.set(this, void 0);
        _AuthTokenStore_tokenFileUpdatesObservable.set(this, void 0);
        __classPrivateFieldSet(this, _AuthTokenStore_dotDevvitDir, dotDevvitDir, "f");
    }
    async readFSToken() {
        if (!(await isFile(__classPrivateFieldGet(this, _AuthTokenStore_instances, "a", _AuthTokenStore_tokenLocation_get)))) {
            return undefined;
        }
        const raw = await readFile(__classPrivateFieldGet(this, _AuthTokenStore_instances, "a", _AuthTokenStore_tokenLocation_get), { encoding: 'utf8' });
        if (raw == null) {
            return undefined;
        }
        try {
            const jsonParse = JSON.parse(raw);
            const token = StoredToken.fromBase64(jsonParse.token);
            if (!token) {
                return undefined;
            }
            return {
                token,
                copyPaste: !!jsonParse.copyPaste,
            };
        }
        catch {
            // This is fine, the JSON parse failed, which means it's an old style token
            const token = StoredToken.fromBase64(raw);
            if (!token) {
                return undefined;
            }
            return {
                token,
                copyPaste: false,
            };
        }
    }
    async writeFSToken(token, copyPaste) {
        await mkdir(__classPrivateFieldGet(this, _AuthTokenStore_dotDevvitDir, "f"), { recursive: true });
        await fsp.writeFile(__classPrivateFieldGet(this, _AuthTokenStore_instances, "a", _AuthTokenStore_tokenLocation_get), JSON.stringify({
            token: Buffer.from(JSON.stringify(token)).toString('base64'),
            copyPaste: !!copyPaste,
        }), 'utf8');
    }
    async clearToken() {
        await mkdir(__classPrivateFieldGet(this, _AuthTokenStore_dotDevvitDir, "f"), { recursive: true });
        await fsp.writeFile(__classPrivateFieldGet(this, _AuthTokenStore_instances, "a", _AuthTokenStore_tokenLocation_get), '', 'utf8');
        await fsp.rm(__classPrivateFieldGet(this, _AuthTokenStore_instances, "a", _AuthTokenStore_tokenLocation_get), { force: true });
    }
}
_AuthTokenStore_dotDevvitDir = new WeakMap(), _AuthTokenStore_tokenFileWatcher = new WeakMap(), _AuthTokenStore_tokenFileUpdatesObservable = new WeakMap(), _AuthTokenStore_instances = new WeakSet(), _AuthTokenStore_tokenLocation_get = function _AuthTokenStore_tokenLocation_get() {
    return path.join(__classPrivateFieldGet(this, _AuthTokenStore_dotDevvitDir, "f"), 'token');
}, _AuthTokenStore_initTokenFileWatcher = function _AuthTokenStore_initTokenFileWatcher() {
    __classPrivateFieldSet(this, _AuthTokenStore_tokenFileWatcher, chokidar.watch(__classPrivateFieldGet(this, _AuthTokenStore_instances, "a", _AuthTokenStore_tokenLocation_get), {
        ignoreInitial: false,
        interval: WATCHER_INTERVAL,
    }), "f");
    // we only need the subject to keep the latest pushed StoredToken
    const REPLAY_SUBJECT_BUFFER_SIZE = 1;
    __classPrivateFieldSet(this, _AuthTokenStore_tokenFileUpdatesObservable, new ReplaySubject(REPLAY_SUBJECT_BUFFER_SIZE), "f");
    __classPrivateFieldGet(this, _AuthTokenStore_tokenFileWatcher, "f").on('all', () => {
        this.readFSToken()
            .then((updatedToken) => {
            // if updated token is valid
            if (updatedToken != null) {
                __classPrivateFieldGet(this, _AuthTokenStore_tokenFileUpdatesObservable, "f").next(updatedToken);
            }
        })
            .catch((err) => {
            console.error(StringUtil.caughtToString(err));
            // token is malformed, don't push updates so no-op
        });
    });
};
