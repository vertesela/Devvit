import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { AssetResolverDefinition, DevServerDefinition, OAuthProviderDefinition, RealtimeDefinition, } from '@devvit/protos';
import { NodeRuntime } from '@devvit/runtimes/platform/node/NodeRuntime.js';
import Koa from 'koa';
import mount from 'koa-mount';
import KoaRouter from 'koa-router';
import serveStatic from 'koa-static';
import websockify from 'koa-websocket';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { NodeFSAuthenticationPlugin } from './plugins/authentication/NodeFSAuthenticationPlugin.js';
import DevServerPlugin from './plugins/dev-server/dev-server-plugin.js';
import { DevServerRealtime } from './plugins/DevServerRealtime.js';
import { LocalAssetResolver } from './plugins/asset-resolver/LocalAssetResolver.js';
import { ASSET_DIRECTORY } from '@devvit/shared-types/constants.js';
const __dirname = fileURLToPath(path.join(import.meta.url, '..'));
const LOCAL_ORIGINS = ['localhost', '127.0.0.1', '0.0.0.0', '[::1]'];
const startWebServer = (options) => {
    const { distDir, port, onRemoteConnection, getSourcemap } = options;
    // Verify the origin of the document opening the websocket connection to prevent
    // untrusted origins from executing sensitive methods (list project dirs, HTTP fetch, etc.)
    // NOTE: verifyClient() isn't preferred and may be deprecated at some point, but the
    // recommended method is a bit more convoluted than we want to deal with for now,
    // see https://github.com/websockets/ws/issues/377#issuecomment-462152231.
    const verifyClient = (info) => {
        if (!info.origin)
            return false;
        // Get just the domain portion of the Origin header, ignoring protocol and port.
        const originDomain = new URL(info.origin).hostname;
        // Just localhost-like domains for now, but could be any known trusted origin.
        return LOCAL_ORIGINS.includes(originDomain);
    };
    // TODO: remove use of any below
    /* eslint-disable @typescript-eslint/no-explicit-any */
    const app = websockify(new Koa(), { verifyClient });
    const htmlRouter = new KoaRouter();
    const sourcemapRouter = new KoaRouter();
    const wsRouter = new KoaRouter();
    /* eslint-enable @typescript-eslint/no-explicit-any */
    sourcemapRouter.get(/^\/worker\.(\w+)\.cjs\.map$/, (ctx) => {
        ctx.type = 'text/plain';
        ctx.body = fs.createReadStream(`${getSourcemap(ctx.params[0])}.map`);
    });
    sourcemapRouter.get('/browser-lite.worker.js.map', (ctx) => {
        ctx.type = 'text/plain';
        ctx.body = fs.createReadStream(getSourcemap('@devvit/runtime-lite/browser-lite.worker.js.map'));
    });
    wsRouter.get('/connect', async (ctx) => {
        await onRemoteConnection(ctx.websocket);
    });
    app.use(mount('/project', serveStatic(distDir)));
    app.use(mount('/assets', serveStatic(path.join(options.projectDir, ASSET_DIRECTORY))));
    // @ts-ignore -- TODO work through typescript not being happy with some of these
    app.ws.use(wsRouter.routes()).use(wsRouter.allowedMethods());
    app.use(htmlRouter.routes()).use(htmlRouter.allowedMethods());
    app.use(sourcemapRouter.routes()).use(sourcemapRouter.allowedMethods());
    // catch all
    app.use(async (ctx) => {
        return ctx.redirect('/project');
    });
    return new Promise((resolve) => {
        const server = app.listen(port, () => {
            resolve(server);
        });
    });
};
export const startServer = async (options) => {
    const { projectDir, port } = options;
    try {
        const runtime = new NodeRuntime();
        await runtime.start();
        runtime.provide(DevServerDefinition, new DevServerPlugin(projectDir, runtime, options.disableExternDevvitProtos));
        runtime.provide(RealtimeDefinition, new DevServerRealtime());
        runtime.provide(OAuthProviderDefinition, new NodeFSAuthenticationPlugin(options.authPluginConfig));
        runtime.provide(AssetResolverDefinition, new LocalAssetResolver(projectDir, path.join(projectDir, ASSET_DIRECTORY)));
        return await startWebServer({
            distDir: path.join(__dirname, '../client'),
            onRemoteConnection: async (ws) => await runtime.addConnection(ws),
            port,
            getSourcemap: runtime.pathForName,
            projectDir: options.projectDir,
        });
    }
    catch (err) {
        console.error(StringUtil.caughtToString(err));
    }
};
export default { startServer };
