import { nothing } from 'lit';
import { getTemplateRenderingStrategy } from '@reddit/faceplate-ui/faceplateUIConfig.js';
import { BlockStackDirection, BlockType } from '@devvit/protos';
import { renderStackBlock } from './renderStackBlock.js';
import { renderSpacerBlock } from './renderSpacerBlock.js';
import { renderTextBlock } from './renderTextBlock.js';
import { renderImageBlock } from './renderImageBlock.js';
import { renderIconBlock } from './renderIconBlock.js';
import { renderButtonBlock } from './renderButtonBlock.js';
import { renderWebViewBlock } from './renderWebViewBlock.js';
import { renderAnimationBlock } from './renderAnimationBlock.js';
import { renderAvatarBlock } from './renderAvatarBlock.js';
import { renderFullSnooBlock } from './renderFullSnooBlock.js';
import { growWrapperSizingStyle } from '../attributes.js';
export const DEFAULT_ROOT_HEIGHT = 320;
export function renderBlocks(block, context = {}) {
    if (block.type !== BlockType.BLOCK_ROOT) {
        console.error('Invalid root block');
        return nothing;
    }
    const height = `${block.config?.rootConfig?.height || DEFAULT_ROOT_HEIGHT}px`;
    return renderStackBlock({
        type: BlockType.BLOCK_STACK,
        config: {
            stackConfig: {
                direction: BlockStackDirection.STACK_VERTICAL,
                children: block.config?.rootConfig?.children ?? [],
            },
        },
        actions: [],
    }, {
        ...context,
        stackDirection: BlockStackDirection.UNRECOGNIZED,
    }, renderBlock, {
        styles: {
            height,
            minHeight: height,
            maxHeight: height,
            overflow: 'hidden',
        },
    });
}
export function renderBlock(block, ctx) {
    const { html, styleMap } = getTemplateRenderingStrategy();
    let render = nothing;
    switch (block.type) {
        case BlockType.BLOCK_STACK:
            render = renderStackBlock(block, ctx, renderBlock);
            break;
        case BlockType.BLOCK_SPACER:
            render = renderSpacerBlock(block, ctx);
            break;
        case BlockType.BLOCK_TEXT:
            render = renderTextBlock(block, ctx);
            break;
        case BlockType.BLOCK_IMAGE:
            render = renderImageBlock(block, ctx);
            break;
        case BlockType.BLOCK_ICON:
            render = renderIconBlock(block, ctx);
            break;
        case BlockType.BLOCK_BUTTON:
            render = renderButtonBlock(block, ctx);
            break;
        case BlockType.UNRECOGNIZED:
            return nothing;
    }
    if (ctx.experimental) {
        switch (block.type) {
            case BlockType.BLOCK_WEBVIEW:
                render = renderWebViewBlock(block, ctx);
                break;
            case BlockType.BLOCK_ANIMATION:
                render = renderAnimationBlock(block, ctx);
                break;
            case BlockType.BLOCK_AVATAR:
                render = renderAvatarBlock(block, ctx);
                break;
            case BlockType.BLOCK_FULLSNOO:
                render = renderFullSnooBlock(block, ctx);
                break;
        }
    }
    /* eslint-disable @reddit/i18n-shreddit/no-unwrapped-strings, lit/attribute-value-entities */
    if (block.size?.grow === true && ctx.stackDirection !== BlockStackDirection.STACK_DEPTH) {
        const styles = growWrapperSizingStyle(block);
        return html `<div
      class="grid grid-cols-1 grow shrink pointer-events-none [&>:not(.pointer-events-none)]:pointer-events-auto"
      style="${styleMap(styles)}"
    >
      ${render}
    </div>`;
    }
    else {
        return render;
    }
    /* eslint-enable @reddit/i18n-shreddit/no-unwrapped-strings, lit/attribute-value-entities */
}
