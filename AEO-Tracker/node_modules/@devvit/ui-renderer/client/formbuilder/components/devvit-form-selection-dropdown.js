var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _DevvitFormSelectionDropdown_selection, _DevvitFormSelectionDropdown_config, _DevvitFormSelectionDropdown_updateSelection, _DevvitFormSelectionDropdown_singleSelectListItem, _DevvitFormSelectionDropdown_multiSelectListItem;
import { css } from 'lit';
import { property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { html, ifDefined } from '@reddit/faceplate-ui/templateRenderingStrategy/clientStrategy.js';
import { dropdownButton } from '@reddit/faceplate-ui/templates/dropdownButton.js';
import { listItem } from '@reddit/faceplate-ui/templates/list-item.js';
import { InputElement } from '@reddit/faceplate/base-classes/input-element.js';
import { msg } from '@reddit/faceplate/lib/i18n/localize.js';
import { FieldConfig_Selection, FormFieldValue_SelectionValue } from '@devvit/protos';
import { styles } from '../../../styles.js';
import '@reddit/faceplate-ui/components/faceplate-dropdown-menu.js';
import '@reddit/faceplate-ui/components/faceplate-menu.js';
import '@reddit/faceplate-ui/components/faceplate-switch-input.js';
import { renderHelpText } from '../fields/renderHelpText.js';
export class DevvitFormSelectionDropdown extends InputElement {
    constructor() {
        super(...arguments);
        this.dropdownOpen = false;
        this.currentLabel = '';
        _DevvitFormSelectionDropdown_selection.set(this, FormFieldValue_SelectionValue.fromPartial({}));
        _DevvitFormSelectionDropdown_config.set(this, FieldConfig_Selection.fromPartial({}));
        _DevvitFormSelectionDropdown_updateSelection.set(this, (choice, selected = true) => {
            if (__classPrivateFieldGet(this, _DevvitFormSelectionDropdown_config, "f").multiSelect) {
                const index = __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values.indexOf(choice.value);
                if (selected && index < 0) {
                    __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values.push(choice.value);
                }
                else if (index >= 0) {
                    __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values.splice(index, 1);
                }
                if (__classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values.length === 0) {
                    this.currentLabel = '';
                }
                else if (__classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values.length === 1) {
                    this.currentLabel =
                        __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_config, "f").choices.find((c) => c.value === __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values[0])?.label ?? '';
                }
                else {
                    this.currentLabel = msg('[Multiple Selections]', {
                        desc: 'Displayed on a drop down menu when multiple values are selected',
                    });
                }
            }
            else {
                __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values = [choice.value];
                this.currentLabel = choice.label;
            }
        });
        _DevvitFormSelectionDropdown_singleSelectListItem.set(this, (choice) => listItem({
            label: choice.label,
            onClick: () => __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_updateSelection, "f").call(this, choice),
        }));
        _DevvitFormSelectionDropdown_multiSelectListItem.set(this, (choice) => listItem({
            label: html `
        <faceplate-switch-input
          @input="${(ev) => __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_updateSelection, "f").call(this, choice, ev.currentTarget.checked)}"
        >
          ${choice.label}
        </faceplate-switch-input>
      `,
            onClick: (ev) => ev.stopImmediatePropagation(),
        }));
    }
    static get styles() {
        return [
            super.styles,
            styles,
            // fixes a layering bug when dropdown menus are too close together
            css `
        .button .dropdown-icon {
          transform: none;
        }
      `,
        ];
    }
    get value() {
        return __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values.join(',');
    }
    willUpdate(changedProperties) {
        if (changedProperties.has('field')) {
            __classPrivateFieldSet(this, _DevvitFormSelectionDropdown_config, this.field?.fieldConfig?.selectionConfig ?? FieldConfig_Selection.fromPartial({}), "f");
            __classPrivateFieldSet(this, _DevvitFormSelectionDropdown_selection, this.field?.defaultValue?.selectionValue ?? FormFieldValue_SelectionValue.fromPartial({}), "f");
            if (!__classPrivateFieldGet(this, _DevvitFormSelectionDropdown_config, "f").multiSelect) {
                this.currentLabel =
                    __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_config, "f").choices.find((c) => c.value === __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values?.[0])?.label ?? '';
            }
        }
    }
    render() {
        let formField;
        if (this.field) {
            const items = __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_config, "f").choices?.map((choice) => __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_config, "f").multiSelect
                ? __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_multiSelectListItem, "f").call(this, choice)
                : __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_singleSelectListItem, "f").call(this, choice));
            const emptyItem = !__classPrivateFieldGet(this, _DevvitFormSelectionDropdown_config, "f").multiSelect && !__classPrivateFieldGet(this, _DevvitFormSelectionDropdown_config, "f").minSelections
                ? listItem({
                    label: html `&nbsp;`,
                    onClick: () => {
                        this.currentLabel = '';
                        __classPrivateFieldGet(this, _DevvitFormSelectionDropdown_selection, "f").values = [];
                    },
                })
                : undefined;
            const classes = {
                'flex-grow': true,
                'z-auto': !this.dropdownOpen,
            };
            formField = html `
        <div class="flex-col flex-grow">
          <faceplate-dropdown-menu
            id="${this.field.fieldId}"
            class="${classMap(classes)}"
            .onopen="${() => (this.dropdownOpen = true)}"
            .onclose="${() => (this.dropdownOpen = false)}"
            ?disabled="${ifDefined(this.field.disabled)}"
          >
            ${dropdownButton({
                attributes: {
                    disabled: this.field.disabled === true,
                    className: 'flex justify-between grow',
                },
                children: html `<span class="grow">${this.currentLabel}</span>`,
                selected: this.dropdownOpen,
            })}
            <faceplate-menu slot="menu" class="max-h-[160px] overflow-y-auto"
              >${emptyItem}${items}
            </faceplate-menu>
          </faceplate-dropdown-menu>
          ${renderHelpText(this.field.helpText)}
        </div>
      `;
        }
        return html `${formField}${super.render()}`;
    }
}
_DevvitFormSelectionDropdown_selection = new WeakMap(), _DevvitFormSelectionDropdown_config = new WeakMap(), _DevvitFormSelectionDropdown_updateSelection = new WeakMap(), _DevvitFormSelectionDropdown_singleSelectListItem = new WeakMap(), _DevvitFormSelectionDropdown_multiSelectListItem = new WeakMap();
__decorate([
    property({ attribute: false }),
    __metadata("design:type", Object)
], DevvitFormSelectionDropdown.prototype, "field", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], DevvitFormSelectionDropdown.prototype, "dropdownOpen", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], DevvitFormSelectionDropdown.prototype, "currentLabel", void 0);
// Faceplate's base classes and mixins aren't playing nice with type checking for some reason
// eslint-disable-next-line @typescript-eslint/no-explicit-any
customElements.define('devvit-form-selection-dropdown', DevvitFormSelectionDropdown);
