var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AppUILooper_instances, _AppUILooper_appState, _AppUILooper_q, _AppUILooper_rendered, _AppUILooper_rerenderTimeout, _AppUILooper_onEffects, _AppUILooper_onPluginCall, _AppUILooper_processEvent, _AppUILooper_renderPost;
import { BlockRenderEventType, RealtimeDefinition } from '@devvit/protos';
import { BrowserLiteClient } from '@devvit/runtime-lite/client/BrowserLiteClient.js';
import { isCircuitBreaker } from '@devvit/runtime-lite/types/CircuitBreaker.js';
import PQueue from 'p-queue';
import { initDevvitGlobal } from '../types/devvit-global.js';
// Effects that can only be fired as the result of a user action
const userActionEffects = ['showToast', 'showForm', 'navigateToUrl'];
initDevvitGlobal();
/**
 * App render and effect looping logic. Rendering and event processing is as
 * follows:
 *
 * 1. Try the local runtime, if available.
 * 2. If a local runtime or bundle is unavailable, or local execution fails
 *    (including CircuitBreak), try the remote.
 * 3. Report execution errors by callback only. In general, all errors are
 *    attempted to be tolerated.
 *
 * App / render state is always preserved even on error so a buggy app will try
 * not to show any issues. A bundle or runtime can be replaced on the fly with
 * losing state.
 */
export class AppUILooper {
    constructor() {
        _AppUILooper_instances.add(this);
        /**
         * App state is never reset in production. Prior remote executions may have
         * occurred. The next loop will replace the state. Do not lose the current
         * state even after a bundle has been downloaded and is ready to load. The
         * only time state should be reinitialized is when a bundle has been
         * _replaced_ such as by devvit-preview.
         */
        _AppUILooper_appState.set(this, {});
        /** No concurrency is used to enforce order. to-do: replace with array? */
        _AppUILooper_q.set(this, new PQueue({ concurrency: 1 }));
        /**
         * True if app has rendered since loaded. Since a successful render isn't
         * known at queue time, it's possible for multiple redundant renders to be
         * enqueued.
         */
        _AppUILooper_rendered.set(this, false);
        _AppUILooper_rerenderTimeout.set(this, void 0);
        _AppUILooper_onPluginCall.set(this, (id, serviceName, method, args, meta) => {
            this.onPluginCall?.(id, serviceName, method, args, meta);
            if (serviceName === RealtimeDefinition.fullName &&
                method === RealtimeDefinition.methods.send.name)
                this._local?.onPluginResponse(id, { error: undefined, success: true, value: {} });
        });
    }
    /** Get the current app state with the current post state. */
    get appState() {
        __classPrivateFieldGet(this, _AppUILooper_appState, "f").__postData = { thingId: this.postID, config: this.postConfig };
        return __classPrivateFieldGet(this, _AppUILooper_appState, "f");
    }
    /**
     * Load an app bundle into the local runtime, if available. The bundle is
     * assumed to implement a UIApp.
     */
    async load(app, sandbox) {
        this.unload();
        try {
            await this._local?.loadBundle(app, sandbox);
        }
        catch (err) {
            this.onError?.('Error', err);
        }
    }
    queueEvent(ev) {
        if (ev.queue) {
            // TODO: Add QoS for different types of events on alternate queues. For
            // now, treat alternate queues as having infinite concurrency.
            void __classPrivateFieldGet(this, _AppUILooper_instances, "m", _AppUILooper_processEvent).call(this, ev);
        }
        else {
            void __classPrivateFieldGet(this, _AppUILooper_q, "f").add(() => __classPrivateFieldGet(this, _AppUILooper_instances, "m", _AppUILooper_processEvent).call(this, ev));
        }
    }
    queueRenderPost(type, id, data) {
        void __classPrivateFieldGet(this, _AppUILooper_q, "f").add(() => __classPrivateFieldGet(this, _AppUILooper_instances, "m", _AppUILooper_renderPost).call(this, type, id, data));
    }
    get rendered() {
        return __classPrivateFieldGet(this, _AppUILooper_rendered, "f");
    }
    /**
     * Discard app and render state. This is used indirectly by devvit-preview
     * which frequently loads new bundles.
     */
    resetAppState() {
        __classPrivateFieldSet(this, _AppUILooper_rendered, false, "f");
        __classPrivateFieldSet(this, _AppUILooper_appState, {}, "f");
    }
    /** Set the runtime source code. */
    setLocalSrc(src) {
        this.unload();
        this._local = src
            ? new BrowserLiteClient(src, (type, err) => this.onError?.(type, err), {
                callback: __classPrivateFieldGet(this, _AppUILooper_onPluginCall, "f"),
                plugins: [RealtimeDefinition.fullName],
            })
            : undefined;
    }
    /** Unload the app and reject any open requests. */
    unload() {
        if (__classPrivateFieldGet(this, _AppUILooper_rerenderTimeout, "f") != null)
            clearTimeout(__classPrivateFieldGet(this, _AppUILooper_rerenderTimeout, "f"));
        // Disable errors, wipe the old client rejecting any open promises, then
        // re-enable errors. Leave app state as-is.
        const onError = this.onError;
        this.onError = undefined;
        this._local?.quit();
        this.onError = onError;
    }
}
_AppUILooper_appState = new WeakMap(), _AppUILooper_q = new WeakMap(), _AppUILooper_rendered = new WeakMap(), _AppUILooper_rerenderTimeout = new WeakMap(), _AppUILooper_onPluginCall = new WeakMap(), _AppUILooper_instances = new WeakSet(), _AppUILooper_onEffects = function _AppUILooper_onEffects(renderType, effects) {
    for (const effect of effects) {
        if (effect.rerenderUi) {
            if (__classPrivateFieldGet(this, _AppUILooper_rerenderTimeout, "f") != null)
                clearTimeout(__classPrivateFieldGet(this, _AppUILooper_rerenderTimeout, "f"));
            __classPrivateFieldSet(this, _AppUILooper_rerenderTimeout, setTimeout(() => {
                this.queueRenderPost(BlockRenderEventType.RENDER_EFFECT_EVENT, 'rerender-effect', {});
            }, (effect.rerenderUi.delaySeconds ?? 0) * 1000), "f");
        }
        else if (effect.sendEvent?.event) {
            this.queueEvent(effect.sendEvent.event);
        }
        else if (renderType !== BlockRenderEventType.RENDER_USER_ACTION ||
            userActionEffects.some((type) => effect[type])) {
            this.onUserAction?.(effect);
        }
    }
}, _AppUILooper_processEvent = async function _AppUILooper_processEvent(ev) {
    let rsp;
    const req = { event: ev, state: this.appState };
    if (this._local?.ready) {
        try {
            rsp = (await this._local.call('HandleUIEvent', req, this.meta));
        }
        catch (err) {
            if (!isCircuitBreaker(err) || !this.remote)
                this.onError?.('Error', err);
            if (devvit?.logLocalErrors)
                console.info('remote call', err);
        }
    }
    if (!rsp) {
        try {
            rsp = await this.remote?.HandleUIEvent(req, this.meta);
        }
        catch (err) {
            this.onError?.('Error', err);
        }
    }
    if (rsp) {
        // Can only change state on the main queue.
        if (!ev.queue) {
            __classPrivateFieldSet(this, _AppUILooper_appState, rsp.state ?? {}, "f");
        }
        const renderType = ev.realtimeEvent
            ? BlockRenderEventType.RENDER_EFFECT_EVENT
            : BlockRenderEventType.RENDER_USER_ACTION;
        __classPrivateFieldGet(this, _AppUILooper_instances, "m", _AppUILooper_onEffects).call(this, renderType, rsp.effects);
    }
}, _AppUILooper_renderPost = async function _AppUILooper_renderPost(type, id, data) {
    const req = { blocks: { type, id, data }, state: this.appState };
    let rsp;
    if (this._local?.ready) {
        try {
            rsp = (await this._local?.call('RenderPost', req, this.meta));
        }
        catch (err) {
            if (isCircuitBreaker(err) && err.response)
                rsp = err.response;
            if (!isCircuitBreaker(err) || !this.remote)
                this.onError?.('Error', err);
            if (devvit?.logLocalErrors)
                console.info('remote call', err);
        }
    }
    if (!rsp) {
        try {
            rsp = await this.remote?.RenderPost(req, this.meta);
        }
        catch (err) {
            this.onError?.('Error', err);
        }
    }
    if (rsp) {
        __classPrivateFieldSet(this, _AppUILooper_rendered, true, "f");
        if (rsp.state)
            __classPrivateFieldSet(this, _AppUILooper_appState, rsp.state, "f");
        this.onRenderPost?.(req, rsp);
        __classPrivateFieldGet(this, _AppUILooper_instances, "m", _AppUILooper_onEffects).call(this, req.blocks.type, rsp.effects);
    }
};
