var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SocketServer_instances, _SocketServer_runtime, _SocketServer_server, _SocketServer_port, _SocketServer_connectionsByID, _SocketServer_livenessCheckInterval, _SocketServer_onNewConnection, _SocketServer_onSocketClosedSync, _SocketServer_onSocketClosed, _SocketServer_onServerClosed, _SocketServer_onError, _SocketServer_onListening;
import { WebSocketServer } from 'ws';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { Log } from '../../lib/loggers/Log.js';
import { ClientSocketEnvelopeRecipient } from './ClientSocketEnvelopeRecipient.js';
// 30 seconds
const WS_PING_INTERVAL = 30000;
export class SocketServer {
    constructor(runtime) {
        _SocketServer_instances.add(this);
        _SocketServer_runtime.set(this, void 0);
        _SocketServer_server.set(this, void 0);
        _SocketServer_port.set(this, undefined);
        _SocketServer_connectionsByID.set(this, {});
        _SocketServer_livenessCheckInterval.set(this, void 0);
        _SocketServer_onNewConnection.set(this, (socket) => {
            this.onNewConnection(socket).catch((err) => Log.error(StringUtil.caughtToString(err)));
        });
        _SocketServer_onSocketClosedSync.set(this, (recipient) => {
            __classPrivateFieldGet(this, _SocketServer_instances, "m", _SocketServer_onSocketClosed).call(this, recipient).catch((err) => Log.error(StringUtil.caughtToString(err)));
        });
        __classPrivateFieldSet(this, _SocketServer_runtime, runtime, "f");
        __classPrivateFieldSet(this, _SocketServer_livenessCheckInterval, setInterval(this.checkConnectionLiveness.bind(this), WS_PING_INTERVAL), "f");
    }
    async dispose() {
        for (const id in __classPrivateFieldGet(this, _SocketServer_connectionsByID, "f")) {
            await __classPrivateFieldGet(this, _SocketServer_connectionsByID, "f")[id].recipient.dispose();
            delete __classPrivateFieldGet(this, _SocketServer_connectionsByID, "f")[id];
        }
        if (__classPrivateFieldGet(this, _SocketServer_livenessCheckInterval, "f") !== undefined) {
            clearInterval(__classPrivateFieldGet(this, _SocketServer_livenessCheckInterval, "f"));
            __classPrivateFieldSet(this, _SocketServer_livenessCheckInterval, undefined, "f");
        }
        __classPrivateFieldGet(this, _SocketServer_server, "f")?.close();
        __classPrivateFieldSet(this, _SocketServer_server, undefined, "f");
    }
    listen(port) {
        if (__classPrivateFieldGet(this, _SocketServer_server, "f") != null) {
            if (__classPrivateFieldGet(this, _SocketServer_port, "f") !== port)
                throw Error(`Socket server listening to port ${__classPrivateFieldGet(this, _SocketServer_port, "f")} not ${port}.`);
            Log.warn(`Socket server already listening to port ${__classPrivateFieldGet(this, _SocketServer_port, "f")}.`);
            return;
        }
        __classPrivateFieldSet(this, _SocketServer_port, port, "f");
        __classPrivateFieldSet(this, _SocketServer_server, new WebSocketServer({ port }), "f");
        __classPrivateFieldGet(this, _SocketServer_server, "f").on('connection', __classPrivateFieldGet(this, _SocketServer_onNewConnection, "f"));
        __classPrivateFieldGet(this, _SocketServer_server, "f").on('close', __classPrivateFieldGet(this, _SocketServer_instances, "m", _SocketServer_onServerClosed).bind(this));
        __classPrivateFieldGet(this, _SocketServer_server, "f").on('error', __classPrivateFieldGet(this, _SocketServer_instances, "m", _SocketServer_onError).bind(this));
        __classPrivateFieldGet(this, _SocketServer_server, "f").on('listening', __classPrivateFieldGet(this, _SocketServer_instances, "m", _SocketServer_onListening).bind(this));
    }
    // TODO: This needs to be public because this class is currently doing dual-duty as a
    //  SocketServer _and_ SocketManager in the koa-websocket case. We have some cases where
    //  this class creates the WebSocketServer and some where it does not.
    //  Extract the socket management functionality out to prevent future confusion about
    //  code in listen() not executing when koa-websocket hands off websockets to this class.
    async onNewConnection(socket) {
        // connect to local runtime
        const recipient = new ClientSocketEnvelopeRecipient(__classPrivateFieldGet(this, _SocketServer_runtime, "f"));
        const connState = {
            recipient: recipient,
            // We're naturally not expecting a pong since we haven't sent a ping yet,
            // and won't until the next liveness check tick.
            pongExpected: false,
            socket: socket,
        };
        __classPrivateFieldGet(this, _SocketServer_connectionsByID, "f")[recipient.id] = connState;
        await recipient.bindSocket(socket);
        __classPrivateFieldGet(this, _SocketServer_runtime, "f").bind(recipient);
        Log.verbose(`Socket server connected to recipient ${recipient.id}.`);
        socket.once('close', () => __classPrivateFieldGet(this, _SocketServer_onSocketClosedSync, "f").call(this, recipient));
        socket.on('pong', () => {
            connState.pongExpected = false;
        });
        return recipient;
    }
    checkConnectionLiveness() {
        for (const conn of Object.values(__classPrivateFieldGet(this, _SocketServer_connectionsByID, "f"))) {
            // We never received a pong even though we sent a ping on our last check.
            if (conn.pongExpected) {
                Log.verbose(`Socket server terminated dead socket for recipient ${conn.recipient.id}.`);
                // Terminate the socket so that we trigger the `close` handler.
                // We specifically do that rather than `.close()` because at this point
                // we know we're not able to gracefully close the connection, and there's
                // no point waiting around.
                conn.socket.terminate();
                continue;
            }
            conn.pongExpected = true;
            conn.socket.ping();
        }
    }
}
_SocketServer_runtime = new WeakMap(), _SocketServer_server = new WeakMap(), _SocketServer_port = new WeakMap(), _SocketServer_connectionsByID = new WeakMap(), _SocketServer_livenessCheckInterval = new WeakMap(), _SocketServer_onNewConnection = new WeakMap(), _SocketServer_onSocketClosedSync = new WeakMap(), _SocketServer_instances = new WeakSet(), _SocketServer_onSocketClosed = async function _SocketServer_onSocketClosed(recipient) {
    await __classPrivateFieldGet(this, _SocketServer_runtime, "f").release(recipient);
    delete __classPrivateFieldGet(this, _SocketServer_connectionsByID, "f")[recipient.id];
    Log.verbose(`Socket server disconnected from recipient ${recipient.id}.`);
}, _SocketServer_onServerClosed = function _SocketServer_onServerClosed() {
    Log.verbose(`Socket server closing port ${__classPrivateFieldGet(this, _SocketServer_port, "f")}.`);
}, _SocketServer_onError = function _SocketServer_onError(error) {
    Log.error(StringUtil.caughtToString(error));
}, _SocketServer_onListening = function _SocketServer_onListening() {
    Log.info(`Socket server listening on port ${__classPrivateFieldGet(this, _SocketServer_port, "f")}.`);
};
