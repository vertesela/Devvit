var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NodeRuntime_remoteServer;
import { createRequire } from 'module';
import '../../lib/getRandomValues.polyfill.js';
import { LocalStorage } from 'node-localstorage';
import { WebSocket } from 'ws';
import { AutomodRegexDefinition, ClockDefinition, V2EventsDefinition, HTTPDefinition, KVStoreDefinition, LoggerDefinition, ModlogDefinition, SchedulerDefinition, StreamBrokerDefinition, SettingsDefinition, RedisAPIDefinition, RedditAPIV2Definition, } from '@devvit/protos';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import path from 'node:path';
import { CommonRuntime } from '../../common/runtime/CommonRuntime.js';
import { Never } from '../../common/runtime/GCPolicy.js';
import { NODE_HOSTNAME } from '../../lib/HostnameUtil.js';
import { Log } from '../../lib/loggers/Log.js';
import AutomodRegex from '../../plugins/AutomodRegex.js';
import Clock from '../../plugins/Clock.js';
import { NodeHTTP } from '../../plugins/http/NodeHttp.js';
import { LocalStorageBroker } from '../../plugins/LocalStorageBroker.js';
import { LocalStorageKV } from '../../plugins/LocalStorageKV.js';
import { ConsoleLogger } from '../../plugins/logger/ConsoleLogger.js';
import Modlog from '../../plugins/Modlog.js';
import RedditAPIV2 from '../../plugins/RedditAPIv2.js';
import { Scheduler } from '../../plugins/Scheduler.js';
import { SocketServer } from './SocketServer.js';
import { V2Events } from '../../plugins/V2Events.js';
import Settings from '../../plugins/Settings.js';
import { LocalRedis } from '../../plugins/LocalRedis.js';
const require = createRequire(import.meta.url);
export class NodeRuntime extends CommonRuntime {
    constructor(namespace = NODE_HOSTNAME, gcPolicy = Never, workerErrorLogger = (err) => Log.error(StringUtil.caughtToString(err))) {
        super(namespace, gcPolicy, workerErrorLogger);
        _NodeRuntime_remoteServer.set(this, new SocketServer(this));
    }
    pathForName(workerNameOrModuleFile) {
        try {
            return require.resolve(`@devvit/runtimes/worker.${workerNameOrModuleFile}.cjs`);
        }
        catch {
            return require.resolve(workerNameOrModuleFile);
        }
    }
    makeWebSocket(url) {
        return new WebSocket(url);
    }
    async loadPlugins(dispatcher) {
        const kvStorage = new LocalStorage(path.join(process.cwd(), './.devvitLocalStorage/kv'));
        const brokerStorage = new LocalStorage(path.join(process.cwd(), './.devvitLocalStorage/broker'));
        this.provide(LoggerDefinition, new ConsoleLogger());
        this.provide(KVStoreDefinition, new LocalStorageKV(kvStorage));
        try {
            const localRedis = await LocalRedis.create();
            this.provide(RedisAPIDefinition, localRedis);
        }
        catch (e) {
            console.log('============================================================================');
            console.log('ðŸ’¥ Redis not available.  Please start a local redis server if you want to ');
            console.log('develop locally using the redis api.  Otherwise, you can ignore this message.');
            console.log('============================================================================');
        }
        this.provide(StreamBrokerDefinition, new LocalStorageBroker(brokerStorage));
        this.provide(ClockDefinition, new Clock());
        this.provide(HTTPDefinition, new NodeHTTP(dispatcher));
        this.provide(AutomodRegexDefinition, new AutomodRegex());
        this.provide(ModlogDefinition, new Modlog());
        this.provide(RedditAPIV2Definition, new RedditAPIV2());
        this.provide(V2EventsDefinition, new V2Events());
        this.provide(SchedulerDefinition, new Scheduler(dispatcher));
        this.provide(SettingsDefinition, new Settings());
    }
    async dispose() {
        await super.dispose();
        await __classPrivateFieldGet(this, _NodeRuntime_remoteServer, "f").dispose();
    }
    /**
     * Start a WebSocket server to accept connections from other remotes
     */
    listen(port = 3000) {
        __classPrivateFieldGet(this, _NodeRuntime_remoteServer, "f").listen(port);
    }
    /**
     * Add a WebSocket connection acquired from an external server instead of one hosted by calling
     * listen()
     */
    async addConnection(ws) {
        await __classPrivateFieldGet(this, _NodeRuntime_remoteServer, "f").onNewConnection(ws);
    }
}
_NodeRuntime_remoteServer = new WeakMap();
// to-do: you probably shouldn't have to subclass the runtime to provide
// different configurations.
export class NodeRuntimeNoPlugins extends NodeRuntime {
    async loadPlugins() { }
}
