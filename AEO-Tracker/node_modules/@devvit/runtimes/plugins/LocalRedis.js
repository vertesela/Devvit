var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LocalRedis_instances, _LocalRedis_redis, _LocalRedis_transactions, _LocalRedis_tx, _LocalRedis_newtx;
import { DoubleValue, Empty, Int64Value, RedisFieldValues, RedisValues, StringValue, } from '@devvit/protos';
import { createClient } from 'redis';
import { ZMembers } from '@devvit/protos';
import { Header } from '../lib/Header.js';
const MaxResults = 1000;
const localRuntimeError = 'Please use devvit playtest to verify your app in a test subreddit.';
function namespacedKey(metadata, key) {
    const installation = metadata?.[Header.Installation]?.values[0] || '';
    const app = metadata?.[Header.App]?.values[0] || '';
    return `${installation}:${app}:${key}`;
}
export class LocalRedis {
    static async create(url) {
        if (!url) {
            if (process.env.CI === 'true') {
                url = 'redis://redis:6379';
            }
            else {
                url = 'redis://localhost:6379';
            }
        }
        const redis = createClient({ url });
        console.log(`connecting to ${url} ...`);
        await redis.connect();
        await redis.flushAll();
        return new LocalRedis(redis);
    }
    constructor(redis) {
        _LocalRedis_instances.add(this);
        _LocalRedis_redis.set(this, void 0);
        _LocalRedis_transactions.set(this, {});
        __classPrivateFieldSet(this, _LocalRedis_redis, redis, "f");
    }
    async Del(request, metadata) {
        const keys = request.keys.map((key) => namespacedKey(metadata, key));
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).del(keys);
            return { value: 0 };
        }
        else {
            const count = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").del(keys);
            return { value: count };
        }
    }
    async Type(request, metadata) {
        const type = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").type(namespacedKey(metadata, request.key));
        return { value: type };
    }
    async Multi(request, _metadata) {
        const transaction = __classPrivateFieldGet(this, _LocalRedis_transactions, "f")[request.id];
        if (!transaction) {
            throw new Error('Transaction not found');
        }
        if (transaction.multi) {
            throw new Error('Transaction already multi');
        }
        transaction.multi = transaction.isoClient.multi();
        return {};
    }
    async Exec(request, _metadata) {
        const transaction = __classPrivateFieldGet(this, _LocalRedis_transactions, "f")[request.id];
        if (!transaction) {
            throw new Error('Transaction not found');
        }
        if (!transaction.multi) {
            await transaction.close();
            throw new Error('Transaction not multi');
        }
        const responses = await transaction.multi.exec();
        console.log(responses);
        delete __classPrivateFieldGet(this, _LocalRedis_transactions, "f")[request.id];
        const values = (responses || []).map((value) => {
            if (typeof value === 'string') {
                return { str: value };
            }
            else if (value === null) {
                return { nil: {} };
            }
            else if (typeof value === 'number') {
                return { num: value };
            }
            else if (Array.isArray(value)) {
                const strings = value.map((v) => v + '');
                return { values: { values: strings } };
            }
            else {
                throw new Error('Unsupported value type');
            }
        });
        await transaction.close();
        return { response: values };
    }
    async Discard(request, _metadata) {
        const transaction = __classPrivateFieldGet(this, _LocalRedis_transactions, "f")[request.id];
        if (!transaction) {
            throw new Error('Transaction not found');
        }
        if (!transaction.multi) {
            await transaction.close();
            throw new Error('Multi not found');
        }
        transaction.multi.discard();
        await transaction.close();
        delete __classPrivateFieldGet(this, _LocalRedis_transactions, "f")[request.id];
        return Empty.fromPartial({});
    }
    async Unwatch(request, _metadata) {
        await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request).unwatch();
        return Empty.fromPartial({});
    }
    async Watch(request, metadata) {
        let id = request.transactionId;
        if (!id) {
            const tx = await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_newtx).call(this);
            id = { id: tx.id };
        }
        if (request.keys.length > 0) {
            const keys = request.keys.map((key) => namespacedKey(metadata, key));
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, id).watch(keys);
        }
        return id;
    }
    async GetRange(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).getRange(key, request.start, request.end);
            return StringValue.fromPartial({});
        }
        else {
            const value = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").getRange(key, request.start, request.end);
            return value ? { value: value } : StringValue.fromPartial({});
        }
    }
    async IncrBy(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).incrBy(key, request.value);
            return Int64Value.fromPartial({});
        }
        else {
            const value = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").incrBy(key, request.value);
            return { value };
        }
    }
    async SetRange(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).setRange(key, request.offset, request.value);
            return Int64Value.fromPartial({});
        }
        else {
            const length = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").setRange(key, request.offset, request.value);
            return { value: length };
        }
    }
    async Strlen(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).strLen(key);
            return Int64Value.fromPartial({});
        }
        else {
            const length = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").strLen(key);
            return { value: length };
        }
    }
    async MGet(request, metadata) {
        const keys = request.keys.map((key) => namespacedKey(metadata, key));
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).mGet(keys);
            return RedisValues.fromPartial({});
        }
        else {
            const values = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").mGet(keys);
            return RedisValues.fromPartial({ values: values.map((value) => (value ? value : '')) });
        }
    }
    async MSet(request, metadata) {
        const keyValues = request.kv.reduce((obj, item) => {
            obj[namespacedKey(metadata, item.key)] = item.value;
            return obj;
        }, {});
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).mSet(keyValues);
        }
        else {
            await __classPrivateFieldGet(this, _LocalRedis_redis, "f").mSet(keyValues);
        }
        return Empty.fromPartial({});
    }
    async Get(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).get(key);
            return StringValue.fromPartial({});
        }
        else {
            const value = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").get(key);
            return { value: value ?? '' };
        }
    }
    async Set(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).set(key, request.value);
            return StringValue.fromPartial({});
        }
        else {
            if (request.nx) {
                const value = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").setNX(key, request.value);
                return { value: value ? 'OK' : '' };
            }
            else {
                const value = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").set(key, request.value);
                return { value: value ?? '' };
            }
        }
    }
    async Expire(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).expire(key, request.seconds);
        }
        else {
            await __classPrivateFieldGet(this, _LocalRedis_redis, "f").expire(key, request.seconds);
        }
        return Empty.fromPartial({});
    }
    async ExpireTime(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).ttl(key);
            return Int64Value.fromPartial({});
        }
        else {
            const ttl = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").ttl(key);
            return { value: ttl };
        }
    }
    async ZCard(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).zCard(key);
            return Int64Value.fromPartial({});
        }
        else {
            const length = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").zCard(key);
            return { value: length };
        }
    }
    async ZAdd(request, metadata) {
        const key = namespacedKey(metadata, request.key);
        const zaddArgs = request.members.flatMap((member) => ({
            score: member.score,
            value: member.member,
        }));
        if (request.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.transactionId).zAdd(key, zaddArgs);
            return Int64Value.fromPartial({});
        }
        else {
            const changed = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").zAdd(key, zaddArgs);
            return { value: changed };
        }
    }
    async ZRem(request, metadata) {
        const key = namespacedKey(metadata, request.key.key);
        if (request.key?.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.key?.transactionId).zRem(key, request.members);
            return Int64Value.fromPartial({});
        }
        else {
            const count = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").zRem(key, request.members);
            return { value: count };
        }
    }
    async ZRange(request, metadata) {
        const key = namespacedKey(metadata, request.key.key);
        const count = Math.min(request.count, MaxResults); // Define MaxResults constant somewhere in your code
        // eslint-disable-next-line
        let opts = {};
        if (!request.byLex && !request.byScore) {
            let stop = parseInt(request.stop);
            const start = parseInt(request.start);
            stop = Math.min(stop, start + MaxResults);
            if (stop < 0)
                stop = start + MaxResults;
            request.stop = stop.toString();
        }
        else {
            opts.LIMIT = {
                offset: request.offset,
                count: count,
            };
        }
        if (request.rev) {
            throw new Error('unsupported');
        }
        if (request.byLex)
            opts.BY = 'LEX';
        if (request.byScore)
            opts.BY = 'SCORE';
        if (request.rev)
            opts.REV = true;
        if (request.key?.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.key?.transactionId).zRangeWithScores(key, request.start, request.stop, opts);
            return ZMembers.fromPartial({});
        }
        else {
            const rsp = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").zRangeWithScores(key, request.start, request.stop, opts);
            return { members: rsp.map(({ score, value }) => ({ score, member: value })) };
        }
    }
    async ZRemRangeByLex(request, metadata) {
        const key = namespacedKey(metadata, request.key.key);
        if (request.key?.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.key?.transactionId).zRemRangeByLex(key, request.min, request.max);
            return Int64Value.fromPartial({});
        }
        else {
            const count = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").zRemRangeByLex(key, request.min, request.max);
            return { value: count };
        }
    }
    async ZRemRangeByRank(request, metadata) {
        const key = namespacedKey(metadata, request.key.key);
        if (request.key?.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.key?.transactionId).zRemRangeByRank(key, request.start, request.stop);
            return Int64Value.fromPartial({});
        }
        else {
            const count = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").zRemRangeByRank(key, request.start, request.stop);
            return { value: count };
        }
    }
    async ZRemRangeByScore(request, metadata) {
        const key = namespacedKey(metadata, request.key.key);
        if (request.key?.transactionId) {
            await __classPrivateFieldGet(this, _LocalRedis_instances, "m", _LocalRedis_tx).call(this, request.key?.transactionId).zRemRangeByScore(key, request.min.toString(), request.max.toString());
            return Int64Value.fromPartial({});
        }
        else {
            const count = await __classPrivateFieldGet(this, _LocalRedis_redis, "f").zRemRangeByScore(key, request.min.toString(), request.max.toString());
            return { value: count };
        }
    }
    async HGet(_request, _metadata) {
        console.error('HGET is not supported in Node Runtime. ' + localRuntimeError);
        return StringValue.fromPartial({});
    }
    async HSet(_request, _metadata) {
        console.error('HSET is not supported in Node Runtime. ' + localRuntimeError);
        return Int64Value.fromPartial({});
    }
    async HGetAll(_request, _metadata) {
        console.error('HGETAll is not supported in Node Runtime. ' + localRuntimeError);
        return RedisFieldValues.fromPartial({});
    }
    async HDel(_request, _metadata) {
        console.error('HDel is not supported in Node Runtime. ' + localRuntimeError);
        return Int64Value.fromPartial({});
    }
    async ZScore(_request, _metadata) {
        console.error('ZScore is not supported in Node Runtime. ' + localRuntimeError);
        return DoubleValue.fromPartial({});
    }
    async ZRank(_request, _metadata) {
        console.error('ZRank is not supported in Node Runtime. ' + localRuntimeError);
        return Int64Value.fromPartial({});
    }
    async ZIncrBy(_request, _metadata) {
        console.error('ZIncrBy is not supported in Node Runtime. ' + localRuntimeError);
        return DoubleValue.fromPartial({});
    }
    async HKeys(_request, _metadata) {
        console.error('HKeys is not supported in Node Runtime. ' + localRuntimeError);
        return { keys: [] };
    }
    async HScan(_request, _metadata) {
        console.error('HScan is not supported in Node Runtime. ' + localRuntimeError);
        return { cursor: 0, fieldValues: [] };
    }
    async HIncrBy(_request, _metadata) {
        console.error('HIncrBy is not supported in Node Runtime. ' + localRuntimeError);
        return Int64Value.fromPartial({});
    }
}
_LocalRedis_redis = new WeakMap(), _LocalRedis_transactions = new WeakMap(), _LocalRedis_instances = new WeakSet(), _LocalRedis_tx = function _LocalRedis_tx(txId) {
    const tx = __classPrivateFieldGet(this, _LocalRedis_transactions, "f")[txId.id];
    if (!tx) {
        throw new Error('Transaction not found');
    }
    if (tx.multi) {
        return tx.multi;
    }
    return tx.isoClient;
}, _LocalRedis_newtx = async function _LocalRedis_newtx() {
    const id = Math.random().toString(36).substring(7);
    let close;
    let ready;
    const closePromise = new Promise((resolve) => {
        close = resolve;
    });
    const readyPromise = new Promise((resolve) => {
        ready = resolve;
    });
    __classPrivateFieldGet(this, _LocalRedis_redis, "f")
        .executeIsolated(async (isoClient) => {
        __classPrivateFieldGet(this, _LocalRedis_transactions, "f")[id] = {
            isoClient,
            close,
            multi: undefined,
            id,
        };
        ready();
        await closePromise;
    })
        .catch((err) => {
        console.error(err);
    });
    await readyPromise;
    return __classPrivateFieldGet(this, _LocalRedis_transactions, "f")[id];
};
