"use strict";

// ../shared-types/dist/inspect.js
var indentPerLevel = "  ";
var smallThreshold = 55;
var defaultOptions = {
  depth: 2
};
function inspect(val, options) {
  const indent = "";
  const refs = {
    visited: /* @__PURE__ */ new Map(),
    currentNumber: 0
  };
  const completeOptions = {
    ...defaultOptions,
    ...options ?? {}
  };
  return inspectRoot(val, completeOptions, refs, indent);
}
function inspectRoot(val, args, refs, indent) {
  switch (typeof val) {
    case "object":
      if (val === null) {
        return "null";
      }
      if (val instanceof Date) {
        return val.toISOString();
      }
      if (val instanceof Error) {
        return val.stack || `${val.name}: ${val.message}`;
      }
      if (val instanceof Promise) {
        return `[Promise]`;
      }
      return inspectObject(val, args, refs, indent);
    case "undefined":
      return "undefined";
    case "function":
      return `[Function: ${val.name}]`;
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "symbol":
      return val.toString();
    default:
      return "";
  }
}
function inspectObject(obj, args, refs, indent) {
  let refConfig = refs.visited.get(obj);
  if (refConfig === void 0) {
    refConfig = { isBeingPrinted: false };
    refs.visited.set(obj, refConfig);
  }
  if (refConfig.isBeingPrinted) {
    if (refConfig.refNumber === void 0) {
      refConfig.refNumber = ++refs.currentNumber;
    }
    return `[Circular *${refConfig.refNumber}]`;
  }
  refConfig.isBeingPrinted = true;
  let depthRemaining = args.depth;
  if (depthRemaining !== null && depthRemaining < 0) {
    refConfig.isBeingPrinted = false;
    return Array.isArray(obj) ? "[Array]" : "[Object]";
  }
  if (depthRemaining !== null) {
    depthRemaining -= 1;
  }
  const entries = [];
  let totalLength = 0;
  const subObjArgs = {
    ...args,
    depth: depthRemaining
  };
  if (Array.isArray(obj)) {
    for (const val of obj) {
      const valString = inspectRoot(val, subObjArgs, refs, indent + indentPerLevel);
      entries.push(valString);
      totalLength += valString.length;
    }
  } else {
    for (const key in obj) {
      const valString = inspectRoot(obj[key], subObjArgs, refs, indent + indentPerLevel);
      entries.push([key, valString]);
      totalLength += key.length;
      totalLength += valString.length;
      totalLength += ": ".length;
    }
  }
  refConfig.isBeingPrinted = false;
  const refLabel = refConfig.refNumber ? `\u27E8ref *${refConfig.refNumber}\u27E9 ` : "";
  if (totalLength < smallThreshold) {
    if (Array.isArray(obj)) {
      return `${refLabel}[ ${entries.join(", ")} ]`;
    }
    return `${refLabel}{${entries.map(([key, val]) => `${key}: ${val}`).join(", ")}}`;
  }
  let result = `${refLabel}${Array.isArray(obj) ? "[" : "{"}`;
  for (let i = 0; i < entries.length; i++) {
    const isLast = i === entries.length - 1;
    const entry = entries[i];
    if (Array.isArray(obj)) {
      result += `
${indent}${indentPerLevel}${entry}`;
    } else {
      const [key, val] = entry;
      result += `
${indent}${indentPerLevel}${key}: ${val}`;
    }
    if (!isLast) {
      result += ",";
    }
  }
  result += `
${indent}${Array.isArray(obj) ? "]" : "}"}`;
  return result;
}

// src/polyfills/bufferedLog.ts
var makeBufferedLogFunction = (buffer, flush) => {
  const encoder = new TextEncoder();
  return function log(type, logmsg, alreadyFlushed = false) {
    const data = new DataView(buffer);
    let logOffset = data.getUint32(0, true);
    if (logOffset < 4) {
      logOffset = 4;
    }
    data.setUint8(logOffset, type);
    logOffset += 1;
    const sizeStoragePosition = logOffset;
    logOffset += 4;
    const result = encoder.encodeInto(logmsg, new Uint8Array(buffer, logOffset));
    if (result.read !== logmsg.length) {
      if (!alreadyFlushed) {
        flush();
        data.setUint32(0, 0, true);
        log(type, logmsg, true);
        return;
      }
    }
    if (result.written == null) {
      throw Error("Unexpected");
    }
    data.setUint32(sizeStoragePosition, result.written, true);
    logOffset += result.written;
    data.setUint32(0, logOffset, true);
  };
};

// src/polyfills/console.polyfill.ts
var inspectOrPrint = (val) => typeof val === "string" ? val : inspect(val);
var formatLogString = (vals) => vals.map(inspectOrPrint).join(" ");
var logFunction;
if (typeof __builtin_log === "function") {
  logFunction = __builtin_log;
} else if (typeof __builtin_log_buffer === "object" && typeof __builtin_log_buffer_flush === "function") {
  logFunction = makeBufferedLogFunction(__builtin_log_buffer, __builtin_log_buffer_flush);
}
var logMethod = (type) => (...vals) => {
  logFunction(type, formatLogString(vals));
};
var console = {
  log: logMethod(0 /* Log */),
  info: logMethod(1 /* Info */),
  warn: logMethod(2 /* Warn */),
  error: logMethod(3 /* Error */),
  debug: logMethod(4 /* Debug */),
  dir(obj, opts) {
    logFunction(4 /* Debug */, inspect(obj, opts));
  }
};
if (globalThis.console === void 0) {
  globalThis.console = console;
}
