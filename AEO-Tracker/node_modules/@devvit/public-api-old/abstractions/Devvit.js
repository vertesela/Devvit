/**
 * GENERATED FILE - DO NOT EDIT
 * See generateDevvitShim.js.
 */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _Devvit_provides, _Devvit_uses, _Devvit_provideHandlers, _Devvit_apiClients, _Devvit_provide, _Devvit_contextActions, _Devvit_registerContextActions, _Devvit_schedulerHandlers, _Devvit_registerSchedulerHandlers, _Devvit_settingsFormFields;
import * as types from '@devvit/protos';
import { Definition, Empty, HandlerResult, } from '@devvit/protos';
import { Actor } from '@devvit/runtimes/api/Actor.js';
import { convertContextActionsToProtos, executeContextActionHandler, getContextActionId, } from '../context-actions/utilities.js';
import { executeSchedulerHandler } from '../scheduler/utilities.js';
import { getSettingsValues, transformFormFields } from '../settings/utilities.js';
/**
 * Provides a binding between a SerializableServiceDefinition and its interface to allow automatic
 * casting with the generic use
 */
class BoundType {
    constructor(ssd) {
        this.ssd = ssd;
    }
}
const redditApiDefinitionNames = Object.freeze([
    'Flair',
    'LinksAndComments',
    'Listings',
    'Moderation',
    'ModNote',
    'NewModmail',
    'PrivateMessages',
    'Subreddits',
    'Users',
    'Widgets',
    'Wiki',
]);
function bind(ssd) {
    return new BoundType(ssd);
}
/**
 * Devvit's non-class-based API for Bundle programs. Bundles are expected to
 * reexport their Devvit singleton. Config state is retained statically so that
 * when a Bundle exports their static instance of Devvit, its constructor can
 * populate the passed in Config with that static state.
 *
 * For the class API, see Actor.
 */
export class Devvit extends Actor {
    // {{TRIGGER_DOC_COMMENT}}
    static addTrigger(config) {
        if ('events' in config) {
            // Disable use of any. This is a tricky overload to write w/out any
            // eslint-disable @typescript-eslint/no-explicit-any
            for (const eventType of config.events) {
                this.addTrigger({
                    event: eventType,
                    handler: (event, meta) => config.handler({
                        type: eventType,
                        event,
                    }, meta),
                });
            }
            // eslint-enable @typescript-eslint/no-explicit-any
            return this;
        }
        const wrapHandler = (fn) => async (arg, meta) => {
            let result = await fn(arg, meta);
            return result ?? HandlerResult.fromPartial({});
        };
        switch (config.event) {
            case _a.Trigger.PostSubmit:
                _a.onPostSubmit(wrapHandler(config.handler));
                break;
            case _a.Trigger.PostCreate:
                _a.onPostCreate(wrapHandler(config.handler));
                break;
            case _a.Trigger.PostUpdate:
                _a.onPostUpdate(wrapHandler(config.handler));
                break;
            case _a.Trigger.PostReport:
                _a.onPostReport(wrapHandler(config.handler));
                break;
            case _a.Trigger.PostDelete:
                _a.onPostDelete(wrapHandler(config.handler));
                break;
            case _a.Trigger.PostFlairUpdate:
                _a.onPostFlairUpdate(wrapHandler(config.handler));
                break;
            case _a.Trigger.CommentSubmit:
                _a.onCommentSubmit(wrapHandler(config.handler));
                break;
            case _a.Trigger.CommentCreate:
                _a.onCommentCreate(wrapHandler(config.handler));
                break;
            case _a.Trigger.CommentUpdate:
                _a.onCommentUpdate(wrapHandler(config.handler));
                break;
            case _a.Trigger.CommentReport:
                _a.onCommentReport(wrapHandler(config.handler));
                break;
            case _a.Trigger.CommentDelete:
                _a.onCommentDelete(wrapHandler(config.handler));
                break;
            case _a.Trigger.AppInstall:
                _a.onAppInstall(wrapHandler(config.handler));
                break;
            case _a.Trigger.AppUpgrade:
                _a.onAppUpgrade(wrapHandler(config.handler));
                break;
            case _a.Trigger.ModAction:
                _a.onModAction(wrapHandler(config.handler));
                break;
            case _a.Trigger.ModMail:
                _a.onModMail(wrapHandler(config.handler));
                break;
        }
        return _a;
    }
    static use(type, opts) {
        return _a._use(Definition.fromSerializable(type.ssd), opts);
    }
    static getApiClient(type) {
        const definition = Definition.fromSerializable(type.ssd);
        const client = __classPrivateFieldGet(this, _a, "f", _Devvit_apiClients)[definition.fullName];
        if (!client) {
            throw new Error(`${definition.name} client has not been initialized. Make sure to call \`Devvit.use\` at the top of your main.ts file.`);
        }
        return client;
    }
    // OnPostSubmit
    static onPostSubmit(cb) {
        _a._extend(types.OnPostSubmitDefinition, '/devvit.actor.automation.v1alpha.OnPostSubmit/OnPostSubmit', cb);
    }
    // OnPostCreate
    static onPostCreate(cb) {
        _a._extend(types.OnPostCreateDefinition, '/devvit.actor.automation.v1alpha.OnPostCreate/OnPostCreate', cb);
    }
    // OnPostUpdate
    static onPostUpdate(cb) {
        _a._extend(types.OnPostUpdateDefinition, '/devvit.actor.automation.v1alpha.OnPostUpdate/OnPostUpdate', cb);
    }
    // OnPostReport
    static onPostReport(cb) {
        _a._extend(types.OnPostReportDefinition, '/devvit.actor.automation.v1alpha.OnPostReport/OnPostReport', cb);
    }
    // OnPostDelete
    static onPostDelete(cb) {
        _a._extend(types.OnPostDeleteDefinition, '/devvit.actor.automation.v1alpha.OnPostDelete/OnPostDelete', cb);
    }
    // OnPostFlairUpdate
    static onPostFlairUpdate(cb) {
        _a._extend(types.OnPostFlairUpdateDefinition, '/devvit.actor.automation.v1alpha.OnPostFlairUpdate/OnPostFlairUpdate', cb);
    }
    // OnCommentSubmit
    static onCommentSubmit(cb) {
        _a._extend(types.OnCommentSubmitDefinition, '/devvit.actor.automation.v1alpha.OnCommentSubmit/OnCommentSubmit', cb);
    }
    // OnCommentCreate
    static onCommentCreate(cb) {
        _a._extend(types.OnCommentCreateDefinition, '/devvit.actor.automation.v1alpha.OnCommentCreate/OnCommentCreate', cb);
    }
    // OnCommentUpdate
    static onCommentUpdate(cb) {
        _a._extend(types.OnCommentUpdateDefinition, '/devvit.actor.automation.v1alpha.OnCommentUpdate/OnCommentUpdate', cb);
    }
    // OnCommentReport
    static onCommentReport(cb) {
        _a._extend(types.OnCommentReportDefinition, '/devvit.actor.automation.v1alpha.OnCommentReport/OnCommentReport', cb);
    }
    // OnCommentDelete
    static onCommentDelete(cb) {
        _a._extend(types.OnCommentDeleteDefinition, '/devvit.actor.automation.v1alpha.OnCommentDelete/OnCommentDelete', cb);
    }
    // OnAppInstall
    static onAppInstall(cb) {
        _a._extend(types.OnAppInstallDefinition, '/devvit.actor.automation.v1alpha.OnAppInstall/OnAppInstall', cb);
    }
    // OnAppUpgrade
    static onAppUpgrade(cb) {
        _a._extend(types.OnAppUpgradeDefinition, '/devvit.actor.automation.v1alpha.OnAppUpgrade/OnAppUpgrade', cb);
    }
    // OnModAction
    static onModAction(cb) {
        _a._extend(types.OnModActionDefinition, '/devvit.actor.automation.v1alpha.OnModAction/OnModAction', cb);
    }
    // OnModMail
    static onModMail(cb) {
        _a._extend(types.OnModMailDefinition, '/devvit.actor.automation.v1alpha.OnModMail/OnModMail', cb);
    }
    static addAction(contextAction) {
        __classPrivateFieldGet(this, _a, "f", _Devvit_contextActions).set(getContextActionId(contextAction, __classPrivateFieldGet(this, _a, "f", _Devvit_contextActions).size), contextAction);
        __classPrivateFieldGet(this, _a, "m", _Devvit_registerContextActions).call(this);
        return _a;
    }
    static addActions(contextActions) {
        for (const contextAction of contextActions) {
            this.addAction(contextAction);
        }
        return _a;
    }
    static addSchedulerHandler(schedulerHandler) {
        __classPrivateFieldGet(_a, _a, "f", _Devvit_schedulerHandlers).set(schedulerHandler.type, schedulerHandler);
        __classPrivateFieldGet(_a, _a, "m", _Devvit_registerSchedulerHandlers).call(_a);
        return _a;
    }
    /**
     * Add fields to the app installation settings. These fields will appear in the subreddit app settings page
     * in the Developer Portal.
     *
     * @param {SettingsFormField[]} settings - The form fields to add to the app installation settings.
     *
     * @example
     * ```ts
     * import { Devvit } from '@devvit/public-api-old';
     *
     * Devvit.addSettings([
     *   {
     *     type: 'string',
     *     name: 'apiKey',
     *     label: 'API Key',
     *     required: true
     *   },
     *   {
     *     type: 'boolean',
     *     name: 'enabled',
     *     label: 'Feature Enabled',
     *     required: true
     *   },
     * ]);
     * ```
     */
    static addSettings(settings) {
        __classPrivateFieldSet(this, _a, settings, "f", _Devvit_settingsFormFields);
        this.use(this.Types.Settings);
        const fields = transformFormFields(__classPrivateFieldGet(this, _a, "f", _Devvit_settingsFormFields));
        this.InstallationSettings.onGetSettingsFields(async () => {
            if (!__classPrivateFieldGet(this, _a, "f", _Devvit_settingsFormFields)) {
                throw new Error('Installation settings is not defined.');
            }
            return types.GetFieldsResponse.fromPartial({
                fields: {
                    fields,
                },
            });
        });
        const flattendFields = __classPrivateFieldGet(this, _a, "f", _Devvit_settingsFormFields).flatMap((field) => {
            if (field.type === 'group') {
                return field.fields;
            }
            return field;
        });
        this.InstallationSettings.onValidateForm(async (req, metadata) => {
            if (!__classPrivateFieldGet(this, _a, "f", _Devvit_settingsFormFields)) {
                throw new Error('Installation settings is not defined.');
            }
            const response = types.ValidateFormResponse.fromPartial({
                success: true,
                errors: {},
            });
            const formValues = getSettingsValues(req.fieldValues);
            await Promise.all(flattendFields.map(async (field) => {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const fieldName = field.name;
                if (fieldName && field.type !== 'group' && field.onValidate) {
                    const value = formValues[fieldName];
                    const validator = field.onValidate;
                    const error = await validator({
                        isEditing: req.editing,
                        value,
                    }, metadata);
                    if (error) {
                        response.success = false;
                        response.errors[fieldName] = error;
                    }
                }
            }));
            return response;
        });
    }
    /** @internal */
    static _reset() {
        __classPrivateFieldSet(this, _a, new Set(), "f", _Devvit_provides);
        __classPrivateFieldSet(this, _a, {}, "f", _Devvit_uses);
        __classPrivateFieldSet(this, _a, {}, "f", _Devvit_provideHandlers);
        __classPrivateFieldSet(this, _a, new Map(), "f", _Devvit_contextActions);
        Object.keys(_a.prototype).forEach((key) => delete _a.prototype[key]);
    }
    /** @internal */
    static _extend(d, m, cb) {
        __classPrivateFieldGet(_a, _a, "m", _Devvit_provide).call(_a, d);
        __classPrivateFieldGet(_a, _a, "f", _Devvit_provideHandlers)[m] = cb;
    }
    /** @internal */
    static _use(d, opts) {
        __classPrivateFieldGet(this, _a, "f", _Devvit_uses)[d.fullName] = {
            def: d,
            options: opts ?? {},
            handler: undefined,
        };
        const wrapped = {};
        for (const method of Object.values(d.methods)) {
            wrapped[method.name] = (args, metadata) => __classPrivateFieldGet(this, _a, "f", _Devvit_uses)[d.fullName].handler?.[method.name]?.(method.requestType?.fromPartial(args ?? {}), metadata);
        }
        __classPrivateFieldGet(this, _a, "f", _Devvit_apiClients)[d.fullName] = wrapped;
        return wrapped;
    }
    constructor(cfg) {
        super(cfg);
        for (const fullName in __classPrivateFieldGet(_a, _a, "f", _Devvit_uses)) {
            const use = __classPrivateFieldGet(_a, _a, "f", _Devvit_uses)[fullName];
            use.handler = cfg.use(use.def, use.options);
        }
        for (const provide of __classPrivateFieldGet(_a, _a, "f", _Devvit_provides))
            cfg.provides(provide);
    }
}
_a = Devvit, _Devvit_provide = function _Devvit_provide(def) {
    if (!__classPrivateFieldGet(this, _a, "f", _Devvit_provides).has(def)) {
        __classPrivateFieldGet(this, _a, "f", _Devvit_provides).add(def);
        for (const key in def.methods) {
            const name = def.methods[key].name;
            _a.prototype[name] = async (args, metadata) => {
                const handler = __classPrivateFieldGet(this, _a, "f", _Devvit_provideHandlers)[`/${def.fullName}/${name}`];
                if (handler) {
                    if (def.methods[key].responseType.$type !== Empty.$type) {
                        return def.methods[key].responseType?.fromPartial((await handler(args, metadata)) ?? Empty.fromPartial({}));
                    }
                    else {
                        await handler(args, metadata);
                    }
                }
                return def.methods[key].responseType?.fromPartial({});
            };
        }
    }
}, _Devvit_registerContextActions = function _Devvit_registerContextActions() {
    if (__classPrivateFieldGet(_a, _a, "f", _Devvit_contextActions).size > 0) {
        _a.ContextAction.onGetActions(async () => {
            return convertContextActionsToProtos(Array.from(__classPrivateFieldGet(_a, _a, "f", _Devvit_contextActions).values()));
        });
        _a.ContextAction.onAction(async (req, metadata) => {
            const contextAction = __classPrivateFieldGet(_a, _a, "f", _Devvit_contextActions).get(req.actionId);
            if (!contextAction) {
                throw new Error('could not find context action handler');
            }
            const response = await executeContextActionHandler(contextAction, req, metadata);
            return {
                ...response,
                effects: [],
            };
        });
    }
}, _Devvit_registerSchedulerHandlers = function _Devvit_registerSchedulerHandlers() {
    if (__classPrivateFieldGet(_a, _a, "f", _Devvit_schedulerHandlers).size > 0) {
        _a.SchedulerHandler.onHandleScheduledAction(async (req, metadata) => {
            const handler = __classPrivateFieldGet(_a, _a, "f", _Devvit_schedulerHandlers).get(req.type);
            if (!handler) {
                throw new Error('could not find handler for scheduled action');
            }
            return executeSchedulerHandler(handler, req, metadata);
        });
    }
};
_Devvit_provides = { value: new Set() };
_Devvit_uses = { value: {} };
/** Methods can be asynchronous. */
_Devvit_provideHandlers = { value: {} };
_Devvit_apiClients = { value: {} };
Devvit.Types = Object.freeze({
    HTTP: bind(Definition.toSerializable(types.HTTPDefinition)),
    Logger: bind(Definition.toSerializable(types.LoggerDefinition)),
    Scheduler: bind(Definition.toSerializable(types.SchedulerDefinition)),
    Settings: bind(Definition.toSerializable(types.SettingsDefinition)),
    Timer: bind(Definition.toSerializable(types.TimerDefinition)),
    MediaService: bind(Definition.toSerializable(types.MediaServiceDefinition)),
    AssetResolver: bind(Definition.toSerializable(types.AssetResolverDefinition)),
    ContextAction: bind(Definition.toSerializable(types.ContextActionDefinition)),
    KVStore: bind(Definition.toSerializable(types.KVStoreDefinition)),
    RedisAPI: bind(Definition.toSerializable(types.RedisAPIDefinition)),
    InstallationSettings: bind(Definition.toSerializable(types.InstallationSettingsDefinition)),
    InstanceSettings: bind(Definition.toSerializable(types.InstanceSettingsDefinition)),
    SchedulerHandler: bind(Definition.toSerializable(types.SchedulerHandlerDefinition)),
    UserConfigurable: bind(Definition.toSerializable(types.UserConfigurableDefinition)),
    OnPostSubmit: bind(Definition.toSerializable(types.OnPostSubmitDefinition)),
    OnPostCreate: bind(Definition.toSerializable(types.OnPostCreateDefinition)),
    OnPostUpdate: bind(Definition.toSerializable(types.OnPostUpdateDefinition)),
    OnPostReport: bind(Definition.toSerializable(types.OnPostReportDefinition)),
    OnPostDelete: bind(Definition.toSerializable(types.OnPostDeleteDefinition)),
    OnPostFlairUpdate: bind(Definition.toSerializable(types.OnPostFlairUpdateDefinition)),
    OnCommentSubmit: bind(Definition.toSerializable(types.OnCommentSubmitDefinition)),
    OnCommentCreate: bind(Definition.toSerializable(types.OnCommentCreateDefinition)),
    OnCommentUpdate: bind(Definition.toSerializable(types.OnCommentUpdateDefinition)),
    OnCommentReport: bind(Definition.toSerializable(types.OnCommentReportDefinition)),
    OnCommentDelete: bind(Definition.toSerializable(types.OnCommentDeleteDefinition)),
    OnAppInstall: bind(Definition.toSerializable(types.OnAppInstallDefinition)),
    OnAppUpgrade: bind(Definition.toSerializable(types.OnAppUpgradeDefinition)),
    OnModAction: bind(Definition.toSerializable(types.OnModActionDefinition)),
    OnModMail: bind(Definition.toSerializable(types.OnModMailDefinition)),
    RedditAPI: {
        Flair: bind(Definition.toSerializable(types.FlairDefinition)),
        LinksAndComments: bind(Definition.toSerializable(types.LinksAndCommentsDefinition)),
        Listings: bind(Definition.toSerializable(types.ListingsDefinition)),
        Moderation: bind(Definition.toSerializable(types.ModerationDefinition)),
        ModNote: bind(Definition.toSerializable(types.ModNoteDefinition)),
        NewModmail: bind(Definition.toSerializable(types.NewModmailDefinition)),
        PrivateMessages: bind(Definition.toSerializable(types.PrivateMessagesDefinition)),
        Subreddits: bind(Definition.toSerializable(types.SubredditsDefinition)),
        Users: bind(Definition.toSerializable(types.UsersDefinition)),
        Widgets: bind(Definition.toSerializable(types.WidgetsDefinition)),
        Wiki: bind(Definition.toSerializable(types.WikiDefinition)),
    },
});
// ContextAction
Devvit.ContextAction = {
    onGetActions(cb) {
        _a._extend(types.ContextActionDefinition, '/devvit.actor.reddit.ContextAction/GetActions', cb);
    },
    onAction(cb) {
        _a._extend(types.ContextActionDefinition, '/devvit.actor.reddit.ContextAction/OnAction', cb);
    },
};
// KVStore
Devvit.KVStore = {
    onPut(cb) {
        _a._extend(types.KVStoreDefinition, '/devvit.plugin.kvstore.KVStore/Put', cb);
    },
    onGet(cb) {
        _a._extend(types.KVStoreDefinition, '/devvit.plugin.kvstore.KVStore/Get', cb);
    },
    onDel(cb) {
        _a._extend(types.KVStoreDefinition, '/devvit.plugin.kvstore.KVStore/Del', cb);
    },
    onList(cb) {
        _a._extend(types.KVStoreDefinition, '/devvit.plugin.kvstore.KVStore/List', cb);
    },
};
// RedisAPI
Devvit.RedisAPI = {
    onGet(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Get', cb);
    },
    onSet(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Set', cb);
    },
    onDel(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Del', cb);
    },
    onType(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Type', cb);
    },
    onIncrBy(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/IncrBy', cb);
    },
    onHSet(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/HSet', cb);
    },
    onHGet(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/HGet', cb);
    },
    onHGetAll(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/HGetAll', cb);
    },
    onHDel(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/HDel', cb);
    },
    onHScan(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/HScan', cb);
    },
    onHKeys(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/HKeys', cb);
    },
    onMulti(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Multi', cb);
    },
    onExec(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Exec', cb);
    },
    onDiscard(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Discard', cb);
    },
    onWatch(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Watch', cb);
    },
    onUnwatch(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Unwatch', cb);
    },
    onGetRange(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/GetRange', cb);
    },
    onSetRange(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/SetRange', cb);
    },
    onStrlen(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Strlen', cb);
    },
    onMGet(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/MGet', cb);
    },
    onMSet(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/MSet', cb);
    },
    onExpire(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/Expire', cb);
    },
    onExpireTime(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/ExpireTime', cb);
    },
    onZAdd(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/ZAdd', cb);
    },
    onZCard(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/ZCard', cb);
    },
    onZRange(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/ZRange', cb);
    },
    onZRem(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/ZRem', cb);
    },
    onZRemRangeByLex(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/ZRemRangeByLex', cb);
    },
    onZRemRangeByRank(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/ZRemRangeByRank', cb);
    },
    onZRemRangeByScore(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/ZRemRangeByScore', cb);
    },
    onZScore(cb) {
        _a._extend(types.RedisAPIDefinition, '/devvit.plugin.redis.RedisAPI/ZScore', cb);
    },
};
// InstallationSettings
Devvit.InstallationSettings = {
    onGetSettingsFields(cb) {
        _a._extend(types.InstallationSettingsDefinition, '/devvit.actor.settings.v1alpha.InstallationSettings/GetSettingsFields', cb);
    },
    onValidateForm(cb) {
        _a._extend(types.InstallationSettingsDefinition, '/devvit.actor.settings.v1alpha.InstallationSettings/ValidateForm', cb);
    },
};
// InstanceSettings
Devvit.InstanceSettings = {
    onGetSettingsFields(cb) {
        _a._extend(types.InstanceSettingsDefinition, '/devvit.actor.settings.v1alpha.InstanceSettings/GetSettingsFields', cb);
    },
    onValidateForm(cb) {
        _a._extend(types.InstanceSettingsDefinition, '/devvit.actor.settings.v1alpha.InstanceSettings/ValidateForm', cb);
    },
};
// SchedulerHandler
Devvit.SchedulerHandler = {
    onHandleScheduledAction(cb) {
        _a._extend(types.SchedulerHandlerDefinition, '/devvit.actor.scheduler.SchedulerHandler/HandleScheduledAction', cb);
    },
};
// UserConfigurable
Devvit.UserConfigurable = {
    onRenderForm(cb) {
        _a._extend(types.UserConfigurableDefinition, '/devvit.actor.user_configurable.UserConfigurable/RenderForm', cb);
    },
    onHandleFormResponse(cb) {
        _a._extend(types.UserConfigurableDefinition, '/devvit.actor.user_configurable.UserConfigurable/HandleFormResponse', cb);
    },
};
_Devvit_contextActions = { value: new Map() };
_Devvit_schedulerHandlers = { value: new Map() };
_Devvit_settingsFormFields = { value: void 0 };
(function (Devvit) {
    /**
     * The type of a trigger
     */
    let Trigger;
    (function (Trigger) {
        Trigger["PostSubmit"] = "PostSubmit";
        Trigger["PostCreate"] = "PostCreate";
        Trigger["PostUpdate"] = "PostUpdate";
        Trigger["PostReport"] = "PostReport";
        Trigger["PostDelete"] = "PostDelete";
        Trigger["PostFlairUpdate"] = "PostFlairUpdate";
        Trigger["CommentSubmit"] = "CommentSubmit";
        Trigger["CommentCreate"] = "CommentCreate";
        Trigger["CommentUpdate"] = "CommentUpdate";
        Trigger["CommentReport"] = "CommentReport";
        Trigger["CommentDelete"] = "CommentDelete";
        Trigger["AppInstall"] = "AppInstall";
        Trigger["AppUpgrade"] = "AppUpgrade";
        Trigger["ModAction"] = "ModAction";
        Trigger["ModMail"] = "ModMail";
    })(Trigger = Devvit.Trigger || (Devvit.Trigger = {}));
})(Devvit || (Devvit = {}));
