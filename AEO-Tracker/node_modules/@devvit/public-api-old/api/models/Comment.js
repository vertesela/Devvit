var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _Comment_id, _Comment_authorId, _Comment_authorName, _Comment_body, _Comment_createdAt, _Comment_parentId, _Comment_postId, _Comment_replies, _Comment_approved, _Comment_edited, _Comment_locked, _Comment_removed, _Comment_stickied, _Comment_spam, _Comment_distinguishedBy, _Comment_numReports, _Comment_collapsedBecauseCrowdControl, _Comment_score, _Comment_permalink, _Comment_metadata, _Comment_getCommentsListing, _Comment_buildCommentsTree;
import { Devvit } from '../../abstractions/Devvit.js';
import { Listing } from './Listing.js';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { asT1ID, asT2ID, asT3ID, isCommentId } from '@devvit/shared-types/tid.js';
import { richtextToString } from '../helpers/richtextToString.js';
import { User } from './User.js';
export class Comment {
    constructor(data, metadata) {
        _Comment_id.set(this, void 0);
        _Comment_authorId.set(this, void 0);
        _Comment_authorName.set(this, void 0);
        _Comment_body.set(this, void 0);
        _Comment_createdAt.set(this, void 0);
        _Comment_parentId.set(this, void 0);
        _Comment_postId.set(this, void 0);
        _Comment_replies.set(this, void 0);
        _Comment_approved.set(this, void 0);
        _Comment_edited.set(this, void 0);
        _Comment_locked.set(this, void 0);
        _Comment_removed.set(this, void 0);
        _Comment_stickied.set(this, void 0);
        _Comment_spam.set(this, void 0);
        _Comment_distinguishedBy.set(this, void 0);
        _Comment_numReports.set(this, void 0);
        _Comment_collapsedBecauseCrowdControl.set(this, void 0);
        _Comment_score.set(this, void 0);
        _Comment_permalink.set(this, void 0);
        _Comment_metadata.set(this, void 0);
        assertNonNull(data.id, 'Comment id is null or undefined');
        assertNonNull(data.body, 'Comment body is null or undefined');
        assertNonNull(data.createdUtc, 'Comment is missing created date');
        assertNonNull(data.author, 'Comment author is null or undefined');
        assertNonNull(data.parentId, 'Comment parentId is null or undefined');
        assertNonNull(data.linkId, 'Comment linkId is null or undefined');
        assertNonNull(data.permalink, 'Comment permalink is null or undefined');
        __classPrivateFieldSet(this, _Comment_id, asT1ID(`t1_${data.id}`), "f");
        __classPrivateFieldSet(this, _Comment_authorId, data.authorFullname ? asT2ID(data.authorFullname) : undefined, "f");
        __classPrivateFieldSet(this, _Comment_authorName, data.author, "f");
        __classPrivateFieldSet(this, _Comment_body, data.body, "f");
        __classPrivateFieldSet(this, _Comment_parentId, isCommentId(data.parentId) ? asT1ID(data.parentId) : asT3ID(data.parentId), "f");
        __classPrivateFieldSet(this, _Comment_postId, asT3ID(data.linkId), "f");
        __classPrivateFieldSet(this, _Comment_edited, data.edited ?? false, "f");
        __classPrivateFieldSet(this, _Comment_locked, data.locked ?? false, "f");
        __classPrivateFieldSet(this, _Comment_removed, data.removed ?? false, "f");
        __classPrivateFieldSet(this, _Comment_stickied, data.stickied ?? false, "f");
        __classPrivateFieldSet(this, _Comment_approved, data.approved ?? false, "f");
        __classPrivateFieldSet(this, _Comment_spam, data.spam ?? false, "f");
        __classPrivateFieldSet(this, _Comment_distinguishedBy, data.distinguished, "f");
        __classPrivateFieldSet(this, _Comment_numReports, data.numReports ?? 0, "f");
        __classPrivateFieldSet(this, _Comment_collapsedBecauseCrowdControl, data.collapsedBecauseCrowdControl ?? false, "f");
        __classPrivateFieldSet(this, _Comment_score, data.score ?? 0, "f");
        __classPrivateFieldSet(this, _Comment_permalink, data.permalink, "f");
        const createdAt = new Date(0);
        createdAt.setUTCSeconds(data.createdUtc);
        __classPrivateFieldSet(this, _Comment_createdAt, createdAt, "f");
        __classPrivateFieldSet(this, _Comment_replies, __classPrivateFieldGet(_a, _a, "m", _Comment_getCommentsListing).call(_a, {
            postId: __classPrivateFieldGet(this, _Comment_postId, "f"),
            commentId: __classPrivateFieldGet(this, _Comment_id, "f"),
        }, metadata), "f");
        __classPrivateFieldSet(this, _Comment_metadata, metadata, "f");
    }
    get id() {
        return __classPrivateFieldGet(this, _Comment_id, "f");
    }
    get authorId() {
        return __classPrivateFieldGet(this, _Comment_authorId, "f");
    }
    get authorName() {
        return __classPrivateFieldGet(this, _Comment_authorName, "f");
    }
    get body() {
        return __classPrivateFieldGet(this, _Comment_body, "f");
    }
    get createdAt() {
        return __classPrivateFieldGet(this, _Comment_createdAt, "f");
    }
    get parentId() {
        return __classPrivateFieldGet(this, _Comment_parentId, "f");
    }
    get postId() {
        return __classPrivateFieldGet(this, _Comment_postId, "f");
    }
    get replies() {
        return __classPrivateFieldGet(this, _Comment_replies, "f");
    }
    get distinguishedBy() {
        return __classPrivateFieldGet(this, _Comment_distinguishedBy, "f");
    }
    get locked() {
        return __classPrivateFieldGet(this, _Comment_locked, "f");
    }
    get stickied() {
        return __classPrivateFieldGet(this, _Comment_stickied, "f");
    }
    get removed() {
        return __classPrivateFieldGet(this, _Comment_removed, "f");
    }
    get approved() {
        return __classPrivateFieldGet(this, _Comment_approved, "f");
    }
    get spam() {
        return __classPrivateFieldGet(this, _Comment_spam, "f");
    }
    get edited() {
        return __classPrivateFieldGet(this, _Comment_edited, "f");
    }
    get numReports() {
        return __classPrivateFieldGet(this, _Comment_numReports, "f");
    }
    get collapsedBecauseCrowdControl() {
        return __classPrivateFieldGet(this, _Comment_collapsedBecauseCrowdControl, "f");
    }
    get score() {
        return __classPrivateFieldGet(this, _Comment_score, "f");
    }
    get permalink() {
        return __classPrivateFieldGet(this, _Comment_permalink, "f");
    }
    toJSON() {
        return {
            id: this.id,
            authorName: this.authorName,
            body: this.body,
            createdAt: this.createdAt,
            parentId: this.parentId,
            postId: this.postId,
            replies: this.replies,
            approved: this.approved,
            locked: this.locked,
            removed: this.removed,
            stickied: this.stickied,
            spam: this.spam,
            edited: this.edited,
            distinguishedBy: this.distinguishedBy,
            numReports: this.numReports,
            collapsedBecauseCrowdControl: this.collapsedBecauseCrowdControl,
            score: this.score,
            permalink: this.permalink,
        };
    }
    isLocked() {
        return __classPrivateFieldGet(this, _Comment_locked, "f");
    }
    isApproved() {
        return __classPrivateFieldGet(this, _Comment_approved, "f");
    }
    isRemoved() {
        return __classPrivateFieldGet(this, _Comment_removed, "f");
    }
    isSpam() {
        return __classPrivateFieldGet(this, _Comment_spam, "f");
    }
    isStickied() {
        return __classPrivateFieldGet(this, _Comment_stickied, "f");
    }
    isDistinguished() {
        return Boolean(__classPrivateFieldGet(this, _Comment_distinguishedBy, "f"));
    }
    isEdited() {
        return __classPrivateFieldGet(this, _Comment_edited, "f");
    }
    async delete() {
        return _a.delete(this.id, __classPrivateFieldGet(this, _Comment_metadata, "f"));
    }
    async edit(options) {
        const newComment = await _a.edit({
            id: this.id,
            ...options,
        }, __classPrivateFieldGet(this, _Comment_metadata, "f"));
        __classPrivateFieldSet(this, _Comment_body, newComment.body, "f");
        __classPrivateFieldSet(this, _Comment_edited, newComment.edited, "f");
        return this;
    }
    async approve() {
        await _a.approve(this.id, __classPrivateFieldGet(this, _Comment_metadata, "f"));
        __classPrivateFieldSet(this, _Comment_approved, true, "f");
        __classPrivateFieldSet(this, _Comment_removed, false, "f");
    }
    async remove(isSpam = false) {
        await _a.remove(this.id, isSpam, __classPrivateFieldGet(this, _Comment_metadata, "f"));
        __classPrivateFieldSet(this, _Comment_removed, true, "f");
        __classPrivateFieldSet(this, _Comment_spam, isSpam, "f");
        __classPrivateFieldSet(this, _Comment_approved, false, "f");
    }
    async lock() {
        await _a.lock(this.id, __classPrivateFieldGet(this, _Comment_metadata, "f"));
        __classPrivateFieldSet(this, _Comment_locked, true, "f");
    }
    async unlock() {
        await _a.unlock(this.id, __classPrivateFieldGet(this, _Comment_metadata, "f"));
        __classPrivateFieldSet(this, _Comment_locked, false, "f");
    }
    async reply(options) {
        return _a.submit({
            id: this.id,
            ...options,
        }, __classPrivateFieldGet(this, _Comment_metadata, "f"));
    }
    async getAuthor() {
        return User.getByUsername(__classPrivateFieldGet(this, _Comment_authorName, "f"), __classPrivateFieldGet(this, _Comment_metadata, "f"));
    }
    async distinguish(makeSticky = false) {
        const { distinguishedBy, stickied } = await _a.distinguish(this.id, makeSticky, false, __classPrivateFieldGet(this, _Comment_metadata, "f"));
        __classPrivateFieldSet(this, _Comment_distinguishedBy, distinguishedBy, "f");
        __classPrivateFieldSet(this, _Comment_stickied, stickied, "f");
    }
    async distinguishAsAdmin(makeSticky = false) {
        const { distinguishedBy, stickied } = await _a.distinguish(this.id, makeSticky, true, __classPrivateFieldGet(this, _Comment_metadata, "f"));
        __classPrivateFieldSet(this, _Comment_distinguishedBy, distinguishedBy, "f");
        __classPrivateFieldSet(this, _Comment_stickied, stickied, "f");
    }
    async undistinguish() {
        const { distinguishedBy, stickied } = await _a.undistinguish(this.id, __classPrivateFieldGet(this, _Comment_metadata, "f"));
        __classPrivateFieldSet(this, _Comment_distinguishedBy, distinguishedBy, "f");
        __classPrivateFieldSet(this, _Comment_stickied, stickied, "f");
    }
    static async getById(id, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.LinksAndComments);
        const commentId = id.startsWith('t1_') ? id : `t1_${id}`;
        const response = await client.Info({
            subreddits: [],
            thingIds: [commentId],
        }, metadata);
        if (!response.data?.children?.[0]?.data) {
            throw new Error('not found');
        }
        return new _a(response.data.children[0].data, metadata);
    }
    static getComments(options, metadata) {
        const { postId, commentId, ...rest } = options;
        return __classPrivateFieldGet(_a, _a, "m", _Comment_getCommentsListing).call(_a, {
            postId: asT3ID(postId),
            commentId: commentId ? asT1ID(commentId) : undefined,
            ...rest,
        }, metadata);
    }
    static async edit(options, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.LinksAndComments);
        const { id } = options;
        let richtextString;
        if ('richtext' in options) {
            richtextString = richtextToString(options.richtext);
        }
        const response = await client.EditUserText({
            thingId: id,
            text: 'text' in options ? options.text : '',
            richtextJson: richtextString,
        }, metadata);
        if (response.json?.errors?.length) {
            throw new Error('Failed to edit comment');
        }
        const comment = response.json?.data?.things?.[0]?.data;
        assertNonNull(comment);
        return new _a(comment);
    }
    static async delete(id, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.LinksAndComments);
        await client.Del({
            id,
        }, metadata);
    }
    static async approve(id, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Moderation);
        await client.Approve({
            id,
        }, metadata);
    }
    static async remove(id, isSpam = false, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Moderation);
        await client.Remove({
            id,
            spam: isSpam,
        }, metadata);
    }
    static async lock(id, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.LinksAndComments);
        await client.Lock({
            id,
        }, metadata);
    }
    static async unlock(id, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.LinksAndComments);
        await client.Unlock({
            id,
        }, metadata);
    }
    static async submit(options, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.LinksAndComments);
        const { id } = options;
        let richtextString;
        if ('richtext' in options) {
            richtextString = richtextToString(options.richtext);
        }
        const response = await client.Comment({
            thingId: id,
            text: 'text' in options ? options.text : '',
            richtextJson: richtextString,
        }, metadata);
        // TODO: figure out a better errors to throw
        if (response.json?.errors?.length) {
            throw new Error('failed to reply to comment');
        }
        const data = response.json?.data?.things?.[0]?.data;
        assertNonNull(data);
        return new _a(data, metadata);
    }
    static async distinguish(id, sticky, asAdmin, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Moderation);
        const response = await client.Distinguish({
            id,
            how: asAdmin ? 'admin' : 'yes',
            sticky,
        }, metadata);
        const comment = response.json?.data?.things?.[0]?.data;
        assertNonNull(comment);
        return {
            distinguishedBy: comment.distinguished,
            stickied: Boolean(comment.stickied),
        };
    }
    static async undistinguish(id, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Moderation);
        const response = await client.Distinguish({
            id,
            how: 'no',
            sticky: false,
        }, metadata);
        const comment = response.json?.data?.things?.[0]?.data;
        assertNonNull(comment);
        return {
            distinguishedBy: comment.distinguished,
            stickied: Boolean(comment.stickied),
        };
    }
    static getCommentsByUser(options, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Users);
        return new Listing({
            hasMore: true,
            before: options.before,
            after: options.after,
            pageSize: options.pageSize,
            limit: options.limit,
            async fetch(fetchOptions) {
                const response = await client.UserWhere({
                    username: options.username,
                    where: 'comments',
                    ...fetchOptions,
                }, metadata);
                assertNonNull(response.data, 'Failed to get comments for user');
                const children = response.data.children?.map((child) => new _a(child.data, metadata)) || [];
                return {
                    children,
                    before: response.data.before,
                    after: response.data.after,
                };
            },
        });
    }
}
_a = Comment, _Comment_id = new WeakMap(), _Comment_authorId = new WeakMap(), _Comment_authorName = new WeakMap(), _Comment_body = new WeakMap(), _Comment_createdAt = new WeakMap(), _Comment_parentId = new WeakMap(), _Comment_postId = new WeakMap(), _Comment_replies = new WeakMap(), _Comment_approved = new WeakMap(), _Comment_edited = new WeakMap(), _Comment_locked = new WeakMap(), _Comment_removed = new WeakMap(), _Comment_stickied = new WeakMap(), _Comment_spam = new WeakMap(), _Comment_distinguishedBy = new WeakMap(), _Comment_numReports = new WeakMap(), _Comment_collapsedBecauseCrowdControl = new WeakMap(), _Comment_score = new WeakMap(), _Comment_permalink = new WeakMap(), _Comment_metadata = new WeakMap(), _Comment_getCommentsListing = function _Comment_getCommentsListing(options, metadata, depthOffset = 0) {
    return new Listing({
        limit: options.limit,
        pageSize: options.pageSize,
        fetch: async (fetchOptions) => {
            let limit = fetchOptions.limit;
            const listingsClient = Devvit.getApiClient(Devvit.Types.RedditAPI.Listings);
            const linksAndCommentsClient = Devvit.getApiClient(Devvit.Types.RedditAPI.LinksAndComments);
            let commentId = options.commentId;
            if (fetchOptions.more) {
                if (fetchOptions.more.children.length) {
                    const more = fetchOptions.more;
                    // The maximum page size for MoreChildren is 100
                    if (!limit || limit > 100) {
                        limit = 100;
                    }
                    const moreIds = more.children.splice(0, limit);
                    const response = await linksAndCommentsClient.MoreChildren({
                        linkId: options.postId,
                        children: moreIds,
                        sort: options.sort,
                    }, metadata);
                    if (!response.json?.data?.things?.length) {
                        return { children: [] };
                    }
                    const { children } = __classPrivateFieldGet(_a, _a, "m", _Comment_buildCommentsTree).call(_a, response.json.data.things, options.postId, options, metadata);
                    return { children, more: more.children.length ? more : undefined };
                }
                else {
                    // parentId is only ever T3 for the MoreChildren case.
                    commentId = fetchOptions.more.parentId;
                    depthOffset = depthOffset + fetchOptions.more.depth;
                }
            }
            const response = await listingsClient.Comments({
                article: options.postId.substring(3),
                comment: commentId?.substring(3),
                limit,
                depth: options.depth,
                sort: options.sort,
            }, metadata);
            // The first item of `response.listings` is always the post (t3) listing
            // and the second item is the comments (t1) listing.
            let responseChildren = response.listings?.[1]?.data?.children ?? [];
            const topLevelComment = responseChildren[0];
            if (commentId && topLevelComment?.data?.replyList?.data) {
                responseChildren = topLevelComment.data.replyList.data.children;
            }
            return __classPrivateFieldGet(_a, _a, "m", _Comment_buildCommentsTree).call(_a, responseChildren, commentId ?? options.postId, options, metadata, depthOffset);
        },
    });
}, _Comment_buildCommentsTree = function _Comment_buildCommentsTree(redditObjects, parentId, options, metadata, depthOffset = 0) {
    const children = [];
    let more;
    // Map of comments to help set parent-child relationship between comments returned by MoreChildren.
    const commentsMap = {};
    for (const child of redditObjects) {
        if (!child.data) {
            continue;
        }
        if (child.data.depth != null) {
            child.data.depth = child.data.depth + depthOffset;
        }
        // Prevent returning comments that are beyond the maximum depth requested.
        if (child.data.depth != null && options.depth != null && child.data.depth >= options.depth) {
            continue;
        }
        const parentComment = child.data.parentId ? commentsMap[child.data.parentId] : undefined;
        if (child.kind === 't1') {
            // Sometimes MoreChildren API returns a comment that has already been seen.
            if (child.data.name === parentId) {
                continue;
            }
            const comment = new _a(child.data, metadata);
            commentsMap[comment.id] = comment;
            __classPrivateFieldSet(comment, _Comment_replies, __classPrivateFieldGet(_a, _a, "m", _Comment_getCommentsListing).call(_a, {
                ...options,
                postId: comment.postId,
                commentId: comment.id,
            }, metadata, depthOffset), "f");
            // Preload the comment's replies Listing
            if ('replyList' in child.data && child.data.replyList?.data) {
                const { children, more } = __classPrivateFieldGet(_a, _a, "m", _Comment_buildCommentsTree).call(_a, child.data.replyList.data.children, comment.id, options, metadata, depthOffset);
                if (children.length) {
                    comment.replies.children.push(...children);
                }
                if (more) {
                    comment.replies.setMore(more);
                }
            }
            // Since the replies for this comment were already load we can skip the first fetch call
            comment.replies.preventInitialFetch();
            if (parentComment) {
                parentComment.replies.children.push(comment);
            }
            else {
                children.push(comment);
            }
        }
        else if (child.kind === 'more' && child.data.parentId && child.data.depth != null) {
            const thisMore = {
                parentId: isCommentId(child.data.parentId)
                    ? asT1ID(child.data.parentId)
                    : asT3ID(child.data.parentId),
                children: child.data.children ?? [],
                depth: child.data.depth,
            };
            if (parentComment) {
                parentComment.replies.setMore(thisMore);
            }
            else if (thisMore.parentId === parentId) {
                more = thisMore;
            }
        }
    }
    return { children, more };
};
