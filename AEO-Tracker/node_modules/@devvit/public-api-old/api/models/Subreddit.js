var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Subreddit_id, _Subreddit_name, _Subreddit_createdAt, _Subreddit_type, _Subreddit_title, _Subreddit_description, _Subreddit_language, _Subreddit_numberOfSubscribers, _Subreddit_numberOfActiveUsers, _Subreddit_nsfw, _Subreddit_settings, _Subreddit_metadata;
import { Devvit } from '../../abstractions/Devvit.js';
import { Header } from '@devvit/runtimes/lib/Header.js';
import { getFromMetadata } from '@devvit/runtimes/common/envelope/EnvelopeUtil.js';
import { Post, } from './Post.js';
import { User, } from './User.js';
import { getModerationLog, } from './ModAction.js';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { asT5ID } from '@devvit/shared-types/tid.js';
import { FlairTemplate } from './Flair.js';
import { Listing } from './Listing.js';
import { Comment } from './Comment.js';
/**
 * A class representing a subreddit.
 */
export class Subreddit {
    /** @hidden */
    constructor(data, metadata) {
        _Subreddit_id.set(this, void 0);
        _Subreddit_name.set(this, void 0);
        _Subreddit_createdAt.set(this, void 0);
        _Subreddit_type.set(this, void 0);
        _Subreddit_title.set(this, void 0);
        _Subreddit_description.set(this, void 0);
        _Subreddit_language.set(this, void 0);
        _Subreddit_numberOfSubscribers.set(this, void 0);
        _Subreddit_numberOfActiveUsers.set(this, void 0);
        _Subreddit_nsfw.set(this, void 0);
        _Subreddit_settings.set(this, void 0);
        _Subreddit_metadata.set(this, void 0);
        assertNonNull(data.id, 'Subreddit id is missing or undefined');
        assertNonNull(data.displayName, 'Subreddit name is missing or undefined');
        __classPrivateFieldSet(this, _Subreddit_id, asT5ID(`t5_${data.id}`), "f");
        __classPrivateFieldSet(this, _Subreddit_name, data.displayName, "f");
        assertNonNull(data.createdUtc, 'Subreddit is missing created date');
        const createdAt = new Date(0);
        createdAt.setUTCSeconds(data.createdUtc);
        __classPrivateFieldSet(this, _Subreddit_createdAt, createdAt, "f");
        __classPrivateFieldSet(this, _Subreddit_type, asSubredditType(data.subredditType), "f");
        __classPrivateFieldSet(this, _Subreddit_title, data.title, "f");
        __classPrivateFieldSet(this, _Subreddit_description, data.description, "f");
        assertNonNull(data.lang, 'Subreddit is missing language');
        __classPrivateFieldSet(this, _Subreddit_language, data.lang, "f");
        __classPrivateFieldSet(this, _Subreddit_numberOfSubscribers, data.subscribers ?? 0, "f");
        __classPrivateFieldSet(this, _Subreddit_numberOfActiveUsers, data.activeUserCount ?? 0, "f");
        __classPrivateFieldSet(this, _Subreddit_nsfw, data.over18 ?? false, "f");
        __classPrivateFieldSet(this, _Subreddit_settings, {
            acceptFollowers: data.acceptFollowers ?? false,
            allOriginalContent: data.allOriginalContent ?? false,
            allowChatPostCreation: data.allowChatPostCreation ?? false,
            allowDiscovery: data.allowDiscovery ?? false,
            allowGalleries: data.allowGalleries ?? false,
            allowImages: data.allowImages ?? false,
            allowPolls: data.allowPolls ?? false,
            allowPredictionContributors: data.allowPredictionContributors ?? false,
            allowPredictions: data.allowPredictions ?? false,
            allowPredictionsTournament: data.allowPredictionsTournament ?? false,
            allowTalks: data.allowTalks ?? false,
            allowVideoGifs: data.allowVideogifs ?? false,
            allowVideos: data.allowVideos ?? false,
            chatPostEnabled: data.isChatPostFeatureEnabled ?? false,
            collectionsEnabled: data.collectionsEnabled ?? false,
            crosspostable: data.isCrosspostableSubreddit ?? false,
            emojisEnabled: data.emojisEnabled ?? false,
            eventPostsEnabled: data.eventPostsEnabled ?? false,
            linkFlairEnabled: data.linkFlairEnabled ?? false,
            originalContentTagEnabled: data.originalContentTagEnabled ?? false,
            restrictCommenting: data.restrictCommenting ?? false,
            restrictPosting: data.restrictPosting ?? false,
            shouldArchivePosts: data.shouldArchivePosts ?? false,
            spoilersEnabled: data.spoilersEnabled ?? false,
            wikiEnabled: data.wikiEnabled ?? false,
            allowedPostType: asAllowedPostType(data.submissionType),
            allowedMediaInComments: data.allowedMediaInComments.map(asCommentMediaTypes),
            bannerBackgroundColor: data.bannerBackgroundColor,
            bannerBackgroundImage: data.bannerBackgroundImage,
            bannerImage: data.bannerImg,
            communityIcon: data.communityIcon,
            headerTitle: data.headerTitle,
            mobileBannerImage: data.mobileBannerImage,
            userFlairs: {
                enabled: data.userFlairEnabledInSr ?? false,
                usersCanAssign: data.canAssignUserFlair ?? false,
            },
            postFlairs: {
                enabled: data.linkFlairEnabled ?? false,
                usersCanAssign: data.canAssignLinkFlair ?? false,
            },
        }, "f");
        __classPrivateFieldSet(this, _Subreddit_metadata, metadata, "f");
    }
    /**
     * The ID (starting with t5_) of the subreddit to retrieve. e.g. t5_2qjpg
     */
    get id() {
        return __classPrivateFieldGet(this, _Subreddit_id, "f");
    }
    /**
     * The name of a subreddit omitting the r/.
     */
    get name() {
        return __classPrivateFieldGet(this, _Subreddit_name, "f");
    }
    /**
     * The creation date of the subreddit.
     */
    get createdAt() {
        return __classPrivateFieldGet(this, _Subreddit_createdAt, "f");
    }
    /**
     * The type of subreddit (public, private, etc.).
     */
    get type() {
        return __classPrivateFieldGet(this, _Subreddit_type, "f");
    }
    /**
     * The title of the subreddit.
     */
    get title() {
        return __classPrivateFieldGet(this, _Subreddit_title, "f");
    }
    /**
     * The description of the subreddit.
     */
    get description() {
        return __classPrivateFieldGet(this, _Subreddit_description, "f");
    }
    /**
     * The language of the subreddit.
     */
    get language() {
        return __classPrivateFieldGet(this, _Subreddit_language, "f");
    }
    /**
     * The number of subscribers of the subreddit.
     */
    get numberOfSubscribers() {
        return __classPrivateFieldGet(this, _Subreddit_numberOfSubscribers, "f");
    }
    /**
     * The number of active users of the subreddit.
     */
    get numberOfActiveUsers() {
        return __classPrivateFieldGet(this, _Subreddit_numberOfActiveUsers, "f");
    }
    /**
     * Whether the subreddit is marked as NSFW (Not Safe For Work).
     */
    get nsfw() {
        return __classPrivateFieldGet(this, _Subreddit_nsfw, "f");
    }
    /**
     * The settings of the subreddit.
     */
    get settings() {
        return __classPrivateFieldGet(this, _Subreddit_settings, "f");
    }
    /**
     * Whether the user flairs are enabled for this subreddit.
     */
    get userFlairsEnabled() {
        return this.settings.userFlairs.enabled;
    }
    /**
     * Whether the post flairs are enabled for this subreddit.
     */
    get postFlairsEnabled() {
        return this.settings.postFlairs.enabled;
    }
    /**
     * Whether the user can assign user flairs.
     * This is only true if the user flairs are enabled.
     */
    get usersCanAssignUserFlairs() {
        return this.settings.userFlairs.usersCanAssign;
    }
    /**
     * Whether the user can assign post flairs.
     * This is only true if the post flairs are enabled.
     */
    get usersCanAssignPostFlairs() {
        return this.settings.postFlairs.usersCanAssign;
    }
    toJSON() {
        return {
            id: this.id,
            name: this.name,
            createdAt: this.createdAt,
            type: this.type,
            title: this.title,
            description: this.description,
            language: this.language,
            nsfw: this.nsfw,
            numberOfSubscribers: this.numberOfSubscribers,
            numberOfActiveUsers: this.numberOfActiveUsers,
            settings: this.settings,
        };
    }
    async submitPost(options, metadata) {
        const submitPostOptions = {
            ...options,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
        };
        return Post.submit(submitPostOptions, metadata);
    }
    getControversialPosts(options = {}) {
        if (!__classPrivateFieldGet(this, _Subreddit_name, "f")) {
            throw new Error('subreddit missing displayName - it might not have been fetched');
        }
        return Post.getControversialPosts({
            ...options,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getTopPosts(options = {}) {
        if (!__classPrivateFieldGet(this, _Subreddit_name, "f")) {
            throw new Error('subreddit missing displayName - it might not have been fetched');
        }
        return Post.getTopPosts({
            ...options,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getApprovedUsers(options = {}) {
        return User.getSubredditUsersByType({
            type: 'contributors',
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    approveUser(username) {
        return User.createRelationship({
            username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'contributor',
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    removeUser(username) {
        return User.removeRelationship({
            username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'contributor',
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getWikiContributors(options = {}) {
        return User.getSubredditUsersByType({
            type: 'wikicontributors',
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    addWikiContributor(username) {
        return User.createRelationship({
            username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'wikicontributor',
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    removeWikiContributor(username) {
        return User.removeRelationship({
            username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'wikicontributor',
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getBannedUsers(options = {}) {
        return User.getSubredditUsersByType({
            type: 'banned',
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    banUser(options) {
        return User.createRelationship({
            username: options.username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'banned',
            banReason: options.reason,
            banMessage: options.message,
            note: options.note,
            duration: options.duration,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    unbanUser(username) {
        return User.removeRelationship({
            username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'banned',
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getBannedWikiContributors(options = {}) {
        return User.getSubredditUsersByType({
            type: 'wikibanned',
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    banWikiContributor(options) {
        return User.createRelationship({
            username: options.username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'wikibanned',
            banReason: options.reason,
            note: options.note,
            duration: options.duration,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    unbanWikiContributor(username) {
        return User.removeRelationship({
            username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'wikibanned',
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getModerators(options = {}) {
        return User.getSubredditUsersByType({
            type: 'moderators',
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    inviteModerator(username, permissions) {
        return User.createRelationship({
            type: 'moderator_invite',
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            username,
            permissions: permissions ?? [],
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    revokeModeratorInvite(username) {
        return User.removeRelationship({
            username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'moderator_invite',
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    removeModerator(username) {
        return User.removeRelationship({
            type: 'moderator',
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            username,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    setModeratorPermissions(username, permissions) {
        return User.setModeratorPermissions(username, __classPrivateFieldGet(this, _Subreddit_name, "f"), permissions, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getMutedUsers(options = {}) {
        return User.getSubredditUsersByType({
            type: 'muted',
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    muteUser(username, note) {
        return User.createRelationship({
            username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'muted',
            note,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    unmuteUser(username) {
        return User.removeRelationship({
            username,
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            type: 'muted',
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getModerationLog(options) {
        return getModerationLog({
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getUserFlairTemplates() {
        return FlairTemplate.getUserFlairTemplates(__classPrivateFieldGet(this, _Subreddit_name, "f"), __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getPostFlairTemplates() {
        return FlairTemplate.getPostFlairTemplates(__classPrivateFieldGet(this, _Subreddit_name, "f"), __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    createPostFlairTemplate(options) {
        return FlairTemplate.createPostFlairTemplate({
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    createUserFlairTemplate(options) {
        return FlairTemplate.createUserFlairTemplate({
            subredditName: __classPrivateFieldGet(this, _Subreddit_name, "f"),
            ...options,
        }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
    }
    getModQueue(options = { type: 'all' }) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Moderation);
        let only;
        switch (options.type) {
            case 'post':
                only = 'links';
                break;
            case 'comment':
                only = 'comments';
                break;
            default:
                only = undefined;
        }
        return new Listing({
            ...options,
            fetch: async (fetchOptions) => {
                const listing = await client.AboutLocation({
                    ...fetchOptions,
                    ...options,
                    location: 'modqueue',
                    subreddit: this.name,
                    only,
                }, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
                return parseListing(listing, __classPrivateFieldGet(this, _Subreddit_metadata, "f"));
            },
        });
    }
    static async getFromMetadata(metadata) {
        assertNonNull(metadata);
        const subredditId = getFromMetadata(Header.Subreddit, metadata);
        assertNonNull(subredditId);
        return Subreddit.getById(asT5ID(subredditId), metadata);
    }
    static async getById(id, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.LinksAndComments);
        const response = await client.Info({ thingIds: [id], subreddits: [] }, metadata);
        const subredditName = response.data?.children[0]?.data?.displayName;
        assertNonNull(subredditName);
        return Subreddit.getByName(subredditName, metadata);
    }
    static async getByName(subredditName, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Subreddits);
        const response = await client.SubredditAbout({
            subreddit: subredditName,
        }, metadata);
        if (!response?.data) {
            throw new Error('not found');
        }
        return new Subreddit(response.data, metadata);
    }
}
_Subreddit_id = new WeakMap(), _Subreddit_name = new WeakMap(), _Subreddit_createdAt = new WeakMap(), _Subreddit_type = new WeakMap(), _Subreddit_title = new WeakMap(), _Subreddit_description = new WeakMap(), _Subreddit_language = new WeakMap(), _Subreddit_numberOfSubscribers = new WeakMap(), _Subreddit_numberOfActiveUsers = new WeakMap(), _Subreddit_nsfw = new WeakMap(), _Subreddit_settings = new WeakMap(), _Subreddit_metadata = new WeakMap();
function asSubredditType(type) {
    if (type === 'public' ||
        type === 'private' ||
        type === 'restricted' ||
        type === 'employees_only' ||
        type === 'gold_restricted' ||
        type === 'archived') {
        return type;
    }
    throw new Error(`invalid subreddit type: ${type}`);
}
function asAllowedPostType(type) {
    if (type === 'any' || type === 'link' || type === 'self') {
        return type;
    }
    throw new Error(`invalid allowed post type: ${type}`);
}
function asCommentMediaTypes(type) {
    if (type === 'animated' || type === 'giphy' || type === 'static' || type === 'expression') {
        return type;
    }
    throw new Error(`invalid comment media type: ${type}`);
}
function parseListing(listing, metadata) {
    const children = listing.data?.children ?? [];
    const postsAndComments = children
        .map((child) => {
        const post = tryParseAsPost(child);
        if (post != null) {
            return post;
        }
        const comment = tryParseAsComment(child);
        if (comment != null) {
            return comment;
        }
        return null;
    })
        .filter(Boolean);
    return {
        after: listing.data?.after,
        before: listing.data?.before,
        children: postsAndComments,
    };
    function tryParseAsPost(obj) {
        try {
            return new Post(obj.data, metadata);
        }
        catch {
            return null;
        }
    }
    function tryParseAsComment(obj) {
        try {
            return new Comment(obj.data, metadata);
        }
        catch {
            return null;
        }
    }
}
