var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _User_id, _User_username, _User_createdAt, _User_linkKarma, _User_commentKarma, _User_nsfw, _User_modPermissionsBySubreddit, _User_metadata;
import { Devvit } from '../../abstractions/Devvit.js';
import { getFromMetadata } from '@devvit/runtimes/common/envelope/EnvelopeUtil.js';
import { Listing } from './Listing.js';
import { asModPermissions, formatModeratorPermissions } from '../helpers/permissions.js';
import { asT2ID } from '@devvit/shared-types/tid.js';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { Post } from './Post.js';
import { Comment } from './Comment.js';
/**
 * A class representing a user.
 */
export class User {
    /**
     * @hidden
     */
    constructor(data, metadata) {
        _User_id.set(this, void 0);
        _User_username.set(this, void 0);
        _User_createdAt.set(this, void 0);
        _User_linkKarma.set(this, void 0);
        _User_commentKarma.set(this, void 0);
        _User_nsfw.set(this, void 0);
        _User_modPermissionsBySubreddit.set(this, new Map());
        _User_metadata.set(this, void 0);
        assertNonNull(data.id, 'User ID is missing or undefined');
        assertNonNull(data.name, 'Username is missing or undefined');
        assertNonNull(data.createdUtc, 'User is missing created date');
        // UserDataByAccountIds returns the ID without the t2_ prefix
        __classPrivateFieldSet(this, _User_id, asT2ID(data.id.startsWith('t2_') ? data.id : `t2_${data.id}`), "f");
        __classPrivateFieldSet(this, _User_username, data.name, "f");
        __classPrivateFieldSet(this, _User_nsfw, data.over18 ?? false, "f");
        const createdAt = new Date(0);
        createdAt.setUTCSeconds(data.createdUtc);
        __classPrivateFieldSet(this, _User_createdAt, createdAt, "f");
        __classPrivateFieldSet(this, _User_linkKarma, data.linkKarma ?? 0, "f");
        __classPrivateFieldSet(this, _User_commentKarma, data.commentKarma ?? 0, "f");
        if (data.modPermissions) {
            for (const [subredditName, permissions] of Object.entries(data.modPermissions)) {
                __classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f").set(subredditName, permissions.map(asModPermissions));
            }
        }
        __classPrivateFieldSet(this, _User_metadata, metadata, "f");
    }
    /**
     * The ID (starting with t2_) of the user to retrieve.
     * @example 't2_1w72'
     */
    get id() {
        return __classPrivateFieldGet(this, _User_id, "f");
    }
    /**
     * The username of the user omitting the u/.
     * @example 'spez'
     */
    get username() {
        return __classPrivateFieldGet(this, _User_username, "f");
    }
    /**
     * The date the user was created.
     */
    get createdAt() {
        return __classPrivateFieldGet(this, _User_createdAt, "f");
    }
    /**
     * The amount of link karma the user has.
     */
    get linkKarma() {
        return __classPrivateFieldGet(this, _User_linkKarma, "f");
    }
    /**
     * The amount of comment karma the user has.
     */
    get commentKarma() {
        return __classPrivateFieldGet(this, _User_commentKarma, "f");
    }
    /**
     * Whether the user's profile is marked as NSFW (Not Safe For Work).
     */
    get nsfw() {
        return __classPrivateFieldGet(this, _User_nsfw, "f");
    }
    /**
     * The permissions the user has on the subreddit.
     */
    get modPermissions() {
        return __classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f");
    }
    toJSON() {
        return {
            id: this.id,
            username: this.username,
            createdAt: this.createdAt,
            linkKarma: this.linkKarma,
            commentKarma: this.commentKarma,
            nsfw: this.nsfw,
            modPermissionsBySubreddit: Object.fromEntries(this.modPermissions),
        };
    }
    /**
     * Get the mod permissions the user has on the subreddit if they are a moderator.
     *
     * @param subredditName - name of the subreddit
     * @returns the moderator permissions the user has on the subreddit
     */
    async getModPermissionsForSubreddit(subredditName) {
        if (__classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f").has(subredditName)) {
            return __classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f").get(subredditName);
        }
        const mods = await User.getSubredditUsersByType({
            subredditName,
            type: 'moderators',
            username: this.username,
        }, __classPrivateFieldGet(this, _User_metadata, "f")).all();
        if (mods.length === 0) {
            return [];
        }
        const permissions = mods[0].modPermissions.get(subredditName) ?? [];
        if (permissions.length > 0) {
            __classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f").set(subredditName, permissions);
        }
        return permissions;
    }
    /**
     * Get the user's comments.
     *
     * @param options - Options for the request
     * @param options.sort - The sort order of the comments. e.g. 'new'
     * @param options.timeframe - The timeframe of the comments. e.g. 'all'
     * @param options.limit - The maximum number of comments to return. e.g. 1000
     * @param options.pageSize - The number of comments to return per request. e.g. 100
     * @returns A Listing of Comment objects.
     */
    getComments(options) {
        return Comment.getCommentsByUser({
            username: this.username,
            ...options,
        }, __classPrivateFieldGet(this, _User_metadata, "f"));
    }
    /**
     * Get the user's posts.
     *
     * @param options - Options for the request
     * @param options.sort - The sort order of the posts. e.g. 'new'
     * @param options.timeframe - The timeframe of the posts. e.g. 'all'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     */
    getPosts(options) {
        return Post.getPostsByUser({
            username: this.username,
            ...options,
        }, __classPrivateFieldGet(this, _User_metadata, "f"));
    }
    static async getById(id, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Users);
        const response = await client.UserDataByAccountIds({ ids: id }, metadata);
        const username = response?.users?.[id]?.name;
        assertNonNull(username, 'Expected the username in response to be not null');
        return User.getByUsername(username, metadata);
    }
    static async getByUsername(username, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Users);
        const response = await client.UserAbout({
            username,
        }, metadata);
        if (!response.data?.id) {
            throw new Error('failed to get user');
        }
        return new User(response.data, metadata);
    }
    static async getFromMetadata(key, metadata) {
        assertNonNull(metadata);
        const userId = getFromMetadata(key, metadata);
        assertNonNull(userId);
        return User.getById(asT2ID(userId), metadata);
    }
    static getSubredditUsersByType(options, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Subreddits);
        return new Listing({
            hasMore: true,
            pageSize: options.pageSize,
            limit: options.limit,
            after: options.after,
            before: options.before,
            fetch: async (fetchOptions) => {
                const response = await client.AboutWhere({
                    where: options.type,
                    user: options.username,
                    subreddit: options.subredditName,
                    show: 'all',
                    ...fetchOptions,
                }, metadata);
                return listingProtosToUsers(response, options.subredditName, metadata);
            },
        });
    }
    static async createRelationship(options, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Users);
        const { type, subredditName, username, permissions, ...optionalFields } = options;
        const response = await client.Friend({
            type,
            subreddit: subredditName,
            name: username,
            permissions: permissions ? formatModeratorPermissions(permissions) : undefined,
            ...optionalFields,
        }, metadata);
        if (response.json?.errors?.length) {
            throw new Error(response.json.errors.join('\n'));
        }
    }
    static async removeRelationship(options, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Users);
        await client.Unfriend({
            type: options.type,
            subreddit: options.subredditName,
            name: options.username,
        }, metadata);
    }
    static async setModeratorPermissions(username, subredditName, permissions, metadata) {
        const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Users);
        const response = await client.SetPermissions({
            subreddit: subredditName,
            name: username,
            type: 'moderator',
            permissions: formatModeratorPermissions(permissions),
        }, metadata);
        if (response.json?.errors?.length) {
            throw new Error(response.json.errors.join('\n'));
        }
    }
}
_User_id = new WeakMap(), _User_username = new WeakMap(), _User_createdAt = new WeakMap(), _User_linkKarma = new WeakMap(), _User_commentKarma = new WeakMap(), _User_nsfw = new WeakMap(), _User_modPermissionsBySubreddit = new WeakMap(), _User_metadata = new WeakMap();
async function listingProtosToUsers(listingProto, subredditName, metadata) {
    const client = Devvit.getApiClient(Devvit.Types.RedditAPI.Users);
    if (!listingProto.data?.children) {
        throw new Error('Listing response is missing children');
    }
    const userIds = listingProto.data.children.map((child) => {
        assertNonNull(child.data?.id, 'User id is still from listing data');
        return child.data.id;
    });
    // break the ids into chunks since they're passed over a query parameter
    const chunkSize = 100;
    const userIdChunks = [];
    for (let i = 0; i < userIds.length; i += chunkSize) {
        userIdChunks.push(userIds.slice(i, i + chunkSize));
    }
    // perform the requests
    const usersMapResponses = await Promise.all(userIdChunks.map((userIds) => client.UserDataByAccountIds({
        ids: userIds.join(','),
    }, metadata)));
    // join the responses back into a single map of user data
    const userDataById = usersMapResponses.reduce((allUsers, response) => ({ ...allUsers, ...response.users }), {});
    const children = listingProto.data.children.map((child) => {
        const id = child.data?.id;
        assertNonNull(id, 'User id is missing from listing');
        const userData = userDataById[id];
        // Casting to unknown because Typescript assumes that userData is always defined
        // because of how we defined the UserDataByAccountIdsResponse_UserAccountData protobuf.
        assertNonNull(userData, 'User data is missing from response');
        return new User({
            id,
            name: userData.name,
            linkKarma: userData.linkKarma,
            commentKarma: userData.commentKarma,
            createdUtc: userData.createdUtc,
            over18: userData.profileOver18,
            snoovatarSize: [],
            modPermissions: {
                [subredditName]: child.data?.modPermissions ?? [],
            },
        }, metadata);
    });
    return {
        children,
        before: listingProto.data.before,
        after: listingProto.data.after,
    };
}
