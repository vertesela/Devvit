/**
 * #widgets_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int32Value, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { AuthorFlairRichText } from '../../../reddit/common.js';
function createBaseWidgetStyles() {
    return { backgroundColor: undefined, headerColor: undefined };
}
export const WidgetStyles = {
    $type: "devvit.plugin.redditapi.widgets.WidgetStyles",
    encode(message, writer = _m0.Writer.create()) {
        if (message.backgroundColor !== undefined) {
            StringValue.encode({ value: message.backgroundColor }, writer.uint32(10).fork()).ldelim();
        }
        if (message.headerColor !== undefined) {
            StringValue.encode({ value: message.headerColor }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWidgetStyles();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.backgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.headerColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            backgroundColor: isSet(object.backgroundColor) ? String(object.backgroundColor) : undefined,
            headerColor: isSet(object.headerColor) ? String(object.headerColor) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.backgroundColor !== undefined && (obj.backgroundColor = message.backgroundColor);
        message.headerColor !== undefined && (obj.headerColor = message.headerColor);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWidgetStyles();
        message.backgroundColor = object.backgroundColor ?? undefined;
        message.headerColor = object.headerColor ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.WidgetStyles", WidgetStyles);
function createBaseWidgetImage() {
    return { url: "", linkUrl: "", height: 0, width: 0 };
}
export const WidgetImage = {
    $type: "devvit.plugin.redditapi.widgets.WidgetImage",
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        if (message.linkUrl !== "") {
            writer.uint32(18).string(message.linkUrl);
        }
        if (message.height !== 0) {
            writer.uint32(24).int32(message.height);
        }
        if (message.width !== 0) {
            writer.uint32(32).int32(message.width);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWidgetImage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.linkUrl = reader.string();
                    break;
                case 3:
                    message.height = reader.int32();
                    break;
                case 4:
                    message.width = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            url: isSet(object.url) ? String(object.url) : "",
            linkUrl: isSet(object.linkUrl) ? String(object.linkUrl) : "",
            height: isSet(object.height) ? Number(object.height) : 0,
            width: isSet(object.width) ? Number(object.width) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        message.linkUrl !== undefined && (obj.linkUrl = message.linkUrl);
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.width !== undefined && (obj.width = Math.round(message.width));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWidgetImage();
        message.url = object.url ?? "";
        message.linkUrl = object.linkUrl ?? "";
        message.height = object.height ?? 0;
        message.width = object.width ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.WidgetImage", WidgetImage);
function createBaseImageWidget() {
    return { id: "", kind: "", data: [], shortName: "", styles: undefined, subreddit: undefined };
}
export const ImageWidget = {
    $type: "devvit.plugin.redditapi.widgets.ImageWidget",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== "") {
            writer.uint32(18).string(message.kind);
        }
        for (const v of message.data) {
            WidgetImage.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.shortName !== "") {
            writer.uint32(34).string(message.shortName);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseImageWidget();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.data.push(WidgetImage.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.shortName = reader.string();
                    break;
                case 5:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: Array.isArray(object?.data) ? object.data.map((e) => WidgetImage.fromJSON(e)) : [],
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.kind !== undefined && (obj.kind = message.kind);
        if (message.data) {
            obj.data = message.data.map((e) => e ? WidgetImage.toJSON(e) : undefined);
        }
        else {
            obj.data = [];
        }
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseImageWidget();
        message.id = object.id ?? "";
        message.kind = object.kind ?? "";
        message.data = object.data?.map((e) => WidgetImage.fromPartial(e)) || [];
        message.shortName = object.shortName ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        message.subreddit = object.subreddit ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.ImageWidget", ImageWidget);
function createBaseAddImageWidgetRequest() {
    return { subreddit: "", data: [], shortName: "", styles: undefined };
}
export const AddImageWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.AddImageWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        for (const v of message.data) {
            WidgetImage.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.shortName !== "") {
            writer.uint32(26).string(message.shortName);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddImageWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.data.push(WidgetImage.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.shortName = reader.string();
                    break;
                case 4:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            data: Array.isArray(object?.data) ? object.data.map((e) => WidgetImage.fromJSON(e)) : [],
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        if (message.data) {
            obj.data = message.data.map((e) => e ? WidgetImage.toJSON(e) : undefined);
        }
        else {
            obj.data = [];
        }
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAddImageWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.data = object.data?.map((e) => WidgetImage.fromPartial(e)) || [];
        message.shortName = object.shortName ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddImageWidgetRequest", AddImageWidgetRequest);
function createBaseUpdateImageWidgetRequest() {
    return { subreddit: "", id: "", data: [], shortName: "", styles: undefined };
}
export const UpdateImageWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.UpdateImageWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        for (const v of message.data) {
            WidgetImage.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.shortName !== "") {
            writer.uint32(34).string(message.shortName);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateImageWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.data.push(WidgetImage.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.shortName = reader.string();
                    break;
                case 5:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            id: isSet(object.id) ? String(object.id) : "",
            data: Array.isArray(object?.data) ? object.data.map((e) => WidgetImage.fromJSON(e)) : [],
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.id !== undefined && (obj.id = message.id);
        if (message.data) {
            obj.data = message.data.map((e) => e ? WidgetImage.toJSON(e) : undefined);
        }
        else {
            obj.data = [];
        }
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateImageWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.id = object.id ?? "";
        message.data = object.data?.map((e) => WidgetImage.fromPartial(e)) || [];
        message.shortName = object.shortName ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateImageWidgetRequest", UpdateImageWidgetRequest);
function createBaseCalendarWidgetConfiguration() {
    return {
        numEvents: 0,
        showDate: false,
        showDescription: false,
        showLocation: false,
        showTime: false,
        showTitle: false,
    };
}
export const CalendarWidgetConfiguration = {
    $type: "devvit.plugin.redditapi.widgets.CalendarWidgetConfiguration",
    encode(message, writer = _m0.Writer.create()) {
        if (message.numEvents !== 0) {
            writer.uint32(8).int32(message.numEvents);
        }
        if (message.showDate === true) {
            writer.uint32(16).bool(message.showDate);
        }
        if (message.showDescription === true) {
            writer.uint32(24).bool(message.showDescription);
        }
        if (message.showLocation === true) {
            writer.uint32(32).bool(message.showLocation);
        }
        if (message.showTime === true) {
            writer.uint32(40).bool(message.showTime);
        }
        if (message.showTitle === true) {
            writer.uint32(48).bool(message.showTitle);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCalendarWidgetConfiguration();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.numEvents = reader.int32();
                    break;
                case 2:
                    message.showDate = reader.bool();
                    break;
                case 3:
                    message.showDescription = reader.bool();
                    break;
                case 4:
                    message.showLocation = reader.bool();
                    break;
                case 5:
                    message.showTime = reader.bool();
                    break;
                case 6:
                    message.showTitle = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            numEvents: isSet(object.numEvents) ? Number(object.numEvents) : 0,
            showDate: isSet(object.showDate) ? Boolean(object.showDate) : false,
            showDescription: isSet(object.showDescription) ? Boolean(object.showDescription) : false,
            showLocation: isSet(object.showLocation) ? Boolean(object.showLocation) : false,
            showTime: isSet(object.showTime) ? Boolean(object.showTime) : false,
            showTitle: isSet(object.showTitle) ? Boolean(object.showTitle) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.numEvents !== undefined && (obj.numEvents = Math.round(message.numEvents));
        message.showDate !== undefined && (obj.showDate = message.showDate);
        message.showDescription !== undefined && (obj.showDescription = message.showDescription);
        message.showLocation !== undefined && (obj.showLocation = message.showLocation);
        message.showTime !== undefined && (obj.showTime = message.showTime);
        message.showTitle !== undefined && (obj.showTitle = message.showTitle);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCalendarWidgetConfiguration();
        message.numEvents = object.numEvents ?? 0;
        message.showDate = object.showDate ?? false;
        message.showDescription = object.showDescription ?? false;
        message.showLocation = object.showLocation ?? false;
        message.showTime = object.showTime ?? false;
        message.showTitle = object.showTitle ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CalendarWidgetConfiguration", CalendarWidgetConfiguration);
function createBaseCalendarWidget() {
    return {
        id: "",
        kind: "",
        configuration: undefined,
        googleCalendarId: "",
        requiresSync: false,
        shortName: "",
        styles: undefined,
    };
}
export const CalendarWidget = {
    $type: "devvit.plugin.redditapi.widgets.CalendarWidget",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== "") {
            writer.uint32(18).string(message.kind);
        }
        if (message.configuration !== undefined) {
            CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(26).fork()).ldelim();
        }
        if (message.googleCalendarId !== "") {
            writer.uint32(34).string(message.googleCalendarId);
        }
        if (message.requiresSync === true) {
            writer.uint32(40).bool(message.requiresSync);
        }
        if (message.shortName !== "") {
            writer.uint32(50).string(message.shortName);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCalendarWidget();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.googleCalendarId = reader.string();
                    break;
                case 5:
                    message.requiresSync = reader.bool();
                    break;
                case 6:
                    message.shortName = reader.string();
                    break;
                case 7:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            kind: isSet(object.kind) ? String(object.kind) : "",
            configuration: isSet(object.configuration)
                ? CalendarWidgetConfiguration.fromJSON(object.configuration)
                : undefined,
            googleCalendarId: isSet(object.googleCalendarId) ? String(object.googleCalendarId) : "",
            requiresSync: isSet(object.requiresSync) ? Boolean(object.requiresSync) : false,
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.kind !== undefined && (obj.kind = message.kind);
        message.configuration !== undefined &&
            (obj.configuration = message.configuration
                ? CalendarWidgetConfiguration.toJSON(message.configuration)
                : undefined);
        message.googleCalendarId !== undefined && (obj.googleCalendarId = message.googleCalendarId);
        message.requiresSync !== undefined && (obj.requiresSync = message.requiresSync);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCalendarWidget();
        message.id = object.id ?? "";
        message.kind = object.kind ?? "";
        message.configuration = (object.configuration !== undefined && object.configuration !== null)
            ? CalendarWidgetConfiguration.fromPartial(object.configuration)
            : undefined;
        message.googleCalendarId = object.googleCalendarId ?? "";
        message.requiresSync = object.requiresSync ?? false;
        message.shortName = object.shortName ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CalendarWidget", CalendarWidget);
function createBaseAddCalendarWidgetRequest() {
    return {
        subreddit: "",
        configuration: undefined,
        googleCalendarId: "",
        requiresSync: false,
        shortName: "",
        styles: undefined,
    };
}
export const AddCalendarWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.AddCalendarWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.configuration !== undefined) {
            CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(18).fork()).ldelim();
        }
        if (message.googleCalendarId !== "") {
            writer.uint32(26).string(message.googleCalendarId);
        }
        if (message.requiresSync === true) {
            writer.uint32(32).bool(message.requiresSync);
        }
        if (message.shortName !== "") {
            writer.uint32(42).string(message.shortName);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddCalendarWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.googleCalendarId = reader.string();
                    break;
                case 4:
                    message.requiresSync = reader.bool();
                    break;
                case 5:
                    message.shortName = reader.string();
                    break;
                case 6:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            configuration: isSet(object.configuration)
                ? CalendarWidgetConfiguration.fromJSON(object.configuration)
                : undefined,
            googleCalendarId: isSet(object.googleCalendarId) ? String(object.googleCalendarId) : "",
            requiresSync: isSet(object.requiresSync) ? Boolean(object.requiresSync) : false,
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.configuration !== undefined &&
            (obj.configuration = message.configuration
                ? CalendarWidgetConfiguration.toJSON(message.configuration)
                : undefined);
        message.googleCalendarId !== undefined && (obj.googleCalendarId = message.googleCalendarId);
        message.requiresSync !== undefined && (obj.requiresSync = message.requiresSync);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAddCalendarWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.configuration = (object.configuration !== undefined && object.configuration !== null)
            ? CalendarWidgetConfiguration.fromPartial(object.configuration)
            : undefined;
        message.googleCalendarId = object.googleCalendarId ?? "";
        message.requiresSync = object.requiresSync ?? false;
        message.shortName = object.shortName ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddCalendarWidgetRequest", AddCalendarWidgetRequest);
function createBaseUpdateCalendarWidgetRequest() {
    return {
        subreddit: "",
        id: "",
        configuration: undefined,
        googleCalendarId: "",
        requiresSync: false,
        shortName: "",
        styles: undefined,
    };
}
export const UpdateCalendarWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.UpdateCalendarWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.configuration !== undefined) {
            CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(26).fork()).ldelim();
        }
        if (message.googleCalendarId !== "") {
            writer.uint32(34).string(message.googleCalendarId);
        }
        if (message.requiresSync === true) {
            writer.uint32(40).bool(message.requiresSync);
        }
        if (message.shortName !== "") {
            writer.uint32(50).string(message.shortName);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCalendarWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.googleCalendarId = reader.string();
                    break;
                case 5:
                    message.requiresSync = reader.bool();
                    break;
                case 6:
                    message.shortName = reader.string();
                    break;
                case 7:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            id: isSet(object.id) ? String(object.id) : "",
            configuration: isSet(object.configuration)
                ? CalendarWidgetConfiguration.fromJSON(object.configuration)
                : undefined,
            googleCalendarId: isSet(object.googleCalendarId) ? String(object.googleCalendarId) : "",
            requiresSync: isSet(object.requiresSync) ? Boolean(object.requiresSync) : false,
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.id !== undefined && (obj.id = message.id);
        message.configuration !== undefined &&
            (obj.configuration = message.configuration
                ? CalendarWidgetConfiguration.toJSON(message.configuration)
                : undefined);
        message.googleCalendarId !== undefined && (obj.googleCalendarId = message.googleCalendarId);
        message.requiresSync !== undefined && (obj.requiresSync = message.requiresSync);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateCalendarWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.id = object.id ?? "";
        message.configuration = (object.configuration !== undefined && object.configuration !== null)
            ? CalendarWidgetConfiguration.fromPartial(object.configuration)
            : undefined;
        message.googleCalendarId = object.googleCalendarId ?? "";
        message.requiresSync = object.requiresSync ?? false;
        message.shortName = object.shortName ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateCalendarWidgetRequest", UpdateCalendarWidgetRequest);
function createBaseTextAreaWidget() {
    return { id: "", kind: "", shortName: "", text: "", styles: undefined };
}
export const TextAreaWidget = {
    $type: "devvit.plugin.redditapi.widgets.TextAreaWidget",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== "") {
            writer.uint32(18).string(message.kind);
        }
        if (message.shortName !== "") {
            writer.uint32(26).string(message.shortName);
        }
        if (message.text !== "") {
            writer.uint32(34).string(message.text);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTextAreaWidget();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.shortName = reader.string();
                    break;
                case 4:
                    message.text = reader.string();
                    break;
                case 5:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            kind: isSet(object.kind) ? String(object.kind) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            text: isSet(object.text) ? String(object.text) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.kind !== undefined && (obj.kind = message.kind);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.text !== undefined && (obj.text = message.text);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseTextAreaWidget();
        message.id = object.id ?? "";
        message.kind = object.kind ?? "";
        message.shortName = object.shortName ?? "";
        message.text = object.text ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.TextAreaWidget", TextAreaWidget);
function createBaseAddTextAreaWidgetRequest() {
    return { subreddit: "", shortName: "", text: "", styles: undefined };
}
export const AddTextAreaWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.AddTextAreaWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.shortName !== "") {
            writer.uint32(18).string(message.shortName);
        }
        if (message.text !== "") {
            writer.uint32(26).string(message.text);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddTextAreaWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.shortName = reader.string();
                    break;
                case 3:
                    message.text = reader.string();
                    break;
                case 4:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            text: isSet(object.text) ? String(object.text) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.text !== undefined && (obj.text = message.text);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAddTextAreaWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.shortName = object.shortName ?? "";
        message.text = object.text ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddTextAreaWidgetRequest", AddTextAreaWidgetRequest);
function createBaseUpdateTextAreaWidgetRequest() {
    return { subreddit: "", id: "", shortName: "", text: "", styles: undefined };
}
export const UpdateTextAreaWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.UpdateTextAreaWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.shortName !== "") {
            writer.uint32(26).string(message.shortName);
        }
        if (message.text !== "") {
            writer.uint32(34).string(message.text);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateTextAreaWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.shortName = reader.string();
                    break;
                case 4:
                    message.text = reader.string();
                    break;
                case 5:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            id: isSet(object.id) ? String(object.id) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            text: isSet(object.text) ? String(object.text) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.id !== undefined && (obj.id = message.id);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.text !== undefined && (obj.text = message.text);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateTextAreaWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.id = object.id ?? "";
        message.shortName = object.shortName ?? "";
        message.text = object.text ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateTextAreaWidgetRequest", UpdateTextAreaWidgetRequest);
function createBaseWidgetButton() {
    return {
        kind: "",
        text: "",
        url: undefined,
        imageUrl: undefined,
        linkUrl: undefined,
        color: undefined,
        fillColor: undefined,
        textColor: undefined,
        height: undefined,
        width: undefined,
        hoverState: undefined,
    };
}
export const WidgetButton = {
    $type: "devvit.plugin.redditapi.widgets.WidgetButton",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.text !== "") {
            writer.uint32(18).string(message.text);
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
        }
        if (message.imageUrl !== undefined) {
            StringValue.encode({ value: message.imageUrl }, writer.uint32(34).fork()).ldelim();
        }
        if (message.linkUrl !== undefined) {
            StringValue.encode({ value: message.linkUrl }, writer.uint32(42).fork()).ldelim();
        }
        if (message.color !== undefined) {
            StringValue.encode({ value: message.color }, writer.uint32(50).fork()).ldelim();
        }
        if (message.fillColor !== undefined) {
            StringValue.encode({ value: message.fillColor }, writer.uint32(58).fork()).ldelim();
        }
        if (message.textColor !== undefined) {
            StringValue.encode({ value: message.textColor }, writer.uint32(66).fork()).ldelim();
        }
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(74).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(82).fork()).ldelim();
        }
        if (message.hoverState !== undefined) {
            WidgetButton_HoverState.encode(message.hoverState, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWidgetButton();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.imageUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.linkUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.color = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.fillColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.textColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.hoverState = WidgetButton_HoverState.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            text: isSet(object.text) ? String(object.text) : "",
            url: isSet(object.url) ? String(object.url) : undefined,
            imageUrl: isSet(object.imageUrl) ? String(object.imageUrl) : undefined,
            linkUrl: isSet(object.linkUrl) ? String(object.linkUrl) : undefined,
            color: isSet(object.color) ? String(object.color) : undefined,
            fillColor: isSet(object.fillColor) ? String(object.fillColor) : undefined,
            textColor: isSet(object.textColor) ? String(object.textColor) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
            hoverState: isSet(object.hoverState) ? WidgetButton_HoverState.fromJSON(object.hoverState) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.text !== undefined && (obj.text = message.text);
        message.url !== undefined && (obj.url = message.url);
        message.imageUrl !== undefined && (obj.imageUrl = message.imageUrl);
        message.linkUrl !== undefined && (obj.linkUrl = message.linkUrl);
        message.color !== undefined && (obj.color = message.color);
        message.fillColor !== undefined && (obj.fillColor = message.fillColor);
        message.textColor !== undefined && (obj.textColor = message.textColor);
        message.height !== undefined && (obj.height = message.height);
        message.width !== undefined && (obj.width = message.width);
        message.hoverState !== undefined &&
            (obj.hoverState = message.hoverState ? WidgetButton_HoverState.toJSON(message.hoverState) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWidgetButton();
        message.kind = object.kind ?? "";
        message.text = object.text ?? "";
        message.url = object.url ?? undefined;
        message.imageUrl = object.imageUrl ?? undefined;
        message.linkUrl = object.linkUrl ?? undefined;
        message.color = object.color ?? undefined;
        message.fillColor = object.fillColor ?? undefined;
        message.textColor = object.textColor ?? undefined;
        message.height = object.height ?? undefined;
        message.width = object.width ?? undefined;
        message.hoverState = (object.hoverState !== undefined && object.hoverState !== null)
            ? WidgetButton_HoverState.fromPartial(object.hoverState)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.WidgetButton", WidgetButton);
function createBaseWidgetButton_HoverState() {
    return {
        kind: "",
        color: undefined,
        fillColor: undefined,
        text: undefined,
        textColor: undefined,
        imageUrl: undefined,
        height: undefined,
        width: undefined,
    };
}
export const WidgetButton_HoverState = {
    $type: "devvit.plugin.redditapi.widgets.WidgetButton.HoverState",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.color !== undefined) {
            StringValue.encode({ value: message.color }, writer.uint32(18).fork()).ldelim();
        }
        if (message.fillColor !== undefined) {
            StringValue.encode({ value: message.fillColor }, writer.uint32(26).fork()).ldelim();
        }
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(34).fork()).ldelim();
        }
        if (message.textColor !== undefined) {
            StringValue.encode({ value: message.textColor }, writer.uint32(42).fork()).ldelim();
        }
        if (message.imageUrl !== undefined) {
            StringValue.encode({ value: message.imageUrl }, writer.uint32(50).fork()).ldelim();
        }
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(58).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWidgetButton_HoverState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.color = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.fillColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.textColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.imageUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            color: isSet(object.color) ? String(object.color) : undefined,
            fillColor: isSet(object.fillColor) ? String(object.fillColor) : undefined,
            text: isSet(object.text) ? String(object.text) : undefined,
            textColor: isSet(object.textColor) ? String(object.textColor) : undefined,
            imageUrl: isSet(object.imageUrl) ? String(object.imageUrl) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.color !== undefined && (obj.color = message.color);
        message.fillColor !== undefined && (obj.fillColor = message.fillColor);
        message.text !== undefined && (obj.text = message.text);
        message.textColor !== undefined && (obj.textColor = message.textColor);
        message.imageUrl !== undefined && (obj.imageUrl = message.imageUrl);
        message.height !== undefined && (obj.height = message.height);
        message.width !== undefined && (obj.width = message.width);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWidgetButton_HoverState();
        message.kind = object.kind ?? "";
        message.color = object.color ?? undefined;
        message.fillColor = object.fillColor ?? undefined;
        message.text = object.text ?? undefined;
        message.textColor = object.textColor ?? undefined;
        message.imageUrl = object.imageUrl ?? undefined;
        message.height = object.height ?? undefined;
        message.width = object.width ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.WidgetButton.HoverState", WidgetButton_HoverState);
function createBaseButtonWidget() {
    return { id: "", kind: "", shortName: "", description: "", buttons: [], styles: undefined };
}
export const ButtonWidget = {
    $type: "devvit.plugin.redditapi.widgets.ButtonWidget",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== "") {
            writer.uint32(18).string(message.kind);
        }
        if (message.shortName !== "") {
            writer.uint32(26).string(message.shortName);
        }
        if (message.description !== "") {
            writer.uint32(34).string(message.description);
        }
        for (const v of message.buttons) {
            WidgetButton.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseButtonWidget();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.shortName = reader.string();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            kind: isSet(object.kind) ? String(object.kind) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            description: isSet(object.description) ? String(object.description) : "",
            buttons: Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.kind !== undefined && (obj.kind = message.kind);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.description !== undefined && (obj.description = message.description);
        if (message.buttons) {
            obj.buttons = message.buttons.map((e) => e ? WidgetButton.toJSON(e) : undefined);
        }
        else {
            obj.buttons = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseButtonWidget();
        message.id = object.id ?? "";
        message.kind = object.kind ?? "";
        message.shortName = object.shortName ?? "";
        message.description = object.description ?? "";
        message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.ButtonWidget", ButtonWidget);
function createBaseAddButtonWidgetRequest() {
    return { subreddit: "", shortName: "", description: "", buttons: [], styles: undefined };
}
export const AddButtonWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.AddButtonWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.shortName !== "") {
            writer.uint32(18).string(message.shortName);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        for (const v of message.buttons) {
            WidgetButton.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddButtonWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.shortName = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            description: isSet(object.description) ? String(object.description) : "",
            buttons: Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.description !== undefined && (obj.description = message.description);
        if (message.buttons) {
            obj.buttons = message.buttons.map((e) => e ? WidgetButton.toJSON(e) : undefined);
        }
        else {
            obj.buttons = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAddButtonWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.shortName = object.shortName ?? "";
        message.description = object.description ?? "";
        message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddButtonWidgetRequest", AddButtonWidgetRequest);
function createBaseUpdateButtonWidgetRequest() {
    return { subreddit: "", id: "", shortName: "", description: "", buttons: [], styles: undefined };
}
export const UpdateButtonWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.UpdateButtonWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.shortName !== "") {
            writer.uint32(26).string(message.shortName);
        }
        if (message.description !== "") {
            writer.uint32(34).string(message.description);
        }
        for (const v of message.buttons) {
            WidgetButton.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateButtonWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.shortName = reader.string();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            id: isSet(object.id) ? String(object.id) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            description: isSet(object.description) ? String(object.description) : "",
            buttons: Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.id !== undefined && (obj.id = message.id);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.description !== undefined && (obj.description = message.description);
        if (message.buttons) {
            obj.buttons = message.buttons.map((e) => e ? WidgetButton.toJSON(e) : undefined);
        }
        else {
            obj.buttons = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateButtonWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.id = object.id ?? "";
        message.shortName = object.shortName ?? "";
        message.description = object.description ?? "";
        message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateButtonWidgetRequest", UpdateButtonWidgetRequest);
function createBaseCommunityListWidget() {
    return { id: "", kind: "", shortName: "", data: [], styles: undefined };
}
export const CommunityListWidget = {
    $type: "devvit.plugin.redditapi.widgets.CommunityListWidget",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== "") {
            writer.uint32(18).string(message.kind);
        }
        if (message.shortName !== "") {
            writer.uint32(26).string(message.shortName);
        }
        for (const v of message.data) {
            CommunityListWidget_CommunityData.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommunityListWidget();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.shortName = reader.string();
                    break;
                case 4:
                    message.data.push(CommunityListWidget_CommunityData.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            kind: isSet(object.kind) ? String(object.kind) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            data: Array.isArray(object?.data)
                ? object.data.map((e) => CommunityListWidget_CommunityData.fromJSON(e))
                : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.kind !== undefined && (obj.kind = message.kind);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        if (message.data) {
            obj.data = message.data.map((e) => e ? CommunityListWidget_CommunityData.toJSON(e) : undefined);
        }
        else {
            obj.data = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCommunityListWidget();
        message.id = object.id ?? "";
        message.kind = object.kind ?? "";
        message.shortName = object.shortName ?? "";
        message.data = object.data?.map((e) => CommunityListWidget_CommunityData.fromPartial(e)) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CommunityListWidget", CommunityListWidget);
function createBaseCommunityListWidget_CommunityData() {
    return {
        communityIcon: "",
        iconUrl: "",
        isNsfw: false,
        isSubscribed: false,
        name: "",
        prefixedName: "",
        primaryColor: "",
        subscribers: 0,
        type: "",
    };
}
export const CommunityListWidget_CommunityData = {
    $type: "devvit.plugin.redditapi.widgets.CommunityListWidget.CommunityData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.communityIcon !== "") {
            writer.uint32(10).string(message.communityIcon);
        }
        if (message.iconUrl !== "") {
            writer.uint32(18).string(message.iconUrl);
        }
        if (message.isNsfw === true) {
            writer.uint32(24).bool(message.isNsfw);
        }
        if (message.isSubscribed === true) {
            writer.uint32(32).bool(message.isSubscribed);
        }
        if (message.name !== "") {
            writer.uint32(42).string(message.name);
        }
        if (message.prefixedName !== "") {
            writer.uint32(50).string(message.prefixedName);
        }
        if (message.primaryColor !== "") {
            writer.uint32(58).string(message.primaryColor);
        }
        if (message.subscribers !== 0) {
            writer.uint32(64).int32(message.subscribers);
        }
        if (message.type !== "") {
            writer.uint32(74).string(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommunityListWidget_CommunityData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.communityIcon = reader.string();
                    break;
                case 2:
                    message.iconUrl = reader.string();
                    break;
                case 3:
                    message.isNsfw = reader.bool();
                    break;
                case 4:
                    message.isSubscribed = reader.bool();
                    break;
                case 5:
                    message.name = reader.string();
                    break;
                case 6:
                    message.prefixedName = reader.string();
                    break;
                case 7:
                    message.primaryColor = reader.string();
                    break;
                case 8:
                    message.subscribers = reader.int32();
                    break;
                case 9:
                    message.type = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            communityIcon: isSet(object.communityIcon) ? String(object.communityIcon) : "",
            iconUrl: isSet(object.iconUrl) ? String(object.iconUrl) : "",
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : false,
            isSubscribed: isSet(object.isSubscribed) ? Boolean(object.isSubscribed) : false,
            name: isSet(object.name) ? String(object.name) : "",
            prefixedName: isSet(object.prefixedName) ? String(object.prefixedName) : "",
            primaryColor: isSet(object.primaryColor) ? String(object.primaryColor) : "",
            subscribers: isSet(object.subscribers) ? Number(object.subscribers) : 0,
            type: isSet(object.type) ? String(object.type) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.communityIcon !== undefined && (obj.communityIcon = message.communityIcon);
        message.iconUrl !== undefined && (obj.iconUrl = message.iconUrl);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        message.isSubscribed !== undefined && (obj.isSubscribed = message.isSubscribed);
        message.name !== undefined && (obj.name = message.name);
        message.prefixedName !== undefined && (obj.prefixedName = message.prefixedName);
        message.primaryColor !== undefined && (obj.primaryColor = message.primaryColor);
        message.subscribers !== undefined && (obj.subscribers = Math.round(message.subscribers));
        message.type !== undefined && (obj.type = message.type);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCommunityListWidget_CommunityData();
        message.communityIcon = object.communityIcon ?? "";
        message.iconUrl = object.iconUrl ?? "";
        message.isNsfw = object.isNsfw ?? false;
        message.isSubscribed = object.isSubscribed ?? false;
        message.name = object.name ?? "";
        message.prefixedName = object.prefixedName ?? "";
        message.primaryColor = object.primaryColor ?? "";
        message.subscribers = object.subscribers ?? 0;
        message.type = object.type ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CommunityListWidget.CommunityData", CommunityListWidget_CommunityData);
function createBaseAddCommunityListWidgetRequest() {
    return { subreddit: "", shortName: "", data: [], styles: undefined };
}
export const AddCommunityListWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.AddCommunityListWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.shortName !== "") {
            writer.uint32(18).string(message.shortName);
        }
        for (const v of message.data) {
            writer.uint32(26).string(v);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddCommunityListWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.shortName = reader.string();
                    break;
                case 3:
                    message.data.push(reader.string());
                    break;
                case 4:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            data: Array.isArray(object?.data) ? object.data.map((e) => String(e)) : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        if (message.data) {
            obj.data = message.data.map((e) => e);
        }
        else {
            obj.data = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAddCommunityListWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.shortName = object.shortName ?? "";
        message.data = object.data?.map((e) => e) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddCommunityListWidgetRequest", AddCommunityListWidgetRequest);
function createBaseUpdateCommunityListWidgetRequest() {
    return { subreddit: "", id: "", shortName: "", data: [], styles: undefined };
}
export const UpdateCommunityListWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.shortName !== "") {
            writer.uint32(26).string(message.shortName);
        }
        for (const v of message.data) {
            writer.uint32(34).string(v);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCommunityListWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.shortName = reader.string();
                    break;
                case 4:
                    message.data.push(reader.string());
                    break;
                case 5:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            id: isSet(object.id) ? String(object.id) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            data: Array.isArray(object?.data) ? object.data.map((e) => String(e)) : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.id !== undefined && (obj.id = message.id);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        if (message.data) {
            obj.data = message.data.map((e) => e);
        }
        else {
            obj.data = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateCommunityListWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.id = object.id ?? "";
        message.shortName = object.shortName ?? "";
        message.data = object.data?.map((e) => e) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetRequest", UpdateCommunityListWidgetRequest);
function createBaseUpdateCommunityListWidgetResponse() {
    return { kind: "", shortName: "", data: [], styles: undefined };
}
export const UpdateCommunityListWidgetResponse = {
    $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.shortName !== "") {
            writer.uint32(18).string(message.shortName);
        }
        for (const v of message.data) {
            writer.uint32(26).string(v);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCommunityListWidgetResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.shortName = reader.string();
                    break;
                case 3:
                    message.data.push(reader.string());
                    break;
                case 4:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            data: Array.isArray(object?.data) ? object.data.map((e) => String(e)) : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        if (message.data) {
            obj.data = message.data.map((e) => e);
        }
        else {
            obj.data = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateCommunityListWidgetResponse();
        message.kind = object.kind ?? "";
        message.shortName = object.shortName ?? "";
        message.data = object.data?.map((e) => e) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetResponse", UpdateCommunityListWidgetResponse);
function createBasePostFlairWidget() {
    return { id: "", kind: "", display: "", order: [], shortName: "", styles: undefined, subreddit: undefined };
}
export const PostFlairWidget = {
    $type: "devvit.plugin.redditapi.widgets.PostFlairWidget",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== "") {
            writer.uint32(18).string(message.kind);
        }
        if (message.display !== "") {
            writer.uint32(26).string(message.display);
        }
        for (const v of message.order) {
            writer.uint32(34).string(v);
        }
        if (message.shortName !== "") {
            writer.uint32(42).string(message.shortName);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostFlairWidget();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.display = reader.string();
                    break;
                case 4:
                    message.order.push(reader.string());
                    break;
                case 5:
                    message.shortName = reader.string();
                    break;
                case 6:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            kind: isSet(object.kind) ? String(object.kind) : "",
            display: isSet(object.display) ? String(object.display) : "",
            order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.kind !== undefined && (obj.kind = message.kind);
        message.display !== undefined && (obj.display = message.display);
        if (message.order) {
            obj.order = message.order.map((e) => e);
        }
        else {
            obj.order = [];
        }
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePostFlairWidget();
        message.id = object.id ?? "";
        message.kind = object.kind ?? "";
        message.display = object.display ?? "";
        message.order = object.order?.map((e) => e) || [];
        message.shortName = object.shortName ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        message.subreddit = object.subreddit ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.PostFlairWidget", PostFlairWidget);
function createBaseAddPostFlairWidgetRequest() {
    return { subreddit: "", display: "", order: [], shortName: "", styles: undefined };
}
export const AddPostFlairWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.AddPostFlairWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.display !== "") {
            writer.uint32(18).string(message.display);
        }
        for (const v of message.order) {
            writer.uint32(26).string(v);
        }
        if (message.shortName !== "") {
            writer.uint32(34).string(message.shortName);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddPostFlairWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.display = reader.string();
                    break;
                case 3:
                    message.order.push(reader.string());
                    break;
                case 4:
                    message.shortName = reader.string();
                    break;
                case 5:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            display: isSet(object.display) ? String(object.display) : "",
            order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.display !== undefined && (obj.display = message.display);
        if (message.order) {
            obj.order = message.order.map((e) => e);
        }
        else {
            obj.order = [];
        }
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAddPostFlairWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.display = object.display ?? "";
        message.order = object.order?.map((e) => e) || [];
        message.shortName = object.shortName ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddPostFlairWidgetRequest", AddPostFlairWidgetRequest);
function createBaseUpdatePostFlairWidgetRequest() {
    return { subreddit: "", id: "", display: "", order: [], shortName: "", styles: undefined };
}
export const UpdatePostFlairWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.UpdatePostFlairWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.display !== "") {
            writer.uint32(26).string(message.display);
        }
        for (const v of message.order) {
            writer.uint32(34).string(v);
        }
        if (message.shortName !== "") {
            writer.uint32(42).string(message.shortName);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdatePostFlairWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.display = reader.string();
                    break;
                case 4:
                    message.order.push(reader.string());
                    break;
                case 5:
                    message.shortName = reader.string();
                    break;
                case 6:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            id: isSet(object.id) ? String(object.id) : "",
            display: isSet(object.display) ? String(object.display) : "",
            order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.id !== undefined && (obj.id = message.id);
        message.display !== undefined && (obj.display = message.display);
        if (message.order) {
            obj.order = message.order.map((e) => e);
        }
        else {
            obj.order = [];
        }
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdatePostFlairWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.id = object.id ?? "";
        message.display = object.display ?? "";
        message.order = object.order?.map((e) => e) || [];
        message.shortName = object.shortName ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdatePostFlairWidgetRequest", UpdatePostFlairWidgetRequest);
function createBaseDeleteWidgetRequest() {
    return { id: "", subreddit: "" };
}
export const DeleteWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.DeleteWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.subreddit !== "") {
            writer.uint32(18).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDeleteWidgetRequest();
        message.id = object.id ?? "";
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.DeleteWidgetRequest", DeleteWidgetRequest);
function createBaseGetWidgetsRequest() {
    return { subreddit: "", progressiveImages: undefined };
}
export const GetWidgetsRequest = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.progressiveImages !== undefined) {
            BoolValue.encode({ value: message.progressiveImages }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.progressiveImages = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            progressiveImages: isSet(object.progressiveImages) ? Boolean(object.progressiveImages) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.progressiveImages !== undefined && (obj.progressiveImages = message.progressiveImages);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsRequest();
        message.subreddit = object.subreddit ?? "";
        message.progressiveImages = object.progressiveImages ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsRequest", GetWidgetsRequest);
function createBaseGetWidgetsResponse() {
    return { layout: undefined, items: {} };
}
export const GetWidgetsResponse = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.layout !== undefined) {
            GetWidgetsResponse_Layout.encode(message.layout, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.items).forEach(([key, value]) => {
            GetWidgetsResponse_ItemsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.layout = GetWidgetsResponse_Layout.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = GetWidgetsResponse_ItemsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.items[entry2.key] = entry2.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            layout: isSet(object.layout) ? GetWidgetsResponse_Layout.fromJSON(object.layout) : undefined,
            items: isObject(object.items)
                ? Object.entries(object.items).reduce((acc, [key, value]) => {
                    acc[key] = GetWidgetsResponse_WidgetItem.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.layout !== undefined &&
            (obj.layout = message.layout ? GetWidgetsResponse_Layout.toJSON(message.layout) : undefined);
        obj.items = {};
        if (message.items) {
            Object.entries(message.items).forEach(([k, v]) => {
                obj.items[k] = GetWidgetsResponse_WidgetItem.toJSON(v);
            });
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsResponse();
        message.layout = (object.layout !== undefined && object.layout !== null)
            ? GetWidgetsResponse_Layout.fromPartial(object.layout)
            : undefined;
        message.items = Object.entries(object.items ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = GetWidgetsResponse_WidgetItem.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse", GetWidgetsResponse);
function createBaseGetWidgetsResponse_WidgetOrdering() {
    return { order: [] };
}
export const GetWidgetsResponse_WidgetOrdering = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetOrdering",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.order) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsResponse_WidgetOrdering();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.order.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.order) {
            obj.order = message.order.map((e) => e);
        }
        else {
            obj.order = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsResponse_WidgetOrdering();
        message.order = object.order?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetOrdering", GetWidgetsResponse_WidgetOrdering);
function createBaseGetWidgetsResponse_Layout() {
    return { idCardWidget: "", topbar: undefined, sidebar: undefined, moderatorWidget: "" };
}
export const GetWidgetsResponse_Layout = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.Layout",
    encode(message, writer = _m0.Writer.create()) {
        if (message.idCardWidget !== "") {
            writer.uint32(10).string(message.idCardWidget);
        }
        if (message.topbar !== undefined) {
            GetWidgetsResponse_WidgetOrdering.encode(message.topbar, writer.uint32(18).fork()).ldelim();
        }
        if (message.sidebar !== undefined) {
            GetWidgetsResponse_WidgetOrdering.encode(message.sidebar, writer.uint32(26).fork()).ldelim();
        }
        if (message.moderatorWidget !== "") {
            writer.uint32(34).string(message.moderatorWidget);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsResponse_Layout();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.idCardWidget = reader.string();
                    break;
                case 2:
                    message.topbar = GetWidgetsResponse_WidgetOrdering.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.sidebar = GetWidgetsResponse_WidgetOrdering.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.moderatorWidget = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            idCardWidget: isSet(object.idCardWidget) ? String(object.idCardWidget) : "",
            topbar: isSet(object.topbar) ? GetWidgetsResponse_WidgetOrdering.fromJSON(object.topbar) : undefined,
            sidebar: isSet(object.sidebar) ? GetWidgetsResponse_WidgetOrdering.fromJSON(object.sidebar) : undefined,
            moderatorWidget: isSet(object.moderatorWidget) ? String(object.moderatorWidget) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.idCardWidget !== undefined && (obj.idCardWidget = message.idCardWidget);
        message.topbar !== undefined &&
            (obj.topbar = message.topbar ? GetWidgetsResponse_WidgetOrdering.toJSON(message.topbar) : undefined);
        message.sidebar !== undefined &&
            (obj.sidebar = message.sidebar ? GetWidgetsResponse_WidgetOrdering.toJSON(message.sidebar) : undefined);
        message.moderatorWidget !== undefined && (obj.moderatorWidget = message.moderatorWidget);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsResponse_Layout();
        message.idCardWidget = object.idCardWidget ?? "";
        message.topbar = (object.topbar !== undefined && object.topbar !== null)
            ? GetWidgetsResponse_WidgetOrdering.fromPartial(object.topbar)
            : undefined;
        message.sidebar = (object.sidebar !== undefined && object.sidebar !== null)
            ? GetWidgetsResponse_WidgetOrdering.fromPartial(object.sidebar)
            : undefined;
        message.moderatorWidget = object.moderatorWidget ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.Layout", GetWidgetsResponse_Layout);
function createBaseGetWidgetsResponse_WidgetItem() {
    return {
        id: "",
        kind: "",
        styles: undefined,
        shortName: "",
        description: undefined,
        data: [],
        buttons: [],
        subscribersCount: undefined,
        currentlyViewingText: undefined,
        currentlyViewingCount: undefined,
        subscribersText: undefined,
        showWiki: undefined,
        templates: {},
        display: undefined,
        order: [],
        mods: [],
        totalMods: undefined,
        googleCalendarId: undefined,
        requiresSync: undefined,
        configuration: undefined,
        text: undefined,
        css: undefined,
        stylesheetUrl: undefined,
        height: undefined,
        imageData: [],
    };
}
export const GetWidgetsResponse_WidgetItem = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== "") {
            writer.uint32(18).string(message.kind);
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(26).fork()).ldelim();
        }
        if (message.shortName !== "") {
            writer.uint32(34).string(message.shortName);
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.data) {
            GetWidgetsResponse_WidgetItem_Data.encode(v, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.buttons) {
            WidgetButton.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.subscribersCount !== undefined) {
            Int64Value.encode({ value: message.subscribersCount }, writer.uint32(66).fork()).ldelim();
        }
        if (message.currentlyViewingText !== undefined) {
            StringValue.encode({ value: message.currentlyViewingText }, writer.uint32(74).fork()).ldelim();
        }
        if (message.currentlyViewingCount !== undefined) {
            Int64Value.encode({ value: message.currentlyViewingCount }, writer.uint32(82).fork()).ldelim();
        }
        if (message.subscribersText !== undefined) {
            StringValue.encode({ value: message.subscribersText }, writer.uint32(90).fork()).ldelim();
        }
        if (message.showWiki !== undefined) {
            BoolValue.encode({ value: message.showWiki }, writer.uint32(98).fork()).ldelim();
        }
        Object.entries(message.templates).forEach(([key, value]) => {
            GetWidgetsResponse_WidgetItem_TemplatesEntry.encode({ key: key, value }, writer.uint32(106).fork())
                .ldelim();
        });
        if (message.display !== undefined) {
            StringValue.encode({ value: message.display }, writer.uint32(114).fork()).ldelim();
        }
        for (const v of message.order) {
            writer.uint32(122).string(v);
        }
        for (const v of message.mods) {
            GetWidgetsResponse_WidgetItem_Moderator.encode(v, writer.uint32(130).fork()).ldelim();
        }
        if (message.totalMods !== undefined) {
            Int64Value.encode({ value: message.totalMods }, writer.uint32(138).fork()).ldelim();
        }
        if (message.googleCalendarId !== undefined) {
            StringValue.encode({ value: message.googleCalendarId }, writer.uint32(146).fork()).ldelim();
        }
        if (message.requiresSync !== undefined) {
            BoolValue.encode({ value: message.requiresSync }, writer.uint32(154).fork()).ldelim();
        }
        if (message.configuration !== undefined) {
            CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(162).fork()).ldelim();
        }
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(170).fork()).ldelim();
        }
        if (message.css !== undefined) {
            StringValue.encode({ value: message.css }, writer.uint32(178).fork()).ldelim();
        }
        if (message.stylesheetUrl !== undefined) {
            StringValue.encode({ value: message.stylesheetUrl }, writer.uint32(186).fork()).ldelim();
        }
        if (message.height !== undefined) {
            Int64Value.encode({ value: message.height }, writer.uint32(194).fork()).ldelim();
        }
        for (const v of message.imageData) {
            WidgetImage.encode(v, writer.uint32(202).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsResponse_WidgetItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.shortName = reader.string();
                    break;
                case 5:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.data.push(GetWidgetsResponse_WidgetItem_Data.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.subscribersCount = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.currentlyViewingText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.currentlyViewingCount = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.subscribersText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.showWiki = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    const entry13 = GetWidgetsResponse_WidgetItem_TemplatesEntry.decode(reader, reader.uint32());
                    if (entry13.value !== undefined) {
                        message.templates[entry13.key] = entry13.value;
                    }
                    break;
                case 14:
                    message.display = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.order.push(reader.string());
                    break;
                case 16:
                    message.mods.push(GetWidgetsResponse_WidgetItem_Moderator.decode(reader, reader.uint32()));
                    break;
                case 17:
                    message.totalMods = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.googleCalendarId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.requiresSync = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.css = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.stylesheetUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.height = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            kind: isSet(object.kind) ? String(object.kind) : "",
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            description: isSet(object.description) ? String(object.description) : undefined,
            data: Array.isArray(object?.data)
                ? object.data.map((e) => GetWidgetsResponse_WidgetItem_Data.fromJSON(e))
                : [],
            buttons: Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
            subscribersCount: isSet(object.subscribersCount) ? Number(object.subscribersCount) : undefined,
            currentlyViewingText: isSet(object.currentlyViewingText) ? String(object.currentlyViewingText) : undefined,
            currentlyViewingCount: isSet(object.currentlyViewingCount) ? Number(object.currentlyViewingCount) : undefined,
            subscribersText: isSet(object.subscribersText) ? String(object.subscribersText) : undefined,
            showWiki: isSet(object.showWiki) ? Boolean(object.showWiki) : undefined,
            templates: isObject(object.templates)
                ? Object.entries(object.templates).reduce((acc, [key, value]) => {
                    acc[key] = GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromJSON(value);
                    return acc;
                }, {})
                : {},
            display: isSet(object.display) ? String(object.display) : undefined,
            order: Array.isArray(object?.order)
                ? object.order.map((e) => String(e))
                : [],
            mods: Array.isArray(object?.mods)
                ? object.mods.map((e) => GetWidgetsResponse_WidgetItem_Moderator.fromJSON(e))
                : [],
            totalMods: isSet(object.totalMods) ? Number(object.totalMods) : undefined,
            googleCalendarId: isSet(object.googleCalendarId) ? String(object.googleCalendarId) : undefined,
            requiresSync: isSet(object.requiresSync) ? Boolean(object.requiresSync) : undefined,
            configuration: isSet(object.configuration)
                ? CalendarWidgetConfiguration.fromJSON(object.configuration)
                : undefined,
            text: isSet(object.text) ? String(object.text) : undefined,
            css: isSet(object.css) ? String(object.css) : undefined,
            stylesheetUrl: isSet(object.stylesheetUrl) ? String(object.stylesheetUrl) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
            imageData: Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.kind !== undefined && (obj.kind = message.kind);
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.description !== undefined && (obj.description = message.description);
        if (message.data) {
            obj.data = message.data.map((e) => e ? GetWidgetsResponse_WidgetItem_Data.toJSON(e) : undefined);
        }
        else {
            obj.data = [];
        }
        if (message.buttons) {
            obj.buttons = message.buttons.map((e) => e ? WidgetButton.toJSON(e) : undefined);
        }
        else {
            obj.buttons = [];
        }
        message.subscribersCount !== undefined && (obj.subscribersCount = message.subscribersCount);
        message.currentlyViewingText !== undefined && (obj.currentlyViewingText = message.currentlyViewingText);
        message.currentlyViewingCount !== undefined && (obj.currentlyViewingCount = message.currentlyViewingCount);
        message.subscribersText !== undefined && (obj.subscribersText = message.subscribersText);
        message.showWiki !== undefined && (obj.showWiki = message.showWiki);
        obj.templates = {};
        if (message.templates) {
            Object.entries(message.templates).forEach(([k, v]) => {
                obj.templates[k] = GetWidgetsResponse_WidgetItem_PostFlairTemplate.toJSON(v);
            });
        }
        message.display !== undefined && (obj.display = message.display);
        if (message.order) {
            obj.order = message.order.map((e) => e);
        }
        else {
            obj.order = [];
        }
        if (message.mods) {
            obj.mods = message.mods.map((e) => e ? GetWidgetsResponse_WidgetItem_Moderator.toJSON(e) : undefined);
        }
        else {
            obj.mods = [];
        }
        message.totalMods !== undefined && (obj.totalMods = message.totalMods);
        message.googleCalendarId !== undefined && (obj.googleCalendarId = message.googleCalendarId);
        message.requiresSync !== undefined && (obj.requiresSync = message.requiresSync);
        message.configuration !== undefined &&
            (obj.configuration = message.configuration
                ? CalendarWidgetConfiguration.toJSON(message.configuration)
                : undefined);
        message.text !== undefined && (obj.text = message.text);
        message.css !== undefined && (obj.css = message.css);
        message.stylesheetUrl !== undefined && (obj.stylesheetUrl = message.stylesheetUrl);
        message.height !== undefined && (obj.height = message.height);
        if (message.imageData) {
            obj.imageData = message.imageData.map((e) => e ? WidgetImage.toJSON(e) : undefined);
        }
        else {
            obj.imageData = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsResponse_WidgetItem();
        message.id = object.id ?? "";
        message.kind = object.kind ?? "";
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        message.shortName = object.shortName ?? "";
        message.description = object.description ?? undefined;
        message.data = object.data?.map((e) => GetWidgetsResponse_WidgetItem_Data.fromPartial(e)) || [];
        message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
        message.subscribersCount = object.subscribersCount ?? undefined;
        message.currentlyViewingText = object.currentlyViewingText ?? undefined;
        message.currentlyViewingCount = object.currentlyViewingCount ?? undefined;
        message.subscribersText = object.subscribersText ?? undefined;
        message.showWiki = object.showWiki ?? undefined;
        message.templates = Object.entries(object.templates ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromPartial(value);
            }
            return acc;
        }, {});
        message.display = object.display ?? undefined;
        message.order = object.order?.map((e) => e) || [];
        message.mods = object.mods?.map((e) => GetWidgetsResponse_WidgetItem_Moderator.fromPartial(e)) || [];
        message.totalMods = object.totalMods ?? undefined;
        message.googleCalendarId = object.googleCalendarId ?? undefined;
        message.requiresSync = object.requiresSync ?? undefined;
        message.configuration = (object.configuration !== undefined && object.configuration !== null)
            ? CalendarWidgetConfiguration.fromPartial(object.configuration)
            : undefined;
        message.text = object.text ?? undefined;
        message.css = object.css ?? undefined;
        message.stylesheetUrl = object.stylesheetUrl ?? undefined;
        message.height = object.height ?? undefined;
        message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem", GetWidgetsResponse_WidgetItem);
function createBaseGetWidgetsResponse_WidgetItem_Data() {
    return {
        url: undefined,
        linkUrl: undefined,
        height: undefined,
        width: undefined,
        iconUrl: undefined,
        name: undefined,
        prefixedName: undefined,
        isSubscribed: undefined,
        type: undefined,
        subscribers: undefined,
        communityIcon: undefined,
        isNsfw: undefined,
        text: undefined,
        children: [],
    };
}
export const GetWidgetsResponse_WidgetItem_Data = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Data",
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(10).fork()).ldelim();
        }
        if (message.linkUrl !== undefined) {
            StringValue.encode({ value: message.linkUrl }, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(26).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(34).fork()).ldelim();
        }
        if (message.iconUrl !== undefined) {
            StringValue.encode({ value: message.iconUrl }, writer.uint32(42).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(50).fork()).ldelim();
        }
        if (message.prefixedName !== undefined) {
            StringValue.encode({ value: message.prefixedName }, writer.uint32(58).fork()).ldelim();
        }
        if (message.isSubscribed !== undefined) {
            BoolValue.encode({ value: message.isSubscribed }, writer.uint32(66).fork()).ldelim();
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(74).fork()).ldelim();
        }
        if (message.subscribers !== undefined) {
            Int64Value.encode({ value: message.subscribers }, writer.uint32(82).fork()).ldelim();
        }
        if (message.communityIcon !== undefined) {
            StringValue.encode({ value: message.communityIcon }, writer.uint32(90).fork()).ldelim();
        }
        if (message.isNsfw !== undefined) {
            BoolValue.encode({ value: message.isNsfw }, writer.uint32(98).fork()).ldelim();
        }
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(106).fork()).ldelim();
        }
        for (const v of message.children) {
            MenuWidgetItem.encode(v, writer.uint32(114).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsResponse_WidgetItem_Data();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.linkUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.iconUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.prefixedName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.isSubscribed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.children.push(MenuWidgetItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            url: isSet(object.url) ? String(object.url) : undefined,
            linkUrl: isSet(object.linkUrl) ? String(object.linkUrl) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
            iconUrl: isSet(object.iconUrl) ? String(object.iconUrl) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            prefixedName: isSet(object.prefixedName) ? String(object.prefixedName) : undefined,
            isSubscribed: isSet(object.isSubscribed) ? Boolean(object.isSubscribed) : undefined,
            type: isSet(object.type) ? String(object.type) : undefined,
            subscribers: isSet(object.subscribers) ? Number(object.subscribers) : undefined,
            communityIcon: isSet(object.communityIcon) ? String(object.communityIcon) : undefined,
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : undefined,
            text: isSet(object.text) ? String(object.text) : undefined,
            children: Array.isArray(object?.children) ? object.children.map((e) => MenuWidgetItem.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        message.linkUrl !== undefined && (obj.linkUrl = message.linkUrl);
        message.height !== undefined && (obj.height = message.height);
        message.width !== undefined && (obj.width = message.width);
        message.iconUrl !== undefined && (obj.iconUrl = message.iconUrl);
        message.name !== undefined && (obj.name = message.name);
        message.prefixedName !== undefined && (obj.prefixedName = message.prefixedName);
        message.isSubscribed !== undefined && (obj.isSubscribed = message.isSubscribed);
        message.type !== undefined && (obj.type = message.type);
        message.subscribers !== undefined && (obj.subscribers = message.subscribers);
        message.communityIcon !== undefined && (obj.communityIcon = message.communityIcon);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        message.text !== undefined && (obj.text = message.text);
        if (message.children) {
            obj.children = message.children.map((e) => e ? MenuWidgetItem.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsResponse_WidgetItem_Data();
        message.url = object.url ?? undefined;
        message.linkUrl = object.linkUrl ?? undefined;
        message.height = object.height ?? undefined;
        message.width = object.width ?? undefined;
        message.iconUrl = object.iconUrl ?? undefined;
        message.name = object.name ?? undefined;
        message.prefixedName = object.prefixedName ?? undefined;
        message.isSubscribed = object.isSubscribed ?? undefined;
        message.type = object.type ?? undefined;
        message.subscribers = object.subscribers ?? undefined;
        message.communityIcon = object.communityIcon ?? undefined;
        message.isNsfw = object.isNsfw ?? undefined;
        message.text = object.text ?? undefined;
        message.children = object.children?.map((e) => MenuWidgetItem.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Data", GetWidgetsResponse_WidgetItem_Data);
function createBaseGetWidgetsResponse_WidgetItem_Moderator() {
    return {
        name: "",
        authorFlairType: "",
        authorFlairTextColor: "",
        authorFlairBackgroundColor: "",
        authorFalirText: "",
        authorFlairRichtext: [],
    };
}
export const GetWidgetsResponse_WidgetItem_Moderator = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Moderator",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.authorFlairType !== "") {
            writer.uint32(18).string(message.authorFlairType);
        }
        if (message.authorFlairTextColor !== "") {
            writer.uint32(26).string(message.authorFlairTextColor);
        }
        if (message.authorFlairBackgroundColor !== "") {
            writer.uint32(34).string(message.authorFlairBackgroundColor);
        }
        if (message.authorFalirText !== "") {
            writer.uint32(42).string(message.authorFalirText);
        }
        for (const v of message.authorFlairRichtext) {
            AuthorFlairRichText.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsResponse_WidgetItem_Moderator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.authorFlairType = reader.string();
                    break;
                case 3:
                    message.authorFlairTextColor = reader.string();
                    break;
                case 4:
                    message.authorFlairBackgroundColor = reader.string();
                    break;
                case 5:
                    message.authorFalirText = reader.string();
                    break;
                case 6:
                    message.authorFlairRichtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            authorFlairType: isSet(object.authorFlairType) ? String(object.authorFlairType) : "",
            authorFlairTextColor: isSet(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : "",
            authorFlairBackgroundColor: isSet(object.authorFlairBackgroundColor)
                ? String(object.authorFlairBackgroundColor)
                : "",
            authorFalirText: isSet(object.authorFalirText) ? String(object.authorFalirText) : "",
            authorFlairRichtext: Array.isArray(object?.authorFlairRichtext)
                ? object.authorFlairRichtext.map((e) => AuthorFlairRichText.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.authorFlairType !== undefined && (obj.authorFlairType = message.authorFlairType);
        message.authorFlairTextColor !== undefined && (obj.authorFlairTextColor = message.authorFlairTextColor);
        message.authorFlairBackgroundColor !== undefined &&
            (obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor);
        message.authorFalirText !== undefined && (obj.authorFalirText = message.authorFalirText);
        if (message.authorFlairRichtext) {
            obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => e ? AuthorFlairRichText.toJSON(e) : undefined);
        }
        else {
            obj.authorFlairRichtext = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsResponse_WidgetItem_Moderator();
        message.name = object.name ?? "";
        message.authorFlairType = object.authorFlairType ?? "";
        message.authorFlairTextColor = object.authorFlairTextColor ?? "";
        message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? "";
        message.authorFalirText = object.authorFalirText ?? "";
        message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Moderator", GetWidgetsResponse_WidgetItem_Moderator);
function createBaseGetWidgetsResponse_WidgetItem_PostFlairTemplate() {
    return { text: "", richtext: [], backgroundColor: "", templateId: "", textColor: "", type: "" };
}
export const GetWidgetsResponse_WidgetItem_PostFlairTemplate = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.PostFlairTemplate",
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== "") {
            writer.uint32(10).string(message.text);
        }
        for (const v of message.richtext) {
            AuthorFlairRichText.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.backgroundColor !== "") {
            writer.uint32(26).string(message.backgroundColor);
        }
        if (message.templateId !== "") {
            writer.uint32(34).string(message.templateId);
        }
        if (message.textColor !== "") {
            writer.uint32(42).string(message.textColor);
        }
        if (message.type !== "") {
            writer.uint32(50).string(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsResponse_WidgetItem_PostFlairTemplate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    message.richtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.backgroundColor = reader.string();
                    break;
                case 4:
                    message.templateId = reader.string();
                    break;
                case 5:
                    message.textColor = reader.string();
                    break;
                case 6:
                    message.type = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            text: isSet(object.text) ? String(object.text) : "",
            richtext: Array.isArray(object?.richtext) ? object.richtext.map((e) => AuthorFlairRichText.fromJSON(e)) : [],
            backgroundColor: isSet(object.backgroundColor) ? String(object.backgroundColor) : "",
            templateId: isSet(object.templateId) ? String(object.templateId) : "",
            textColor: isSet(object.textColor) ? String(object.textColor) : "",
            type: isSet(object.type) ? String(object.type) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.text !== undefined && (obj.text = message.text);
        if (message.richtext) {
            obj.richtext = message.richtext.map((e) => e ? AuthorFlairRichText.toJSON(e) : undefined);
        }
        else {
            obj.richtext = [];
        }
        message.backgroundColor !== undefined && (obj.backgroundColor = message.backgroundColor);
        message.templateId !== undefined && (obj.templateId = message.templateId);
        message.textColor !== undefined && (obj.textColor = message.textColor);
        message.type !== undefined && (obj.type = message.type);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsResponse_WidgetItem_PostFlairTemplate();
        message.text = object.text ?? "";
        message.richtext = object.richtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
        message.backgroundColor = object.backgroundColor ?? "";
        message.templateId = object.templateId ?? "";
        message.textColor = object.textColor ?? "";
        message.type = object.type ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.PostFlairTemplate", GetWidgetsResponse_WidgetItem_PostFlairTemplate);
function createBaseGetWidgetsResponse_WidgetItem_TemplatesEntry() {
    return { key: "", value: undefined };
}
export const GetWidgetsResponse_WidgetItem_TemplatesEntry = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.TemplatesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            GetWidgetsResponse_WidgetItem_PostFlairTemplate.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsResponse_WidgetItem_TemplatesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = GetWidgetsResponse_WidgetItem_PostFlairTemplate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined &&
            (obj.value = message.value ? GetWidgetsResponse_WidgetItem_PostFlairTemplate.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsResponse_WidgetItem_TemplatesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.TemplatesEntry", GetWidgetsResponse_WidgetItem_TemplatesEntry);
function createBaseGetWidgetsResponse_ItemsEntry() {
    return { key: "", value: undefined };
}
export const GetWidgetsResponse_ItemsEntry = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.ItemsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            GetWidgetsResponse_WidgetItem.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetsResponse_ItemsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = GetWidgetsResponse_WidgetItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? GetWidgetsResponse_WidgetItem.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined &&
            (obj.value = message.value ? GetWidgetsResponse_WidgetItem.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetsResponse_ItemsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? GetWidgetsResponse_WidgetItem.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.ItemsEntry", GetWidgetsResponse_ItemsEntry);
function createBaseMenuWidgetItem() {
    return { text: undefined, url: undefined, children: [] };
}
export const MenuWidgetItem = {
    $type: "devvit.plugin.redditapi.widgets.MenuWidgetItem",
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(10).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.children) {
            MenuWidgetItem.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMenuWidgetItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.children.push(MenuWidgetItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            text: isSet(object.text) ? String(object.text) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            children: Array.isArray(object?.children) ? object.children.map((e) => MenuWidgetItem.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.text !== undefined && (obj.text = message.text);
        message.url !== undefined && (obj.url = message.url);
        if (message.children) {
            obj.children = message.children.map((e) => e ? MenuWidgetItem.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMenuWidgetItem();
        message.text = object.text ?? undefined;
        message.url = object.url ?? undefined;
        message.children = object.children?.map((e) => MenuWidgetItem.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.MenuWidgetItem", MenuWidgetItem);
function createBaseOrderWidgetsRequest() {
    return { subreddit: "", order: [] };
}
export const OrderWidgetsRequest = {
    $type: "devvit.plugin.redditapi.widgets.OrderWidgetsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        for (const v of message.order) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrderWidgetsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.order.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        if (message.order) {
            obj.order = message.order.map((e) => e);
        }
        else {
            obj.order = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseOrderWidgetsRequest();
        message.subreddit = object.subreddit ?? "";
        message.order = object.order?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.OrderWidgetsRequest", OrderWidgetsRequest);
function createBaseGetWidgetImageUploadLeaseRequest() {
    return { subreddit: "", filepath: "", mimetype: "" };
}
export const GetWidgetImageUploadLeaseRequest = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.filepath !== "") {
            writer.uint32(18).string(message.filepath);
        }
        if (message.mimetype !== "") {
            writer.uint32(26).string(message.mimetype);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetImageUploadLeaseRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.filepath = reader.string();
                    break;
                case 3:
                    message.mimetype = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            filepath: isSet(object.filepath) ? String(object.filepath) : "",
            mimetype: isSet(object.mimetype) ? String(object.mimetype) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.filepath !== undefined && (obj.filepath = message.filepath);
        message.mimetype !== undefined && (obj.mimetype = message.mimetype);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetImageUploadLeaseRequest();
        message.subreddit = object.subreddit ?? "";
        message.filepath = object.filepath ?? "";
        message.mimetype = object.mimetype ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseRequest", GetWidgetImageUploadLeaseRequest);
function createBaseGetWidgetImageUploadLeaseResponse() {
    return { s3UploadLease: undefined, websocketUrl: "" };
}
export const GetWidgetImageUploadLeaseResponse = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.s3UploadLease !== undefined) {
            GetWidgetImageUploadLeaseResponse_S3UploadLease.encode(message.s3UploadLease, writer.uint32(10).fork()).ldelim();
        }
        if (message.websocketUrl !== "") {
            writer.uint32(18).string(message.websocketUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetImageUploadLeaseResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.s3UploadLease = GetWidgetImageUploadLeaseResponse_S3UploadLease.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.websocketUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            s3UploadLease: isSet(object.s3UploadLease)
                ? GetWidgetImageUploadLeaseResponse_S3UploadLease.fromJSON(object.s3UploadLease)
                : undefined,
            websocketUrl: isSet(object.websocketUrl) ? String(object.websocketUrl) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.s3UploadLease !== undefined && (obj.s3UploadLease = message.s3UploadLease
            ? GetWidgetImageUploadLeaseResponse_S3UploadLease.toJSON(message.s3UploadLease)
            : undefined);
        message.websocketUrl !== undefined && (obj.websocketUrl = message.websocketUrl);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetImageUploadLeaseResponse();
        message.s3UploadLease = (object.s3UploadLease !== undefined && object.s3UploadLease !== null)
            ? GetWidgetImageUploadLeaseResponse_S3UploadLease.fromPartial(object.s3UploadLease)
            : undefined;
        message.websocketUrl = object.websocketUrl ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse", GetWidgetImageUploadLeaseResponse);
function createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease() {
    return { action: "", fields: [] };
}
export const GetWidgetImageUploadLeaseResponse_S3UploadLease = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease",
    encode(message, writer = _m0.Writer.create()) {
        if (message.action !== "") {
            writer.uint32(10).string(message.action);
        }
        for (const v of message.fields) {
            GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.action = reader.string();
                    break;
                case 2:
                    message.fields.push(GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            action: isSet(object.action) ? String(object.action) : "",
            fields: Array.isArray(object?.fields)
                ? object.fields.map((e) => GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.action !== undefined && (obj.action = message.action);
        if (message.fields) {
            obj.fields = message.fields.map((e) => e ? GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.toJSON(e) : undefined);
        }
        else {
            obj.fields = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease();
        message.action = object.action ?? "";
        message.fields =
            object.fields?.map((e) => GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease", GetWidgetImageUploadLeaseResponse_S3UploadLease);
function createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair() {
    return { name: "", value: "" };
}
export const GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair = {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease.NameValuePair",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            value: isSet(object.value) ? String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair();
        message.name = object.name ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease.NameValuePair", GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair);
function createBaseCustomWidget() {
    return { id: "", kind: "", shortName: "", text: "", height: 0, css: "", imageData: [], styles: undefined };
}
export const CustomWidget = {
    $type: "devvit.plugin.redditapi.widgets.CustomWidget",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== "") {
            writer.uint32(18).string(message.kind);
        }
        if (message.shortName !== "") {
            writer.uint32(26).string(message.shortName);
        }
        if (message.text !== "") {
            writer.uint32(34).string(message.text);
        }
        if (message.height !== 0) {
            writer.uint32(48).int32(message.height);
        }
        if (message.css !== "") {
            writer.uint32(58).string(message.css);
        }
        for (const v of message.imageData) {
            WidgetImage.encode(v, writer.uint32(66).fork()).ldelim();
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCustomWidget();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.shortName = reader.string();
                    break;
                case 4:
                    message.text = reader.string();
                    break;
                case 6:
                    message.height = reader.int32();
                    break;
                case 7:
                    message.css = reader.string();
                    break;
                case 8:
                    message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            kind: isSet(object.kind) ? String(object.kind) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            text: isSet(object.text) ? String(object.text) : "",
            height: isSet(object.height) ? Number(object.height) : 0,
            css: isSet(object.css) ? String(object.css) : "",
            imageData: Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.kind !== undefined && (obj.kind = message.kind);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.text !== undefined && (obj.text = message.text);
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.css !== undefined && (obj.css = message.css);
        if (message.imageData) {
            obj.imageData = message.imageData.map((e) => e ? WidgetImage.toJSON(e) : undefined);
        }
        else {
            obj.imageData = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCustomWidget();
        message.id = object.id ?? "";
        message.kind = object.kind ?? "";
        message.shortName = object.shortName ?? "";
        message.text = object.text ?? "";
        message.height = object.height ?? 0;
        message.css = object.css ?? "";
        message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CustomWidget", CustomWidget);
function createBaseAddCustomWidgetRequest() {
    return { subreddit: "", shortName: "", text: "", height: 0, css: "", imageData: [], styles: undefined };
}
export const AddCustomWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.AddCustomWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.shortName !== "") {
            writer.uint32(18).string(message.shortName);
        }
        if (message.text !== "") {
            writer.uint32(26).string(message.text);
        }
        if (message.height !== 0) {
            writer.uint32(32).int32(message.height);
        }
        if (message.css !== "") {
            writer.uint32(42).string(message.css);
        }
        for (const v of message.imageData) {
            WidgetImage.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddCustomWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.shortName = reader.string();
                    break;
                case 3:
                    message.text = reader.string();
                    break;
                case 4:
                    message.height = reader.int32();
                    break;
                case 5:
                    message.css = reader.string();
                    break;
                case 6:
                    message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            text: isSet(object.text) ? String(object.text) : "",
            height: isSet(object.height) ? Number(object.height) : 0,
            css: isSet(object.css) ? String(object.css) : "",
            imageData: Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.text !== undefined && (obj.text = message.text);
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.css !== undefined && (obj.css = message.css);
        if (message.imageData) {
            obj.imageData = message.imageData.map((e) => e ? WidgetImage.toJSON(e) : undefined);
        }
        else {
            obj.imageData = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAddCustomWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.shortName = object.shortName ?? "";
        message.text = object.text ?? "";
        message.height = object.height ?? 0;
        message.css = object.css ?? "";
        message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddCustomWidgetRequest", AddCustomWidgetRequest);
function createBaseUpdateCustomWidgetRequest() {
    return { subreddit: "", id: "", shortName: "", text: "", height: 0, css: "", imageData: [], styles: undefined };
}
export const UpdateCustomWidgetRequest = {
    $type: "devvit.plugin.redditapi.widgets.UpdateCustomWidgetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.shortName !== "") {
            writer.uint32(26).string(message.shortName);
        }
        if (message.text !== "") {
            writer.uint32(34).string(message.text);
        }
        if (message.height !== 0) {
            writer.uint32(40).int32(message.height);
        }
        if (message.css !== "") {
            writer.uint32(50).string(message.css);
        }
        for (const v of message.imageData) {
            WidgetImage.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.styles !== undefined) {
            WidgetStyles.encode(message.styles, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateCustomWidgetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.shortName = reader.string();
                    break;
                case 4:
                    message.text = reader.string();
                    break;
                case 5:
                    message.height = reader.int32();
                    break;
                case 6:
                    message.css = reader.string();
                    break;
                case 7:
                    message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.styles = WidgetStyles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            id: isSet(object.id) ? String(object.id) : "",
            shortName: isSet(object.shortName) ? String(object.shortName) : "",
            text: isSet(object.text) ? String(object.text) : "",
            height: isSet(object.height) ? Number(object.height) : 0,
            css: isSet(object.css) ? String(object.css) : "",
            imageData: Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
            styles: isSet(object.styles) ? WidgetStyles.fromJSON(object.styles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.id !== undefined && (obj.id = message.id);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.text !== undefined && (obj.text = message.text);
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.css !== undefined && (obj.css = message.css);
        if (message.imageData) {
            obj.imageData = message.imageData.map((e) => e ? WidgetImage.toJSON(e) : undefined);
        }
        else {
            obj.imageData = [];
        }
        message.styles !== undefined && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateCustomWidgetRequest();
        message.subreddit = object.subreddit ?? "";
        message.id = object.id ?? "";
        message.shortName = object.shortName ?? "";
        message.text = object.text ?? "";
        message.height = object.height ?? 0;
        message.css = object.css ?? "";
        message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
        message.styles = (object.styles !== undefined && object.styles !== null)
            ? WidgetStyles.fromPartial(object.styles)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateCustomWidgetRequest", UpdateCustomWidgetRequest);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
