/**
 * #automod.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Struct } from '../../google/protobuf/struct.js';
import { BoolValue, Int32Value, StringValue } from '../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../typeRegistry.js';
import { Comment } from '../reddit/comment.js';
import { Post } from '../reddit/post.js';
import { Subreddit } from '../reddit/subreddit.js';
import { User } from '../reddit/user.js';
function createBaseAutomodInvocation() {
    return {
        yamlText: undefined,
        comment: undefined,
        post: undefined,
        author: undefined,
        parentPost: undefined,
        subreddit: undefined,
        crosspost: undefined,
        crosspostSubreddit: undefined,
        crosspostAuthor: undefined,
        poll: undefined,
    };
}
export const AutomodInvocation = {
    $type: "devvit.gateway.AutomodInvocation",
    encode(message, writer = _m0.Writer.create()) {
        if (message.yamlText !== undefined) {
            StringValue.encode({ value: message.yamlText }, writer.uint32(10).fork()).ldelim();
        }
        if (message.comment !== undefined) {
            Comment.encode(message.comment, writer.uint32(18).fork()).ldelim();
        }
        if (message.post !== undefined) {
            Post.encode(message.post, writer.uint32(26).fork()).ldelim();
        }
        if (message.author !== undefined) {
            User.encode(message.author, writer.uint32(34).fork()).ldelim();
        }
        if (message.parentPost !== undefined) {
            Post.encode(message.parentPost, writer.uint32(42).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            Subreddit.encode(message.subreddit, writer.uint32(50).fork()).ldelim();
        }
        if (message.crosspost !== undefined) {
            Post.encode(message.crosspost, writer.uint32(58).fork()).ldelim();
        }
        if (message.crosspostSubreddit !== undefined) {
            Subreddit.encode(message.crosspostSubreddit, writer.uint32(66).fork()).ldelim();
        }
        if (message.crosspostAuthor !== undefined) {
            User.encode(message.crosspostAuthor, writer.uint32(74).fork()).ldelim();
        }
        if (message.poll !== undefined) {
            Poll.encode(message.poll, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAutomodInvocation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.yamlText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.comment = Comment.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.post = Post.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.author = User.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.parentPost = Post.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.subreddit = Subreddit.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.crosspost = Post.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.crosspostSubreddit = Subreddit.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.crosspostAuthor = User.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.poll = Poll.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            yamlText: isSet(object.yamlText) ? String(object.yamlText) : undefined,
            comment: isSet(object.comment) ? Comment.fromJSON(object.comment) : undefined,
            post: isSet(object.post) ? Post.fromJSON(object.post) : undefined,
            author: isSet(object.author) ? User.fromJSON(object.author) : undefined,
            parentPost: isSet(object.parentPost) ? Post.fromJSON(object.parentPost) : undefined,
            subreddit: isSet(object.subreddit) ? Subreddit.fromJSON(object.subreddit) : undefined,
            crosspost: isSet(object.crosspost) ? Post.fromJSON(object.crosspost) : undefined,
            crosspostSubreddit: isSet(object.crosspostSubreddit) ? Subreddit.fromJSON(object.crosspostSubreddit) : undefined,
            crosspostAuthor: isSet(object.crosspostAuthor) ? User.fromJSON(object.crosspostAuthor) : undefined,
            poll: isSet(object.poll) ? Poll.fromJSON(object.poll) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.yamlText !== undefined && (obj.yamlText = message.yamlText);
        message.comment !== undefined && (obj.comment = message.comment ? Comment.toJSON(message.comment) : undefined);
        message.post !== undefined && (obj.post = message.post ? Post.toJSON(message.post) : undefined);
        message.author !== undefined && (obj.author = message.author ? User.toJSON(message.author) : undefined);
        message.parentPost !== undefined &&
            (obj.parentPost = message.parentPost ? Post.toJSON(message.parentPost) : undefined);
        message.subreddit !== undefined &&
            (obj.subreddit = message.subreddit ? Subreddit.toJSON(message.subreddit) : undefined);
        message.crosspost !== undefined && (obj.crosspost = message.crosspost ? Post.toJSON(message.crosspost) : undefined);
        message.crosspostSubreddit !== undefined &&
            (obj.crosspostSubreddit = message.crosspostSubreddit ? Subreddit.toJSON(message.crosspostSubreddit) : undefined);
        message.crosspostAuthor !== undefined &&
            (obj.crosspostAuthor = message.crosspostAuthor ? User.toJSON(message.crosspostAuthor) : undefined);
        message.poll !== undefined && (obj.poll = message.poll ? Poll.toJSON(message.poll) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAutomodInvocation();
        message.yamlText = object.yamlText ?? undefined;
        message.comment = (object.comment !== undefined && object.comment !== null)
            ? Comment.fromPartial(object.comment)
            : undefined;
        message.post = (object.post !== undefined && object.post !== null) ? Post.fromPartial(object.post) : undefined;
        message.author = (object.author !== undefined && object.author !== null)
            ? User.fromPartial(object.author)
            : undefined;
        message.parentPost = (object.parentPost !== undefined && object.parentPost !== null)
            ? Post.fromPartial(object.parentPost)
            : undefined;
        message.subreddit = (object.subreddit !== undefined && object.subreddit !== null)
            ? Subreddit.fromPartial(object.subreddit)
            : undefined;
        message.crosspost = (object.crosspost !== undefined && object.crosspost !== null)
            ? Post.fromPartial(object.crosspost)
            : undefined;
        message.crosspostSubreddit = (object.crosspostSubreddit !== undefined && object.crosspostSubreddit !== null)
            ? Subreddit.fromPartial(object.crosspostSubreddit)
            : undefined;
        message.crosspostAuthor = (object.crosspostAuthor !== undefined && object.crosspostAuthor !== null)
            ? User.fromPartial(object.crosspostAuthor)
            : undefined;
        message.poll = (object.poll !== undefined && object.poll !== null) ? Poll.fromPartial(object.poll) : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.gateway.AutomodInvocation", AutomodInvocation);
function createBasePoll() {
    return {
        isPrediction: undefined,
        options: [],
        predictionStatus: undefined,
        resolvedOptionId: undefined,
        totalStakeAmount: undefined,
        totalVoteCount: undefined,
        tournamentId: undefined,
        userSelection: undefined,
        userWonAmount: undefined,
        voteUpdatesRemained: undefined,
        votingEndTimestamp: undefined,
    };
}
export const Poll = {
    $type: "devvit.gateway.Poll",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isPrediction !== undefined) {
            BoolValue.encode({ value: message.isPrediction }, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.options) {
            Struct.encode(Struct.wrap(v), writer.uint32(18).fork()).ldelim();
        }
        if (message.predictionStatus !== undefined) {
            StringValue.encode({ value: message.predictionStatus }, writer.uint32(26).fork()).ldelim();
        }
        if (message.resolvedOptionId !== undefined) {
            StringValue.encode({ value: message.resolvedOptionId }, writer.uint32(34).fork()).ldelim();
        }
        if (message.totalStakeAmount !== undefined) {
            Int32Value.encode({ value: message.totalStakeAmount }, writer.uint32(42).fork()).ldelim();
        }
        if (message.totalVoteCount !== undefined) {
            Int32Value.encode({ value: message.totalVoteCount }, writer.uint32(50).fork()).ldelim();
        }
        if (message.tournamentId !== undefined) {
            StringValue.encode({ value: message.tournamentId }, writer.uint32(58).fork()).ldelim();
        }
        if (message.userSelection !== undefined) {
            StringValue.encode({ value: message.userSelection }, writer.uint32(66).fork()).ldelim();
        }
        if (message.userWonAmount !== undefined) {
            Int32Value.encode({ value: message.userWonAmount }, writer.uint32(74).fork()).ldelim();
        }
        if (message.voteUpdatesRemained !== undefined) {
            Int32Value.encode({ value: message.voteUpdatesRemained }, writer.uint32(82).fork()).ldelim();
        }
        if (message.votingEndTimestamp !== undefined) {
            Int32Value.encode({ value: message.votingEndTimestamp }, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoll();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isPrediction = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.options.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
                    break;
                case 3:
                    message.predictionStatus = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.resolvedOptionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.totalStakeAmount = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.totalVoteCount = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.tournamentId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.userSelection = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.userWonAmount = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.voteUpdatesRemained = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.votingEndTimestamp = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isPrediction: isSet(object.isPrediction) ? Boolean(object.isPrediction) : undefined,
            options: Array.isArray(object?.options) ? [...object.options] : [],
            predictionStatus: isSet(object.predictionStatus) ? String(object.predictionStatus) : undefined,
            resolvedOptionId: isSet(object.resolvedOptionId) ? String(object.resolvedOptionId) : undefined,
            totalStakeAmount: isSet(object.totalStakeAmount) ? Number(object.totalStakeAmount) : undefined,
            totalVoteCount: isSet(object.totalVoteCount) ? Number(object.totalVoteCount) : undefined,
            tournamentId: isSet(object.tournamentId) ? String(object.tournamentId) : undefined,
            userSelection: isSet(object.userSelection) ? String(object.userSelection) : undefined,
            userWonAmount: isSet(object.userWonAmount) ? Number(object.userWonAmount) : undefined,
            voteUpdatesRemained: isSet(object.voteUpdatesRemained) ? Number(object.voteUpdatesRemained) : undefined,
            votingEndTimestamp: isSet(object.votingEndTimestamp) ? Number(object.votingEndTimestamp) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.isPrediction !== undefined && (obj.isPrediction = message.isPrediction);
        if (message.options) {
            obj.options = message.options.map((e) => e);
        }
        else {
            obj.options = [];
        }
        message.predictionStatus !== undefined && (obj.predictionStatus = message.predictionStatus);
        message.resolvedOptionId !== undefined && (obj.resolvedOptionId = message.resolvedOptionId);
        message.totalStakeAmount !== undefined && (obj.totalStakeAmount = message.totalStakeAmount);
        message.totalVoteCount !== undefined && (obj.totalVoteCount = message.totalVoteCount);
        message.tournamentId !== undefined && (obj.tournamentId = message.tournamentId);
        message.userSelection !== undefined && (obj.userSelection = message.userSelection);
        message.userWonAmount !== undefined && (obj.userWonAmount = message.userWonAmount);
        message.voteUpdatesRemained !== undefined && (obj.voteUpdatesRemained = message.voteUpdatesRemained);
        message.votingEndTimestamp !== undefined && (obj.votingEndTimestamp = message.votingEndTimestamp);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePoll();
        message.isPrediction = object.isPrediction ?? undefined;
        message.options = object.options?.map((e) => e) || [];
        message.predictionStatus = object.predictionStatus ?? undefined;
        message.resolvedOptionId = object.resolvedOptionId ?? undefined;
        message.totalStakeAmount = object.totalStakeAmount ?? undefined;
        message.totalVoteCount = object.totalVoteCount ?? undefined;
        message.tournamentId = object.tournamentId ?? undefined;
        message.userSelection = object.userSelection ?? undefined;
        message.userWonAmount = object.userWonAmount ?? undefined;
        message.voteUpdatesRemained = object.voteUpdatesRemained ?? undefined;
        message.votingEndTimestamp = object.votingEndTimestamp ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.gateway.Poll", Poll);
function createBaseAutomodResult() {
    return { result: "", errors: "" };
}
export const AutomodResult = {
    $type: "devvit.gateway.AutomodResult",
    encode(message, writer = _m0.Writer.create()) {
        if (message.result !== "") {
            writer.uint32(10).string(message.result);
        }
        if (message.errors !== "") {
            writer.uint32(18).string(message.errors);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAutomodResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.result = reader.string();
                    break;
                case 2:
                    message.errors = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            result: isSet(object.result) ? String(object.result) : "",
            errors: isSet(object.errors) ? String(object.errors) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.result !== undefined && (obj.result = message.result);
        message.errors !== undefined && (obj.errors = message.errors);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAutomodResult();
        message.result = object.result ?? "";
        message.errors = object.errors ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.gateway.AutomodResult", AutomodResult);
export class AutomodClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.gateway.Automod";
        this.rpc = rpc;
        this.Evaluate = this.Evaluate.bind(this);
    }
    Evaluate(request) {
        const data = AutomodInvocation.encode(request).finish();
        const promise = this.rpc.request(this.service, "Evaluate", data);
        return promise.then((data) => AutomodResult.decode(new _m0.Reader(data)));
    }
}
export const AutomodDefinition = {
    name: "Automod",
    fullName: "devvit.gateway.Automod",
    methods: {
        evaluate: {
            name: "Evaluate",
            requestType: AutomodInvocation,
            requestStream: false,
            responseType: AutomodResult,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
