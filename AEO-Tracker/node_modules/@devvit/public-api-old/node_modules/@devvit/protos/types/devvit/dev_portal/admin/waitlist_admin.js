/**
 * #waitlist_admin.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Empty } from '../../../google/protobuf/empty.js';
import { Timestamp } from '../../../google/protobuf/timestamp.js';
import { StringValue } from '../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
export var WaitlistStatus;
(function (WaitlistStatus) {
    WaitlistStatus[WaitlistStatus["PENDING"] = 0] = "PENDING";
    WaitlistStatus[WaitlistStatus["ACCEPTED"] = 1] = "ACCEPTED";
    WaitlistStatus[WaitlistStatus["REJECTED"] = 2] = "REJECTED";
    WaitlistStatus[WaitlistStatus["REVOKED"] = 3] = "REVOKED";
    WaitlistStatus[WaitlistStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(WaitlistStatus || (WaitlistStatus = {}));
export function waitlistStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "PENDING":
            return WaitlistStatus.PENDING;
        case 1:
        case "ACCEPTED":
            return WaitlistStatus.ACCEPTED;
        case 2:
        case "REJECTED":
            return WaitlistStatus.REJECTED;
        case 3:
        case "REVOKED":
            return WaitlistStatus.REVOKED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return WaitlistStatus.UNRECOGNIZED;
    }
}
export function waitlistStatusToJSON(object) {
    switch (object) {
        case WaitlistStatus.PENDING:
            return 0;
        case WaitlistStatus.ACCEPTED:
            return 1;
        case WaitlistStatus.REJECTED:
            return 2;
        case WaitlistStatus.REVOKED:
            return 3;
        case WaitlistStatus.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseSubmission() {
    return {
        id: "",
        userId: "",
        userName: "",
        whatToBuild: "",
        botsBuilt: "",
        createdAt: undefined,
        updatedAt: undefined,
        status: 0,
        acceptedTermsVersion: 0,
    };
}
export const Submission = {
    $type: "devvit.dev_portal.admin.Submission",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.userId !== "") {
            writer.uint32(18).string(message.userId);
        }
        if (message.userName !== "") {
            writer.uint32(26).string(message.userName);
        }
        if (message.whatToBuild !== "") {
            writer.uint32(34).string(message.whatToBuild);
        }
        if (message.botsBuilt !== "") {
            writer.uint32(42).string(message.botsBuilt);
        }
        if (message.createdAt !== undefined) {
            Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).ldelim();
        }
        if (message.updatedAt !== undefined) {
            Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).ldelim();
        }
        if (message.status !== 0) {
            writer.uint32(64).int32(message.status);
        }
        if (message.acceptedTermsVersion !== 0) {
            writer.uint32(72).int32(message.acceptedTermsVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmission();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.userName = reader.string();
                    break;
                case 4:
                    message.whatToBuild = reader.string();
                    break;
                case 5:
                    message.botsBuilt = reader.string();
                    break;
                case 6:
                    message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.status = reader.int32();
                    break;
                case 9:
                    message.acceptedTermsVersion = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            userId: isSet(object.userId) ? String(object.userId) : "",
            userName: isSet(object.userName) ? String(object.userName) : "",
            whatToBuild: isSet(object.whatToBuild) ? String(object.whatToBuild) : "",
            botsBuilt: isSet(object.botsBuilt) ? String(object.botsBuilt) : "",
            createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
            updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
            status: isSet(object.status) ? waitlistStatusFromJSON(object.status) : 0,
            acceptedTermsVersion: isSet(object.acceptedTermsVersion) ? Number(object.acceptedTermsVersion) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.userId !== undefined && (obj.userId = message.userId);
        message.userName !== undefined && (obj.userName = message.userName);
        message.whatToBuild !== undefined && (obj.whatToBuild = message.whatToBuild);
        message.botsBuilt !== undefined && (obj.botsBuilt = message.botsBuilt);
        message.createdAt !== undefined && (obj.createdAt = message.createdAt.toISOString());
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt.toISOString());
        message.status !== undefined && (obj.status = waitlistStatusToJSON(message.status));
        message.acceptedTermsVersion !== undefined && (obj.acceptedTermsVersion = Math.round(message.acceptedTermsVersion));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmission();
        message.id = object.id ?? "";
        message.userId = object.userId ?? "";
        message.userName = object.userName ?? "";
        message.whatToBuild = object.whatToBuild ?? "";
        message.botsBuilt = object.botsBuilt ?? "";
        message.createdAt = object.createdAt ?? undefined;
        message.updatedAt = object.updatedAt ?? undefined;
        message.status = object.status ?? 0;
        message.acceptedTermsVersion = object.acceptedTermsVersion ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.admin.Submission", Submission);
function createBaseSubmissionsRequest() {
    return { limit: 0, after: undefined, before: undefined, username: undefined };
}
export const SubmissionsRequest = {
    $type: "devvit.dev_portal.admin.SubmissionsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.limit !== 0) {
            writer.uint32(8).int32(message.limit);
        }
        if (message.after !== undefined) {
            Timestamp.encode(toTimestamp(message.after), writer.uint32(18).fork()).ldelim();
        }
        if (message.before !== undefined) {
            Timestamp.encode(toTimestamp(message.before), writer.uint32(26).fork()).ldelim();
        }
        if (message.username !== undefined) {
            writer.uint32(34).string(message.username);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.limit = reader.int32();
                    break;
                case 2:
                    message.after = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.before = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            limit: isSet(object.limit) ? Number(object.limit) : 0,
            after: isSet(object.after) ? fromJsonTimestamp(object.after) : undefined,
            before: isSet(object.before) ? fromJsonTimestamp(object.before) : undefined,
            username: isSet(object.username) ? String(object.username) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.limit !== undefined && (obj.limit = Math.round(message.limit));
        message.after !== undefined && (obj.after = message.after.toISOString());
        message.before !== undefined && (obj.before = message.before.toISOString());
        message.username !== undefined && (obj.username = message.username);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmissionsRequest();
        message.limit = object.limit ?? 0;
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.username = object.username ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionsRequest", SubmissionsRequest);
function createBaseSubmissionsResponse() {
    return { submissions: [], totalSubmissions: 0, count: 0, first: undefined, last: undefined };
}
export const SubmissionsResponse = {
    $type: "devvit.dev_portal.admin.SubmissionsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.submissions) {
            Submission.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.totalSubmissions !== 0) {
            writer.uint32(16).int32(message.totalSubmissions);
        }
        if (message.count !== 0) {
            writer.uint32(24).int32(message.count);
        }
        if (message.first !== undefined) {
            Timestamp.encode(toTimestamp(message.first), writer.uint32(34).fork()).ldelim();
        }
        if (message.last !== undefined) {
            Timestamp.encode(toTimestamp(message.last), writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.submissions.push(Submission.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalSubmissions = reader.int32();
                    break;
                case 3:
                    message.count = reader.int32();
                    break;
                case 4:
                    message.first = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.last = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            submissions: Array.isArray(object?.submissions) ? object.submissions.map((e) => Submission.fromJSON(e)) : [],
            totalSubmissions: isSet(object.totalSubmissions) ? Number(object.totalSubmissions) : 0,
            count: isSet(object.count) ? Number(object.count) : 0,
            first: isSet(object.first) ? fromJsonTimestamp(object.first) : undefined,
            last: isSet(object.last) ? fromJsonTimestamp(object.last) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.submissions) {
            obj.submissions = message.submissions.map((e) => e ? Submission.toJSON(e) : undefined);
        }
        else {
            obj.submissions = [];
        }
        message.totalSubmissions !== undefined && (obj.totalSubmissions = Math.round(message.totalSubmissions));
        message.count !== undefined && (obj.count = Math.round(message.count));
        message.first !== undefined && (obj.first = message.first.toISOString());
        message.last !== undefined && (obj.last = message.last.toISOString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmissionsResponse();
        message.submissions = object.submissions?.map((e) => Submission.fromPartial(e)) || [];
        message.totalSubmissions = object.totalSubmissions ?? 0;
        message.count = object.count ?? 0;
        message.first = object.first ?? undefined;
        message.last = object.last ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionsResponse", SubmissionsResponse);
function createBaseSubmissionUpdateRequest() {
    return { id: "", status: 0 };
}
export const SubmissionUpdateRequest = {
    $type: "devvit.dev_portal.admin.SubmissionUpdateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.status !== 0) {
            writer.uint32(16).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionUpdateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            status: isSet(object.status) ? waitlistStatusFromJSON(object.status) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.status !== undefined && (obj.status = waitlistStatusToJSON(message.status));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmissionUpdateRequest();
        message.id = object.id ?? "";
        message.status = object.status ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionUpdateRequest", SubmissionUpdateRequest);
function createBaseSubmissionUpdateResponse() {
    return { success: false, message: undefined };
}
export const SubmissionUpdateResponse = {
    $type: "devvit.dev_portal.admin.SubmissionUpdateResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.success === true) {
            writer.uint32(8).bool(message.success);
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionUpdateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.success = reader.bool();
                    break;
                case 2:
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? Boolean(object.success) : false,
            message: isSet(object.message) ? String(object.message) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.success !== undefined && (obj.success = message.success);
        message.message !== undefined && (obj.message = message.message);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmissionUpdateResponse();
        message.success = object.success ?? false;
        message.message = object.message ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionUpdateResponse", SubmissionUpdateResponse);
function createBaseSubmissionAddRequest() {
    return { userId: undefined, userName: undefined };
}
export const SubmissionAddRequest = {
    $type: "devvit.dev_portal.admin.SubmissionAddRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.userId !== undefined) {
            writer.uint32(10).string(message.userId);
        }
        if (message.userName !== undefined) {
            writer.uint32(18).string(message.userName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionAddRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.userName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            userId: isSet(object.userId) ? String(object.userId) : undefined,
            userName: isSet(object.userName) ? String(object.userName) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.userId !== undefined && (obj.userId = message.userId);
        message.userName !== undefined && (obj.userName = message.userName);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmissionAddRequest();
        message.userId = object.userId ?? undefined;
        message.userName = object.userName ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionAddRequest", SubmissionAddRequest);
function createBaseSubmissionAddResponse() {
    return { success: false, message: undefined };
}
export const SubmissionAddResponse = {
    $type: "devvit.dev_portal.admin.SubmissionAddResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.success === true) {
            writer.uint32(8).bool(message.success);
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionAddResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.success = reader.bool();
                    break;
                case 2:
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? Boolean(object.success) : false,
            message: isSet(object.message) ? String(object.message) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.success !== undefined && (obj.success = message.success);
        message.message !== undefined && (obj.message = message.message);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmissionAddResponse();
        message.success = object.success ?? false;
        message.message = object.message ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionAddResponse", SubmissionAddResponse);
export class WaitlistAdminClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.dev_portal.admin.WaitlistAdmin";
        this.rpc = rpc;
        this.GetSubmissions = this.GetSubmissions.bind(this);
        this.UpdateSubmission = this.UpdateSubmission.bind(this);
        this.AddSubmission = this.AddSubmission.bind(this);
        this.ExportAsCSV = this.ExportAsCSV.bind(this);
    }
    GetSubmissions(request) {
        const data = SubmissionsRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "GetSubmissions", data);
        return promise.then((data) => SubmissionsResponse.decode(new _m0.Reader(data)));
    }
    UpdateSubmission(request) {
        const data = SubmissionUpdateRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpdateSubmission", data);
        return promise.then((data) => SubmissionUpdateResponse.decode(new _m0.Reader(data)));
    }
    AddSubmission(request) {
        const data = SubmissionAddRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "AddSubmission", data);
        return promise.then((data) => SubmissionAddResponse.decode(new _m0.Reader(data)));
    }
    ExportAsCSV(request) {
        const data = Empty.encode(request).finish();
        const promise = this.rpc.request(this.service, "ExportAsCSV", data);
        return promise.then((data) => StringValue.decode(new _m0.Reader(data)));
    }
}
export const WaitlistAdminDefinition = {
    name: "WaitlistAdmin",
    fullName: "devvit.dev_portal.admin.WaitlistAdmin",
    methods: {
        getSubmissions: {
            name: "GetSubmissions",
            requestType: SubmissionsRequest,
            requestStream: false,
            responseType: SubmissionsResponse,
            responseStream: false,
            options: {},
        },
        updateSubmission: {
            name: "UpdateSubmission",
            requestType: SubmissionUpdateRequest,
            requestStream: false,
            responseType: SubmissionUpdateResponse,
            responseStream: false,
            options: {},
        },
        addSubmission: {
            name: "AddSubmission",
            requestType: SubmissionAddRequest,
            requestStream: false,
            responseType: SubmissionAddResponse,
            responseStream: false,
            options: {},
        },
        exportAsCSV: {
            name: "ExportAsCSV",
            requestType: Empty,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
    },
};
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
