/**
 * #subreddit_metadata.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { messageTypeRegistry } from '../../typeRegistry.js';
import { ContextActionList } from '../actor/reddit/context_action.js';
import { LinkedBundle } from '../runtime/bundle.js';
function createBaseSubredditContextActions() {
    return { actorHostname: "", actions: undefined };
}
export const SubredditContextActions = {
    $type: "devvit.gql.SubredditContextActions",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actorHostname !== "") {
            writer.uint32(10).string(message.actorHostname);
        }
        if (message.actions !== undefined) {
            ContextActionList.encode(message.actions, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditContextActions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actorHostname = reader.string();
                    break;
                case 2:
                    message.actions = ContextActionList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actorHostname: isSet(object.actorHostname) ? String(object.actorHostname) : "",
            actions: isSet(object.actions) ? ContextActionList.fromJSON(object.actions) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.actorHostname !== undefined && (obj.actorHostname = message.actorHostname);
        message.actions !== undefined &&
            (obj.actions = message.actions ? ContextActionList.toJSON(message.actions) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditContextActions();
        message.actorHostname = object.actorHostname ?? "";
        message.actions = (object.actions !== undefined && object.actions !== null)
            ? ContextActionList.fromPartial(object.actions)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.gql.SubredditContextActions", SubredditContextActions);
function createBaseDevvitSubredditMetadata() {
    return { installedRemoteApps: [], contextActions: [], errors: [] };
}
export const DevvitSubredditMetadata = {
    $type: "devvit.gql.DevvitSubredditMetadata",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.installedRemoteApps) {
            LinkedBundle.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.contextActions) {
            SubredditContextActions.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.errors) {
            ErrorMessage.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDevvitSubredditMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.installedRemoteApps.push(LinkedBundle.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.contextActions.push(SubredditContextActions.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.errors.push(ErrorMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            installedRemoteApps: Array.isArray(object?.installedRemoteApps)
                ? object.installedRemoteApps.map((e) => LinkedBundle.fromJSON(e))
                : [],
            contextActions: Array.isArray(object?.contextActions)
                ? object.contextActions.map((e) => SubredditContextActions.fromJSON(e))
                : [],
            errors: Array.isArray(object?.errors) ? object.errors.map((e) => ErrorMessage.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.installedRemoteApps) {
            obj.installedRemoteApps = message.installedRemoteApps.map((e) => e ? LinkedBundle.toJSON(e) : undefined);
        }
        else {
            obj.installedRemoteApps = [];
        }
        if (message.contextActions) {
            obj.contextActions = message.contextActions.map((e) => e ? SubredditContextActions.toJSON(e) : undefined);
        }
        else {
            obj.contextActions = [];
        }
        if (message.errors) {
            obj.errors = message.errors.map((e) => e ? ErrorMessage.toJSON(e) : undefined);
        }
        else {
            obj.errors = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDevvitSubredditMetadata();
        message.installedRemoteApps = object.installedRemoteApps?.map((e) => LinkedBundle.fromPartial(e)) || [];
        message.contextActions = object.contextActions?.map((e) => SubredditContextActions.fromPartial(e)) || [];
        message.errors = object.errors?.map((e) => ErrorMessage.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.gql.DevvitSubredditMetadata", DevvitSubredditMetadata);
function createBaseErrorMessage() {
    return { message: "" };
}
export const ErrorMessage = {
    $type: "devvit.gql.ErrorMessage",
    encode(message, writer = _m0.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseErrorMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { message: isSet(object.message) ? String(object.message) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.message !== undefined && (obj.message = message.message);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseErrorMessage();
        message.message = object.message ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.gql.ErrorMessage", ErrorMessage);
function isSet(value) {
    return value !== null && value !== undefined;
}
