import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { SubmissionsRequest, SubmissionsResponse, SubmissionUpdateRequest, SubmissionUpdateResponse, SubmissionAddRequest, SubmissionAddResponse, } from './waitlist_admin.js';
import { Empty } from '../../../google/protobuf/empty.js';
import { StringValue } from '../../../google/protobuf/wrappers.js';
export var WaitlistAdminMethod;
(function (WaitlistAdminMethod) {
    WaitlistAdminMethod["GetSubmissions"] = "GetSubmissions";
    WaitlistAdminMethod["UpdateSubmission"] = "UpdateSubmission";
    WaitlistAdminMethod["AddSubmission"] = "AddSubmission";
    WaitlistAdminMethod["ExportAsCSV"] = "ExportAsCSV";
})(WaitlistAdminMethod || (WaitlistAdminMethod = {}));
export const WaitlistAdminMethodList = [
    WaitlistAdminMethod.GetSubmissions,
    WaitlistAdminMethod.UpdateSubmission,
    WaitlistAdminMethod.AddSubmission,
    WaitlistAdminMethod.ExportAsCSV,
];
export function createWaitlistAdminServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal.admin',
        serviceName: 'WaitlistAdmin',
        methodList: WaitlistAdminMethodList,
        matchRoute: matchWaitlistAdminRoute,
    });
}
function matchWaitlistAdminRoute(method, events) {
    switch (method) {
        case 'GetSubmissions':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetSubmissions' };
                await events.onMatch(ctx);
                return handleWaitlistAdminGetSubmissionsRequest(ctx, service, data, interceptors);
            };
        case 'UpdateSubmission':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpdateSubmission' };
                await events.onMatch(ctx);
                return handleWaitlistAdminUpdateSubmissionRequest(ctx, service, data, interceptors);
            };
        case 'AddSubmission':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AddSubmission' };
                await events.onMatch(ctx);
                return handleWaitlistAdminAddSubmissionRequest(ctx, service, data, interceptors);
            };
        case 'ExportAsCSV':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ExportAsCSV' };
                await events.onMatch(ctx);
                return handleWaitlistAdminExportAsCSVRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWaitlistAdminGetSubmissionsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWaitlistAdminGetSubmissionsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWaitlistAdminGetSubmissionsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWaitlistAdminUpdateSubmissionRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWaitlistAdminUpdateSubmissionJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWaitlistAdminUpdateSubmissionProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWaitlistAdminAddSubmissionRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWaitlistAdminAddSubmissionJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWaitlistAdminAddSubmissionProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWaitlistAdminExportAsCSVRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWaitlistAdminExportAsCSVJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWaitlistAdminExportAsCSVProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleWaitlistAdminGetSubmissionsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SubmissionsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetSubmissions(ctx, inputReq);
        });
    }
    else {
        response = await service.GetSubmissions(ctx, request);
    }
    return JSON.stringify(SubmissionsResponse.toJSON(response));
}
async function handleWaitlistAdminUpdateSubmissionJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SubmissionUpdateRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateSubmission(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateSubmission(ctx, request);
    }
    return JSON.stringify(SubmissionUpdateResponse.toJSON(response));
}
async function handleWaitlistAdminAddSubmissionJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SubmissionAddRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AddSubmission(ctx, inputReq);
        });
    }
    else {
        response = await service.AddSubmission(ctx, request);
    }
    return JSON.stringify(SubmissionAddResponse.toJSON(response));
}
async function handleWaitlistAdminExportAsCSVJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ExportAsCSV(ctx, inputReq);
        });
    }
    else {
        response = await service.ExportAsCSV(ctx, request);
    }
    return JSON.stringify(StringValue.toJSON(response));
}
async function handleWaitlistAdminGetSubmissionsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SubmissionsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetSubmissions(ctx, inputReq);
        });
    }
    else {
        response = await service.GetSubmissions(ctx, request);
    }
    return Buffer.from(SubmissionsResponse.encode(response).finish());
}
async function handleWaitlistAdminUpdateSubmissionProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SubmissionUpdateRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateSubmission(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateSubmission(ctx, request);
    }
    return Buffer.from(SubmissionUpdateResponse.encode(response).finish());
}
async function handleWaitlistAdminAddSubmissionProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SubmissionAddRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AddSubmission(ctx, inputReq);
        });
    }
    else {
        response = await service.AddSubmission(ctx, request);
    }
    return Buffer.from(SubmissionAddResponse.encode(response).finish());
}
async function handleWaitlistAdminExportAsCSVProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ExportAsCSV(ctx, inputReq);
        });
    }
    else {
        response = await service.ExportAsCSV(ctx, request);
    }
    return Buffer.from(StringValue.encode(response).finish());
}
