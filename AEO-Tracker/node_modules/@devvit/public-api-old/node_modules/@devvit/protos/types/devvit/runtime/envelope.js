/**
 * #envelope.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Value } from '../../google/protobuf/struct.js';
import { messageTypeRegistry } from '../../typeRegistry.js';
import { Strings } from './runtime_common.js';
function createBaseEnvelope() {
    return {
        id: "",
        src: "",
        dst: "",
        method: "",
        streamId: "",
        traceId: "",
        success: false,
        message: undefined,
        request: false,
        complete: false,
        metadata: {},
    };
}
export const Envelope = {
    $type: "devvit.runtime.Envelope",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(90).string(message.id);
        }
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.dst !== "") {
            writer.uint32(18).string(message.dst);
        }
        if (message.method !== "") {
            writer.uint32(26).string(message.method);
        }
        if (message.streamId !== "") {
            writer.uint32(34).string(message.streamId);
        }
        if (message.traceId !== "") {
            writer.uint32(82).string(message.traceId);
        }
        if (message.success === true) {
            writer.uint32(40).bool(message.success);
        }
        if (message.message !== undefined) {
            Value.encode(Value.wrap(message.message), writer.uint32(50).fork()).ldelim();
        }
        if (message.request === true) {
            writer.uint32(56).bool(message.request);
        }
        if (message.complete === true) {
            writer.uint32(64).bool(message.complete);
        }
        Object.entries(message.metadata).forEach(([key, value]) => {
            Envelope_MetadataEntry.encode({ key: key, value }, writer.uint32(74).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnvelope();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 11:
                    message.id = reader.string();
                    break;
                case 1:
                    message.src = reader.string();
                    break;
                case 2:
                    message.dst = reader.string();
                    break;
                case 3:
                    message.method = reader.string();
                    break;
                case 4:
                    message.streamId = reader.string();
                    break;
                case 10:
                    message.traceId = reader.string();
                    break;
                case 5:
                    message.success = reader.bool();
                    break;
                case 6:
                    message.message = Value.unwrap(Value.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.request = reader.bool();
                    break;
                case 8:
                    message.complete = reader.bool();
                    break;
                case 9:
                    const entry9 = Envelope_MetadataEntry.decode(reader, reader.uint32());
                    if (entry9.value !== undefined) {
                        message.metadata[entry9.key] = entry9.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            src: isSet(object.src) ? String(object.src) : "",
            dst: isSet(object.dst) ? String(object.dst) : "",
            method: isSet(object.method) ? String(object.method) : "",
            streamId: isSet(object.streamId) ? String(object.streamId) : "",
            traceId: isSet(object.traceId) ? String(object.traceId) : "",
            success: isSet(object.success) ? Boolean(object.success) : false,
            message: isSet(object?.message) ? object.message : undefined,
            request: isSet(object.request) ? Boolean(object.request) : false,
            complete: isSet(object.complete) ? Boolean(object.complete) : false,
            metadata: isObject(object.metadata)
                ? Object.entries(object.metadata).reduce((acc, [key, value]) => {
                    acc[key] = Strings.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.src !== undefined && (obj.src = message.src);
        message.dst !== undefined && (obj.dst = message.dst);
        message.method !== undefined && (obj.method = message.method);
        message.streamId !== undefined && (obj.streamId = message.streamId);
        message.traceId !== undefined && (obj.traceId = message.traceId);
        message.success !== undefined && (obj.success = message.success);
        message.message !== undefined && (obj.message = message.message);
        message.request !== undefined && (obj.request = message.request);
        message.complete !== undefined && (obj.complete = message.complete);
        obj.metadata = {};
        if (message.metadata) {
            Object.entries(message.metadata).forEach(([k, v]) => {
                obj.metadata[k] = Strings.toJSON(v);
            });
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseEnvelope();
        message.id = object.id ?? "";
        message.src = object.src ?? "";
        message.dst = object.dst ?? "";
        message.method = object.method ?? "";
        message.streamId = object.streamId ?? "";
        message.traceId = object.traceId ?? "";
        message.success = object.success ?? false;
        message.message = object.message ?? undefined;
        message.request = object.request ?? false;
        message.complete = object.complete ?? false;
        message.metadata = Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = Strings.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set("devvit.runtime.Envelope", Envelope);
function createBaseEnvelope_MetadataEntry() {
    return { key: "", value: undefined };
}
export const Envelope_MetadataEntry = {
    $type: "devvit.runtime.Envelope.MetadataEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Strings.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnvelope_MetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = Strings.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? Strings.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? Strings.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseEnvelope_MetadataEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? Strings.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.runtime.Envelope.MetadataEntry", Envelope_MetadataEntry);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
