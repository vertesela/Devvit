/**
 * #step.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Struct } from '../../../../google/protobuf/struct.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { Comment } from '../../../reddit/comment.js';
import { Post } from '../../../reddit/post.js';
import { User } from '../../../reddit/user.js';
function createBaseStepDescription() {
    return { actor: "", config: undefined };
}
export const StepDescription = {
    $type: "devvit.actor.automation.v1alpha.StepDescription",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actor !== "") {
            writer.uint32(10).string(message.actor);
        }
        if (message.config !== undefined) {
            Struct.encode(Struct.wrap(message.config), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepDescription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actor = reader.string();
                    break;
                case 2:
                    message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actor: isSet(object.actor) ? String(object.actor) : "",
            config: isObject(object.config) ? object.config : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.actor !== undefined && (obj.actor = message.actor);
        message.config !== undefined && (obj.config = message.config);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStepDescription();
        message.actor = object.actor ?? "";
        message.config = object.config ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepDescription", StepDescription);
function createBaseStepInput() {
    return { config: undefined, prev: undefined };
}
export const StepInput = {
    $type: "devvit.actor.automation.v1alpha.StepInput",
    encode(message, writer = _m0.Writer.create()) {
        if (message.config !== undefined) {
            Struct.encode(Struct.wrap(message.config), writer.uint32(10).fork()).ldelim();
        }
        if (message.prev !== undefined) {
            Struct.encode(Struct.wrap(message.prev), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.prev = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            config: isObject(object.config) ? object.config : undefined,
            prev: isObject(object.prev) ? object.prev : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.config !== undefined && (obj.config = message.config);
        message.prev !== undefined && (obj.prev = message.prev);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStepInput();
        message.config = object.config ?? undefined;
        message.prev = object.prev ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepInput", StepInput);
function createBaseStepCommentInput() {
    return { input: undefined, comment: undefined };
}
export const StepCommentInput = {
    $type: "devvit.actor.automation.v1alpha.StepCommentInput",
    encode(message, writer = _m0.Writer.create()) {
        if (message.input !== undefined) {
            StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
        }
        if (message.comment !== undefined) {
            Comment.encode(message.comment, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepCommentInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.input = StepInput.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.comment = Comment.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            input: isSet(object.input) ? StepInput.fromJSON(object.input) : undefined,
            comment: isSet(object.comment) ? Comment.fromJSON(object.comment) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.input !== undefined && (obj.input = message.input ? StepInput.toJSON(message.input) : undefined);
        message.comment !== undefined && (obj.comment = message.comment ? Comment.toJSON(message.comment) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStepCommentInput();
        message.input = (object.input !== undefined && object.input !== null)
            ? StepInput.fromPartial(object.input)
            : undefined;
        message.comment = (object.comment !== undefined && object.comment !== null)
            ? Comment.fromPartial(object.comment)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepCommentInput", StepCommentInput);
function createBaseStepPostInput() {
    return { input: undefined, post: undefined };
}
export const StepPostInput = {
    $type: "devvit.actor.automation.v1alpha.StepPostInput",
    encode(message, writer = _m0.Writer.create()) {
        if (message.input !== undefined) {
            StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
        }
        if (message.post !== undefined) {
            Post.encode(message.post, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepPostInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.input = StepInput.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.post = Post.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            input: isSet(object.input) ? StepInput.fromJSON(object.input) : undefined,
            post: isSet(object.post) ? Post.fromJSON(object.post) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.input !== undefined && (obj.input = message.input ? StepInput.toJSON(message.input) : undefined);
        message.post !== undefined && (obj.post = message.post ? Post.toJSON(message.post) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStepPostInput();
        message.input = (object.input !== undefined && object.input !== null)
            ? StepInput.fromPartial(object.input)
            : undefined;
        message.post = (object.post !== undefined && object.post !== null) ? Post.fromPartial(object.post) : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepPostInput", StepPostInput);
function createBaseStepUserInput() {
    return { input: undefined, user: undefined };
}
export const StepUserInput = {
    $type: "devvit.actor.automation.v1alpha.StepUserInput",
    encode(message, writer = _m0.Writer.create()) {
        if (message.input !== undefined) {
            StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
        }
        if (message.user !== undefined) {
            User.encode(message.user, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepUserInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.input = StepInput.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.user = User.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            input: isSet(object.input) ? StepInput.fromJSON(object.input) : undefined,
            user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.input !== undefined && (obj.input = message.input ? StepInput.toJSON(message.input) : undefined);
        message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStepUserInput();
        message.input = (object.input !== undefined && object.input !== null)
            ? StepInput.fromPartial(object.input)
            : undefined;
        message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepUserInput", StepUserInput);
function createBaseStepResult() {
    return { output: undefined, stop: false };
}
export const StepResult = {
    $type: "devvit.actor.automation.v1alpha.StepResult",
    encode(message, writer = _m0.Writer.create()) {
        if (message.output !== undefined) {
            Struct.encode(Struct.wrap(message.output), writer.uint32(10).fork()).ldelim();
        }
        if (message.stop === true) {
            writer.uint32(16).bool(message.stop);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.output = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.stop = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            output: isObject(object.output) ? object.output : undefined,
            stop: isSet(object.stop) ? Boolean(object.stop) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.output !== undefined && (obj.output = message.output);
        message.stop !== undefined && (obj.stop = message.stop);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStepResult();
        message.output = object.output ?? undefined;
        message.stop = object.stop ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepResult", StepResult);
function createBaseStepReport() {
    return { actor: "", message: "", duration: 0, success: false, data: undefined };
}
export const StepReport = {
    $type: "devvit.actor.automation.v1alpha.StepReport",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actor !== "") {
            writer.uint32(10).string(message.actor);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.duration !== 0) {
            writer.uint32(29).float(message.duration);
        }
        if (message.success === true) {
            writer.uint32(32).bool(message.success);
        }
        if (message.data !== undefined) {
            StepResult.encode(message.data, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStepReport();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actor = reader.string();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.duration = reader.float();
                    break;
                case 4:
                    message.success = reader.bool();
                    break;
                case 5:
                    message.data = StepResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actor: isSet(object.actor) ? String(object.actor) : "",
            message: isSet(object.message) ? String(object.message) : "",
            duration: isSet(object.duration) ? Number(object.duration) : 0,
            success: isSet(object.success) ? Boolean(object.success) : false,
            data: isSet(object.data) ? StepResult.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.actor !== undefined && (obj.actor = message.actor);
        message.message !== undefined && (obj.message = message.message);
        message.duration !== undefined && (obj.duration = message.duration);
        message.success !== undefined && (obj.success = message.success);
        message.data !== undefined && (obj.data = message.data ? StepResult.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStepReport();
        message.actor = object.actor ?? "";
        message.message = object.message ?? "";
        message.duration = object.duration ?? 0;
        message.success = object.success ?? false;
        message.data = (object.data !== undefined && object.data !== null)
            ? StepResult.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepReport", StepReport);
export class CommentStepClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.actor.automation.v1alpha.CommentStep";
        this.rpc = rpc;
        this.Invoke = this.Invoke.bind(this);
    }
    Invoke(request) {
        const data = StepCommentInput.encode(request).finish();
        const promise = this.rpc.request(this.service, "Invoke", data);
        return promise.then((data) => StepResult.decode(new _m0.Reader(data)));
    }
}
export const CommentStepDefinition = {
    name: "CommentStep",
    fullName: "devvit.actor.automation.v1alpha.CommentStep",
    methods: {
        invoke: {
            name: "Invoke",
            requestType: StepCommentInput,
            requestStream: false,
            responseType: StepResult,
            responseStream: false,
            options: {},
        },
    },
};
export class PostStepClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.actor.automation.v1alpha.PostStep";
        this.rpc = rpc;
        this.Invoke = this.Invoke.bind(this);
    }
    Invoke(request) {
        const data = StepPostInput.encode(request).finish();
        const promise = this.rpc.request(this.service, "Invoke", data);
        return promise.then((data) => StepResult.decode(new _m0.Reader(data)));
    }
}
export const PostStepDefinition = {
    name: "PostStep",
    fullName: "devvit.actor.automation.v1alpha.PostStep",
    methods: {
        invoke: {
            name: "Invoke",
            requestType: StepPostInput,
            requestStream: false,
            responseType: StepResult,
            responseStream: false,
            options: {},
        },
    },
};
export class UserStepClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.actor.automation.v1alpha.UserStep";
        this.rpc = rpc;
        this.Invoke = this.Invoke.bind(this);
    }
    Invoke(request) {
        const data = StepUserInput.encode(request).finish();
        const promise = this.rpc.request(this.service, "Invoke", data);
        return promise.then((data) => StepResult.decode(new _m0.Reader(data)));
    }
}
export const UserStepDefinition = {
    name: "UserStep",
    fullName: "devvit.actor.automation.v1alpha.UserStep",
    methods: {
        invoke: {
            name: "Invoke",
            requestType: StepUserInput,
            requestStream: false,
            responseType: StepResult,
            responseStream: false,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
