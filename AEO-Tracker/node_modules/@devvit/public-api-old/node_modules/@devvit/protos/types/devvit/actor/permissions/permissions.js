/**
 * #permissions.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
export var Permission;
(function (Permission) {
    Permission[Permission["SYSTEM"] = 0] = "SYSTEM";
    Permission[Permission["HTTP"] = 1] = "HTTP";
    Permission[Permission["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Permission || (Permission = {}));
export function permissionFromJSON(object) {
    switch (object) {
        case 0:
        case "SYSTEM":
            return Permission.SYSTEM;
        case 1:
        case "HTTP":
            return Permission.HTTP;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Permission.UNRECOGNIZED;
    }
}
export function permissionToJSON(object) {
    switch (object) {
        case Permission.SYSTEM:
            return 0;
        case Permission.HTTP:
            return 1;
        case Permission.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseNestedRule() {
    return { requires: [] };
}
export const NestedRule = {
    $type: "devvit.actor.permissions.NestedRule",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.requires) {
            PermissionOrRule.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNestedRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requires.push(PermissionOrRule.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            requires: Array.isArray(object?.requires) ? object.requires.map((e) => PermissionOrRule.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.requires) {
            obj.requires = message.requires.map((e) => e ? PermissionOrRule.toJSON(e) : undefined);
        }
        else {
            obj.requires = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseNestedRule();
        message.requires = object.requires?.map((e) => PermissionOrRule.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.permissions.NestedRule", NestedRule);
function createBasePermissionOrRule() {
    return { permission: undefined, and: undefined, or: undefined };
}
export const PermissionOrRule = {
    $type: "devvit.actor.permissions.PermissionOrRule",
    encode(message, writer = _m0.Writer.create()) {
        if (message.permission !== undefined) {
            writer.uint32(8).int32(message.permission);
        }
        if (message.and !== undefined) {
            NestedRule.encode(message.and, writer.uint32(18).fork()).ldelim();
        }
        if (message.or !== undefined) {
            NestedRule.encode(message.or, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePermissionOrRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.permission = reader.int32();
                    break;
                case 2:
                    message.and = NestedRule.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.or = NestedRule.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            permission: isSet(object.permission) ? permissionFromJSON(object.permission) : undefined,
            and: isSet(object.and) ? NestedRule.fromJSON(object.and) : undefined,
            or: isSet(object.or) ? NestedRule.fromJSON(object.or) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.permission !== undefined &&
            (obj.permission = message.permission !== undefined ? permissionToJSON(message.permission) : undefined);
        message.and !== undefined && (obj.and = message.and ? NestedRule.toJSON(message.and) : undefined);
        message.or !== undefined && (obj.or = message.or ? NestedRule.toJSON(message.or) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePermissionOrRule();
        message.permission = object.permission ?? undefined;
        message.and = (object.and !== undefined && object.and !== null) ? NestedRule.fromPartial(object.and) : undefined;
        message.or = (object.or !== undefined && object.or !== null) ? NestedRule.fromPartial(object.or) : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.permissions.PermissionOrRule", PermissionOrRule);
function createBasePermissionConfig() {
    return { actor: "", has: [], requires: [] };
}
export const PermissionConfig = {
    $type: "devvit.actor.permissions.PermissionConfig",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actor !== "") {
            writer.uint32(10).string(message.actor);
        }
        writer.uint32(18).fork();
        for (const v of message.has) {
            writer.int32(v);
        }
        writer.ldelim();
        for (const v of message.requires) {
            PermissionOrRule.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePermissionConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actor = reader.string();
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.has.push(reader.int32());
                        }
                    }
                    else {
                        message.has.push(reader.int32());
                    }
                    break;
                case 3:
                    message.requires.push(PermissionOrRule.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actor: isSet(object.actor) ? String(object.actor) : "",
            has: Array.isArray(object?.has) ? object.has.map((e) => permissionFromJSON(e)) : [],
            requires: Array.isArray(object?.requires) ? object.requires.map((e) => PermissionOrRule.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.actor !== undefined && (obj.actor = message.actor);
        if (message.has) {
            obj.has = message.has.map((e) => permissionToJSON(e));
        }
        else {
            obj.has = [];
        }
        if (message.requires) {
            obj.requires = message.requires.map((e) => e ? PermissionOrRule.toJSON(e) : undefined);
        }
        else {
            obj.requires = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBasePermissionConfig();
        message.actor = object.actor ?? "";
        message.has = object.has?.map((e) => e) || [];
        message.requires = object.requires?.map((e) => PermissionOrRule.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.permissions.PermissionConfig", PermissionConfig);
function createBasePermissionList() {
    return { permissions: [] };
}
export const PermissionList = {
    $type: "devvit.actor.permissions.PermissionList",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.permissions) {
            PermissionConfig.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePermissionList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.permissions.push(PermissionConfig.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            permissions: Array.isArray(object?.permissions)
                ? object.permissions.map((e) => PermissionConfig.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.permissions) {
            obj.permissions = message.permissions.map((e) => e ? PermissionConfig.toJSON(e) : undefined);
        }
        else {
            obj.permissions = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBasePermissionList();
        message.permissions = object.permissions?.map((e) => PermissionConfig.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.permissions.PermissionList", PermissionList);
function isSet(value) {
    return value !== null && value !== undefined;
}
