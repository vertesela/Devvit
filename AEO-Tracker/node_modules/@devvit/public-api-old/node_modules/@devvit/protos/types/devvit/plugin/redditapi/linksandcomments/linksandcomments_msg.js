/**
 * #linksandcomments_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Any } from '../../../../google/protobuf/any.js';
import { BoolValue, Int32Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { Comment } from '../../../reddit/comment.js';
function createBaseCommentRequest() {
    return { richtextJson: undefined, text: "", thingId: "" };
}
export const CommentRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.CommentRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.richtextJson !== undefined) {
            StringValue.encode({ value: message.richtextJson }, writer.uint32(10).fork()).ldelim();
        }
        if (message.text !== "") {
            writer.uint32(18).string(message.text);
        }
        if (message.thingId !== "") {
            writer.uint32(26).string(message.thingId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommentRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.richtextJson = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.thingId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            richtextJson: isSet(object.richtextJson) ? String(object.richtextJson) : undefined,
            text: isSet(object.text) ? String(object.text) : "",
            thingId: isSet(object.thingId) ? String(object.thingId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.richtextJson !== undefined && (obj.richtextJson = message.richtextJson);
        message.text !== undefined && (obj.text = message.text);
        message.thingId !== undefined && (obj.thingId = message.thingId);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCommentRequest();
        message.richtextJson = object.richtextJson ?? undefined;
        message.text = object.text ?? "";
        message.thingId = object.thingId ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.CommentRequest", CommentRequest);
function createBaseFollowPostRequest() {
    return { follow: false, fullname: "" };
}
export const FollowPostRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.FollowPostRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.follow === true) {
            writer.uint32(8).bool(message.follow);
        }
        if (message.fullname !== "") {
            writer.uint32(18).string(message.fullname);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFollowPostRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.follow = reader.bool();
                    break;
                case 2:
                    message.fullname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            follow: isSet(object.follow) ? Boolean(object.follow) : false,
            fullname: isSet(object.fullname) ? String(object.fullname) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.follow !== undefined && (obj.follow = message.follow);
        message.fullname !== undefined && (obj.fullname = message.fullname);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFollowPostRequest();
        message.follow = object.follow ?? false;
        message.fullname = object.fullname ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.FollowPostRequest", FollowPostRequest);
function createBaseBasicIdRequest() {
    return { id: "" };
}
export const BasicIdRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBasicIdRequest();
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.BasicIdRequest", BasicIdRequest);
function createBaseInfoRequest() {
    return { subreddits: [], thingIds: [], url: undefined };
}
export const InfoRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.InfoRequest",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.subreddits) {
            writer.uint32(10).string(v);
        }
        for (const v of message.thingIds) {
            writer.uint32(18).string(v);
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddits.push(reader.string());
                    break;
                case 2:
                    message.thingIds.push(reader.string());
                    break;
                case 3:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddits: Array.isArray(object?.subreddits) ? object.subreddits.map((e) => String(e)) : [],
            thingIds: Array.isArray(object?.thingIds) ? object.thingIds.map((e) => String(e)) : [],
            url: isSet(object.url) ? String(object.url) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddits) {
            obj.subreddits = message.subreddits.map((e) => e);
        }
        else {
            obj.subreddits = [];
        }
        if (message.thingIds) {
            obj.thingIds = message.thingIds.map((e) => e);
        }
        else {
            obj.thingIds = [];
        }
        message.url !== undefined && (obj.url = message.url);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseInfoRequest();
        message.subreddits = object.subreddits?.map((e) => e) || [];
        message.thingIds = object.thingIds?.map((e) => e) || [];
        message.url = object.url ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.InfoRequest", InfoRequest);
function createBaseMoreChildrenRequest() {
    return { children: [], depth: undefined, limitChildren: undefined, linkId: "", sort: undefined, id: undefined };
}
export const MoreChildrenRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.MoreChildrenRequest",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.children) {
            writer.uint32(10).string(v);
        }
        if (message.depth !== undefined) {
            Int32Value.encode({ value: message.depth }, writer.uint32(18).fork()).ldelim();
        }
        if (message.limitChildren !== undefined) {
            BoolValue.encode({ value: message.limitChildren }, writer.uint32(34).fork()).ldelim();
        }
        if (message.linkId !== "") {
            writer.uint32(42).string(message.linkId);
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(50).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMoreChildrenRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.children.push(reader.string());
                    break;
                case 2:
                    message.depth = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limitChildren = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.linkId = reader.string();
                    break;
                case 6:
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            children: Array.isArray(object?.children) ? object.children.map((e) => String(e)) : [],
            depth: isSet(object.depth) ? Number(object.depth) : undefined,
            limitChildren: isSet(object.limitChildren) ? Boolean(object.limitChildren) : undefined,
            linkId: isSet(object.linkId) ? String(object.linkId) : "",
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.children) {
            obj.children = message.children.map((e) => e);
        }
        else {
            obj.children = [];
        }
        message.depth !== undefined && (obj.depth = message.depth);
        message.limitChildren !== undefined && (obj.limitChildren = message.limitChildren);
        message.linkId !== undefined && (obj.linkId = message.linkId);
        message.sort !== undefined && (obj.sort = message.sort);
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMoreChildrenRequest();
        message.children = object.children?.map((e) => e) || [];
        message.depth = object.depth ?? undefined;
        message.limitChildren = object.limitChildren ?? undefined;
        message.linkId = object.linkId ?? "";
        message.sort = object.sort ?? undefined;
        message.id = object.id ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.MoreChildrenRequest", MoreChildrenRequest);
function createBaseReportRequest() {
    return {
        additionalInfo: undefined,
        customText: undefined,
        modmailConvId: undefined,
        otherReason: undefined,
        reason: "",
        ruleReason: undefined,
        siteReason: undefined,
        srName: undefined,
        thingId: "",
        usernames: undefined,
    };
}
export const ReportRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.ReportRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.additionalInfo !== undefined) {
            StringValue.encode({ value: message.additionalInfo }, writer.uint32(10).fork()).ldelim();
        }
        if (message.customText !== undefined) {
            StringValue.encode({ value: message.customText }, writer.uint32(18).fork()).ldelim();
        }
        if (message.modmailConvId !== undefined) {
            StringValue.encode({ value: message.modmailConvId }, writer.uint32(42).fork()).ldelim();
        }
        if (message.otherReason !== undefined) {
            StringValue.encode({ value: message.otherReason }, writer.uint32(50).fork()).ldelim();
        }
        if (message.reason !== "") {
            writer.uint32(58).string(message.reason);
        }
        if (message.ruleReason !== undefined) {
            StringValue.encode({ value: message.ruleReason }, writer.uint32(66).fork()).ldelim();
        }
        if (message.siteReason !== undefined) {
            StringValue.encode({ value: message.siteReason }, writer.uint32(74).fork()).ldelim();
        }
        if (message.srName !== undefined) {
            StringValue.encode({ value: message.srName }, writer.uint32(82).fork()).ldelim();
        }
        if (message.thingId !== "") {
            writer.uint32(90).string(message.thingId);
        }
        if (message.usernames !== undefined) {
            StringValue.encode({ value: message.usernames }, writer.uint32(98).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReportRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.additionalInfo = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.customText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.modmailConvId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.otherReason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.reason = reader.string();
                    break;
                case 8:
                    message.ruleReason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.siteReason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.srName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.thingId = reader.string();
                    break;
                case 12:
                    message.usernames = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            additionalInfo: isSet(object.additionalInfo) ? String(object.additionalInfo) : undefined,
            customText: isSet(object.customText) ? String(object.customText) : undefined,
            modmailConvId: isSet(object.modmailConvId) ? String(object.modmailConvId) : undefined,
            otherReason: isSet(object.otherReason) ? String(object.otherReason) : undefined,
            reason: isSet(object.reason) ? String(object.reason) : "",
            ruleReason: isSet(object.ruleReason) ? String(object.ruleReason) : undefined,
            siteReason: isSet(object.siteReason) ? String(object.siteReason) : undefined,
            srName: isSet(object.srName) ? String(object.srName) : undefined,
            thingId: isSet(object.thingId) ? String(object.thingId) : "",
            usernames: isSet(object.usernames) ? String(object.usernames) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.additionalInfo !== undefined && (obj.additionalInfo = message.additionalInfo);
        message.customText !== undefined && (obj.customText = message.customText);
        message.modmailConvId !== undefined && (obj.modmailConvId = message.modmailConvId);
        message.otherReason !== undefined && (obj.otherReason = message.otherReason);
        message.reason !== undefined && (obj.reason = message.reason);
        message.ruleReason !== undefined && (obj.ruleReason = message.ruleReason);
        message.siteReason !== undefined && (obj.siteReason = message.siteReason);
        message.srName !== undefined && (obj.srName = message.srName);
        message.thingId !== undefined && (obj.thingId = message.thingId);
        message.usernames !== undefined && (obj.usernames = message.usernames);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseReportRequest();
        message.additionalInfo = object.additionalInfo ?? undefined;
        message.customText = object.customText ?? undefined;
        message.modmailConvId = object.modmailConvId ?? undefined;
        message.otherReason = object.otherReason ?? undefined;
        message.reason = object.reason ?? "";
        message.ruleReason = object.ruleReason ?? undefined;
        message.siteReason = object.siteReason ?? undefined;
        message.srName = object.srName ?? undefined;
        message.thingId = object.thingId ?? "";
        message.usernames = object.usernames ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.ReportRequest", ReportRequest);
function createBaseReportAwardRequest() {
    return { awardId: "", reason: undefined };
}
export const ReportAwardRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.ReportAwardRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.awardId !== "") {
            writer.uint32(10).string(message.awardId);
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReportAwardRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.awardId = reader.string();
                    break;
                case 2:
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            awardId: isSet(object.awardId) ? String(object.awardId) : "",
            reason: isSet(object.reason) ? String(object.reason) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.awardId !== undefined && (obj.awardId = message.awardId);
        message.reason !== undefined && (obj.reason = message.reason);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseReportAwardRequest();
        message.awardId = object.awardId ?? "";
        message.reason = object.reason ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.ReportAwardRequest", ReportAwardRequest);
function createBaseSaveRequest() {
    return { id: "" };
}
export const SaveRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.SaveRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSaveRequest();
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SaveRequest", SaveRequest);
function createBaseSendRepliesRequest() {
    return { id: "", state: false };
}
export const SendRepliesRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.SendRepliesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.state === true) {
            writer.uint32(16).bool(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendRepliesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.state = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            state: isSet(object.state) ? Boolean(object.state) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.state !== undefined && (obj.state = message.state);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSendRepliesRequest();
        message.id = object.id ?? "";
        message.state = object.state ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SendRepliesRequest", SendRepliesRequest);
function createBaseSetContestModeRequest() {
    return { id: "", state: false };
}
export const SetContestModeRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.SetContestModeRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.state === true) {
            writer.uint32(16).bool(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetContestModeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.state = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            state: isSet(object.state) ? Boolean(object.state) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.state !== undefined && (obj.state = message.state);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSetContestModeRequest();
        message.id = object.id ?? "";
        message.state = object.state ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SetContestModeRequest", SetContestModeRequest);
function createBaseSetSubredditStickyRequest() {
    return { id: "", num: undefined, state: false, toProfile: undefined };
}
export const SetSubredditStickyRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.SetSubredditStickyRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.num !== undefined) {
            Int32Value.encode({ value: message.num }, writer.uint32(18).fork()).ldelim();
        }
        if (message.state === true) {
            writer.uint32(24).bool(message.state);
        }
        if (message.toProfile !== undefined) {
            BoolValue.encode({ value: message.toProfile }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSubredditStickyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.num = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.state = reader.bool();
                    break;
                case 4:
                    message.toProfile = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            num: isSet(object.num) ? Number(object.num) : undefined,
            state: isSet(object.state) ? Boolean(object.state) : false,
            toProfile: isSet(object.toProfile) ? Boolean(object.toProfile) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.num !== undefined && (obj.num = message.num);
        message.state !== undefined && (obj.state = message.state);
        message.toProfile !== undefined && (obj.toProfile = message.toProfile);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSetSubredditStickyRequest();
        message.id = object.id ?? "";
        message.num = object.num ?? undefined;
        message.state = object.state ?? false;
        message.toProfile = object.toProfile ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SetSubredditStickyRequest", SetSubredditStickyRequest);
function createBaseSetSuggestedSortRequest() {
    return { id: "", sort: "" };
}
export const SetSuggestedSortRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.SetSuggestedSortRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.sort !== "") {
            writer.uint32(18).string(message.sort);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSuggestedSortRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.sort = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "", sort: isSet(object.sort) ? String(object.sort) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.sort !== undefined && (obj.sort = message.sort);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSetSuggestedSortRequest();
        message.id = object.id ?? "";
        message.sort = object.sort ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SetSuggestedSortRequest", SetSuggestedSortRequest);
function createBaseSubmitRequest() {
    return {
        collectionId: undefined,
        flairId: undefined,
        flairText: undefined,
        kind: "",
        nsfw: undefined,
        richtextJson: undefined,
        sendreplies: undefined,
        spoiler: undefined,
        sr: "",
        text: undefined,
        title: "",
        url: undefined,
        videoPosterUrl: undefined,
        crosspostFullname: undefined,
    };
}
export const SubmitRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.SubmitRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.collectionId !== undefined) {
            StringValue.encode({ value: message.collectionId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.flairId !== undefined) {
            StringValue.encode({ value: message.flairId }, writer.uint32(58).fork()).ldelim();
        }
        if (message.flairText !== undefined) {
            StringValue.encode({ value: message.flairText }, writer.uint32(66).fork()).ldelim();
        }
        if (message.kind !== "") {
            writer.uint32(74).string(message.kind);
        }
        if (message.nsfw !== undefined) {
            BoolValue.encode({ value: message.nsfw }, writer.uint32(82).fork()).ldelim();
        }
        if (message.richtextJson !== undefined) {
            StringValue.encode({ value: message.richtextJson }, writer.uint32(98).fork()).ldelim();
        }
        if (message.sendreplies !== undefined) {
            BoolValue.encode({ value: message.sendreplies }, writer.uint32(106).fork()).ldelim();
        }
        if (message.spoiler !== undefined) {
            BoolValue.encode({ value: message.spoiler }, writer.uint32(114).fork()).ldelim();
        }
        if (message.sr !== "") {
            writer.uint32(122).string(message.sr);
        }
        if (message.text !== undefined) {
            StringValue.encode({ value: message.text }, writer.uint32(130).fork()).ldelim();
        }
        if (message.title !== "") {
            writer.uint32(138).string(message.title);
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(146).fork()).ldelim();
        }
        if (message.videoPosterUrl !== undefined) {
            StringValue.encode({ value: message.videoPosterUrl }, writer.uint32(154).fork()).ldelim();
        }
        if (message.crosspostFullname !== undefined) {
            StringValue.encode({ value: message.crosspostFullname }, writer.uint32(162).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmitRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.collectionId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.flairId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.flairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.kind = reader.string();
                    break;
                case 10:
                    message.nsfw = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.richtextJson = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.sendreplies = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.spoiler = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.sr = reader.string();
                    break;
                case 16:
                    message.text = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.title = reader.string();
                    break;
                case 18:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.videoPosterUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.crosspostFullname = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            collectionId: isSet(object.collectionId) ? String(object.collectionId) : undefined,
            flairId: isSet(object.flairId) ? String(object.flairId) : undefined,
            flairText: isSet(object.flairText) ? String(object.flairText) : undefined,
            kind: isSet(object.kind) ? String(object.kind) : "",
            nsfw: isSet(object.nsfw) ? Boolean(object.nsfw) : undefined,
            richtextJson: isSet(object.richtextJson) ? String(object.richtextJson) : undefined,
            sendreplies: isSet(object.sendreplies) ? Boolean(object.sendreplies) : undefined,
            spoiler: isSet(object.spoiler) ? Boolean(object.spoiler) : undefined,
            sr: isSet(object.sr) ? String(object.sr) : "",
            text: isSet(object.text) ? String(object.text) : undefined,
            title: isSet(object.title) ? String(object.title) : "",
            url: isSet(object.url) ? String(object.url) : undefined,
            videoPosterUrl: isSet(object.videoPosterUrl) ? String(object.videoPosterUrl) : undefined,
            crosspostFullname: isSet(object.crosspostFullname) ? String(object.crosspostFullname) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.collectionId !== undefined && (obj.collectionId = message.collectionId);
        message.flairId !== undefined && (obj.flairId = message.flairId);
        message.flairText !== undefined && (obj.flairText = message.flairText);
        message.kind !== undefined && (obj.kind = message.kind);
        message.nsfw !== undefined && (obj.nsfw = message.nsfw);
        message.richtextJson !== undefined && (obj.richtextJson = message.richtextJson);
        message.sendreplies !== undefined && (obj.sendreplies = message.sendreplies);
        message.spoiler !== undefined && (obj.spoiler = message.spoiler);
        message.sr !== undefined && (obj.sr = message.sr);
        message.text !== undefined && (obj.text = message.text);
        message.title !== undefined && (obj.title = message.title);
        message.url !== undefined && (obj.url = message.url);
        message.videoPosterUrl !== undefined && (obj.videoPosterUrl = message.videoPosterUrl);
        message.crosspostFullname !== undefined && (obj.crosspostFullname = message.crosspostFullname);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmitRequest();
        message.collectionId = object.collectionId ?? undefined;
        message.flairId = object.flairId ?? undefined;
        message.flairText = object.flairText ?? undefined;
        message.kind = object.kind ?? "";
        message.nsfw = object.nsfw ?? undefined;
        message.richtextJson = object.richtextJson ?? undefined;
        message.sendreplies = object.sendreplies ?? undefined;
        message.spoiler = object.spoiler ?? undefined;
        message.sr = object.sr ?? "";
        message.text = object.text ?? undefined;
        message.title = object.title ?? "";
        message.url = object.url ?? undefined;
        message.videoPosterUrl = object.videoPosterUrl ?? undefined;
        message.crosspostFullname = object.crosspostFullname ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SubmitRequest", SubmitRequest);
function createBaseVoteRequest() {
    return { dir: 0, id: "" };
}
export const VoteRequest = {
    $type: "devvit.plugin.redditapi.linksandcomments.VoteRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.dir !== 0) {
            writer.uint32(8).int32(message.dir);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVoteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dir = reader.int32();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { dir: isSet(object.dir) ? Number(object.dir) : 0, id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.dir !== undefined && (obj.dir = Math.round(message.dir));
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseVoteRequest();
        message.dir = object.dir ?? 0;
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.VoteRequest", VoteRequest);
function createBaseJsonWrappedComment() {
    return { json: undefined };
}
export const JsonWrappedComment = {
    $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment",
    encode(message, writer = _m0.Writer.create()) {
        if (message.json !== undefined) {
            JsonWrappedComment_Json.encode(message.json, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonWrappedComment();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.json = JsonWrappedComment_Json.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { json: isSet(object.json) ? JsonWrappedComment_Json.fromJSON(object.json) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.json !== undefined && (obj.json = message.json ? JsonWrappedComment_Json.toJSON(message.json) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseJsonWrappedComment();
        message.json = (object.json !== undefined && object.json !== null)
            ? JsonWrappedComment_Json.fromPartial(object.json)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.JsonWrappedComment", JsonWrappedComment);
function createBaseJsonWrappedComment_WrappedComment() {
    return { kind: "", data: undefined };
}
export const JsonWrappedComment_WrappedComment = {
    $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.WrappedComment",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            Comment.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonWrappedComment_WrappedComment();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = Comment.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? Comment.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined && (obj.data = message.data ? Comment.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseJsonWrappedComment_WrappedComment();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null) ? Comment.fromPartial(object.data) : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.WrappedComment", JsonWrappedComment_WrappedComment);
function createBaseJsonWrappedComment_JsonData() {
    return { things: [] };
}
export const JsonWrappedComment_JsonData = {
    $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.JsonData",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.things) {
            JsonWrappedComment_WrappedComment.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonWrappedComment_JsonData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.things.push(JsonWrappedComment_WrappedComment.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            things: Array.isArray(object?.things)
                ? object.things.map((e) => JsonWrappedComment_WrappedComment.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.things) {
            obj.things = message.things.map((e) => e ? JsonWrappedComment_WrappedComment.toJSON(e) : undefined);
        }
        else {
            obj.things = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseJsonWrappedComment_JsonData();
        message.things = object.things?.map((e) => JsonWrappedComment_WrappedComment.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.JsonData", JsonWrappedComment_JsonData);
function createBaseJsonWrappedComment_Json() {
    return { errors: [], data: undefined };
}
export const JsonWrappedComment_Json = {
    $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.Json",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.errors) {
            writer.uint32(10).string(v);
        }
        if (message.data !== undefined) {
            JsonWrappedComment_JsonData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonWrappedComment_Json();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.errors.push(reader.string());
                    break;
                case 2:
                    message.data = JsonWrappedComment_JsonData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            errors: Array.isArray(object?.errors) ? object.errors.map((e) => String(e)) : [],
            data: isSet(object.data) ? JsonWrappedComment_JsonData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.errors) {
            obj.errors = message.errors.map((e) => e);
        }
        else {
            obj.errors = [];
        }
        message.data !== undefined &&
            (obj.data = message.data ? JsonWrappedComment_JsonData.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseJsonWrappedComment_Json();
        message.errors = object.errors?.map((e) => e) || [];
        message.data = (object.data !== undefined && object.data !== null)
            ? JsonWrappedComment_JsonData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.Json", JsonWrappedComment_Json);
function createBaseSubmitResponse() {
    return { json: undefined };
}
export const SubmitResponse = {
    $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.json !== undefined) {
            SubmitResponse_JsonType.encode(message.json, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmitResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 4:
                    message.json = SubmitResponse_JsonType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { json: isSet(object.json) ? SubmitResponse_JsonType.fromJSON(object.json) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.json !== undefined && (obj.json = message.json ? SubmitResponse_JsonType.toJSON(message.json) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmitResponse();
        message.json = (object.json !== undefined && object.json !== null)
            ? SubmitResponse_JsonType.fromPartial(object.json)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SubmitResponse", SubmitResponse);
function createBaseSubmitResponse_JsonType() {
    return { errors: [], data: undefined };
}
export const SubmitResponse_JsonType = {
    $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.errors) {
            Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            SubmitResponse_JsonType_JsonData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmitResponse_JsonType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.errors.push(Any.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.data = SubmitResponse_JsonType_JsonData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            errors: Array.isArray(object?.errors) ? object.errors.map((e) => Any.fromJSON(e)) : [],
            data: isSet(object.data) ? SubmitResponse_JsonType_JsonData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.errors) {
            obj.errors = message.errors.map((e) => e ? Any.toJSON(e) : undefined);
        }
        else {
            obj.errors = [];
        }
        message.data !== undefined &&
            (obj.data = message.data ? SubmitResponse_JsonType_JsonData.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmitResponse_JsonType();
        message.errors = object.errors?.map((e) => Any.fromPartial(e)) || [];
        message.data = (object.data !== undefined && object.data !== null)
            ? SubmitResponse_JsonType_JsonData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType", SubmitResponse_JsonType);
function createBaseSubmitResponse_JsonType_JsonData() {
    return { url: undefined, draftsCount: undefined, id: undefined, name: undefined };
}
export const SubmitResponse_JsonType_JsonData = {
    $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType.JsonData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(10).fork()).ldelim();
        }
        if (message.draftsCount !== undefined) {
            Int32Value.encode({ value: message.draftsCount }, writer.uint32(18).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmitResponse_JsonType_JsonData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.draftsCount = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            url: isSet(object.url) ? String(object.url) : undefined,
            draftsCount: isSet(object.draftsCount) ? Number(object.draftsCount) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        message.draftsCount !== undefined && (obj.draftsCount = message.draftsCount);
        message.id !== undefined && (obj.id = message.id);
        message.name !== undefined && (obj.name = message.name);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmitResponse_JsonType_JsonData();
        message.url = object.url ?? undefined;
        message.draftsCount = object.draftsCount ?? undefined;
        message.id = object.id ?? undefined;
        message.name = object.name ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType.JsonData", SubmitResponse_JsonType_JsonData);
function isSet(value) {
    return value !== null && value !== undefined;
}
