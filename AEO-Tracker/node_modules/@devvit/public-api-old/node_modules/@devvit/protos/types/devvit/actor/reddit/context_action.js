/**
 * #context_action.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Empty } from '../../../google/protobuf/empty.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
import { RedditObject, SubredditObject } from '../../plugin/redditapi/common/common_msg.js';
import { Effect } from '../../ui/effects/v1alpha/effect.js';
import { ConfigForm } from '../user_configurable/user_configurable.js';
import { contextTypeFromJSON, contextTypeToJSON } from './context_type.js';
function createBaseContextActionAllowedContexts() {
    return { post: false, comment: false, subreddit: false };
}
export const ContextActionAllowedContexts = {
    $type: "devvit.actor.reddit.ContextActionAllowedContexts",
    encode(message, writer = _m0.Writer.create()) {
        if (message.post === true) {
            writer.uint32(8).bool(message.post);
        }
        if (message.comment === true) {
            writer.uint32(16).bool(message.comment);
        }
        if (message.subreddit === true) {
            writer.uint32(24).bool(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContextActionAllowedContexts();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.post = reader.bool();
                    break;
                case 2:
                    message.comment = reader.bool();
                    break;
                case 3:
                    message.subreddit = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            post: isSet(object.post) ? Boolean(object.post) : false,
            comment: isSet(object.comment) ? Boolean(object.comment) : false,
            subreddit: isSet(object.subreddit) ? Boolean(object.subreddit) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.post !== undefined && (obj.post = message.post);
        message.comment !== undefined && (obj.comment = message.comment);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseContextActionAllowedContexts();
        message.post = object.post ?? false;
        message.comment = object.comment ?? false;
        message.subreddit = object.subreddit ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionAllowedContexts", ContextActionAllowedContexts);
function createBaseContextActionAllowedUsers() {
    return { moderator: false, member: false, loggedOut: false };
}
export const ContextActionAllowedUsers = {
    $type: "devvit.actor.reddit.ContextActionAllowedUsers",
    encode(message, writer = _m0.Writer.create()) {
        if (message.moderator === true) {
            writer.uint32(8).bool(message.moderator);
        }
        if (message.member === true) {
            writer.uint32(16).bool(message.member);
        }
        if (message.loggedOut === true) {
            writer.uint32(24).bool(message.loggedOut);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContextActionAllowedUsers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.moderator = reader.bool();
                    break;
                case 2:
                    message.member = reader.bool();
                    break;
                case 3:
                    message.loggedOut = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            moderator: isSet(object.moderator) ? Boolean(object.moderator) : false,
            member: isSet(object.member) ? Boolean(object.member) : false,
            loggedOut: isSet(object.loggedOut) ? Boolean(object.loggedOut) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.moderator !== undefined && (obj.moderator = message.moderator);
        message.member !== undefined && (obj.member = message.member);
        message.loggedOut !== undefined && (obj.loggedOut = message.loggedOut);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseContextActionAllowedUsers();
        message.moderator = object.moderator ?? false;
        message.member = object.member ?? false;
        message.loggedOut = object.loggedOut ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionAllowedUsers", ContextActionAllowedUsers);
function createBaseContextActionDescription() {
    return { actionId: "", name: "", description: "", contexts: undefined, users: undefined, userInput: undefined };
}
export const ContextActionDescription = {
    $type: "devvit.actor.reddit.ContextActionDescription",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actionId !== "") {
            writer.uint32(10).string(message.actionId);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.contexts !== undefined) {
            ContextActionAllowedContexts.encode(message.contexts, writer.uint32(34).fork()).ldelim();
        }
        if (message.users !== undefined) {
            ContextActionAllowedUsers.encode(message.users, writer.uint32(42).fork()).ldelim();
        }
        if (message.userInput !== undefined) {
            ConfigForm.encode(message.userInput, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContextActionDescription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actionId = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.contexts = ContextActionAllowedContexts.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.users = ContextActionAllowedUsers.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.userInput = ConfigForm.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actionId: isSet(object.actionId) ? String(object.actionId) : "",
            name: isSet(object.name) ? String(object.name) : "",
            description: isSet(object.description) ? String(object.description) : "",
            contexts: isSet(object.contexts) ? ContextActionAllowedContexts.fromJSON(object.contexts) : undefined,
            users: isSet(object.users) ? ContextActionAllowedUsers.fromJSON(object.users) : undefined,
            userInput: isSet(object.userInput) ? ConfigForm.fromJSON(object.userInput) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.actionId !== undefined && (obj.actionId = message.actionId);
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined && (obj.description = message.description);
        message.contexts !== undefined &&
            (obj.contexts = message.contexts ? ContextActionAllowedContexts.toJSON(message.contexts) : undefined);
        message.users !== undefined &&
            (obj.users = message.users ? ContextActionAllowedUsers.toJSON(message.users) : undefined);
        message.userInput !== undefined &&
            (obj.userInput = message.userInput ? ConfigForm.toJSON(message.userInput) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseContextActionDescription();
        message.actionId = object.actionId ?? "";
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.contexts = (object.contexts !== undefined && object.contexts !== null)
            ? ContextActionAllowedContexts.fromPartial(object.contexts)
            : undefined;
        message.users = (object.users !== undefined && object.users !== null)
            ? ContextActionAllowedUsers.fromPartial(object.users)
            : undefined;
        message.userInput = (object.userInput !== undefined && object.userInput !== null)
            ? ConfigForm.fromPartial(object.userInput)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionDescription", ContextActionDescription);
function createBaseContextActionList() {
    return { actions: [] };
}
export const ContextActionList = {
    $type: "devvit.actor.reddit.ContextActionList",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actions) {
            ContextActionDescription.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContextActionList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(ContextActionDescription.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actions: Array.isArray(object?.actions)
                ? object.actions.map((e) => ContextActionDescription.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.actions) {
            obj.actions = message.actions.map((e) => e ? ContextActionDescription.toJSON(e) : undefined);
        }
        else {
            obj.actions = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseContextActionList();
        message.actions = object.actions?.map((e) => ContextActionDescription.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionList", ContextActionList);
function createBaseContextActionRequest() {
    return { actionId: "", context: 0, post: undefined, comment: undefined, subreddit: undefined, userInput: undefined };
}
export const ContextActionRequest = {
    $type: "devvit.actor.reddit.ContextActionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actionId !== "") {
            writer.uint32(10).string(message.actionId);
        }
        if (message.context !== 0) {
            writer.uint32(16).int32(message.context);
        }
        if (message.post !== undefined) {
            RedditObject.encode(message.post, writer.uint32(26).fork()).ldelim();
        }
        if (message.comment !== undefined) {
            RedditObject.encode(message.comment, writer.uint32(34).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            SubredditObject.encode(message.subreddit, writer.uint32(42).fork()).ldelim();
        }
        if (message.userInput !== undefined) {
            ConfigForm.encode(message.userInput, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContextActionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actionId = reader.string();
                    break;
                case 2:
                    message.context = reader.int32();
                    break;
                case 3:
                    message.post = RedditObject.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.comment = RedditObject.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.subreddit = SubredditObject.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.userInput = ConfigForm.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actionId: isSet(object.actionId) ? String(object.actionId) : "",
            context: isSet(object.context) ? contextTypeFromJSON(object.context) : 0,
            post: isSet(object.post) ? RedditObject.fromJSON(object.post) : undefined,
            comment: isSet(object.comment) ? RedditObject.fromJSON(object.comment) : undefined,
            subreddit: isSet(object.subreddit) ? SubredditObject.fromJSON(object.subreddit) : undefined,
            userInput: isSet(object.userInput) ? ConfigForm.fromJSON(object.userInput) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.actionId !== undefined && (obj.actionId = message.actionId);
        message.context !== undefined && (obj.context = contextTypeToJSON(message.context));
        message.post !== undefined && (obj.post = message.post ? RedditObject.toJSON(message.post) : undefined);
        message.comment !== undefined && (obj.comment = message.comment ? RedditObject.toJSON(message.comment) : undefined);
        message.subreddit !== undefined &&
            (obj.subreddit = message.subreddit ? SubredditObject.toJSON(message.subreddit) : undefined);
        message.userInput !== undefined &&
            (obj.userInput = message.userInput ? ConfigForm.toJSON(message.userInput) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseContextActionRequest();
        message.actionId = object.actionId ?? "";
        message.context = object.context ?? 0;
        message.post = (object.post !== undefined && object.post !== null)
            ? RedditObject.fromPartial(object.post)
            : undefined;
        message.comment = (object.comment !== undefined && object.comment !== null)
            ? RedditObject.fromPartial(object.comment)
            : undefined;
        message.subreddit = (object.subreddit !== undefined && object.subreddit !== null)
            ? SubredditObject.fromPartial(object.subreddit)
            : undefined;
        message.userInput = (object.userInput !== undefined && object.userInput !== null)
            ? ConfigForm.fromPartial(object.userInput)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionRequest", ContextActionRequest);
function createBaseContextActionResponse() {
    return { success: false, message: "", effects: [] };
}
export const ContextActionResponse = {
    $type: "devvit.actor.reddit.ContextActionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.success === true) {
            writer.uint32(8).bool(message.success);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        for (const v of message.effects) {
            Effect.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContextActionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.success = reader.bool();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.effects.push(Effect.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? Boolean(object.success) : false,
            message: isSet(object.message) ? String(object.message) : "",
            effects: Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.success !== undefined && (obj.success = message.success);
        message.message !== undefined && (obj.message = message.message);
        if (message.effects) {
            obj.effects = message.effects.map((e) => e ? Effect.toJSON(e) : undefined);
        }
        else {
            obj.effects = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseContextActionResponse();
        message.success = object.success ?? false;
        message.message = object.message ?? "";
        message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionResponse", ContextActionResponse);
export class ContextActionClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.actor.reddit.ContextAction";
        this.rpc = rpc;
        this.GetActions = this.GetActions.bind(this);
        this.OnAction = this.OnAction.bind(this);
    }
    GetActions(request) {
        const data = Empty.encode(request).finish();
        const promise = this.rpc.request(this.service, "GetActions", data);
        return promise.then((data) => ContextActionList.decode(new _m0.Reader(data)));
    }
    OnAction(request) {
        const data = ContextActionRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "OnAction", data);
        return promise.then((data) => ContextActionResponse.decode(new _m0.Reader(data)));
    }
}
export const ContextActionDefinition = {
    name: "ContextAction",
    fullName: "devvit.actor.reddit.ContextAction",
    methods: {
        getActions: {
            name: "GetActions",
            requestType: Empty,
            requestStream: false,
            responseType: ContextActionList,
            responseStream: false,
            options: {},
        },
        onAction: {
            name: "OnAction",
            requestType: ContextActionRequest,
            requestStream: false,
            responseType: ContextActionResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
