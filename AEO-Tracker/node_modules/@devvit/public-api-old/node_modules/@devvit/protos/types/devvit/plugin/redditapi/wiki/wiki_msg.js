/**
 * #wiki_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import Long from "long";
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { WrappedUserObject } from '../common/common_msg.js';
function createBaseGetWikiPagesRequest() {
    return { subreddit: "" };
}
export const GetWikiPagesRequest = {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPagesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWikiPagesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { subreddit: isSet(object.subreddit) ? String(object.subreddit) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWikiPagesRequest();
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPagesRequest", GetWikiPagesRequest);
function createBaseGetWikiPagesResponse() {
    return { kind: "", data: [] };
}
export const GetWikiPagesResponse = {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPagesResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        for (const v of message.data) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWikiPagesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: Array.isArray(object?.data) ? object.data.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        if (message.data) {
            obj.data = message.data.map((e) => e);
        }
        else {
            obj.data = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWikiPagesResponse();
        message.kind = object.kind ?? "";
        message.data = object.data?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPagesResponse", GetWikiPagesResponse);
function createBaseGetWikiPageRequest() {
    return { subreddit: "", page: "" };
}
export const GetWikiPageRequest = {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPageRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.page !== "") {
            writer.uint32(18).string(message.page);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWikiPageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.page = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            page: isSet(object.page) ? String(object.page) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.page !== undefined && (obj.page = message.page);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWikiPageRequest();
        message.subreddit = object.subreddit ?? "";
        message.page = object.page ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPageRequest", GetWikiPageRequest);
function createBaseWikiPage() {
    return {
        contentMd: "",
        contentHtml: "",
        revisionId: "",
        revisionDate: 0,
        mayRevise: false,
        reason: undefined,
        revisionBy: undefined,
    };
}
export const WikiPage = {
    $type: "devvit.plugin.redditapi.wiki.WikiPage",
    encode(message, writer = _m0.Writer.create()) {
        if (message.contentMd !== "") {
            writer.uint32(10).string(message.contentMd);
        }
        if (message.contentHtml !== "") {
            writer.uint32(18).string(message.contentHtml);
        }
        if (message.revisionId !== "") {
            writer.uint32(26).string(message.revisionId);
        }
        if (message.revisionDate !== 0) {
            writer.uint32(32).int64(message.revisionDate);
        }
        if (message.mayRevise === true) {
            writer.uint32(40).bool(message.mayRevise);
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
        }
        if (message.revisionBy !== undefined) {
            WrappedUserObject.encode(message.revisionBy, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWikiPage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contentMd = reader.string();
                    break;
                case 2:
                    message.contentHtml = reader.string();
                    break;
                case 3:
                    message.revisionId = reader.string();
                    break;
                case 4:
                    message.revisionDate = longToNumber(reader.int64());
                    break;
                case 5:
                    message.mayRevise = reader.bool();
                    break;
                case 6:
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.revisionBy = WrappedUserObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contentMd: isSet(object.contentMd) ? String(object.contentMd) : "",
            contentHtml: isSet(object.contentHtml) ? String(object.contentHtml) : "",
            revisionId: isSet(object.revisionId) ? String(object.revisionId) : "",
            revisionDate: isSet(object.revisionDate) ? Number(object.revisionDate) : 0,
            mayRevise: isSet(object.mayRevise) ? Boolean(object.mayRevise) : false,
            reason: isSet(object.reason) ? String(object.reason) : undefined,
            revisionBy: isSet(object.revisionBy) ? WrappedUserObject.fromJSON(object.revisionBy) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.contentMd !== undefined && (obj.contentMd = message.contentMd);
        message.contentHtml !== undefined && (obj.contentHtml = message.contentHtml);
        message.revisionId !== undefined && (obj.revisionId = message.revisionId);
        message.revisionDate !== undefined && (obj.revisionDate = Math.round(message.revisionDate));
        message.mayRevise !== undefined && (obj.mayRevise = message.mayRevise);
        message.reason !== undefined && (obj.reason = message.reason);
        message.revisionBy !== undefined &&
            (obj.revisionBy = message.revisionBy ? WrappedUserObject.toJSON(message.revisionBy) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWikiPage();
        message.contentMd = object.contentMd ?? "";
        message.contentHtml = object.contentHtml ?? "";
        message.revisionId = object.revisionId ?? "";
        message.revisionDate = object.revisionDate ?? 0;
        message.mayRevise = object.mayRevise ?? false;
        message.reason = object.reason ?? undefined;
        message.revisionBy = (object.revisionBy !== undefined && object.revisionBy !== null)
            ? WrappedUserObject.fromPartial(object.revisionBy)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPage", WikiPage);
function createBaseGetWikiPageResponse() {
    return { kind: "", data: undefined };
}
export const GetWikiPageResponse = {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPageResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            WikiPage.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWikiPageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = WikiPage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? WikiPage.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined && (obj.data = message.data ? WikiPage.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWikiPageResponse();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null) ? WikiPage.fromPartial(object.data) : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPageResponse", GetWikiPageResponse);
function createBaseEditWikiPageRequest() {
    return { subreddit: "", page: "", content: "", reason: "" };
}
export const EditWikiPageRequest = {
    $type: "devvit.plugin.redditapi.wiki.EditWikiPageRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.page !== "") {
            writer.uint32(18).string(message.page);
        }
        if (message.content !== "") {
            writer.uint32(26).string(message.content);
        }
        if (message.reason !== "") {
            writer.uint32(34).string(message.reason);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEditWikiPageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.page = reader.string();
                    break;
                case 3:
                    message.content = reader.string();
                    break;
                case 4:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            page: isSet(object.page) ? String(object.page) : "",
            content: isSet(object.content) ? String(object.content) : "",
            reason: isSet(object.reason) ? String(object.reason) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.page !== undefined && (obj.page = message.page);
        message.content !== undefined && (obj.content = message.content);
        message.reason !== undefined && (obj.reason = message.reason);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseEditWikiPageRequest();
        message.subreddit = object.subreddit ?? "";
        message.page = object.page ?? "";
        message.content = object.content ?? "";
        message.reason = object.reason ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.EditWikiPageRequest", EditWikiPageRequest);
function createBaseHideWikiPageRevisionRequest() {
    return { subreddit: "", page: "", revision: "" };
}
export const HideWikiPageRevisionRequest = {
    $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.page !== "") {
            writer.uint32(18).string(message.page);
        }
        if (message.revision !== "") {
            writer.uint32(26).string(message.revision);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHideWikiPageRevisionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.page = reader.string();
                    break;
                case 3:
                    message.revision = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            page: isSet(object.page) ? String(object.page) : "",
            revision: isSet(object.revision) ? String(object.revision) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.page !== undefined && (obj.page = message.page);
        message.revision !== undefined && (obj.revision = message.revision);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHideWikiPageRevisionRequest();
        message.subreddit = object.subreddit ?? "";
        message.page = object.page ?? "";
        message.revision = object.revision ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.HideWikiPageRevisionRequest", HideWikiPageRevisionRequest);
function createBaseHideWikiPageRevisionResponse() {
    return { status: false };
}
export const HideWikiPageRevisionResponse = {
    $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.status === true) {
            writer.uint32(8).bool(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHideWikiPageRevisionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.status = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { status: isSet(object.status) ? Boolean(object.status) : false };
    },
    toJSON(message) {
        const obj = {};
        message.status !== undefined && (obj.status = message.status);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHideWikiPageRevisionResponse();
        message.status = object.status ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.HideWikiPageRevisionResponse", HideWikiPageRevisionResponse);
function createBaseGetWikiPageRevisionsRequest() {
    return {
        subreddit: "",
        page: "",
        after: undefined,
        before: undefined,
        limit: undefined,
        count: undefined,
        show: undefined,
        srDetail: undefined,
    };
}
export const GetWikiPageRevisionsRequest = {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPageRevisionsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.page !== "") {
            writer.uint32(18).string(message.page);
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(34).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
        }
        if (message.show !== undefined) {
            BoolValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
        }
        if (message.srDetail !== undefined) {
            BoolValue.encode({ value: message.srDetail }, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWikiPageRevisionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.page = reader.string();
                    break;
                case 3:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.show = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.srDetail = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            page: isSet(object.page) ? String(object.page) : "",
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            show: isSet(object.show) ? Boolean(object.show) : undefined,
            srDetail: isSet(object.srDetail) ? Boolean(object.srDetail) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.page !== undefined && (obj.page = message.page);
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.limit !== undefined && (obj.limit = message.limit);
        message.count !== undefined && (obj.count = message.count);
        message.show !== undefined && (obj.show = message.show);
        message.srDetail !== undefined && (obj.srDetail = message.srDetail);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWikiPageRevisionsRequest();
        message.subreddit = object.subreddit ?? "";
        message.page = object.page ?? "";
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.limit = object.limit ?? undefined;
        message.count = object.count ?? undefined;
        message.show = object.show ?? undefined;
        message.srDetail = object.srDetail ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPageRevisionsRequest", GetWikiPageRevisionsRequest);
function createBaseWikiPageRevision() {
    return { id: "", page: "", timestamp: 0, reason: "", revisionHidden: false, author: undefined };
}
export const WikiPageRevision = {
    $type: "devvit.plugin.redditapi.wiki.WikiPageRevision",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.page !== "") {
            writer.uint32(18).string(message.page);
        }
        if (message.timestamp !== 0) {
            writer.uint32(24).int64(message.timestamp);
        }
        if (message.reason !== "") {
            writer.uint32(34).string(message.reason);
        }
        if (message.revisionHidden === true) {
            writer.uint32(40).bool(message.revisionHidden);
        }
        if (message.author !== undefined) {
            WrappedUserObject.encode(message.author, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWikiPageRevision();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.page = reader.string();
                    break;
                case 3:
                    message.timestamp = longToNumber(reader.int64());
                    break;
                case 4:
                    message.reason = reader.string();
                    break;
                case 5:
                    message.revisionHidden = reader.bool();
                    break;
                case 6:
                    message.author = WrappedUserObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            page: isSet(object.page) ? String(object.page) : "",
            timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,
            reason: isSet(object.reason) ? String(object.reason) : "",
            revisionHidden: isSet(object.revisionHidden) ? Boolean(object.revisionHidden) : false,
            author: isSet(object.author) ? WrappedUserObject.fromJSON(object.author) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.page !== undefined && (obj.page = message.page);
        message.timestamp !== undefined && (obj.timestamp = Math.round(message.timestamp));
        message.reason !== undefined && (obj.reason = message.reason);
        message.revisionHidden !== undefined && (obj.revisionHidden = message.revisionHidden);
        message.author !== undefined &&
            (obj.author = message.author ? WrappedUserObject.toJSON(message.author) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWikiPageRevision();
        message.id = object.id ?? "";
        message.page = object.page ?? "";
        message.timestamp = object.timestamp ?? 0;
        message.reason = object.reason ?? "";
        message.revisionHidden = object.revisionHidden ?? false;
        message.author = (object.author !== undefined && object.author !== null)
            ? WrappedUserObject.fromPartial(object.author)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageRevision", WikiPageRevision);
function createBaseWikiPageRevisionListing() {
    return { kind: "", data: undefined };
}
export const WikiPageRevisionListing = {
    $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            WikiPageRevisionListing_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWikiPageRevisionListing();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = WikiPageRevisionListing_Data.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? WikiPageRevisionListing_Data.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? WikiPageRevisionListing_Data.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWikiPageRevisionListing();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? WikiPageRevisionListing_Data.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageRevisionListing", WikiPageRevisionListing);
function createBaseWikiPageRevisionListing_Data() {
    return { after: undefined, before: undefined, children: [], dist: undefined };
}
export const WikiPageRevisionListing_Data = {
    $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing.Data",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.children) {
            WikiPageRevision.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.dist !== undefined) {
            Int64Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWikiPageRevisionListing_Data();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.children.push(WikiPageRevision.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.dist = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            children: Array.isArray(object?.children) ? object.children.map((e) => WikiPageRevision.fromJSON(e)) : [],
            dist: isSet(object.dist) ? Number(object.dist) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        if (message.children) {
            obj.children = message.children.map((e) => e ? WikiPageRevision.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        message.dist !== undefined && (obj.dist = message.dist);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWikiPageRevisionListing_Data();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.children = object.children?.map((e) => WikiPageRevision.fromPartial(e)) || [];
        message.dist = object.dist ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageRevisionListing.Data", WikiPageRevisionListing_Data);
function createBaseGetWikiRevisionsRequest() {
    return {
        subreddit: "",
        after: undefined,
        before: undefined,
        limit: undefined,
        count: undefined,
        show: undefined,
        srDetail: undefined,
    };
}
export const GetWikiRevisionsRequest = {
    $type: "devvit.plugin.redditapi.wiki.GetWikiRevisionsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
        }
        if (message.show !== undefined) {
            BoolValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
        }
        if (message.srDetail !== undefined) {
            BoolValue.encode({ value: message.srDetail }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWikiRevisionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.show = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.srDetail = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            show: isSet(object.show) ? Boolean(object.show) : undefined,
            srDetail: isSet(object.srDetail) ? Boolean(object.srDetail) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.limit !== undefined && (obj.limit = message.limit);
        message.count !== undefined && (obj.count = message.count);
        message.show !== undefined && (obj.show = message.show);
        message.srDetail !== undefined && (obj.srDetail = message.srDetail);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWikiRevisionsRequest();
        message.subreddit = object.subreddit ?? "";
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.limit = object.limit ?? undefined;
        message.count = object.count ?? undefined;
        message.show = object.show ?? undefined;
        message.srDetail = object.srDetail ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiRevisionsRequest", GetWikiRevisionsRequest);
function createBaseRevertWikiPageRequest() {
    return { subreddit: "", page: "", revision: "" };
}
export const RevertWikiPageRequest = {
    $type: "devvit.plugin.redditapi.wiki.RevertWikiPageRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.page !== "") {
            writer.uint32(18).string(message.page);
        }
        if (message.revision !== "") {
            writer.uint32(26).string(message.revision);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevertWikiPageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.page = reader.string();
                    break;
                case 3:
                    message.revision = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            page: isSet(object.page) ? String(object.page) : "",
            revision: isSet(object.revision) ? String(object.revision) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.page !== undefined && (obj.page = message.page);
        message.revision !== undefined && (obj.revision = message.revision);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRevertWikiPageRequest();
        message.subreddit = object.subreddit ?? "";
        message.page = object.page ?? "";
        message.revision = object.revision ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.RevertWikiPageRequest", RevertWikiPageRequest);
function createBaseGetWikiPageSettingsRequest() {
    return { subreddit: "", page: "" };
}
export const GetWikiPageSettingsRequest = {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPageSettingsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.page !== "") {
            writer.uint32(18).string(message.page);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWikiPageSettingsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.page = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            page: isSet(object.page) ? String(object.page) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.page !== undefined && (obj.page = message.page);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetWikiPageSettingsRequest();
        message.subreddit = object.subreddit ?? "";
        message.page = object.page ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPageSettingsRequest", GetWikiPageSettingsRequest);
function createBaseWikiPageSettings() {
    return { kind: "", data: undefined };
}
export const WikiPageSettings = {
    $type: "devvit.plugin.redditapi.wiki.WikiPageSettings",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            WikiPageSettings_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWikiPageSettings();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = WikiPageSettings_Data.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? WikiPageSettings_Data.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined && (obj.data = message.data ? WikiPageSettings_Data.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWikiPageSettings();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? WikiPageSettings_Data.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageSettings", WikiPageSettings);
function createBaseWikiPageSettings_Data() {
    return { permLevel: 0, editors: [], listed: false };
}
export const WikiPageSettings_Data = {
    $type: "devvit.plugin.redditapi.wiki.WikiPageSettings.Data",
    encode(message, writer = _m0.Writer.create()) {
        if (message.permLevel !== 0) {
            writer.uint32(8).int32(message.permLevel);
        }
        for (const v of message.editors) {
            WrappedUserObject.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.listed === true) {
            writer.uint32(24).bool(message.listed);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWikiPageSettings_Data();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.permLevel = reader.int32();
                    break;
                case 2:
                    message.editors.push(WrappedUserObject.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.listed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            permLevel: isSet(object.permLevel) ? Number(object.permLevel) : 0,
            editors: Array.isArray(object?.editors) ? object.editors.map((e) => WrappedUserObject.fromJSON(e)) : [],
            listed: isSet(object.listed) ? Boolean(object.listed) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.permLevel !== undefined && (obj.permLevel = Math.round(message.permLevel));
        if (message.editors) {
            obj.editors = message.editors.map((e) => e ? WrappedUserObject.toJSON(e) : undefined);
        }
        else {
            obj.editors = [];
        }
        message.listed !== undefined && (obj.listed = message.listed);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWikiPageSettings_Data();
        message.permLevel = object.permLevel ?? 0;
        message.editors = object.editors?.map((e) => WrappedUserObject.fromPartial(e)) || [];
        message.listed = object.listed ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageSettings.Data", WikiPageSettings_Data);
function createBaseUpdateWikiPageSettingsRequest() {
    return { subreddit: "", page: "", permlevel: 0, listed: "" };
}
export const UpdateWikiPageSettingsRequest = {
    $type: "devvit.plugin.redditapi.wiki.UpdateWikiPageSettingsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.page !== "") {
            writer.uint32(18).string(message.page);
        }
        if (message.permlevel !== 0) {
            writer.uint32(24).int32(message.permlevel);
        }
        if (message.listed !== "") {
            writer.uint32(34).string(message.listed);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateWikiPageSettingsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.page = reader.string();
                    break;
                case 3:
                    message.permlevel = reader.int32();
                    break;
                case 4:
                    message.listed = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            page: isSet(object.page) ? String(object.page) : "",
            permlevel: isSet(object.permlevel) ? Number(object.permlevel) : 0,
            listed: isSet(object.listed) ? String(object.listed) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.page !== undefined && (obj.page = message.page);
        message.permlevel !== undefined && (obj.permlevel = Math.round(message.permlevel));
        message.listed !== undefined && (obj.listed = message.listed);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateWikiPageSettingsRequest();
        message.subreddit = object.subreddit ?? "";
        message.page = object.page ?? "";
        message.permlevel = object.permlevel ?? 0;
        message.listed = object.listed ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.UpdateWikiPageSettingsRequest", UpdateWikiPageSettingsRequest);
function createBaseAllowEditorRequest() {
    return { subreddit: "", page: "", act: "", username: "" };
}
export const AllowEditorRequest = {
    $type: "devvit.plugin.redditapi.wiki.AllowEditorRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.page !== "") {
            writer.uint32(18).string(message.page);
        }
        if (message.act !== "") {
            writer.uint32(26).string(message.act);
        }
        if (message.username !== "") {
            writer.uint32(34).string(message.username);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAllowEditorRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.page = reader.string();
                    break;
                case 3:
                    message.act = reader.string();
                    break;
                case 4:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            page: isSet(object.page) ? String(object.page) : "",
            act: isSet(object.act) ? String(object.act) : "",
            username: isSet(object.username) ? String(object.username) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.page !== undefined && (obj.page = message.page);
        message.act !== undefined && (obj.act = message.act);
        message.username !== undefined && (obj.username = message.username);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAllowEditorRequest();
        message.subreddit = object.subreddit ?? "";
        message.page = object.page ?? "";
        message.act = object.act ?? "";
        message.username = object.username ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.AllowEditorRequest", AllowEditorRequest);
var globalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
