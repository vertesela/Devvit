/**
 * #subreddits_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import Long from "long";
import _m0 from 'protobufjs/minimal.js';
import { Any } from '../../../../google/protobuf/any.js';
import { BoolValue, Int32Value, Int64Value, StringValue } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { CommentContributionSettings, MediaEmbed, UserFlairRichtext } from '../../../reddit/common.js';
function createBaseAboutWhereRequest() {
    return {
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        show: undefined,
        user: undefined,
        subreddit: undefined,
        where: "",
    };
}
export const AboutWhereRequest = {
    $type: "devvit.plugin.redditapi.subreddits.AboutWhereRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
        }
        if (message.user !== undefined) {
            StringValue.encode({ value: message.user }, writer.uint32(58).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(66).fork()).ldelim();
        }
        if (message.where !== "") {
            writer.uint32(74).string(message.where);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAboutWhereRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.user = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.where = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            user: isSet(object.user) ? String(object.user) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            where: isSet(object.where) ? String(object.where) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.count !== undefined && (obj.count = message.count);
        message.limit !== undefined && (obj.limit = message.limit);
        message.show !== undefined && (obj.show = message.show);
        message.user !== undefined && (obj.user = message.user);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.where !== undefined && (obj.where = message.where);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAboutWhereRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.show = object.show ?? undefined;
        message.user = object.user ?? undefined;
        message.subreddit = object.subreddit ?? undefined;
        message.where = object.where ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.AboutWhereRequest", AboutWhereRequest);
function createBaseBasicSubredditRequest() {
    return { subreddit: "" };
}
export const BasicSubredditRequest = {
    $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicSubredditRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { subreddit: isSet(object.subreddit) ? String(object.subreddit) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBasicSubredditRequest();
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.BasicSubredditRequest", BasicSubredditRequest);
function createBaseDeleteSrImgRequest() {
    return { subreddit: "", imgName: "" };
}
export const DeleteSrImgRequest = {
    $type: "devvit.plugin.redditapi.subreddits.DeleteSrImgRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.imgName !== "") {
            writer.uint32(18).string(message.imgName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteSrImgRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.imgName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            imgName: isSet(object.imgName) ? String(object.imgName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.imgName !== undefined && (obj.imgName = message.imgName);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDeleteSrImgRequest();
        message.subreddit = object.subreddit ?? "";
        message.imgName = object.imgName ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.DeleteSrImgRequest", DeleteSrImgRequest);
function createBaseBasicSearchRequest() {
    return {
        exact: undefined,
        includeOver18: undefined,
        includeUnadvertisable: undefined,
        query: "",
        searchQueryId: undefined,
        typeaheadActive: undefined,
    };
}
export const BasicSearchRequest = {
    $type: "devvit.plugin.redditapi.subreddits.BasicSearchRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.exact !== undefined) {
            BoolValue.encode({ value: message.exact }, writer.uint32(10).fork()).ldelim();
        }
        if (message.includeOver18 !== undefined) {
            BoolValue.encode({ value: message.includeOver18 }, writer.uint32(18).fork()).ldelim();
        }
        if (message.includeUnadvertisable !== undefined) {
            BoolValue.encode({ value: message.includeUnadvertisable }, writer.uint32(26).fork()).ldelim();
        }
        if (message.query !== "") {
            writer.uint32(34).string(message.query);
        }
        if (message.searchQueryId !== undefined) {
            StringValue.encode({ value: message.searchQueryId }, writer.uint32(42).fork()).ldelim();
        }
        if (message.typeaheadActive !== undefined) {
            BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicSearchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exact = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.includeOver18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.includeUnadvertisable = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.query = reader.string();
                    break;
                case 5:
                    message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            exact: isSet(object.exact) ? Boolean(object.exact) : undefined,
            includeOver18: isSet(object.includeOver18) ? Boolean(object.includeOver18) : undefined,
            includeUnadvertisable: isSet(object.includeUnadvertisable) ? Boolean(object.includeUnadvertisable) : undefined,
            query: isSet(object.query) ? String(object.query) : "",
            searchQueryId: isSet(object.searchQueryId) ? String(object.searchQueryId) : undefined,
            typeaheadActive: isSet(object.typeaheadActive) ? Boolean(object.typeaheadActive) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.exact !== undefined && (obj.exact = message.exact);
        message.includeOver18 !== undefined && (obj.includeOver18 = message.includeOver18);
        message.includeUnadvertisable !== undefined && (obj.includeUnadvertisable = message.includeUnadvertisable);
        message.query !== undefined && (obj.query = message.query);
        message.searchQueryId !== undefined && (obj.searchQueryId = message.searchQueryId);
        message.typeaheadActive !== undefined && (obj.typeaheadActive = message.typeaheadActive);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBasicSearchRequest();
        message.exact = object.exact ?? undefined;
        message.includeOver18 = object.includeOver18 ?? undefined;
        message.includeUnadvertisable = object.includeUnadvertisable ?? undefined;
        message.query = object.query ?? "";
        message.searchQueryId = object.searchQueryId ?? undefined;
        message.typeaheadActive = object.typeaheadActive ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.BasicSearchRequest", BasicSearchRequest);
function createBaseSiteAdminRequest() {
    return {
        acceptFollowers: false,
        adminOverrideSpamComments: false,
        adminOverrideSpamLinks: false,
        adminOverrideSpamSelfposts: false,
        allOriginalContent: false,
        allowChatPostCreation: false,
        allowDiscovery: false,
        allowGalleries: false,
        allowImages: false,
        allowPolls: false,
        allowPostCrossposts: false,
        allowPredictionContributors: false,
        allowPredictions: false,
        allowPredictionsTournament: false,
        allowTalks: false,
        allowTop: false,
        allowVideos: false,
        banEvasionThreshold: 0,
        collapseDeletedComments: false,
        commentContributionSettings: undefined,
        commentScoreHideMins: 0,
        crowdControlFilter: false,
        crowdControlLevel: 0,
        crowdControlMode: false,
        crowdControlPostLevel: 0,
        description: "",
        disableContributorRequests: false,
        excludeBannedModqueue: false,
        freeFormReports: false,
        gRecaptchaResponse: "",
        hatefulContentThresholdAbuse: 0,
        hatefulContentThresholdIdentity: 0,
        headerTitle: "",
        keyColor: "",
        linkType: "",
        name: "",
        newPinnedPostPnsEnabled: false,
        originalContentTagEnabled: false,
        over18: false,
        predictionLeaderboardEntryType: 0,
        publicDescription: "",
        restrictCommenting: false,
        restrictPosting: false,
        shouldArchivePosts: false,
        showMedia: false,
        showMediaPreview: false,
        spamComments: "",
        spamLinks: "",
        spamSelfposts: "",
        spoilersEnabled: false,
        sr: "",
        submitLinkLabel: "",
        submitText: "",
        submitTextLabel: "",
        suggestedCommentSort: "",
        title: "",
        toxicityThresholdChatLevel: 0,
        type: "",
        userFlairPnsEnabled: false,
        welcomeMessageEnabled: false,
        welcomeMessageText: "",
        wikiEditAge: 0,
        wikiEditKarma: 0,
        wikimode: "",
        crowdControlChatLevel: 0,
        hideAds: false,
        modmailHarassmentFilterEnabled: false,
    };
}
export const SiteAdminRequest = {
    $type: "devvit.plugin.redditapi.subreddits.SiteAdminRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.acceptFollowers === true) {
            writer.uint32(8).bool(message.acceptFollowers);
        }
        if (message.adminOverrideSpamComments === true) {
            writer.uint32(16).bool(message.adminOverrideSpamComments);
        }
        if (message.adminOverrideSpamLinks === true) {
            writer.uint32(24).bool(message.adminOverrideSpamLinks);
        }
        if (message.adminOverrideSpamSelfposts === true) {
            writer.uint32(32).bool(message.adminOverrideSpamSelfposts);
        }
        if (message.allOriginalContent === true) {
            writer.uint32(40).bool(message.allOriginalContent);
        }
        if (message.allowChatPostCreation === true) {
            writer.uint32(48).bool(message.allowChatPostCreation);
        }
        if (message.allowDiscovery === true) {
            writer.uint32(56).bool(message.allowDiscovery);
        }
        if (message.allowGalleries === true) {
            writer.uint32(64).bool(message.allowGalleries);
        }
        if (message.allowImages === true) {
            writer.uint32(72).bool(message.allowImages);
        }
        if (message.allowPolls === true) {
            writer.uint32(80).bool(message.allowPolls);
        }
        if (message.allowPostCrossposts === true) {
            writer.uint32(88).bool(message.allowPostCrossposts);
        }
        if (message.allowPredictionContributors === true) {
            writer.uint32(96).bool(message.allowPredictionContributors);
        }
        if (message.allowPredictions === true) {
            writer.uint32(104).bool(message.allowPredictions);
        }
        if (message.allowPredictionsTournament === true) {
            writer.uint32(112).bool(message.allowPredictionsTournament);
        }
        if (message.allowTalks === true) {
            writer.uint32(120).bool(message.allowTalks);
        }
        if (message.allowTop === true) {
            writer.uint32(128).bool(message.allowTop);
        }
        if (message.allowVideos === true) {
            writer.uint32(136).bool(message.allowVideos);
        }
        if (message.banEvasionThreshold !== 0) {
            writer.uint32(144).int64(message.banEvasionThreshold);
        }
        if (message.collapseDeletedComments === true) {
            writer.uint32(152).bool(message.collapseDeletedComments);
        }
        if (message.commentContributionSettings !== undefined) {
            CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(162).fork()).ldelim();
        }
        if (message.commentScoreHideMins !== 0) {
            writer.uint32(168).int32(message.commentScoreHideMins);
        }
        if (message.crowdControlFilter === true) {
            writer.uint32(176).bool(message.crowdControlFilter);
        }
        if (message.crowdControlLevel !== 0) {
            writer.uint32(184).int64(message.crowdControlLevel);
        }
        if (message.crowdControlMode === true) {
            writer.uint32(192).bool(message.crowdControlMode);
        }
        if (message.crowdControlPostLevel !== 0) {
            writer.uint32(200).int64(message.crowdControlPostLevel);
        }
        if (message.description !== "") {
            writer.uint32(210).string(message.description);
        }
        if (message.disableContributorRequests === true) {
            writer.uint32(216).bool(message.disableContributorRequests);
        }
        if (message.excludeBannedModqueue === true) {
            writer.uint32(224).bool(message.excludeBannedModqueue);
        }
        if (message.freeFormReports === true) {
            writer.uint32(232).bool(message.freeFormReports);
        }
        if (message.gRecaptchaResponse !== "") {
            writer.uint32(242).string(message.gRecaptchaResponse);
        }
        if (message.hatefulContentThresholdAbuse !== 0) {
            writer.uint32(248).int64(message.hatefulContentThresholdAbuse);
        }
        if (message.hatefulContentThresholdIdentity !== 0) {
            writer.uint32(256).int64(message.hatefulContentThresholdIdentity);
        }
        if (message.headerTitle !== "") {
            writer.uint32(266).string(message.headerTitle);
        }
        if (message.keyColor !== "") {
            writer.uint32(274).string(message.keyColor);
        }
        if (message.linkType !== "") {
            writer.uint32(290).string(message.linkType);
        }
        if (message.name !== "") {
            writer.uint32(298).string(message.name);
        }
        if (message.newPinnedPostPnsEnabled === true) {
            writer.uint32(304).bool(message.newPinnedPostPnsEnabled);
        }
        if (message.originalContentTagEnabled === true) {
            writer.uint32(312).bool(message.originalContentTagEnabled);
        }
        if (message.over18 === true) {
            writer.uint32(320).bool(message.over18);
        }
        if (message.predictionLeaderboardEntryType !== 0) {
            writer.uint32(328).int64(message.predictionLeaderboardEntryType);
        }
        if (message.publicDescription !== "") {
            writer.uint32(338).string(message.publicDescription);
        }
        if (message.restrictCommenting === true) {
            writer.uint32(344).bool(message.restrictCommenting);
        }
        if (message.restrictPosting === true) {
            writer.uint32(352).bool(message.restrictPosting);
        }
        if (message.shouldArchivePosts === true) {
            writer.uint32(360).bool(message.shouldArchivePosts);
        }
        if (message.showMedia === true) {
            writer.uint32(368).bool(message.showMedia);
        }
        if (message.showMediaPreview === true) {
            writer.uint32(376).bool(message.showMediaPreview);
        }
        if (message.spamComments !== "") {
            writer.uint32(386).string(message.spamComments);
        }
        if (message.spamLinks !== "") {
            writer.uint32(394).string(message.spamLinks);
        }
        if (message.spamSelfposts !== "") {
            writer.uint32(402).string(message.spamSelfposts);
        }
        if (message.spoilersEnabled === true) {
            writer.uint32(408).bool(message.spoilersEnabled);
        }
        if (message.sr !== "") {
            writer.uint32(418).string(message.sr);
        }
        if (message.submitLinkLabel !== "") {
            writer.uint32(426).string(message.submitLinkLabel);
        }
        if (message.submitText !== "") {
            writer.uint32(434).string(message.submitText);
        }
        if (message.submitTextLabel !== "") {
            writer.uint32(442).string(message.submitTextLabel);
        }
        if (message.suggestedCommentSort !== "") {
            writer.uint32(450).string(message.suggestedCommentSort);
        }
        if (message.title !== "") {
            writer.uint32(458).string(message.title);
        }
        if (message.toxicityThresholdChatLevel !== 0) {
            writer.uint32(464).int64(message.toxicityThresholdChatLevel);
        }
        if (message.type !== "") {
            writer.uint32(474).string(message.type);
        }
        if (message.userFlairPnsEnabled === true) {
            writer.uint32(480).bool(message.userFlairPnsEnabled);
        }
        if (message.welcomeMessageEnabled === true) {
            writer.uint32(488).bool(message.welcomeMessageEnabled);
        }
        if (message.welcomeMessageText !== "") {
            writer.uint32(498).string(message.welcomeMessageText);
        }
        if (message.wikiEditAge !== 0) {
            writer.uint32(504).int64(message.wikiEditAge);
        }
        if (message.wikiEditKarma !== 0) {
            writer.uint32(512).int64(message.wikiEditKarma);
        }
        if (message.wikimode !== "") {
            writer.uint32(522).string(message.wikimode);
        }
        if (message.crowdControlChatLevel !== 0) {
            writer.uint32(528).int64(message.crowdControlChatLevel);
        }
        if (message.hideAds === true) {
            writer.uint32(536).bool(message.hideAds);
        }
        if (message.modmailHarassmentFilterEnabled === true) {
            writer.uint32(544).bool(message.modmailHarassmentFilterEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSiteAdminRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.acceptFollowers = reader.bool();
                    break;
                case 2:
                    message.adminOverrideSpamComments = reader.bool();
                    break;
                case 3:
                    message.adminOverrideSpamLinks = reader.bool();
                    break;
                case 4:
                    message.adminOverrideSpamSelfposts = reader.bool();
                    break;
                case 5:
                    message.allOriginalContent = reader.bool();
                    break;
                case 6:
                    message.allowChatPostCreation = reader.bool();
                    break;
                case 7:
                    message.allowDiscovery = reader.bool();
                    break;
                case 8:
                    message.allowGalleries = reader.bool();
                    break;
                case 9:
                    message.allowImages = reader.bool();
                    break;
                case 10:
                    message.allowPolls = reader.bool();
                    break;
                case 11:
                    message.allowPostCrossposts = reader.bool();
                    break;
                case 12:
                    message.allowPredictionContributors = reader.bool();
                    break;
                case 13:
                    message.allowPredictions = reader.bool();
                    break;
                case 14:
                    message.allowPredictionsTournament = reader.bool();
                    break;
                case 15:
                    message.allowTalks = reader.bool();
                    break;
                case 16:
                    message.allowTop = reader.bool();
                    break;
                case 17:
                    message.allowVideos = reader.bool();
                    break;
                case 18:
                    message.banEvasionThreshold = longToNumber(reader.int64());
                    break;
                case 19:
                    message.collapseDeletedComments = reader.bool();
                    break;
                case 20:
                    message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.commentScoreHideMins = reader.int32();
                    break;
                case 22:
                    message.crowdControlFilter = reader.bool();
                    break;
                case 23:
                    message.crowdControlLevel = longToNumber(reader.int64());
                    break;
                case 24:
                    message.crowdControlMode = reader.bool();
                    break;
                case 25:
                    message.crowdControlPostLevel = longToNumber(reader.int64());
                    break;
                case 26:
                    message.description = reader.string();
                    break;
                case 27:
                    message.disableContributorRequests = reader.bool();
                    break;
                case 28:
                    message.excludeBannedModqueue = reader.bool();
                    break;
                case 29:
                    message.freeFormReports = reader.bool();
                    break;
                case 30:
                    message.gRecaptchaResponse = reader.string();
                    break;
                case 31:
                    message.hatefulContentThresholdAbuse = longToNumber(reader.int64());
                    break;
                case 32:
                    message.hatefulContentThresholdIdentity = longToNumber(reader.int64());
                    break;
                case 33:
                    message.headerTitle = reader.string();
                    break;
                case 34:
                    message.keyColor = reader.string();
                    break;
                case 36:
                    message.linkType = reader.string();
                    break;
                case 37:
                    message.name = reader.string();
                    break;
                case 38:
                    message.newPinnedPostPnsEnabled = reader.bool();
                    break;
                case 39:
                    message.originalContentTagEnabled = reader.bool();
                    break;
                case 40:
                    message.over18 = reader.bool();
                    break;
                case 41:
                    message.predictionLeaderboardEntryType = longToNumber(reader.int64());
                    break;
                case 42:
                    message.publicDescription = reader.string();
                    break;
                case 43:
                    message.restrictCommenting = reader.bool();
                    break;
                case 44:
                    message.restrictPosting = reader.bool();
                    break;
                case 45:
                    message.shouldArchivePosts = reader.bool();
                    break;
                case 46:
                    message.showMedia = reader.bool();
                    break;
                case 47:
                    message.showMediaPreview = reader.bool();
                    break;
                case 48:
                    message.spamComments = reader.string();
                    break;
                case 49:
                    message.spamLinks = reader.string();
                    break;
                case 50:
                    message.spamSelfposts = reader.string();
                    break;
                case 51:
                    message.spoilersEnabled = reader.bool();
                    break;
                case 52:
                    message.sr = reader.string();
                    break;
                case 53:
                    message.submitLinkLabel = reader.string();
                    break;
                case 54:
                    message.submitText = reader.string();
                    break;
                case 55:
                    message.submitTextLabel = reader.string();
                    break;
                case 56:
                    message.suggestedCommentSort = reader.string();
                    break;
                case 57:
                    message.title = reader.string();
                    break;
                case 58:
                    message.toxicityThresholdChatLevel = longToNumber(reader.int64());
                    break;
                case 59:
                    message.type = reader.string();
                    break;
                case 60:
                    message.userFlairPnsEnabled = reader.bool();
                    break;
                case 61:
                    message.welcomeMessageEnabled = reader.bool();
                    break;
                case 62:
                    message.welcomeMessageText = reader.string();
                    break;
                case 63:
                    message.wikiEditAge = longToNumber(reader.int64());
                    break;
                case 64:
                    message.wikiEditKarma = longToNumber(reader.int64());
                    break;
                case 65:
                    message.wikimode = reader.string();
                    break;
                case 66:
                    message.crowdControlChatLevel = longToNumber(reader.int64());
                    break;
                case 67:
                    message.hideAds = reader.bool();
                    break;
                case 68:
                    message.modmailHarassmentFilterEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            acceptFollowers: isSet(object.acceptFollowers) ? Boolean(object.acceptFollowers) : false,
            adminOverrideSpamComments: isSet(object.adminOverrideSpamComments)
                ? Boolean(object.adminOverrideSpamComments)
                : false,
            adminOverrideSpamLinks: isSet(object.adminOverrideSpamLinks) ? Boolean(object.adminOverrideSpamLinks) : false,
            adminOverrideSpamSelfposts: isSet(object.adminOverrideSpamSelfposts)
                ? Boolean(object.adminOverrideSpamSelfposts)
                : false,
            allOriginalContent: isSet(object.allOriginalContent) ? Boolean(object.allOriginalContent) : false,
            allowChatPostCreation: isSet(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : false,
            allowDiscovery: isSet(object.allowDiscovery) ? Boolean(object.allowDiscovery) : false,
            allowGalleries: isSet(object.allowGalleries) ? Boolean(object.allowGalleries) : false,
            allowImages: isSet(object.allowImages) ? Boolean(object.allowImages) : false,
            allowPolls: isSet(object.allowPolls) ? Boolean(object.allowPolls) : false,
            allowPostCrossposts: isSet(object.allowPostCrossposts) ? Boolean(object.allowPostCrossposts) : false,
            allowPredictionContributors: isSet(object.allowPredictionContributors)
                ? Boolean(object.allowPredictionContributors)
                : false,
            allowPredictions: isSet(object.allowPredictions) ? Boolean(object.allowPredictions) : false,
            allowPredictionsTournament: isSet(object.allowPredictionsTournament)
                ? Boolean(object.allowPredictionsTournament)
                : false,
            allowTalks: isSet(object.allowTalks) ? Boolean(object.allowTalks) : false,
            allowTop: isSet(object.allowTop) ? Boolean(object.allowTop) : false,
            allowVideos: isSet(object.allowVideos) ? Boolean(object.allowVideos) : false,
            banEvasionThreshold: isSet(object.banEvasionThreshold) ? Number(object.banEvasionThreshold) : 0,
            collapseDeletedComments: isSet(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : false,
            commentContributionSettings: isSet(object.commentContributionSettings)
                ? CommentContributionSettings.fromJSON(object.commentContributionSettings)
                : undefined,
            commentScoreHideMins: isSet(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : 0,
            crowdControlFilter: isSet(object.crowdControlFilter) ? Boolean(object.crowdControlFilter) : false,
            crowdControlLevel: isSet(object.crowdControlLevel) ? Number(object.crowdControlLevel) : 0,
            crowdControlMode: isSet(object.crowdControlMode) ? Boolean(object.crowdControlMode) : false,
            crowdControlPostLevel: isSet(object.crowdControlPostLevel) ? Number(object.crowdControlPostLevel) : 0,
            description: isSet(object.description) ? String(object.description) : "",
            disableContributorRequests: isSet(object.disableContributorRequests)
                ? Boolean(object.disableContributorRequests)
                : false,
            excludeBannedModqueue: isSet(object.excludeBannedModqueue) ? Boolean(object.excludeBannedModqueue) : false,
            freeFormReports: isSet(object.freeFormReports) ? Boolean(object.freeFormReports) : false,
            gRecaptchaResponse: isSet(object.gRecaptchaResponse) ? String(object.gRecaptchaResponse) : "",
            hatefulContentThresholdAbuse: isSet(object.hatefulContentThresholdAbuse)
                ? Number(object.hatefulContentThresholdAbuse)
                : 0,
            hatefulContentThresholdIdentity: isSet(object.hatefulContentThresholdIdentity)
                ? Number(object.hatefulContentThresholdIdentity)
                : 0,
            headerTitle: isSet(object.headerTitle) ? String(object.headerTitle) : "",
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : "",
            linkType: isSet(object.linkType) ? String(object.linkType) : "",
            name: isSet(object.name) ? String(object.name) : "",
            newPinnedPostPnsEnabled: isSet(object.newPinnedPostPnsEnabled) ? Boolean(object.newPinnedPostPnsEnabled) : false,
            originalContentTagEnabled: isSet(object.originalContentTagEnabled)
                ? Boolean(object.originalContentTagEnabled)
                : false,
            over18: isSet(object.over18) ? Boolean(object.over18) : false,
            predictionLeaderboardEntryType: isSet(object.predictionLeaderboardEntryType)
                ? Number(object.predictionLeaderboardEntryType)
                : 0,
            publicDescription: isSet(object.publicDescription) ? String(object.publicDescription) : "",
            restrictCommenting: isSet(object.restrictCommenting) ? Boolean(object.restrictCommenting) : false,
            restrictPosting: isSet(object.restrictPosting) ? Boolean(object.restrictPosting) : false,
            shouldArchivePosts: isSet(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : false,
            showMedia: isSet(object.showMedia) ? Boolean(object.showMedia) : false,
            showMediaPreview: isSet(object.showMediaPreview) ? Boolean(object.showMediaPreview) : false,
            spamComments: isSet(object.spamComments) ? String(object.spamComments) : "",
            spamLinks: isSet(object.spamLinks) ? String(object.spamLinks) : "",
            spamSelfposts: isSet(object.spamSelfposts) ? String(object.spamSelfposts) : "",
            spoilersEnabled: isSet(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : false,
            sr: isSet(object.sr) ? String(object.sr) : "",
            submitLinkLabel: isSet(object.submitLinkLabel) ? String(object.submitLinkLabel) : "",
            submitText: isSet(object.submitText) ? String(object.submitText) : "",
            submitTextLabel: isSet(object.submitTextLabel) ? String(object.submitTextLabel) : "",
            suggestedCommentSort: isSet(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : "",
            title: isSet(object.title) ? String(object.title) : "",
            toxicityThresholdChatLevel: isSet(object.toxicityThresholdChatLevel)
                ? Number(object.toxicityThresholdChatLevel)
                : 0,
            type: isSet(object.type) ? String(object.type) : "",
            userFlairPnsEnabled: isSet(object.userFlairPnsEnabled) ? Boolean(object.userFlairPnsEnabled) : false,
            welcomeMessageEnabled: isSet(object.welcomeMessageEnabled) ? Boolean(object.welcomeMessageEnabled) : false,
            welcomeMessageText: isSet(object.welcomeMessageText) ? String(object.welcomeMessageText) : "",
            wikiEditAge: isSet(object.wikiEditAge) ? Number(object.wikiEditAge) : 0,
            wikiEditKarma: isSet(object.wikiEditKarma) ? Number(object.wikiEditKarma) : 0,
            wikimode: isSet(object.wikimode) ? String(object.wikimode) : "",
            crowdControlChatLevel: isSet(object.crowdControlChatLevel) ? Number(object.crowdControlChatLevel) : 0,
            hideAds: isSet(object.hideAds) ? Boolean(object.hideAds) : false,
            modmailHarassmentFilterEnabled: isSet(object.modmailHarassmentFilterEnabled)
                ? Boolean(object.modmailHarassmentFilterEnabled)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.acceptFollowers !== undefined && (obj.acceptFollowers = message.acceptFollowers);
        message.adminOverrideSpamComments !== undefined &&
            (obj.adminOverrideSpamComments = message.adminOverrideSpamComments);
        message.adminOverrideSpamLinks !== undefined && (obj.adminOverrideSpamLinks = message.adminOverrideSpamLinks);
        message.adminOverrideSpamSelfposts !== undefined &&
            (obj.adminOverrideSpamSelfposts = message.adminOverrideSpamSelfposts);
        message.allOriginalContent !== undefined && (obj.allOriginalContent = message.allOriginalContent);
        message.allowChatPostCreation !== undefined && (obj.allowChatPostCreation = message.allowChatPostCreation);
        message.allowDiscovery !== undefined && (obj.allowDiscovery = message.allowDiscovery);
        message.allowGalleries !== undefined && (obj.allowGalleries = message.allowGalleries);
        message.allowImages !== undefined && (obj.allowImages = message.allowImages);
        message.allowPolls !== undefined && (obj.allowPolls = message.allowPolls);
        message.allowPostCrossposts !== undefined && (obj.allowPostCrossposts = message.allowPostCrossposts);
        message.allowPredictionContributors !== undefined &&
            (obj.allowPredictionContributors = message.allowPredictionContributors);
        message.allowPredictions !== undefined && (obj.allowPredictions = message.allowPredictions);
        message.allowPredictionsTournament !== undefined &&
            (obj.allowPredictionsTournament = message.allowPredictionsTournament);
        message.allowTalks !== undefined && (obj.allowTalks = message.allowTalks);
        message.allowTop !== undefined && (obj.allowTop = message.allowTop);
        message.allowVideos !== undefined && (obj.allowVideos = message.allowVideos);
        message.banEvasionThreshold !== undefined && (obj.banEvasionThreshold = Math.round(message.banEvasionThreshold));
        message.collapseDeletedComments !== undefined && (obj.collapseDeletedComments = message.collapseDeletedComments);
        message.commentContributionSettings !== undefined &&
            (obj.commentContributionSettings = message.commentContributionSettings
                ? CommentContributionSettings.toJSON(message.commentContributionSettings)
                : undefined);
        message.commentScoreHideMins !== undefined && (obj.commentScoreHideMins = Math.round(message.commentScoreHideMins));
        message.crowdControlFilter !== undefined && (obj.crowdControlFilter = message.crowdControlFilter);
        message.crowdControlLevel !== undefined && (obj.crowdControlLevel = Math.round(message.crowdControlLevel));
        message.crowdControlMode !== undefined && (obj.crowdControlMode = message.crowdControlMode);
        message.crowdControlPostLevel !== undefined &&
            (obj.crowdControlPostLevel = Math.round(message.crowdControlPostLevel));
        message.description !== undefined && (obj.description = message.description);
        message.disableContributorRequests !== undefined &&
            (obj.disableContributorRequests = message.disableContributorRequests);
        message.excludeBannedModqueue !== undefined && (obj.excludeBannedModqueue = message.excludeBannedModqueue);
        message.freeFormReports !== undefined && (obj.freeFormReports = message.freeFormReports);
        message.gRecaptchaResponse !== undefined && (obj.gRecaptchaResponse = message.gRecaptchaResponse);
        message.hatefulContentThresholdAbuse !== undefined &&
            (obj.hatefulContentThresholdAbuse = Math.round(message.hatefulContentThresholdAbuse));
        message.hatefulContentThresholdIdentity !== undefined &&
            (obj.hatefulContentThresholdIdentity = Math.round(message.hatefulContentThresholdIdentity));
        message.headerTitle !== undefined && (obj.headerTitle = message.headerTitle);
        message.keyColor !== undefined && (obj.keyColor = message.keyColor);
        message.linkType !== undefined && (obj.linkType = message.linkType);
        message.name !== undefined && (obj.name = message.name);
        message.newPinnedPostPnsEnabled !== undefined && (obj.newPinnedPostPnsEnabled = message.newPinnedPostPnsEnabled);
        message.originalContentTagEnabled !== undefined &&
            (obj.originalContentTagEnabled = message.originalContentTagEnabled);
        message.over18 !== undefined && (obj.over18 = message.over18);
        message.predictionLeaderboardEntryType !== undefined &&
            (obj.predictionLeaderboardEntryType = Math.round(message.predictionLeaderboardEntryType));
        message.publicDescription !== undefined && (obj.publicDescription = message.publicDescription);
        message.restrictCommenting !== undefined && (obj.restrictCommenting = message.restrictCommenting);
        message.restrictPosting !== undefined && (obj.restrictPosting = message.restrictPosting);
        message.shouldArchivePosts !== undefined && (obj.shouldArchivePosts = message.shouldArchivePosts);
        message.showMedia !== undefined && (obj.showMedia = message.showMedia);
        message.showMediaPreview !== undefined && (obj.showMediaPreview = message.showMediaPreview);
        message.spamComments !== undefined && (obj.spamComments = message.spamComments);
        message.spamLinks !== undefined && (obj.spamLinks = message.spamLinks);
        message.spamSelfposts !== undefined && (obj.spamSelfposts = message.spamSelfposts);
        message.spoilersEnabled !== undefined && (obj.spoilersEnabled = message.spoilersEnabled);
        message.sr !== undefined && (obj.sr = message.sr);
        message.submitLinkLabel !== undefined && (obj.submitLinkLabel = message.submitLinkLabel);
        message.submitText !== undefined && (obj.submitText = message.submitText);
        message.submitTextLabel !== undefined && (obj.submitTextLabel = message.submitTextLabel);
        message.suggestedCommentSort !== undefined && (obj.suggestedCommentSort = message.suggestedCommentSort);
        message.title !== undefined && (obj.title = message.title);
        message.toxicityThresholdChatLevel !== undefined &&
            (obj.toxicityThresholdChatLevel = Math.round(message.toxicityThresholdChatLevel));
        message.type !== undefined && (obj.type = message.type);
        message.userFlairPnsEnabled !== undefined && (obj.userFlairPnsEnabled = message.userFlairPnsEnabled);
        message.welcomeMessageEnabled !== undefined && (obj.welcomeMessageEnabled = message.welcomeMessageEnabled);
        message.welcomeMessageText !== undefined && (obj.welcomeMessageText = message.welcomeMessageText);
        message.wikiEditAge !== undefined && (obj.wikiEditAge = Math.round(message.wikiEditAge));
        message.wikiEditKarma !== undefined && (obj.wikiEditKarma = Math.round(message.wikiEditKarma));
        message.wikimode !== undefined && (obj.wikimode = message.wikimode);
        message.crowdControlChatLevel !== undefined &&
            (obj.crowdControlChatLevel = Math.round(message.crowdControlChatLevel));
        message.hideAds !== undefined && (obj.hideAds = message.hideAds);
        message.modmailHarassmentFilterEnabled !== undefined &&
            (obj.modmailHarassmentFilterEnabled = message.modmailHarassmentFilterEnabled);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSiteAdminRequest();
        message.acceptFollowers = object.acceptFollowers ?? false;
        message.adminOverrideSpamComments = object.adminOverrideSpamComments ?? false;
        message.adminOverrideSpamLinks = object.adminOverrideSpamLinks ?? false;
        message.adminOverrideSpamSelfposts = object.adminOverrideSpamSelfposts ?? false;
        message.allOriginalContent = object.allOriginalContent ?? false;
        message.allowChatPostCreation = object.allowChatPostCreation ?? false;
        message.allowDiscovery = object.allowDiscovery ?? false;
        message.allowGalleries = object.allowGalleries ?? false;
        message.allowImages = object.allowImages ?? false;
        message.allowPolls = object.allowPolls ?? false;
        message.allowPostCrossposts = object.allowPostCrossposts ?? false;
        message.allowPredictionContributors = object.allowPredictionContributors ?? false;
        message.allowPredictions = object.allowPredictions ?? false;
        message.allowPredictionsTournament = object.allowPredictionsTournament ?? false;
        message.allowTalks = object.allowTalks ?? false;
        message.allowTop = object.allowTop ?? false;
        message.allowVideos = object.allowVideos ?? false;
        message.banEvasionThreshold = object.banEvasionThreshold ?? 0;
        message.collapseDeletedComments = object.collapseDeletedComments ?? false;
        message.commentContributionSettings =
            (object.commentContributionSettings !== undefined && object.commentContributionSettings !== null)
                ? CommentContributionSettings.fromPartial(object.commentContributionSettings)
                : undefined;
        message.commentScoreHideMins = object.commentScoreHideMins ?? 0;
        message.crowdControlFilter = object.crowdControlFilter ?? false;
        message.crowdControlLevel = object.crowdControlLevel ?? 0;
        message.crowdControlMode = object.crowdControlMode ?? false;
        message.crowdControlPostLevel = object.crowdControlPostLevel ?? 0;
        message.description = object.description ?? "";
        message.disableContributorRequests = object.disableContributorRequests ?? false;
        message.excludeBannedModqueue = object.excludeBannedModqueue ?? false;
        message.freeFormReports = object.freeFormReports ?? false;
        message.gRecaptchaResponse = object.gRecaptchaResponse ?? "";
        message.hatefulContentThresholdAbuse = object.hatefulContentThresholdAbuse ?? 0;
        message.hatefulContentThresholdIdentity = object.hatefulContentThresholdIdentity ?? 0;
        message.headerTitle = object.headerTitle ?? "";
        message.keyColor = object.keyColor ?? "";
        message.linkType = object.linkType ?? "";
        message.name = object.name ?? "";
        message.newPinnedPostPnsEnabled = object.newPinnedPostPnsEnabled ?? false;
        message.originalContentTagEnabled = object.originalContentTagEnabled ?? false;
        message.over18 = object.over18 ?? false;
        message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? 0;
        message.publicDescription = object.publicDescription ?? "";
        message.restrictCommenting = object.restrictCommenting ?? false;
        message.restrictPosting = object.restrictPosting ?? false;
        message.shouldArchivePosts = object.shouldArchivePosts ?? false;
        message.showMedia = object.showMedia ?? false;
        message.showMediaPreview = object.showMediaPreview ?? false;
        message.spamComments = object.spamComments ?? "";
        message.spamLinks = object.spamLinks ?? "";
        message.spamSelfposts = object.spamSelfposts ?? "";
        message.spoilersEnabled = object.spoilersEnabled ?? false;
        message.sr = object.sr ?? "";
        message.submitLinkLabel = object.submitLinkLabel ?? "";
        message.submitText = object.submitText ?? "";
        message.submitTextLabel = object.submitTextLabel ?? "";
        message.suggestedCommentSort = object.suggestedCommentSort ?? "";
        message.title = object.title ?? "";
        message.toxicityThresholdChatLevel = object.toxicityThresholdChatLevel ?? 0;
        message.type = object.type ?? "";
        message.userFlairPnsEnabled = object.userFlairPnsEnabled ?? false;
        message.welcomeMessageEnabled = object.welcomeMessageEnabled ?? false;
        message.welcomeMessageText = object.welcomeMessageText ?? "";
        message.wikiEditAge = object.wikiEditAge ?? 0;
        message.wikiEditKarma = object.wikiEditKarma ?? 0;
        message.wikimode = object.wikimode ?? "";
        message.crowdControlChatLevel = object.crowdControlChatLevel ?? 0;
        message.hideAds = object.hideAds ?? false;
        message.modmailHarassmentFilterEnabled = object.modmailHarassmentFilterEnabled ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SiteAdminRequest", SiteAdminRequest);
function createBaseSubredditAutocompleteRequest() {
    return {
        includeOver18: undefined,
        includeProfiles: undefined,
        limit: undefined,
        query: "",
        searchQueryId: undefined,
        typeaheadActive: undefined,
    };
}
export const SubredditAutocompleteRequest = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.includeOver18 !== undefined) {
            BoolValue.encode({ value: message.includeOver18 }, writer.uint32(10).fork()).ldelim();
        }
        if (message.includeProfiles !== undefined) {
            BoolValue.encode({ value: message.includeProfiles }, writer.uint32(18).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();
        }
        if (message.query !== "") {
            writer.uint32(34).string(message.query);
        }
        if (message.searchQueryId !== undefined) {
            StringValue.encode({ value: message.searchQueryId }, writer.uint32(42).fork()).ldelim();
        }
        if (message.typeaheadActive !== undefined) {
            BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAutocompleteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.includeOver18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.includeProfiles = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.query = reader.string();
                    break;
                case 5:
                    message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            includeOver18: isSet(object.includeOver18) ? Boolean(object.includeOver18) : undefined,
            includeProfiles: isSet(object.includeProfiles) ? Boolean(object.includeProfiles) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            query: isSet(object.query) ? String(object.query) : "",
            searchQueryId: isSet(object.searchQueryId) ? String(object.searchQueryId) : undefined,
            typeaheadActive: isSet(object.typeaheadActive) ? Boolean(object.typeaheadActive) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.includeOver18 !== undefined && (obj.includeOver18 = message.includeOver18);
        message.includeProfiles !== undefined && (obj.includeProfiles = message.includeProfiles);
        message.limit !== undefined && (obj.limit = message.limit);
        message.query !== undefined && (obj.query = message.query);
        message.searchQueryId !== undefined && (obj.searchQueryId = message.searchQueryId);
        message.typeaheadActive !== undefined && (obj.typeaheadActive = message.typeaheadActive);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAutocompleteRequest();
        message.includeOver18 = object.includeOver18 ?? undefined;
        message.includeProfiles = object.includeProfiles ?? undefined;
        message.limit = object.limit ?? undefined;
        message.query = object.query ?? "";
        message.searchQueryId = object.searchQueryId ?? undefined;
        message.typeaheadActive = object.typeaheadActive ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteRequest", SubredditAutocompleteRequest);
function createBaseSubredditStylesheetRequest() {
    return { op: "", reason: "", stylesheetContents: "", subreddit: "" };
}
export const SubredditStylesheetRequest = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditStylesheetRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.op !== "") {
            writer.uint32(10).string(message.op);
        }
        if (message.reason !== "") {
            writer.uint32(18).string(message.reason);
        }
        if (message.stylesheetContents !== "") {
            writer.uint32(26).string(message.stylesheetContents);
        }
        if (message.subreddit !== "") {
            writer.uint32(34).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditStylesheetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.string();
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                case 3:
                    message.stylesheetContents = reader.string();
                    break;
                case 4:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            op: isSet(object.op) ? String(object.op) : "",
            reason: isSet(object.reason) ? String(object.reason) : "",
            stylesheetContents: isSet(object.stylesheetContents) ? String(object.stylesheetContents) : "",
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.op !== undefined && (obj.op = message.op);
        message.reason !== undefined && (obj.reason = message.reason);
        message.stylesheetContents !== undefined && (obj.stylesheetContents = message.stylesheetContents);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditStylesheetRequest();
        message.op = object.op ?? "";
        message.reason = object.reason ?? "";
        message.stylesheetContents = object.stylesheetContents ?? "";
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditStylesheetRequest", SubredditStylesheetRequest);
function createBaseSubscribeRequest() {
    return { action: "", actionSource: "", skipInitialDefaults: false, sr: "", srName: "" };
}
export const SubscribeRequest = {
    $type: "devvit.plugin.redditapi.subreddits.SubscribeRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.action !== "") {
            writer.uint32(10).string(message.action);
        }
        if (message.actionSource !== "") {
            writer.uint32(18).string(message.actionSource);
        }
        if (message.skipInitialDefaults === true) {
            writer.uint32(24).bool(message.skipInitialDefaults);
        }
        if (message.sr !== "") {
            writer.uint32(34).string(message.sr);
        }
        if (message.srName !== "") {
            writer.uint32(42).string(message.srName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.action = reader.string();
                    break;
                case 2:
                    message.actionSource = reader.string();
                    break;
                case 3:
                    message.skipInitialDefaults = reader.bool();
                    break;
                case 4:
                    message.sr = reader.string();
                    break;
                case 5:
                    message.srName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            action: isSet(object.action) ? String(object.action) : "",
            actionSource: isSet(object.actionSource) ? String(object.actionSource) : "",
            skipInitialDefaults: isSet(object.skipInitialDefaults) ? Boolean(object.skipInitialDefaults) : false,
            sr: isSet(object.sr) ? String(object.sr) : "",
            srName: isSet(object.srName) ? String(object.srName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.action !== undefined && (obj.action = message.action);
        message.actionSource !== undefined && (obj.actionSource = message.actionSource);
        message.skipInitialDefaults !== undefined && (obj.skipInitialDefaults = message.skipInitialDefaults);
        message.sr !== undefined && (obj.sr = message.sr);
        message.srName !== undefined && (obj.srName = message.srName);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubscribeRequest();
        message.action = object.action ?? "";
        message.actionSource = object.actionSource ?? "";
        message.skipInitialDefaults = object.skipInitialDefaults ?? false;
        message.sr = object.sr ?? "";
        message.srName = object.srName ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubscribeRequest", SubscribeRequest);
function createBaseUploadSrImgRequest() {
    return { file: "", header: 0, imgType: "", name: "", uploadType: "", subreddit: "" };
}
export const UploadSrImgRequest = {
    $type: "devvit.plugin.redditapi.subreddits.UploadSrImgRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.file !== "") {
            writer.uint32(10).string(message.file);
        }
        if (message.header !== 0) {
            writer.uint32(16).int64(message.header);
        }
        if (message.imgType !== "") {
            writer.uint32(26).string(message.imgType);
        }
        if (message.name !== "") {
            writer.uint32(34).string(message.name);
        }
        if (message.uploadType !== "") {
            writer.uint32(42).string(message.uploadType);
        }
        if (message.subreddit !== "") {
            writer.uint32(50).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadSrImgRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.file = reader.string();
                    break;
                case 2:
                    message.header = longToNumber(reader.int64());
                    break;
                case 3:
                    message.imgType = reader.string();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.uploadType = reader.string();
                    break;
                case 6:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            file: isSet(object.file) ? String(object.file) : "",
            header: isSet(object.header) ? Number(object.header) : 0,
            imgType: isSet(object.imgType) ? String(object.imgType) : "",
            name: isSet(object.name) ? String(object.name) : "",
            uploadType: isSet(object.uploadType) ? String(object.uploadType) : "",
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.file !== undefined && (obj.file = message.file);
        message.header !== undefined && (obj.header = Math.round(message.header));
        message.imgType !== undefined && (obj.imgType = message.imgType);
        message.name !== undefined && (obj.name = message.name);
        message.uploadType !== undefined && (obj.uploadType = message.uploadType);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUploadSrImgRequest();
        message.file = object.file ?? "";
        message.header = object.header ?? 0;
        message.imgType = object.imgType ?? "";
        message.name = object.name ?? "";
        message.uploadType = object.uploadType ?? "";
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UploadSrImgRequest", UploadSrImgRequest);
function createBaseSubredditAboutEditRequest() {
    return { created: "", location: "", subreddit: "" };
}
export const SubredditAboutEditRequest = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.created !== "") {
            writer.uint32(10).string(message.created);
        }
        if (message.location !== "") {
            writer.uint32(18).string(message.location);
        }
        if (message.subreddit !== "") {
            writer.uint32(26).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutEditRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.created = reader.string();
                    break;
                case 2:
                    message.location = reader.string();
                    break;
                case 3:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            created: isSet(object.created) ? String(object.created) : "",
            location: isSet(object.location) ? String(object.location) : "",
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.created !== undefined && (obj.created = message.created);
        message.location !== undefined && (obj.location = message.location);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutEditRequest();
        message.created = object.created ?? "";
        message.location = object.location ?? "";
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutEditRequest", SubredditAboutEditRequest);
function createBaseStickyRequest() {
    return { num: 0, subreddit: "" };
}
export const StickyRequest = {
    $type: "devvit.plugin.redditapi.subreddits.StickyRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.num !== 0) {
            writer.uint32(8).int64(message.num);
        }
        if (message.subreddit !== "") {
            writer.uint32(18).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStickyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.num = longToNumber(reader.int64());
                    break;
                case 2:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            num: isSet(object.num) ? Number(object.num) : 0,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.num !== undefined && (obj.num = Math.round(message.num));
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStickyRequest();
        message.num = object.num ?? 0;
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyRequest", StickyRequest);
function createBaseBasicWhereRequest() {
    return { after: undefined, before: undefined, count: undefined, limit: undefined, show: undefined, where: "" };
}
export const BasicWhereRequest = {
    $type: "devvit.plugin.redditapi.subreddits.BasicWhereRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
        }
        if (message.where !== "") {
            writer.uint32(58).string(message.where);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicWhereRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.where = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            where: isSet(object.where) ? String(object.where) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.count !== undefined && (obj.count = message.count);
        message.limit !== undefined && (obj.limit = message.limit);
        message.show !== undefined && (obj.show = message.show);
        message.where !== undefined && (obj.where = message.where);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBasicWhereRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.show = object.show ?? undefined;
        message.where = object.where ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.BasicWhereRequest", BasicWhereRequest);
function createBaseSubredditsSearchRequest() {
    return {
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        q: "",
        searchQueryId: undefined,
        show: undefined,
        showUsers: undefined,
        sort: undefined,
        typeaheadActive: undefined,
    };
}
export const SubredditsSearchRequest = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.q !== "") {
            writer.uint32(42).string(message.q);
        }
        if (message.searchQueryId !== undefined) {
            StringValue.encode({ value: message.searchQueryId }, writer.uint32(50).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
        }
        if (message.showUsers !== undefined) {
            BoolValue.encode({ value: message.showUsers }, writer.uint32(66).fork()).ldelim();
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(74).fork()).ldelim();
        }
        if (message.typeaheadActive !== undefined) {
            BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsSearchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.q = reader.string();
                    break;
                case 6:
                    message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.showUsers = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            q: isSet(object.q) ? String(object.q) : "",
            searchQueryId: isSet(object.searchQueryId) ? String(object.searchQueryId) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            showUsers: isSet(object.showUsers) ? Boolean(object.showUsers) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            typeaheadActive: isSet(object.typeaheadActive) ? Boolean(object.typeaheadActive) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.count !== undefined && (obj.count = message.count);
        message.limit !== undefined && (obj.limit = message.limit);
        message.q !== undefined && (obj.q = message.q);
        message.searchQueryId !== undefined && (obj.searchQueryId = message.searchQueryId);
        message.show !== undefined && (obj.show = message.show);
        message.showUsers !== undefined && (obj.showUsers = message.showUsers);
        message.sort !== undefined && (obj.sort = message.sort);
        message.typeaheadActive !== undefined && (obj.typeaheadActive = message.typeaheadActive);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditsSearchRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.q = object.q ?? "";
        message.searchQueryId = object.searchQueryId ?? undefined;
        message.show = object.show ?? undefined;
        message.showUsers = object.showUsers ?? undefined;
        message.sort = object.sort ?? undefined;
        message.typeaheadActive = object.typeaheadActive ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditsSearchRequest", SubredditsSearchRequest);
function createBaseUsersSearchRequest() {
    return {
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        q: "",
        searchQueryId: undefined,
        show: undefined,
        sort: undefined,
        typeaheadActive: undefined,
    };
}
export const UsersSearchRequest = {
    $type: "devvit.plugin.redditapi.subreddits.UsersSearchRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.q !== "") {
            writer.uint32(42).string(message.q);
        }
        if (message.searchQueryId !== undefined) {
            StringValue.encode({ value: message.searchQueryId }, writer.uint32(50).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(66).fork()).ldelim();
        }
        if (message.typeaheadActive !== undefined) {
            BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUsersSearchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.q = reader.string();
                    break;
                case 6:
                    message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            q: isSet(object.q) ? String(object.q) : "",
            searchQueryId: isSet(object.searchQueryId) ? String(object.searchQueryId) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            typeaheadActive: isSet(object.typeaheadActive) ? Boolean(object.typeaheadActive) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.count !== undefined && (obj.count = message.count);
        message.limit !== undefined && (obj.limit = message.limit);
        message.q !== undefined && (obj.q = message.q);
        message.searchQueryId !== undefined && (obj.searchQueryId = message.searchQueryId);
        message.show !== undefined && (obj.show = message.show);
        message.sort !== undefined && (obj.sort = message.sort);
        message.typeaheadActive !== undefined && (obj.typeaheadActive = message.typeaheadActive);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUsersSearchRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.q = object.q ?? "";
        message.searchQueryId = object.searchQueryId ?? undefined;
        message.show = object.show ?? undefined;
        message.sort = object.sort ?? undefined;
        message.typeaheadActive = object.typeaheadActive ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UsersSearchRequest", UsersSearchRequest);
function createBaseSearchRedditNamesResponse() {
    return { names: [] };
}
export const SearchRedditNamesResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SearchRedditNamesResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.names) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchRedditNamesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.names.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { names: Array.isArray(object?.names) ? object.names.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.names) {
            obj.names = message.names.map((e) => e);
        }
        else {
            obj.names = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSearchRedditNamesResponse();
        message.names = object.names?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SearchRedditNamesResponse", SearchRedditNamesResponse);
function createBaseSearchSubredditsResponse() {
    return { subreddits: [] };
}
export const SearchSubredditsResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SearchSubredditsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.subreddits) {
            SearchSubredditsResponse_SubredditData.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchSubredditsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddits.push(SearchSubredditsResponse_SubredditData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddits: Array.isArray(object?.subreddits)
                ? object.subreddits.map((e) => SearchSubredditsResponse_SubredditData.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddits) {
            obj.subreddits = message.subreddits.map((e) => e ? SearchSubredditsResponse_SubredditData.toJSON(e) : undefined);
        }
        else {
            obj.subreddits = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSearchSubredditsResponse();
        message.subreddits = object.subreddits?.map((e) => SearchSubredditsResponse_SubredditData.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SearchSubredditsResponse", SearchSubredditsResponse);
function createBaseSearchSubredditsResponse_SubredditData() {
    return {
        activeUserCount: undefined,
        iconImg: undefined,
        keyColor: undefined,
        name: undefined,
        subscriberCount: undefined,
        isChatPostFeatureEnabled: undefined,
        allowChatPostCreation: undefined,
        allowImages: undefined,
    };
}
export const SearchSubredditsResponse_SubredditData = {
    $type: "devvit.plugin.redditapi.subreddits.SearchSubredditsResponse.SubredditData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.activeUserCount !== undefined) {
            Int32Value.encode({ value: message.activeUserCount }, writer.uint32(10).fork()).ldelim();
        }
        if (message.iconImg !== undefined) {
            StringValue.encode({ value: message.iconImg }, writer.uint32(18).fork()).ldelim();
        }
        if (message.keyColor !== undefined) {
            StringValue.encode({ value: message.keyColor }, writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
        }
        if (message.subscriberCount !== undefined) {
            Int32Value.encode({ value: message.subscriberCount }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isChatPostFeatureEnabled !== undefined) {
            BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(50).fork()).ldelim();
        }
        if (message.allowChatPostCreation !== undefined) {
            BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(58).fork()).ldelim();
        }
        if (message.allowImages !== undefined) {
            BoolValue.encode({ value: message.allowImages }, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchSubredditsResponse_SubredditData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.activeUserCount = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.iconImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.keyColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.subscriberCount = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            activeUserCount: isSet(object.activeUserCount) ? Number(object.activeUserCount) : undefined,
            iconImg: isSet(object.iconImg) ? String(object.iconImg) : undefined,
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            subscriberCount: isSet(object.subscriberCount) ? Number(object.subscriberCount) : undefined,
            isChatPostFeatureEnabled: isSet(object.isChatPostFeatureEnabled)
                ? Boolean(object.isChatPostFeatureEnabled)
                : undefined,
            allowChatPostCreation: isSet(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : undefined,
            allowImages: isSet(object.allowImages) ? Boolean(object.allowImages) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.activeUserCount !== undefined && (obj.activeUserCount = message.activeUserCount);
        message.iconImg !== undefined && (obj.iconImg = message.iconImg);
        message.keyColor !== undefined && (obj.keyColor = message.keyColor);
        message.name !== undefined && (obj.name = message.name);
        message.subscriberCount !== undefined && (obj.subscriberCount = message.subscriberCount);
        message.isChatPostFeatureEnabled !== undefined && (obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled);
        message.allowChatPostCreation !== undefined && (obj.allowChatPostCreation = message.allowChatPostCreation);
        message.allowImages !== undefined && (obj.allowImages = message.allowImages);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSearchSubredditsResponse_SubredditData();
        message.activeUserCount = object.activeUserCount ?? undefined;
        message.iconImg = object.iconImg ?? undefined;
        message.keyColor = object.keyColor ?? undefined;
        message.name = object.name ?? undefined;
        message.subscriberCount = object.subscriberCount ?? undefined;
        message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? undefined;
        message.allowChatPostCreation = object.allowChatPostCreation ?? undefined;
        message.allowImages = object.allowImages ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SearchSubredditsResponse.SubredditData", SearchSubredditsResponse_SubredditData);
function createBaseSubmitTextResponse() {
    return { submitText: undefined, submitTextHtml: undefined };
}
export const SubmitTextResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubmitTextResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.submitText !== undefined) {
            StringValue.encode({ value: message.submitText }, writer.uint32(10).fork()).ldelim();
        }
        if (message.submitTextHtml !== undefined) {
            StringValue.encode({ value: message.submitTextHtml }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmitTextResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.submitText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            submitText: isSet(object.submitText) ? String(object.submitText) : undefined,
            submitTextHtml: isSet(object.submitTextHtml) ? String(object.submitTextHtml) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.submitText !== undefined && (obj.submitText = message.submitText);
        message.submitTextHtml !== undefined && (obj.submitTextHtml = message.submitTextHtml);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubmitTextResponse();
        message.submitText = object.submitText ?? undefined;
        message.submitTextHtml = object.submitTextHtml ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubmitTextResponse", SubmitTextResponse);
function createBaseSubredditAutocompleteResponse() {
    return { kind: undefined, data: undefined };
}
export const SubredditAutocompleteResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            SubredditAutocompleteResponse_AutocompleteResponse.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAutocompleteResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = SubredditAutocompleteResponse_AutocompleteResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? SubredditAutocompleteResponse_AutocompleteResponse.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? SubredditAutocompleteResponse_AutocompleteResponse.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAutocompleteResponse();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? SubredditAutocompleteResponse_AutocompleteResponse.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse", SubredditAutocompleteResponse);
function createBaseSubredditAutocompleteResponse_AutocompleteAccount() {
    return {
        isEmployee: undefined,
        isFriend: undefined,
        snoovatarSize: undefined,
        id: undefined,
        verified: undefined,
        isGold: undefined,
        isMod: undefined,
        hasVerifiedEmail: undefined,
        iconImg: undefined,
        hideFromRobots: undefined,
        linkKarma: undefined,
        acceptChats: undefined,
        isBlocked: undefined,
        prefShowSnoovatar: undefined,
        name: undefined,
        created: undefined,
        createdUtc: undefined,
        snoovatarImg: undefined,
        commentKarma: undefined,
        acceptFollowers: undefined,
        hasSubscribed: undefined,
        acceptPms: undefined,
    };
}
export const SubredditAutocompleteResponse_AutocompleteAccount = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isEmployee !== undefined) {
            BoolValue.encode({ value: message.isEmployee }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isFriend !== undefined) {
            BoolValue.encode({ value: message.isFriend }, writer.uint32(18).fork()).ldelim();
        }
        if (message.snoovatarSize !== undefined) {
            Int32Value.encode({ value: message.snoovatarSize }, writer.uint32(26).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(34).fork()).ldelim();
        }
        if (message.verified !== undefined) {
            BoolValue.encode({ value: message.verified }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isGold !== undefined) {
            BoolValue.encode({ value: message.isGold }, writer.uint32(50).fork()).ldelim();
        }
        if (message.isMod !== undefined) {
            BoolValue.encode({ value: message.isMod }, writer.uint32(58).fork()).ldelim();
        }
        if (message.hasVerifiedEmail !== undefined) {
            BoolValue.encode({ value: message.hasVerifiedEmail }, writer.uint32(66).fork()).ldelim();
        }
        if (message.iconImg !== undefined) {
            StringValue.encode({ value: message.iconImg }, writer.uint32(74).fork()).ldelim();
        }
        if (message.hideFromRobots !== undefined) {
            BoolValue.encode({ value: message.hideFromRobots }, writer.uint32(82).fork()).ldelim();
        }
        if (message.linkKarma !== undefined) {
            Int32Value.encode({ value: message.linkKarma }, writer.uint32(90).fork()).ldelim();
        }
        if (message.acceptChats !== undefined) {
            BoolValue.encode({ value: message.acceptChats }, writer.uint32(98).fork()).ldelim();
        }
        if (message.isBlocked !== undefined) {
            BoolValue.encode({ value: message.isBlocked }, writer.uint32(106).fork()).ldelim();
        }
        if (message.prefShowSnoovatar !== undefined) {
            BoolValue.encode({ value: message.prefShowSnoovatar }, writer.uint32(114).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(122).fork()).ldelim();
        }
        if (message.created !== undefined) {
            Int64Value.encode({ value: message.created }, writer.uint32(130).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(138).fork()).ldelim();
        }
        if (message.snoovatarImg !== undefined) {
            StringValue.encode({ value: message.snoovatarImg }, writer.uint32(146).fork()).ldelim();
        }
        if (message.commentKarma !== undefined) {
            Int64Value.encode({ value: message.commentKarma }, writer.uint32(154).fork()).ldelim();
        }
        if (message.acceptFollowers !== undefined) {
            BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(162).fork()).ldelim();
        }
        if (message.hasSubscribed !== undefined) {
            BoolValue.encode({ value: message.hasSubscribed }, writer.uint32(170).fork()).ldelim();
        }
        if (message.acceptPms !== undefined) {
            BoolValue.encode({ value: message.acceptPms }, writer.uint32(178).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isEmployee = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.isFriend = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.snoovatarSize = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.verified = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.isGold = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.isMod = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.hasVerifiedEmail = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.iconImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.hideFromRobots = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.linkKarma = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.acceptChats = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.isBlocked = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.prefShowSnoovatar = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.created = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.snoovatarImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.commentKarma = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.hasSubscribed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.acceptPms = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isEmployee: isSet(object.isEmployee) ? Boolean(object.isEmployee) : undefined,
            isFriend: isSet(object.isFriend) ? Boolean(object.isFriend) : undefined,
            snoovatarSize: isSet(object.snoovatarSize) ? Number(object.snoovatarSize) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            verified: isSet(object.verified) ? Boolean(object.verified) : undefined,
            isGold: isSet(object.isGold) ? Boolean(object.isGold) : undefined,
            isMod: isSet(object.isMod) ? Boolean(object.isMod) : undefined,
            hasVerifiedEmail: isSet(object.hasVerifiedEmail) ? Boolean(object.hasVerifiedEmail) : undefined,
            iconImg: isSet(object.iconImg) ? String(object.iconImg) : undefined,
            hideFromRobots: isSet(object.hideFromRobots) ? Boolean(object.hideFromRobots) : undefined,
            linkKarma: isSet(object.linkKarma) ? Number(object.linkKarma) : undefined,
            acceptChats: isSet(object.acceptChats) ? Boolean(object.acceptChats) : undefined,
            isBlocked: isSet(object.isBlocked) ? Boolean(object.isBlocked) : undefined,
            prefShowSnoovatar: isSet(object.prefShowSnoovatar) ? Boolean(object.prefShowSnoovatar) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            created: isSet(object.created) ? Number(object.created) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            snoovatarImg: isSet(object.snoovatarImg) ? String(object.snoovatarImg) : undefined,
            commentKarma: isSet(object.commentKarma) ? Number(object.commentKarma) : undefined,
            acceptFollowers: isSet(object.acceptFollowers) ? Boolean(object.acceptFollowers) : undefined,
            hasSubscribed: isSet(object.hasSubscribed) ? Boolean(object.hasSubscribed) : undefined,
            acceptPms: isSet(object.acceptPms) ? Boolean(object.acceptPms) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.isEmployee !== undefined && (obj.isEmployee = message.isEmployee);
        message.isFriend !== undefined && (obj.isFriend = message.isFriend);
        message.snoovatarSize !== undefined && (obj.snoovatarSize = message.snoovatarSize);
        message.id !== undefined && (obj.id = message.id);
        message.verified !== undefined && (obj.verified = message.verified);
        message.isGold !== undefined && (obj.isGold = message.isGold);
        message.isMod !== undefined && (obj.isMod = message.isMod);
        message.hasVerifiedEmail !== undefined && (obj.hasVerifiedEmail = message.hasVerifiedEmail);
        message.iconImg !== undefined && (obj.iconImg = message.iconImg);
        message.hideFromRobots !== undefined && (obj.hideFromRobots = message.hideFromRobots);
        message.linkKarma !== undefined && (obj.linkKarma = message.linkKarma);
        message.acceptChats !== undefined && (obj.acceptChats = message.acceptChats);
        message.isBlocked !== undefined && (obj.isBlocked = message.isBlocked);
        message.prefShowSnoovatar !== undefined && (obj.prefShowSnoovatar = message.prefShowSnoovatar);
        message.name !== undefined && (obj.name = message.name);
        message.created !== undefined && (obj.created = message.created);
        message.createdUtc !== undefined && (obj.createdUtc = message.createdUtc);
        message.snoovatarImg !== undefined && (obj.snoovatarImg = message.snoovatarImg);
        message.commentKarma !== undefined && (obj.commentKarma = message.commentKarma);
        message.acceptFollowers !== undefined && (obj.acceptFollowers = message.acceptFollowers);
        message.hasSubscribed !== undefined && (obj.hasSubscribed = message.hasSubscribed);
        message.acceptPms !== undefined && (obj.acceptPms = message.acceptPms);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount();
        message.isEmployee = object.isEmployee ?? undefined;
        message.isFriend = object.isFriend ?? undefined;
        message.snoovatarSize = object.snoovatarSize ?? undefined;
        message.id = object.id ?? undefined;
        message.verified = object.verified ?? undefined;
        message.isGold = object.isGold ?? undefined;
        message.isMod = object.isMod ?? undefined;
        message.hasVerifiedEmail = object.hasVerifiedEmail ?? undefined;
        message.iconImg = object.iconImg ?? undefined;
        message.hideFromRobots = object.hideFromRobots ?? undefined;
        message.linkKarma = object.linkKarma ?? undefined;
        message.acceptChats = object.acceptChats ?? undefined;
        message.isBlocked = object.isBlocked ?? undefined;
        message.prefShowSnoovatar = object.prefShowSnoovatar ?? undefined;
        message.name = object.name ?? undefined;
        message.created = object.created ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.snoovatarImg = object.snoovatarImg ?? undefined;
        message.commentKarma = object.commentKarma ?? undefined;
        message.acceptFollowers = object.acceptFollowers ?? undefined;
        message.hasSubscribed = object.hasSubscribed ?? undefined;
        message.acceptPms = object.acceptPms ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount", SubredditAutocompleteResponse_AutocompleteAccount);
function createBaseSubredditAutocompleteResponse_AutocompleteAccount_Subreddit() {
    return {
        defaultSet: undefined,
        userIsContributor: undefined,
        bannerImg: undefined,
        allowedMediaInComments: [],
        userIsBanned: undefined,
        freeFormReports: undefined,
        communityIcon: undefined,
        showMedia: undefined,
        iconColor: undefined,
        userIsMuted: undefined,
        displayName: undefined,
        headerImg: undefined,
        title: undefined,
        previousNames: [],
        over18: undefined,
        iconSize: [],
        primaryColor: undefined,
        iconImg: undefined,
        description: undefined,
        submitLinkLabel: undefined,
        headerSize: undefined,
        restrictPosting: undefined,
        restrictCommenting: undefined,
        subscribers: undefined,
        submitTextLabel: undefined,
        isDefaultIcon: undefined,
        inkFlairPosition: undefined,
        displayNamePrefixed: undefined,
        keyColor: undefined,
        name: undefined,
        isDefaultBanner: undefined,
        url: undefined,
        quarantine: undefined,
        bannerSize: undefined,
        userIsModerator: undefined,
        acceptFollowers: undefined,
        publicDescription: undefined,
        linkFlairEnabled: undefined,
        disableContributorRequests: undefined,
        subredditType: undefined,
        userIsSubscriber: undefined,
    };
}
export const SubredditAutocompleteResponse_AutocompleteAccount_Subreddit = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount.Subreddit",
    encode(message, writer = _m0.Writer.create()) {
        if (message.defaultSet !== undefined) {
            BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
        }
        if (message.userIsContributor !== undefined) {
            BoolValue.encode({ value: message.userIsContributor }, writer.uint32(18).fork()).ldelim();
        }
        if (message.bannerImg !== undefined) {
            StringValue.encode({ value: message.bannerImg }, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.allowedMediaInComments) {
            StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
        }
        if (message.userIsBanned !== undefined) {
            BoolValue.encode({ value: message.userIsBanned }, writer.uint32(42).fork()).ldelim();
        }
        if (message.freeFormReports !== undefined) {
            BoolValue.encode({ value: message.freeFormReports }, writer.uint32(50).fork()).ldelim();
        }
        if (message.communityIcon !== undefined) {
            StringValue.encode({ value: message.communityIcon }, writer.uint32(58).fork()).ldelim();
        }
        if (message.showMedia !== undefined) {
            BoolValue.encode({ value: message.showMedia }, writer.uint32(66).fork()).ldelim();
        }
        if (message.iconColor !== undefined) {
            StringValue.encode({ value: message.iconColor }, writer.uint32(74).fork()).ldelim();
        }
        if (message.userIsMuted !== undefined) {
            BoolValue.encode({ value: message.userIsMuted }, writer.uint32(82).fork()).ldelim();
        }
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(90).fork()).ldelim();
        }
        if (message.headerImg !== undefined) {
            StringValue.encode({ value: message.headerImg }, writer.uint32(98).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(106).fork()).ldelim();
        }
        for (const v of message.previousNames) {
            StringValue.encode({ value: v }, writer.uint32(114).fork()).ldelim();
        }
        if (message.over18 !== undefined) {
            BoolValue.encode({ value: message.over18 }, writer.uint32(122).fork()).ldelim();
        }
        for (const v of message.iconSize) {
            Int32Value.encode({ value: v }, writer.uint32(130).fork()).ldelim();
        }
        if (message.primaryColor !== undefined) {
            StringValue.encode({ value: message.primaryColor }, writer.uint32(138).fork()).ldelim();
        }
        if (message.iconImg !== undefined) {
            StringValue.encode({ value: message.iconImg }, writer.uint32(146).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(154).fork()).ldelim();
        }
        if (message.submitLinkLabel !== undefined) {
            StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(162).fork()).ldelim();
        }
        if (message.headerSize !== undefined) {
            Int32Value.encode({ value: message.headerSize }, writer.uint32(170).fork()).ldelim();
        }
        if (message.restrictPosting !== undefined) {
            BoolValue.encode({ value: message.restrictPosting }, writer.uint32(178).fork()).ldelim();
        }
        if (message.restrictCommenting !== undefined) {
            BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(186).fork()).ldelim();
        }
        if (message.subscribers !== undefined) {
            Int64Value.encode({ value: message.subscribers }, writer.uint32(194).fork()).ldelim();
        }
        if (message.submitTextLabel !== undefined) {
            StringValue.encode({ value: message.submitTextLabel }, writer.uint32(202).fork()).ldelim();
        }
        if (message.isDefaultIcon !== undefined) {
            BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(210).fork()).ldelim();
        }
        if (message.inkFlairPosition !== undefined) {
            StringValue.encode({ value: message.inkFlairPosition }, writer.uint32(218).fork()).ldelim();
        }
        if (message.displayNamePrefixed !== undefined) {
            StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(226).fork()).ldelim();
        }
        if (message.keyColor !== undefined) {
            StringValue.encode({ value: message.keyColor }, writer.uint32(234).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(242).fork()).ldelim();
        }
        if (message.isDefaultBanner !== undefined) {
            BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(250).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(258).fork()).ldelim();
        }
        if (message.quarantine !== undefined) {
            BoolValue.encode({ value: message.quarantine }, writer.uint32(266).fork()).ldelim();
        }
        if (message.bannerSize !== undefined) {
            Int32Value.encode({ value: message.bannerSize }, writer.uint32(274).fork()).ldelim();
        }
        if (message.userIsModerator !== undefined) {
            BoolValue.encode({ value: message.userIsModerator }, writer.uint32(282).fork()).ldelim();
        }
        if (message.acceptFollowers !== undefined) {
            BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(290).fork()).ldelim();
        }
        if (message.publicDescription !== undefined) {
            StringValue.encode({ value: message.publicDescription }, writer.uint32(298).fork()).ldelim();
        }
        if (message.linkFlairEnabled !== undefined) {
            BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(306).fork()).ldelim();
        }
        if (message.disableContributorRequests !== undefined) {
            BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(314).fork()).ldelim();
        }
        if (message.subredditType !== undefined) {
            StringValue.encode({ value: message.subredditType }, writer.uint32(322).fork()).ldelim();
        }
        if (message.userIsSubscriber !== undefined) {
            BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(330).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount_Subreddit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 5:
                    message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.iconColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.headerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 15:
                    message.over18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
                    break;
                case 17:
                    message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.iconImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.headerSize = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 26:
                    message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 27:
                    message.inkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 28:
                    message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 29:
                    message.keyColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 30:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 31:
                    message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 32:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 33:
                    message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 34:
                    message.bannerSize = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 35:
                    message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 36:
                    message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 37:
                    message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 38:
                    message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 39:
                    message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 40:
                    message.subredditType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 41:
                    message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultSet: isSet(object.defaultSet) ? Boolean(object.defaultSet) : undefined,
            userIsContributor: isSet(object.userIsContributor) ? Boolean(object.userIsContributor) : undefined,
            bannerImg: isSet(object.bannerImg) ? String(object.bannerImg) : undefined,
            allowedMediaInComments: Array.isArray(object?.allowedMediaInComments)
                ? object.allowedMediaInComments.map((e) => String(e))
                : [],
            userIsBanned: isSet(object.userIsBanned) ? Boolean(object.userIsBanned) : undefined,
            freeFormReports: isSet(object.freeFormReports) ? Boolean(object.freeFormReports) : undefined,
            communityIcon: isSet(object.communityIcon) ? String(object.communityIcon) : undefined,
            showMedia: isSet(object.showMedia) ? Boolean(object.showMedia) : undefined,
            iconColor: isSet(object.iconColor) ? String(object.iconColor) : undefined,
            userIsMuted: isSet(object.userIsMuted) ? Boolean(object.userIsMuted) : undefined,
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            headerImg: isSet(object.headerImg) ? String(object.headerImg) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            previousNames: Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
            over18: isSet(object.over18) ? Boolean(object.over18) : undefined,
            iconSize: Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
            primaryColor: isSet(object.primaryColor) ? String(object.primaryColor) : undefined,
            iconImg: isSet(object.iconImg) ? String(object.iconImg) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            submitLinkLabel: isSet(object.submitLinkLabel) ? String(object.submitLinkLabel) : undefined,
            headerSize: isSet(object.headerSize) ? Number(object.headerSize) : undefined,
            restrictPosting: isSet(object.restrictPosting) ? Boolean(object.restrictPosting) : undefined,
            restrictCommenting: isSet(object.restrictCommenting) ? Boolean(object.restrictCommenting) : undefined,
            subscribers: isSet(object.subscribers) ? Number(object.subscribers) : undefined,
            submitTextLabel: isSet(object.submitTextLabel) ? String(object.submitTextLabel) : undefined,
            isDefaultIcon: isSet(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : undefined,
            inkFlairPosition: isSet(object.inkFlairPosition) ? String(object.inkFlairPosition) : undefined,
            displayNamePrefixed: isSet(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : undefined,
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            isDefaultBanner: isSet(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            quarantine: isSet(object.quarantine) ? Boolean(object.quarantine) : undefined,
            bannerSize: isSet(object.bannerSize) ? Number(object.bannerSize) : undefined,
            userIsModerator: isSet(object.userIsModerator) ? Boolean(object.userIsModerator) : undefined,
            acceptFollowers: isSet(object.acceptFollowers) ? Boolean(object.acceptFollowers) : undefined,
            publicDescription: isSet(object.publicDescription) ? String(object.publicDescription) : undefined,
            linkFlairEnabled: isSet(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : undefined,
            disableContributorRequests: isSet(object.disableContributorRequests)
                ? Boolean(object.disableContributorRequests)
                : undefined,
            subredditType: isSet(object.subredditType) ? String(object.subredditType) : undefined,
            userIsSubscriber: isSet(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.defaultSet !== undefined && (obj.defaultSet = message.defaultSet);
        message.userIsContributor !== undefined && (obj.userIsContributor = message.userIsContributor);
        message.bannerImg !== undefined && (obj.bannerImg = message.bannerImg);
        if (message.allowedMediaInComments) {
            obj.allowedMediaInComments = message.allowedMediaInComments.map((e) => e);
        }
        else {
            obj.allowedMediaInComments = [];
        }
        message.userIsBanned !== undefined && (obj.userIsBanned = message.userIsBanned);
        message.freeFormReports !== undefined && (obj.freeFormReports = message.freeFormReports);
        message.communityIcon !== undefined && (obj.communityIcon = message.communityIcon);
        message.showMedia !== undefined && (obj.showMedia = message.showMedia);
        message.iconColor !== undefined && (obj.iconColor = message.iconColor);
        message.userIsMuted !== undefined && (obj.userIsMuted = message.userIsMuted);
        message.displayName !== undefined && (obj.displayName = message.displayName);
        message.headerImg !== undefined && (obj.headerImg = message.headerImg);
        message.title !== undefined && (obj.title = message.title);
        if (message.previousNames) {
            obj.previousNames = message.previousNames.map((e) => e);
        }
        else {
            obj.previousNames = [];
        }
        message.over18 !== undefined && (obj.over18 = message.over18);
        if (message.iconSize) {
            obj.iconSize = message.iconSize.map((e) => e);
        }
        else {
            obj.iconSize = [];
        }
        message.primaryColor !== undefined && (obj.primaryColor = message.primaryColor);
        message.iconImg !== undefined && (obj.iconImg = message.iconImg);
        message.description !== undefined && (obj.description = message.description);
        message.submitLinkLabel !== undefined && (obj.submitLinkLabel = message.submitLinkLabel);
        message.headerSize !== undefined && (obj.headerSize = message.headerSize);
        message.restrictPosting !== undefined && (obj.restrictPosting = message.restrictPosting);
        message.restrictCommenting !== undefined && (obj.restrictCommenting = message.restrictCommenting);
        message.subscribers !== undefined && (obj.subscribers = message.subscribers);
        message.submitTextLabel !== undefined && (obj.submitTextLabel = message.submitTextLabel);
        message.isDefaultIcon !== undefined && (obj.isDefaultIcon = message.isDefaultIcon);
        message.inkFlairPosition !== undefined && (obj.inkFlairPosition = message.inkFlairPosition);
        message.displayNamePrefixed !== undefined && (obj.displayNamePrefixed = message.displayNamePrefixed);
        message.keyColor !== undefined && (obj.keyColor = message.keyColor);
        message.name !== undefined && (obj.name = message.name);
        message.isDefaultBanner !== undefined && (obj.isDefaultBanner = message.isDefaultBanner);
        message.url !== undefined && (obj.url = message.url);
        message.quarantine !== undefined && (obj.quarantine = message.quarantine);
        message.bannerSize !== undefined && (obj.bannerSize = message.bannerSize);
        message.userIsModerator !== undefined && (obj.userIsModerator = message.userIsModerator);
        message.acceptFollowers !== undefined && (obj.acceptFollowers = message.acceptFollowers);
        message.publicDescription !== undefined && (obj.publicDescription = message.publicDescription);
        message.linkFlairEnabled !== undefined && (obj.linkFlairEnabled = message.linkFlairEnabled);
        message.disableContributorRequests !== undefined &&
            (obj.disableContributorRequests = message.disableContributorRequests);
        message.subredditType !== undefined && (obj.subredditType = message.subredditType);
        message.userIsSubscriber !== undefined && (obj.userIsSubscriber = message.userIsSubscriber);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount_Subreddit();
        message.defaultSet = object.defaultSet ?? undefined;
        message.userIsContributor = object.userIsContributor ?? undefined;
        message.bannerImg = object.bannerImg ?? undefined;
        message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
        message.userIsBanned = object.userIsBanned ?? undefined;
        message.freeFormReports = object.freeFormReports ?? undefined;
        message.communityIcon = object.communityIcon ?? undefined;
        message.showMedia = object.showMedia ?? undefined;
        message.iconColor = object.iconColor ?? undefined;
        message.userIsMuted = object.userIsMuted ?? undefined;
        message.displayName = object.displayName ?? undefined;
        message.headerImg = object.headerImg ?? undefined;
        message.title = object.title ?? undefined;
        message.previousNames = object.previousNames?.map((e) => e) || [];
        message.over18 = object.over18 ?? undefined;
        message.iconSize = object.iconSize?.map((e) => e) || [];
        message.primaryColor = object.primaryColor ?? undefined;
        message.iconImg = object.iconImg ?? undefined;
        message.description = object.description ?? undefined;
        message.submitLinkLabel = object.submitLinkLabel ?? undefined;
        message.headerSize = object.headerSize ?? undefined;
        message.restrictPosting = object.restrictPosting ?? undefined;
        message.restrictCommenting = object.restrictCommenting ?? undefined;
        message.subscribers = object.subscribers ?? undefined;
        message.submitTextLabel = object.submitTextLabel ?? undefined;
        message.isDefaultIcon = object.isDefaultIcon ?? undefined;
        message.inkFlairPosition = object.inkFlairPosition ?? undefined;
        message.displayNamePrefixed = object.displayNamePrefixed ?? undefined;
        message.keyColor = object.keyColor ?? undefined;
        message.name = object.name ?? undefined;
        message.isDefaultBanner = object.isDefaultBanner ?? undefined;
        message.url = object.url ?? undefined;
        message.quarantine = object.quarantine ?? undefined;
        message.bannerSize = object.bannerSize ?? undefined;
        message.userIsModerator = object.userIsModerator ?? undefined;
        message.acceptFollowers = object.acceptFollowers ?? undefined;
        message.publicDescription = object.publicDescription ?? undefined;
        message.linkFlairEnabled = object.linkFlairEnabled ?? undefined;
        message.disableContributorRequests = object.disableContributorRequests ?? undefined;
        message.subredditType = object.subredditType ?? undefined;
        message.userIsSubscriber = object.userIsSubscriber ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount.Subreddit", SubredditAutocompleteResponse_AutocompleteAccount_Subreddit);
function createBaseSubredditAutocompleteResponse_WrappedAutoCompleteSubreddit() {
    return { kind: "", data: undefined };
}
export const SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteSubreddit",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            FullSubredditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteSubreddit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = FullSubredditObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? FullSubredditObject.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined && (obj.data = message.data ? FullSubredditObject.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteSubreddit();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? FullSubredditObject.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteSubreddit", SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit);
function createBaseSubredditAutocompleteResponse_WrappedAutoCompleteAccount() {
    return { kind: "", data: undefined };
}
export const SubredditAutocompleteResponse_WrappedAutoCompleteAccount = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteAccount",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.data !== undefined) {
            SubredditAutocompleteResponse_AutocompleteAccount.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteAccount();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.data = SubredditAutocompleteResponse_AutocompleteAccount.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            data: isSet(object.data) ? SubredditAutocompleteResponse_AutocompleteAccount.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? SubredditAutocompleteResponse_AutocompleteAccount.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteAccount();
        message.kind = object.kind ?? "";
        message.data = (object.data !== undefined && object.data !== null)
            ? SubredditAutocompleteResponse_AutocompleteAccount.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteAccount", SubredditAutocompleteResponse_WrappedAutoCompleteAccount);
function createBaseSubredditAutocompleteResponse_AutocompleteResponse() {
    return { after: undefined, before: undefined, dist: undefined, childrenSubreddits: [], childrenAccounts: [] };
}
export const SubredditAutocompleteResponse_AutocompleteResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.dist !== undefined) {
            Int32Value.encode({ value: message.dist }, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.childrenSubreddits) {
            SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.encode(v, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.childrenAccounts) {
            SubredditAutocompleteResponse_WrappedAutoCompleteAccount.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAutocompleteResponse_AutocompleteResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.dist = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.childrenSubreddits.push(SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.childrenAccounts.push(SubredditAutocompleteResponse_WrappedAutoCompleteAccount.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            dist: isSet(object.dist) ? Number(object.dist) : undefined,
            childrenSubreddits: Array.isArray(object?.childrenSubreddits)
                ? object.childrenSubreddits.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.fromJSON(e))
                : [],
            childrenAccounts: Array.isArray(object?.childrenAccounts)
                ? object.childrenAccounts.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteAccount.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.dist !== undefined && (obj.dist = message.dist);
        if (message.childrenSubreddits) {
            obj.childrenSubreddits = message.childrenSubreddits.map((e) => e ? SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.toJSON(e) : undefined);
        }
        else {
            obj.childrenSubreddits = [];
        }
        if (message.childrenAccounts) {
            obj.childrenAccounts = message.childrenAccounts.map((e) => e ? SubredditAutocompleteResponse_WrappedAutoCompleteAccount.toJSON(e) : undefined);
        }
        else {
            obj.childrenAccounts = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAutocompleteResponse_AutocompleteResponse();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.dist = object.dist ?? undefined;
        message.childrenSubreddits =
            object.childrenSubreddits?.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.fromPartial(e)) || [];
        message.childrenAccounts =
            object.childrenAccounts?.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteAccount.fromPartial(e)) ||
                [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteResponse", SubredditAutocompleteResponse_AutocompleteResponse);
function createBaseUploadSrImgResponse() {
    return { errors: [], imgSrc: undefined, errorsValues: [] };
}
export const UploadSrImgResponse = {
    $type: "devvit.plugin.redditapi.subreddits.UploadSrImgResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.errors) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        if (message.imgSrc !== undefined) {
            StringValue.encode({ value: message.imgSrc }, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.errorsValues) {
            StringValue.encode({ value: v }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadSrImgResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.errors.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 2:
                    message.imgSrc = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.errorsValues.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            errors: Array.isArray(object?.errors) ? object.errors.map((e) => String(e)) : [],
            imgSrc: isSet(object.imgSrc) ? String(object.imgSrc) : undefined,
            errorsValues: Array.isArray(object?.errorsValues) ? object.errorsValues.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.errors) {
            obj.errors = message.errors.map((e) => e);
        }
        else {
            obj.errors = [];
        }
        message.imgSrc !== undefined && (obj.imgSrc = message.imgSrc);
        if (message.errorsValues) {
            obj.errorsValues = message.errorsValues.map((e) => e);
        }
        else {
            obj.errorsValues = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUploadSrImgResponse();
        message.errors = object.errors?.map((e) => e) || [];
        message.imgSrc = object.imgSrc ?? undefined;
        message.errorsValues = object.errorsValues?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UploadSrImgResponse", UploadSrImgResponse);
function createBaseSubredditPostRequirementsResponse() {
    return {
        titleRegexes: [],
        bodyBlacklistedStrings: [],
        titleBlacklistedStrings: [],
        bodyTextMaxLength: undefined,
        titleRequiredStrings: [],
        guidelinesText: undefined,
        galleryMinItems: undefined,
        domainBlacklist: [],
        domainWhitelist: [],
        titleTextMaxLength: undefined,
        bodyRestrictionPolicy: undefined,
        linkRestrictionPolicy: undefined,
        guidelinesDisplayPolicy: undefined,
        bodyRequiredStrings: [],
        titleTextMinLength: undefined,
        galleryCaptionsRequirement: undefined,
        isFlairRequired: undefined,
        galleryMaxItems: undefined,
        galleryUrlsRequirement: undefined,
        bodyRegexes: [],
        linkRepostAge: undefined,
        bodyTextMinLength: undefined,
    };
}
export const SubredditPostRequirementsResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditPostRequirementsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.titleRegexes) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.bodyBlacklistedStrings) {
            StringValue.encode({ value: v }, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.titleBlacklistedStrings) {
            StringValue.encode({ value: v }, writer.uint32(26).fork()).ldelim();
        }
        if (message.bodyTextMaxLength !== undefined) {
            Int32Value.encode({ value: message.bodyTextMaxLength }, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.titleRequiredStrings) {
            StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
        }
        if (message.guidelinesText !== undefined) {
            StringValue.encode({ value: message.guidelinesText }, writer.uint32(50).fork()).ldelim();
        }
        if (message.galleryMinItems !== undefined) {
            Int32Value.encode({ value: message.galleryMinItems }, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.domainBlacklist) {
            StringValue.encode({ value: v }, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.domainWhitelist) {
            StringValue.encode({ value: v }, writer.uint32(74).fork()).ldelim();
        }
        if (message.titleTextMaxLength !== undefined) {
            Int32Value.encode({ value: message.titleTextMaxLength }, writer.uint32(82).fork()).ldelim();
        }
        if (message.bodyRestrictionPolicy !== undefined) {
            StringValue.encode({ value: message.bodyRestrictionPolicy }, writer.uint32(90).fork()).ldelim();
        }
        if (message.linkRestrictionPolicy !== undefined) {
            StringValue.encode({ value: message.linkRestrictionPolicy }, writer.uint32(98).fork()).ldelim();
        }
        if (message.guidelinesDisplayPolicy !== undefined) {
            StringValue.encode({ value: message.guidelinesDisplayPolicy }, writer.uint32(106).fork()).ldelim();
        }
        for (const v of message.bodyRequiredStrings) {
            StringValue.encode({ value: v }, writer.uint32(114).fork()).ldelim();
        }
        if (message.titleTextMinLength !== undefined) {
            Int32Value.encode({ value: message.titleTextMinLength }, writer.uint32(122).fork()).ldelim();
        }
        if (message.galleryCaptionsRequirement !== undefined) {
            StringValue.encode({ value: message.galleryCaptionsRequirement }, writer.uint32(130).fork()).ldelim();
        }
        if (message.isFlairRequired !== undefined) {
            BoolValue.encode({ value: message.isFlairRequired }, writer.uint32(138).fork()).ldelim();
        }
        if (message.galleryMaxItems !== undefined) {
            Int32Value.encode({ value: message.galleryMaxItems }, writer.uint32(146).fork()).ldelim();
        }
        if (message.galleryUrlsRequirement !== undefined) {
            StringValue.encode({ value: message.galleryUrlsRequirement }, writer.uint32(154).fork()).ldelim();
        }
        for (const v of message.bodyRegexes) {
            StringValue.encode({ value: v }, writer.uint32(162).fork()).ldelim();
        }
        if (message.linkRepostAge !== undefined) {
            Int32Value.encode({ value: message.linkRepostAge }, writer.uint32(170).fork()).ldelim();
        }
        if (message.bodyTextMinLength !== undefined) {
            Int32Value.encode({ value: message.bodyTextMinLength }, writer.uint32(178).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditPostRequirementsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.titleRegexes.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 2:
                    message.bodyBlacklistedStrings.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 3:
                    message.titleBlacklistedStrings.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 4:
                    message.bodyTextMaxLength = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.titleRequiredStrings.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 6:
                    message.guidelinesText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.galleryMinItems = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.domainBlacklist.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 9:
                    message.domainWhitelist.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 10:
                    message.titleTextMaxLength = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.bodyRestrictionPolicy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.linkRestrictionPolicy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.guidelinesDisplayPolicy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.bodyRequiredStrings.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 15:
                    message.titleTextMinLength = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.galleryCaptionsRequirement = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.isFlairRequired = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.galleryMaxItems = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.galleryUrlsRequirement = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.bodyRegexes.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 21:
                    message.linkRepostAge = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.bodyTextMinLength = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            titleRegexes: Array.isArray(object?.titleRegexes) ? object.titleRegexes.map((e) => String(e)) : [],
            bodyBlacklistedStrings: Array.isArray(object?.bodyBlacklistedStrings)
                ? object.bodyBlacklistedStrings.map((e) => String(e))
                : [],
            titleBlacklistedStrings: Array.isArray(object?.titleBlacklistedStrings)
                ? object.titleBlacklistedStrings.map((e) => String(e))
                : [],
            bodyTextMaxLength: isSet(object.bodyTextMaxLength) ? Number(object.bodyTextMaxLength) : undefined,
            titleRequiredStrings: Array.isArray(object?.titleRequiredStrings)
                ? object.titleRequiredStrings.map((e) => String(e))
                : [],
            guidelinesText: isSet(object.guidelinesText) ? String(object.guidelinesText) : undefined,
            galleryMinItems: isSet(object.galleryMinItems) ? Number(object.galleryMinItems) : undefined,
            domainBlacklist: Array.isArray(object?.domainBlacklist) ? object.domainBlacklist.map((e) => String(e)) : [],
            domainWhitelist: Array.isArray(object?.domainWhitelist) ? object.domainWhitelist.map((e) => String(e)) : [],
            titleTextMaxLength: isSet(object.titleTextMaxLength) ? Number(object.titleTextMaxLength) : undefined,
            bodyRestrictionPolicy: isSet(object.bodyRestrictionPolicy) ? String(object.bodyRestrictionPolicy) : undefined,
            linkRestrictionPolicy: isSet(object.linkRestrictionPolicy) ? String(object.linkRestrictionPolicy) : undefined,
            guidelinesDisplayPolicy: isSet(object.guidelinesDisplayPolicy)
                ? String(object.guidelinesDisplayPolicy)
                : undefined,
            bodyRequiredStrings: Array.isArray(object?.bodyRequiredStrings)
                ? object.bodyRequiredStrings.map((e) => String(e))
                : [],
            titleTextMinLength: isSet(object.titleTextMinLength) ? Number(object.titleTextMinLength) : undefined,
            galleryCaptionsRequirement: isSet(object.galleryCaptionsRequirement)
                ? String(object.galleryCaptionsRequirement)
                : undefined,
            isFlairRequired: isSet(object.isFlairRequired) ? Boolean(object.isFlairRequired) : undefined,
            galleryMaxItems: isSet(object.galleryMaxItems) ? Number(object.galleryMaxItems) : undefined,
            galleryUrlsRequirement: isSet(object.galleryUrlsRequirement) ? String(object.galleryUrlsRequirement) : undefined,
            bodyRegexes: Array.isArray(object?.bodyRegexes) ? object.bodyRegexes.map((e) => String(e)) : [],
            linkRepostAge: isSet(object.linkRepostAge) ? Number(object.linkRepostAge) : undefined,
            bodyTextMinLength: isSet(object.bodyTextMinLength) ? Number(object.bodyTextMinLength) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.titleRegexes) {
            obj.titleRegexes = message.titleRegexes.map((e) => e);
        }
        else {
            obj.titleRegexes = [];
        }
        if (message.bodyBlacklistedStrings) {
            obj.bodyBlacklistedStrings = message.bodyBlacklistedStrings.map((e) => e);
        }
        else {
            obj.bodyBlacklistedStrings = [];
        }
        if (message.titleBlacklistedStrings) {
            obj.titleBlacklistedStrings = message.titleBlacklistedStrings.map((e) => e);
        }
        else {
            obj.titleBlacklistedStrings = [];
        }
        message.bodyTextMaxLength !== undefined && (obj.bodyTextMaxLength = message.bodyTextMaxLength);
        if (message.titleRequiredStrings) {
            obj.titleRequiredStrings = message.titleRequiredStrings.map((e) => e);
        }
        else {
            obj.titleRequiredStrings = [];
        }
        message.guidelinesText !== undefined && (obj.guidelinesText = message.guidelinesText);
        message.galleryMinItems !== undefined && (obj.galleryMinItems = message.galleryMinItems);
        if (message.domainBlacklist) {
            obj.domainBlacklist = message.domainBlacklist.map((e) => e);
        }
        else {
            obj.domainBlacklist = [];
        }
        if (message.domainWhitelist) {
            obj.domainWhitelist = message.domainWhitelist.map((e) => e);
        }
        else {
            obj.domainWhitelist = [];
        }
        message.titleTextMaxLength !== undefined && (obj.titleTextMaxLength = message.titleTextMaxLength);
        message.bodyRestrictionPolicy !== undefined && (obj.bodyRestrictionPolicy = message.bodyRestrictionPolicy);
        message.linkRestrictionPolicy !== undefined && (obj.linkRestrictionPolicy = message.linkRestrictionPolicy);
        message.guidelinesDisplayPolicy !== undefined && (obj.guidelinesDisplayPolicy = message.guidelinesDisplayPolicy);
        if (message.bodyRequiredStrings) {
            obj.bodyRequiredStrings = message.bodyRequiredStrings.map((e) => e);
        }
        else {
            obj.bodyRequiredStrings = [];
        }
        message.titleTextMinLength !== undefined && (obj.titleTextMinLength = message.titleTextMinLength);
        message.galleryCaptionsRequirement !== undefined &&
            (obj.galleryCaptionsRequirement = message.galleryCaptionsRequirement);
        message.isFlairRequired !== undefined && (obj.isFlairRequired = message.isFlairRequired);
        message.galleryMaxItems !== undefined && (obj.galleryMaxItems = message.galleryMaxItems);
        message.galleryUrlsRequirement !== undefined && (obj.galleryUrlsRequirement = message.galleryUrlsRequirement);
        if (message.bodyRegexes) {
            obj.bodyRegexes = message.bodyRegexes.map((e) => e);
        }
        else {
            obj.bodyRegexes = [];
        }
        message.linkRepostAge !== undefined && (obj.linkRepostAge = message.linkRepostAge);
        message.bodyTextMinLength !== undefined && (obj.bodyTextMinLength = message.bodyTextMinLength);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditPostRequirementsResponse();
        message.titleRegexes = object.titleRegexes?.map((e) => e) || [];
        message.bodyBlacklistedStrings = object.bodyBlacklistedStrings?.map((e) => e) || [];
        message.titleBlacklistedStrings = object.titleBlacklistedStrings?.map((e) => e) || [];
        message.bodyTextMaxLength = object.bodyTextMaxLength ?? undefined;
        message.titleRequiredStrings = object.titleRequiredStrings?.map((e) => e) || [];
        message.guidelinesText = object.guidelinesText ?? undefined;
        message.galleryMinItems = object.galleryMinItems ?? undefined;
        message.domainBlacklist = object.domainBlacklist?.map((e) => e) || [];
        message.domainWhitelist = object.domainWhitelist?.map((e) => e) || [];
        message.titleTextMaxLength = object.titleTextMaxLength ?? undefined;
        message.bodyRestrictionPolicy = object.bodyRestrictionPolicy ?? undefined;
        message.linkRestrictionPolicy = object.linkRestrictionPolicy ?? undefined;
        message.guidelinesDisplayPolicy = object.guidelinesDisplayPolicy ?? undefined;
        message.bodyRequiredStrings = object.bodyRequiredStrings?.map((e) => e) || [];
        message.titleTextMinLength = object.titleTextMinLength ?? undefined;
        message.galleryCaptionsRequirement = object.galleryCaptionsRequirement ?? undefined;
        message.isFlairRequired = object.isFlairRequired ?? undefined;
        message.galleryMaxItems = object.galleryMaxItems ?? undefined;
        message.galleryUrlsRequirement = object.galleryUrlsRequirement ?? undefined;
        message.bodyRegexes = object.bodyRegexes?.map((e) => e) || [];
        message.linkRepostAge = object.linkRepostAge ?? undefined;
        message.bodyTextMinLength = object.bodyTextMinLength ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditPostRequirementsResponse", SubredditPostRequirementsResponse);
function createBaseSubredditAboutResponse() {
    return { kind: undefined, data: undefined };
}
export const SubredditAboutResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            SubredditAboutResponse_AboutData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = SubredditAboutResponse_AboutData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? SubredditAboutResponse_AboutData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? SubredditAboutResponse_AboutData.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutResponse();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? SubredditAboutResponse_AboutData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutResponse", SubredditAboutResponse);
function createBaseSubredditAboutResponse_AboutData() {
    return {
        userFlairBackgroundColor: undefined,
        submitTextHtml: undefined,
        restrictPosting: undefined,
        userIsBanned: undefined,
        freeFormReports: undefined,
        wikiEnabled: undefined,
        userIsMuted: undefined,
        userCanFlairInSr: undefined,
        displayName: undefined,
        headerImg: undefined,
        title: undefined,
        allowGalleries: undefined,
        iconSize: undefined,
        primaryColor: undefined,
        activeUserCount: undefined,
        iconImg: undefined,
        displayNamePrefixed: undefined,
        accountsActive: undefined,
        publicTraffic: undefined,
        subscribers: undefined,
        userFlairRichtext: [],
        name: undefined,
        quarantine: undefined,
        hideAds: undefined,
        predictionLeaderboardEntryType: undefined,
        emojisEnabled: undefined,
        advertiserCategory: undefined,
        publicDescription: undefined,
        commentScoreHideMins: undefined,
        allowPredictions: undefined,
        userHasFavorited: undefined,
        userFlairTemplateId: undefined,
        communityIcon: undefined,
        bannerBackgroundImage: undefined,
        originalContentTagEnabled: undefined,
        communityReviewed: undefined,
        submitText: undefined,
        descriptionHtml: undefined,
        spoilersEnabled: undefined,
        commentContributionSettings: undefined,
        allowTalks: undefined,
        headerSize: undefined,
        userFlairPosition: undefined,
        allOriginalContent: undefined,
        collectionsEnabled: undefined,
        isEnrolledInNewModmail: undefined,
        keyColor: undefined,
        eventPostsEnabled: undefined,
        canAssignUserFlair: undefined,
        created: undefined,
        wls: undefined,
        showMediaPreview: undefined,
        submissionType: undefined,
        userIsSubscriber: undefined,
        allowedMediaInComments: [],
        allowVideogifs: undefined,
        shouldArchivePosts: undefined,
        userFlairType: undefined,
        allowPolls: undefined,
        collapseDeletedComments: undefined,
        coins: undefined,
        emojisCustomSize: undefined,
        publicDescriptionHtml: undefined,
        allowVideos: undefined,
        isCrosspostableSubreddit: undefined,
        notificationLevel: undefined,
        shouldShowMediaInCommentsSetting: undefined,
        canAssignLinkFlair: undefined,
        hasMenuWidget: undefined,
        accountsActiveIsFuzzed: undefined,
        allowPredictionContributors: undefined,
        submitTextLabel: undefined,
        linkFlairPosition: undefined,
        userSrFlairEnabled: undefined,
        userFlairEnabledInSr: undefined,
        allowChatPostCreation: undefined,
        allowDiscovery: undefined,
        acceptFollowers: undefined,
        userSrThemeEnabled: undefined,
        linkFlairEnabled: undefined,
        disableContributorRequests: undefined,
        subredditType: undefined,
        suggestedCommentSort: undefined,
        bannerImg: undefined,
        userFlairText: undefined,
        bannerBackgroundColor: undefined,
        showMedia: undefined,
        id: undefined,
        userIsModerator: undefined,
        over18: undefined,
        headerTitle: undefined,
        description: undefined,
        isChatPostFeatureEnabled: undefined,
        submitLinkLabel: undefined,
        userFlairTextColor: undefined,
        restrictCommenting: undefined,
        userFlairCssClass: undefined,
        allowImages: undefined,
        lang: undefined,
        whitelistStatus: undefined,
        url: undefined,
        createdUtc: undefined,
        bannerSize: undefined,
        mobileBannerImage: undefined,
        userIsContributor: undefined,
        allowPredictionsTournament: undefined,
    };
}
export const SubredditAboutResponse_AboutData = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutResponse.AboutData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.userFlairBackgroundColor !== undefined) {
            StringValue.encode({ value: message.userFlairBackgroundColor }, writer.uint32(10).fork()).ldelim();
        }
        if (message.submitTextHtml !== undefined) {
            StringValue.encode({ value: message.submitTextHtml }, writer.uint32(18).fork()).ldelim();
        }
        if (message.restrictPosting !== undefined) {
            BoolValue.encode({ value: message.restrictPosting }, writer.uint32(26).fork()).ldelim();
        }
        if (message.userIsBanned !== undefined) {
            BoolValue.encode({ value: message.userIsBanned }, writer.uint32(34).fork()).ldelim();
        }
        if (message.freeFormReports !== undefined) {
            BoolValue.encode({ value: message.freeFormReports }, writer.uint32(42).fork()).ldelim();
        }
        if (message.wikiEnabled !== undefined) {
            BoolValue.encode({ value: message.wikiEnabled }, writer.uint32(50).fork()).ldelim();
        }
        if (message.userIsMuted !== undefined) {
            BoolValue.encode({ value: message.userIsMuted }, writer.uint32(58).fork()).ldelim();
        }
        if (message.userCanFlairInSr !== undefined) {
            BoolValue.encode({ value: message.userCanFlairInSr }, writer.uint32(66).fork()).ldelim();
        }
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(74).fork()).ldelim();
        }
        if (message.headerImg !== undefined) {
            StringValue.encode({ value: message.headerImg }, writer.uint32(82).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(90).fork()).ldelim();
        }
        if (message.allowGalleries !== undefined) {
            BoolValue.encode({ value: message.allowGalleries }, writer.uint32(98).fork()).ldelim();
        }
        if (message.iconSize !== undefined) {
            Int64Value.encode({ value: message.iconSize }, writer.uint32(106).fork()).ldelim();
        }
        if (message.primaryColor !== undefined) {
            StringValue.encode({ value: message.primaryColor }, writer.uint32(114).fork()).ldelim();
        }
        if (message.activeUserCount !== undefined) {
            Int64Value.encode({ value: message.activeUserCount }, writer.uint32(122).fork()).ldelim();
        }
        if (message.iconImg !== undefined) {
            StringValue.encode({ value: message.iconImg }, writer.uint32(130).fork()).ldelim();
        }
        if (message.displayNamePrefixed !== undefined) {
            StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(138).fork()).ldelim();
        }
        if (message.accountsActive !== undefined) {
            Int64Value.encode({ value: message.accountsActive }, writer.uint32(146).fork()).ldelim();
        }
        if (message.publicTraffic !== undefined) {
            BoolValue.encode({ value: message.publicTraffic }, writer.uint32(154).fork()).ldelim();
        }
        if (message.subscribers !== undefined) {
            Int64Value.encode({ value: message.subscribers }, writer.uint32(162).fork()).ldelim();
        }
        for (const v of message.userFlairRichtext) {
            UserFlairRichtext.encode(v, writer.uint32(170).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(178).fork()).ldelim();
        }
        if (message.quarantine !== undefined) {
            BoolValue.encode({ value: message.quarantine }, writer.uint32(186).fork()).ldelim();
        }
        if (message.hideAds !== undefined) {
            BoolValue.encode({ value: message.hideAds }, writer.uint32(194).fork()).ldelim();
        }
        if (message.predictionLeaderboardEntryType !== undefined) {
            StringValue.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(202).fork()).ldelim();
        }
        if (message.emojisEnabled !== undefined) {
            BoolValue.encode({ value: message.emojisEnabled }, writer.uint32(210).fork()).ldelim();
        }
        if (message.advertiserCategory !== undefined) {
            StringValue.encode({ value: message.advertiserCategory }, writer.uint32(218).fork()).ldelim();
        }
        if (message.publicDescription !== undefined) {
            StringValue.encode({ value: message.publicDescription }, writer.uint32(226).fork()).ldelim();
        }
        if (message.commentScoreHideMins !== undefined) {
            Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(234).fork()).ldelim();
        }
        if (message.allowPredictions !== undefined) {
            BoolValue.encode({ value: message.allowPredictions }, writer.uint32(242).fork()).ldelim();
        }
        if (message.userHasFavorited !== undefined) {
            BoolValue.encode({ value: message.userHasFavorited }, writer.uint32(250).fork()).ldelim();
        }
        if (message.userFlairTemplateId !== undefined) {
            StringValue.encode({ value: message.userFlairTemplateId }, writer.uint32(258).fork()).ldelim();
        }
        if (message.communityIcon !== undefined) {
            StringValue.encode({ value: message.communityIcon }, writer.uint32(266).fork()).ldelim();
        }
        if (message.bannerBackgroundImage !== undefined) {
            StringValue.encode({ value: message.bannerBackgroundImage }, writer.uint32(274).fork()).ldelim();
        }
        if (message.originalContentTagEnabled !== undefined) {
            BoolValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(282).fork()).ldelim();
        }
        if (message.communityReviewed !== undefined) {
            BoolValue.encode({ value: message.communityReviewed }, writer.uint32(290).fork()).ldelim();
        }
        if (message.submitText !== undefined) {
            StringValue.encode({ value: message.submitText }, writer.uint32(298).fork()).ldelim();
        }
        if (message.descriptionHtml !== undefined) {
            StringValue.encode({ value: message.descriptionHtml }, writer.uint32(306).fork()).ldelim();
        }
        if (message.spoilersEnabled !== undefined) {
            BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(314).fork()).ldelim();
        }
        if (message.commentContributionSettings !== undefined) {
            CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(322).fork()).ldelim();
        }
        if (message.allowTalks !== undefined) {
            BoolValue.encode({ value: message.allowTalks }, writer.uint32(330).fork()).ldelim();
        }
        if (message.headerSize !== undefined) {
            Int64Value.encode({ value: message.headerSize }, writer.uint32(338).fork()).ldelim();
        }
        if (message.userFlairPosition !== undefined) {
            StringValue.encode({ value: message.userFlairPosition }, writer.uint32(346).fork()).ldelim();
        }
        if (message.allOriginalContent !== undefined) {
            BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(354).fork()).ldelim();
        }
        if (message.collectionsEnabled !== undefined) {
            BoolValue.encode({ value: message.collectionsEnabled }, writer.uint32(362).fork()).ldelim();
        }
        if (message.isEnrolledInNewModmail !== undefined) {
            BoolValue.encode({ value: message.isEnrolledInNewModmail }, writer.uint32(370).fork()).ldelim();
        }
        if (message.keyColor !== undefined) {
            StringValue.encode({ value: message.keyColor }, writer.uint32(378).fork()).ldelim();
        }
        if (message.eventPostsEnabled !== undefined) {
            BoolValue.encode({ value: message.eventPostsEnabled }, writer.uint32(386).fork()).ldelim();
        }
        if (message.canAssignUserFlair !== undefined) {
            BoolValue.encode({ value: message.canAssignUserFlair }, writer.uint32(394).fork()).ldelim();
        }
        if (message.created !== undefined) {
            Int64Value.encode({ value: message.created }, writer.uint32(402).fork()).ldelim();
        }
        if (message.wls !== undefined) {
            StringValue.encode({ value: message.wls }, writer.uint32(410).fork()).ldelim();
        }
        if (message.showMediaPreview !== undefined) {
            BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(418).fork()).ldelim();
        }
        if (message.submissionType !== undefined) {
            StringValue.encode({ value: message.submissionType }, writer.uint32(426).fork()).ldelim();
        }
        if (message.userIsSubscriber !== undefined) {
            BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(434).fork()).ldelim();
        }
        for (const v of message.allowedMediaInComments) {
            StringValue.encode({ value: v }, writer.uint32(442).fork()).ldelim();
        }
        if (message.allowVideogifs !== undefined) {
            BoolValue.encode({ value: message.allowVideogifs }, writer.uint32(450).fork()).ldelim();
        }
        if (message.shouldArchivePosts !== undefined) {
            BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(458).fork()).ldelim();
        }
        if (message.userFlairType !== undefined) {
            StringValue.encode({ value: message.userFlairType }, writer.uint32(466).fork()).ldelim();
        }
        if (message.allowPolls !== undefined) {
            BoolValue.encode({ value: message.allowPolls }, writer.uint32(474).fork()).ldelim();
        }
        if (message.collapseDeletedComments !== undefined) {
            BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(482).fork()).ldelim();
        }
        if (message.coins !== undefined) {
            Int64Value.encode({ value: message.coins }, writer.uint32(490).fork()).ldelim();
        }
        if (message.emojisCustomSize !== undefined) {
            Int64Value.encode({ value: message.emojisCustomSize }, writer.uint32(498).fork()).ldelim();
        }
        if (message.publicDescriptionHtml !== undefined) {
            StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(506).fork()).ldelim();
        }
        if (message.allowVideos !== undefined) {
            BoolValue.encode({ value: message.allowVideos }, writer.uint32(514).fork()).ldelim();
        }
        if (message.isCrosspostableSubreddit !== undefined) {
            BoolValue.encode({ value: message.isCrosspostableSubreddit }, writer.uint32(522).fork()).ldelim();
        }
        if (message.notificationLevel !== undefined) {
            StringValue.encode({ value: message.notificationLevel }, writer.uint32(530).fork()).ldelim();
        }
        if (message.shouldShowMediaInCommentsSetting !== undefined) {
            BoolValue.encode({ value: message.shouldShowMediaInCommentsSetting }, writer.uint32(538).fork()).ldelim();
        }
        if (message.canAssignLinkFlair !== undefined) {
            BoolValue.encode({ value: message.canAssignLinkFlair }, writer.uint32(546).fork()).ldelim();
        }
        if (message.hasMenuWidget !== undefined) {
            BoolValue.encode({ value: message.hasMenuWidget }, writer.uint32(554).fork()).ldelim();
        }
        if (message.accountsActiveIsFuzzed !== undefined) {
            BoolValue.encode({ value: message.accountsActiveIsFuzzed }, writer.uint32(562).fork()).ldelim();
        }
        if (message.allowPredictionContributors !== undefined) {
            BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(570).fork()).ldelim();
        }
        if (message.submitTextLabel !== undefined) {
            StringValue.encode({ value: message.submitTextLabel }, writer.uint32(578).fork()).ldelim();
        }
        if (message.linkFlairPosition !== undefined) {
            StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(586).fork()).ldelim();
        }
        if (message.userSrFlairEnabled !== undefined) {
            BoolValue.encode({ value: message.userSrFlairEnabled }, writer.uint32(594).fork()).ldelim();
        }
        if (message.userFlairEnabledInSr !== undefined) {
            BoolValue.encode({ value: message.userFlairEnabledInSr }, writer.uint32(602).fork()).ldelim();
        }
        if (message.allowChatPostCreation !== undefined) {
            BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(610).fork()).ldelim();
        }
        if (message.allowDiscovery !== undefined) {
            BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(618).fork()).ldelim();
        }
        if (message.acceptFollowers !== undefined) {
            BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(626).fork()).ldelim();
        }
        if (message.userSrThemeEnabled !== undefined) {
            BoolValue.encode({ value: message.userSrThemeEnabled }, writer.uint32(634).fork()).ldelim();
        }
        if (message.linkFlairEnabled !== undefined) {
            BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(642).fork()).ldelim();
        }
        if (message.disableContributorRequests !== undefined) {
            BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(650).fork()).ldelim();
        }
        if (message.subredditType !== undefined) {
            StringValue.encode({ value: message.subredditType }, writer.uint32(658).fork()).ldelim();
        }
        if (message.suggestedCommentSort !== undefined) {
            StringValue.encode({ value: message.suggestedCommentSort }, writer.uint32(666).fork()).ldelim();
        }
        if (message.bannerImg !== undefined) {
            StringValue.encode({ value: message.bannerImg }, writer.uint32(674).fork()).ldelim();
        }
        if (message.userFlairText !== undefined) {
            StringValue.encode({ value: message.userFlairText }, writer.uint32(682).fork()).ldelim();
        }
        if (message.bannerBackgroundColor !== undefined) {
            StringValue.encode({ value: message.bannerBackgroundColor }, writer.uint32(690).fork()).ldelim();
        }
        if (message.showMedia !== undefined) {
            BoolValue.encode({ value: message.showMedia }, writer.uint32(698).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(706).fork()).ldelim();
        }
        if (message.userIsModerator !== undefined) {
            BoolValue.encode({ value: message.userIsModerator }, writer.uint32(714).fork()).ldelim();
        }
        if (message.over18 !== undefined) {
            BoolValue.encode({ value: message.over18 }, writer.uint32(722).fork()).ldelim();
        }
        if (message.headerTitle !== undefined) {
            StringValue.encode({ value: message.headerTitle }, writer.uint32(730).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(738).fork()).ldelim();
        }
        if (message.isChatPostFeatureEnabled !== undefined) {
            BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(746).fork()).ldelim();
        }
        if (message.submitLinkLabel !== undefined) {
            StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(754).fork()).ldelim();
        }
        if (message.userFlairTextColor !== undefined) {
            StringValue.encode({ value: message.userFlairTextColor }, writer.uint32(762).fork()).ldelim();
        }
        if (message.restrictCommenting !== undefined) {
            BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(770).fork()).ldelim();
        }
        if (message.userFlairCssClass !== undefined) {
            StringValue.encode({ value: message.userFlairCssClass }, writer.uint32(778).fork()).ldelim();
        }
        if (message.allowImages !== undefined) {
            BoolValue.encode({ value: message.allowImages }, writer.uint32(786).fork()).ldelim();
        }
        if (message.lang !== undefined) {
            StringValue.encode({ value: message.lang }, writer.uint32(794).fork()).ldelim();
        }
        if (message.whitelistStatus !== undefined) {
            BoolValue.encode({ value: message.whitelistStatus }, writer.uint32(802).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(810).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(818).fork()).ldelim();
        }
        if (message.bannerSize !== undefined) {
            Int64Value.encode({ value: message.bannerSize }, writer.uint32(826).fork()).ldelim();
        }
        if (message.mobileBannerImage !== undefined) {
            StringValue.encode({ value: message.mobileBannerImage }, writer.uint32(834).fork()).ldelim();
        }
        if (message.userIsContributor !== undefined) {
            BoolValue.encode({ value: message.userIsContributor }, writer.uint32(842).fork()).ldelim();
        }
        if (message.allowPredictionsTournament !== undefined) {
            BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(850).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutResponse_AboutData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.wikiEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.userCanFlairInSr = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.headerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.iconSize = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.activeUserCount = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.iconImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.accountsActive = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.userFlairRichtext.push(UserFlairRichtext.decode(reader, reader.uint32()));
                    break;
                case 22:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.predictionLeaderboardEntryType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 26:
                    message.emojisEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 27:
                    message.advertiserCategory = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 28:
                    message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 29:
                    message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 30:
                    message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 31:
                    message.userHasFavorited = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 32:
                    message.userFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 33:
                    message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 34:
                    message.bannerBackgroundImage = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 35:
                    message.originalContentTagEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 36:
                    message.communityReviewed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 37:
                    message.submitText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 38:
                    message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 39:
                    message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 40:
                    message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
                    break;
                case 41:
                    message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 42:
                    message.headerSize = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 43:
                    message.userFlairPosition = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 44:
                    message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 45:
                    message.collectionsEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 46:
                    message.isEnrolledInNewModmail = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 47:
                    message.keyColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 48:
                    message.eventPostsEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 49:
                    message.canAssignUserFlair = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 50:
                    message.created = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 51:
                    message.wls = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 52:
                    message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 53:
                    message.submissionType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 54:
                    message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 55:
                    message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 56:
                    message.allowVideogifs = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 57:
                    message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 58:
                    message.userFlairType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 59:
                    message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 60:
                    message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 61:
                    message.coins = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 62:
                    message.emojisCustomSize = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 63:
                    message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 64:
                    message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 65:
                    message.isCrosspostableSubreddit = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 66:
                    message.notificationLevel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 67:
                    message.shouldShowMediaInCommentsSetting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 68:
                    message.canAssignLinkFlair = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 69:
                    message.hasMenuWidget = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 70:
                    message.accountsActiveIsFuzzed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 71:
                    message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 72:
                    message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 73:
                    message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 74:
                    message.userSrFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 75:
                    message.userFlairEnabledInSr = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 76:
                    message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 77:
                    message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 78:
                    message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 79:
                    message.userSrThemeEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 80:
                    message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 81:
                    message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 82:
                    message.subredditType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 83:
                    message.suggestedCommentSort = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 84:
                    message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 85:
                    message.userFlairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 86:
                    message.bannerBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 87:
                    message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 88:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 89:
                    message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 90:
                    message.over18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 91:
                    message.headerTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 92:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 93:
                    message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 94:
                    message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 95:
                    message.userFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 96:
                    message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 97:
                    message.userFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 98:
                    message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 99:
                    message.lang = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 100:
                    message.whitelistStatus = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 101:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 102:
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 103:
                    message.bannerSize = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 104:
                    message.mobileBannerImage = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 105:
                    message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 106:
                    message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            userFlairBackgroundColor: isSet(object.userFlairBackgroundColor)
                ? String(object.userFlairBackgroundColor)
                : undefined,
            submitTextHtml: isSet(object.submitTextHtml) ? String(object.submitTextHtml) : undefined,
            restrictPosting: isSet(object.restrictPosting) ? Boolean(object.restrictPosting) : undefined,
            userIsBanned: isSet(object.userIsBanned) ? Boolean(object.userIsBanned) : undefined,
            freeFormReports: isSet(object.freeFormReports) ? Boolean(object.freeFormReports) : undefined,
            wikiEnabled: isSet(object.wikiEnabled) ? Boolean(object.wikiEnabled) : undefined,
            userIsMuted: isSet(object.userIsMuted) ? Boolean(object.userIsMuted) : undefined,
            userCanFlairInSr: isSet(object.userCanFlairInSr) ? Boolean(object.userCanFlairInSr) : undefined,
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            headerImg: isSet(object.headerImg) ? String(object.headerImg) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            allowGalleries: isSet(object.allowGalleries) ? Boolean(object.allowGalleries) : undefined,
            iconSize: isSet(object.iconSize) ? Number(object.iconSize) : undefined,
            primaryColor: isSet(object.primaryColor) ? String(object.primaryColor) : undefined,
            activeUserCount: isSet(object.activeUserCount) ? Number(object.activeUserCount) : undefined,
            iconImg: isSet(object.iconImg) ? String(object.iconImg) : undefined,
            displayNamePrefixed: isSet(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : undefined,
            accountsActive: isSet(object.accountsActive) ? Number(object.accountsActive) : undefined,
            publicTraffic: isSet(object.publicTraffic) ? Boolean(object.publicTraffic) : undefined,
            subscribers: isSet(object.subscribers) ? Number(object.subscribers) : undefined,
            userFlairRichtext: Array.isArray(object?.userFlairRichtext)
                ? object.userFlairRichtext.map((e) => UserFlairRichtext.fromJSON(e))
                : [],
            name: isSet(object.name) ? String(object.name) : undefined,
            quarantine: isSet(object.quarantine) ? Boolean(object.quarantine) : undefined,
            hideAds: isSet(object.hideAds) ? Boolean(object.hideAds) : undefined,
            predictionLeaderboardEntryType: isSet(object.predictionLeaderboardEntryType)
                ? String(object.predictionLeaderboardEntryType)
                : undefined,
            emojisEnabled: isSet(object.emojisEnabled) ? Boolean(object.emojisEnabled) : undefined,
            advertiserCategory: isSet(object.advertiserCategory) ? String(object.advertiserCategory) : undefined,
            publicDescription: isSet(object.publicDescription) ? String(object.publicDescription) : undefined,
            commentScoreHideMins: isSet(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : undefined,
            allowPredictions: isSet(object.allowPredictions) ? Boolean(object.allowPredictions) : undefined,
            userHasFavorited: isSet(object.userHasFavorited) ? Boolean(object.userHasFavorited) : undefined,
            userFlairTemplateId: isSet(object.userFlairTemplateId) ? String(object.userFlairTemplateId) : undefined,
            communityIcon: isSet(object.communityIcon) ? String(object.communityIcon) : undefined,
            bannerBackgroundImage: isSet(object.bannerBackgroundImage) ? String(object.bannerBackgroundImage) : undefined,
            originalContentTagEnabled: isSet(object.originalContentTagEnabled)
                ? Boolean(object.originalContentTagEnabled)
                : undefined,
            communityReviewed: isSet(object.communityReviewed) ? Boolean(object.communityReviewed) : undefined,
            submitText: isSet(object.submitText) ? String(object.submitText) : undefined,
            descriptionHtml: isSet(object.descriptionHtml) ? String(object.descriptionHtml) : undefined,
            spoilersEnabled: isSet(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : undefined,
            commentContributionSettings: isSet(object.commentContributionSettings)
                ? CommentContributionSettings.fromJSON(object.commentContributionSettings)
                : undefined,
            allowTalks: isSet(object.allowTalks) ? Boolean(object.allowTalks) : undefined,
            headerSize: isSet(object.headerSize) ? Number(object.headerSize) : undefined,
            userFlairPosition: isSet(object.userFlairPosition) ? String(object.userFlairPosition) : undefined,
            allOriginalContent: isSet(object.allOriginalContent) ? Boolean(object.allOriginalContent) : undefined,
            collectionsEnabled: isSet(object.collectionsEnabled) ? Boolean(object.collectionsEnabled) : undefined,
            isEnrolledInNewModmail: isSet(object.isEnrolledInNewModmail) ? Boolean(object.isEnrolledInNewModmail) : undefined,
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : undefined,
            eventPostsEnabled: isSet(object.eventPostsEnabled) ? Boolean(object.eventPostsEnabled) : undefined,
            canAssignUserFlair: isSet(object.canAssignUserFlair) ? Boolean(object.canAssignUserFlair) : undefined,
            created: isSet(object.created) ? Number(object.created) : undefined,
            wls: isSet(object.wls) ? String(object.wls) : undefined,
            showMediaPreview: isSet(object.showMediaPreview) ? Boolean(object.showMediaPreview) : undefined,
            submissionType: isSet(object.submissionType) ? String(object.submissionType) : undefined,
            userIsSubscriber: isSet(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : undefined,
            allowedMediaInComments: Array.isArray(object?.allowedMediaInComments)
                ? object.allowedMediaInComments.map((e) => String(e))
                : [],
            allowVideogifs: isSet(object.allowVideogifs) ? Boolean(object.allowVideogifs) : undefined,
            shouldArchivePosts: isSet(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : undefined,
            userFlairType: isSet(object.userFlairType) ? String(object.userFlairType) : undefined,
            allowPolls: isSet(object.allowPolls) ? Boolean(object.allowPolls) : undefined,
            collapseDeletedComments: isSet(object.collapseDeletedComments)
                ? Boolean(object.collapseDeletedComments)
                : undefined,
            coins: isSet(object.coins) ? Number(object.coins) : undefined,
            emojisCustomSize: isSet(object.emojisCustomSize) ? Number(object.emojisCustomSize) : undefined,
            publicDescriptionHtml: isSet(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : undefined,
            allowVideos: isSet(object.allowVideos) ? Boolean(object.allowVideos) : undefined,
            isCrosspostableSubreddit: isSet(object.isCrosspostableSubreddit)
                ? Boolean(object.isCrosspostableSubreddit)
                : undefined,
            notificationLevel: isSet(object.notificationLevel) ? String(object.notificationLevel) : undefined,
            shouldShowMediaInCommentsSetting: isSet(object.shouldShowMediaInCommentsSetting)
                ? Boolean(object.shouldShowMediaInCommentsSetting)
                : undefined,
            canAssignLinkFlair: isSet(object.canAssignLinkFlair) ? Boolean(object.canAssignLinkFlair) : undefined,
            hasMenuWidget: isSet(object.hasMenuWidget) ? Boolean(object.hasMenuWidget) : undefined,
            accountsActiveIsFuzzed: isSet(object.accountsActiveIsFuzzed) ? Boolean(object.accountsActiveIsFuzzed) : undefined,
            allowPredictionContributors: isSet(object.allowPredictionContributors)
                ? Boolean(object.allowPredictionContributors)
                : undefined,
            submitTextLabel: isSet(object.submitTextLabel) ? String(object.submitTextLabel) : undefined,
            linkFlairPosition: isSet(object.linkFlairPosition) ? String(object.linkFlairPosition) : undefined,
            userSrFlairEnabled: isSet(object.userSrFlairEnabled) ? Boolean(object.userSrFlairEnabled) : undefined,
            userFlairEnabledInSr: isSet(object.userFlairEnabledInSr) ? Boolean(object.userFlairEnabledInSr) : undefined,
            allowChatPostCreation: isSet(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : undefined,
            allowDiscovery: isSet(object.allowDiscovery) ? Boolean(object.allowDiscovery) : undefined,
            acceptFollowers: isSet(object.acceptFollowers) ? Boolean(object.acceptFollowers) : undefined,
            userSrThemeEnabled: isSet(object.userSrThemeEnabled) ? Boolean(object.userSrThemeEnabled) : undefined,
            linkFlairEnabled: isSet(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : undefined,
            disableContributorRequests: isSet(object.disableContributorRequests)
                ? Boolean(object.disableContributorRequests)
                : undefined,
            subredditType: isSet(object.subredditType) ? String(object.subredditType) : undefined,
            suggestedCommentSort: isSet(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : undefined,
            bannerImg: isSet(object.bannerImg) ? String(object.bannerImg) : undefined,
            userFlairText: isSet(object.userFlairText) ? String(object.userFlairText) : undefined,
            bannerBackgroundColor: isSet(object.bannerBackgroundColor) ? String(object.bannerBackgroundColor) : undefined,
            showMedia: isSet(object.showMedia) ? Boolean(object.showMedia) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            userIsModerator: isSet(object.userIsModerator) ? Boolean(object.userIsModerator) : undefined,
            over18: isSet(object.over18) ? Boolean(object.over18) : undefined,
            headerTitle: isSet(object.headerTitle) ? String(object.headerTitle) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            isChatPostFeatureEnabled: isSet(object.isChatPostFeatureEnabled)
                ? Boolean(object.isChatPostFeatureEnabled)
                : undefined,
            submitLinkLabel: isSet(object.submitLinkLabel) ? String(object.submitLinkLabel) : undefined,
            userFlairTextColor: isSet(object.userFlairTextColor) ? String(object.userFlairTextColor) : undefined,
            restrictCommenting: isSet(object.restrictCommenting) ? Boolean(object.restrictCommenting) : undefined,
            userFlairCssClass: isSet(object.userFlairCssClass) ? String(object.userFlairCssClass) : undefined,
            allowImages: isSet(object.allowImages) ? Boolean(object.allowImages) : undefined,
            lang: isSet(object.lang) ? String(object.lang) : undefined,
            whitelistStatus: isSet(object.whitelistStatus) ? Boolean(object.whitelistStatus) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            bannerSize: isSet(object.bannerSize) ? Number(object.bannerSize) : undefined,
            mobileBannerImage: isSet(object.mobileBannerImage) ? String(object.mobileBannerImage) : undefined,
            userIsContributor: isSet(object.userIsContributor) ? Boolean(object.userIsContributor) : undefined,
            allowPredictionsTournament: isSet(object.allowPredictionsTournament)
                ? Boolean(object.allowPredictionsTournament)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.userFlairBackgroundColor !== undefined && (obj.userFlairBackgroundColor = message.userFlairBackgroundColor);
        message.submitTextHtml !== undefined && (obj.submitTextHtml = message.submitTextHtml);
        message.restrictPosting !== undefined && (obj.restrictPosting = message.restrictPosting);
        message.userIsBanned !== undefined && (obj.userIsBanned = message.userIsBanned);
        message.freeFormReports !== undefined && (obj.freeFormReports = message.freeFormReports);
        message.wikiEnabled !== undefined && (obj.wikiEnabled = message.wikiEnabled);
        message.userIsMuted !== undefined && (obj.userIsMuted = message.userIsMuted);
        message.userCanFlairInSr !== undefined && (obj.userCanFlairInSr = message.userCanFlairInSr);
        message.displayName !== undefined && (obj.displayName = message.displayName);
        message.headerImg !== undefined && (obj.headerImg = message.headerImg);
        message.title !== undefined && (obj.title = message.title);
        message.allowGalleries !== undefined && (obj.allowGalleries = message.allowGalleries);
        message.iconSize !== undefined && (obj.iconSize = message.iconSize);
        message.primaryColor !== undefined && (obj.primaryColor = message.primaryColor);
        message.activeUserCount !== undefined && (obj.activeUserCount = message.activeUserCount);
        message.iconImg !== undefined && (obj.iconImg = message.iconImg);
        message.displayNamePrefixed !== undefined && (obj.displayNamePrefixed = message.displayNamePrefixed);
        message.accountsActive !== undefined && (obj.accountsActive = message.accountsActive);
        message.publicTraffic !== undefined && (obj.publicTraffic = message.publicTraffic);
        message.subscribers !== undefined && (obj.subscribers = message.subscribers);
        if (message.userFlairRichtext) {
            obj.userFlairRichtext = message.userFlairRichtext.map((e) => e ? UserFlairRichtext.toJSON(e) : undefined);
        }
        else {
            obj.userFlairRichtext = [];
        }
        message.name !== undefined && (obj.name = message.name);
        message.quarantine !== undefined && (obj.quarantine = message.quarantine);
        message.hideAds !== undefined && (obj.hideAds = message.hideAds);
        message.predictionLeaderboardEntryType !== undefined &&
            (obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType);
        message.emojisEnabled !== undefined && (obj.emojisEnabled = message.emojisEnabled);
        message.advertiserCategory !== undefined && (obj.advertiserCategory = message.advertiserCategory);
        message.publicDescription !== undefined && (obj.publicDescription = message.publicDescription);
        message.commentScoreHideMins !== undefined && (obj.commentScoreHideMins = message.commentScoreHideMins);
        message.allowPredictions !== undefined && (obj.allowPredictions = message.allowPredictions);
        message.userHasFavorited !== undefined && (obj.userHasFavorited = message.userHasFavorited);
        message.userFlairTemplateId !== undefined && (obj.userFlairTemplateId = message.userFlairTemplateId);
        message.communityIcon !== undefined && (obj.communityIcon = message.communityIcon);
        message.bannerBackgroundImage !== undefined && (obj.bannerBackgroundImage = message.bannerBackgroundImage);
        message.originalContentTagEnabled !== undefined &&
            (obj.originalContentTagEnabled = message.originalContentTagEnabled);
        message.communityReviewed !== undefined && (obj.communityReviewed = message.communityReviewed);
        message.submitText !== undefined && (obj.submitText = message.submitText);
        message.descriptionHtml !== undefined && (obj.descriptionHtml = message.descriptionHtml);
        message.spoilersEnabled !== undefined && (obj.spoilersEnabled = message.spoilersEnabled);
        message.commentContributionSettings !== undefined &&
            (obj.commentContributionSettings = message.commentContributionSettings
                ? CommentContributionSettings.toJSON(message.commentContributionSettings)
                : undefined);
        message.allowTalks !== undefined && (obj.allowTalks = message.allowTalks);
        message.headerSize !== undefined && (obj.headerSize = message.headerSize);
        message.userFlairPosition !== undefined && (obj.userFlairPosition = message.userFlairPosition);
        message.allOriginalContent !== undefined && (obj.allOriginalContent = message.allOriginalContent);
        message.collectionsEnabled !== undefined && (obj.collectionsEnabled = message.collectionsEnabled);
        message.isEnrolledInNewModmail !== undefined && (obj.isEnrolledInNewModmail = message.isEnrolledInNewModmail);
        message.keyColor !== undefined && (obj.keyColor = message.keyColor);
        message.eventPostsEnabled !== undefined && (obj.eventPostsEnabled = message.eventPostsEnabled);
        message.canAssignUserFlair !== undefined && (obj.canAssignUserFlair = message.canAssignUserFlair);
        message.created !== undefined && (obj.created = message.created);
        message.wls !== undefined && (obj.wls = message.wls);
        message.showMediaPreview !== undefined && (obj.showMediaPreview = message.showMediaPreview);
        message.submissionType !== undefined && (obj.submissionType = message.submissionType);
        message.userIsSubscriber !== undefined && (obj.userIsSubscriber = message.userIsSubscriber);
        if (message.allowedMediaInComments) {
            obj.allowedMediaInComments = message.allowedMediaInComments.map((e) => e);
        }
        else {
            obj.allowedMediaInComments = [];
        }
        message.allowVideogifs !== undefined && (obj.allowVideogifs = message.allowVideogifs);
        message.shouldArchivePosts !== undefined && (obj.shouldArchivePosts = message.shouldArchivePosts);
        message.userFlairType !== undefined && (obj.userFlairType = message.userFlairType);
        message.allowPolls !== undefined && (obj.allowPolls = message.allowPolls);
        message.collapseDeletedComments !== undefined && (obj.collapseDeletedComments = message.collapseDeletedComments);
        message.coins !== undefined && (obj.coins = message.coins);
        message.emojisCustomSize !== undefined && (obj.emojisCustomSize = message.emojisCustomSize);
        message.publicDescriptionHtml !== undefined && (obj.publicDescriptionHtml = message.publicDescriptionHtml);
        message.allowVideos !== undefined && (obj.allowVideos = message.allowVideos);
        message.isCrosspostableSubreddit !== undefined && (obj.isCrosspostableSubreddit = message.isCrosspostableSubreddit);
        message.notificationLevel !== undefined && (obj.notificationLevel = message.notificationLevel);
        message.shouldShowMediaInCommentsSetting !== undefined &&
            (obj.shouldShowMediaInCommentsSetting = message.shouldShowMediaInCommentsSetting);
        message.canAssignLinkFlair !== undefined && (obj.canAssignLinkFlair = message.canAssignLinkFlair);
        message.hasMenuWidget !== undefined && (obj.hasMenuWidget = message.hasMenuWidget);
        message.accountsActiveIsFuzzed !== undefined && (obj.accountsActiveIsFuzzed = message.accountsActiveIsFuzzed);
        message.allowPredictionContributors !== undefined &&
            (obj.allowPredictionContributors = message.allowPredictionContributors);
        message.submitTextLabel !== undefined && (obj.submitTextLabel = message.submitTextLabel);
        message.linkFlairPosition !== undefined && (obj.linkFlairPosition = message.linkFlairPosition);
        message.userSrFlairEnabled !== undefined && (obj.userSrFlairEnabled = message.userSrFlairEnabled);
        message.userFlairEnabledInSr !== undefined && (obj.userFlairEnabledInSr = message.userFlairEnabledInSr);
        message.allowChatPostCreation !== undefined && (obj.allowChatPostCreation = message.allowChatPostCreation);
        message.allowDiscovery !== undefined && (obj.allowDiscovery = message.allowDiscovery);
        message.acceptFollowers !== undefined && (obj.acceptFollowers = message.acceptFollowers);
        message.userSrThemeEnabled !== undefined && (obj.userSrThemeEnabled = message.userSrThemeEnabled);
        message.linkFlairEnabled !== undefined && (obj.linkFlairEnabled = message.linkFlairEnabled);
        message.disableContributorRequests !== undefined &&
            (obj.disableContributorRequests = message.disableContributorRequests);
        message.subredditType !== undefined && (obj.subredditType = message.subredditType);
        message.suggestedCommentSort !== undefined && (obj.suggestedCommentSort = message.suggestedCommentSort);
        message.bannerImg !== undefined && (obj.bannerImg = message.bannerImg);
        message.userFlairText !== undefined && (obj.userFlairText = message.userFlairText);
        message.bannerBackgroundColor !== undefined && (obj.bannerBackgroundColor = message.bannerBackgroundColor);
        message.showMedia !== undefined && (obj.showMedia = message.showMedia);
        message.id !== undefined && (obj.id = message.id);
        message.userIsModerator !== undefined && (obj.userIsModerator = message.userIsModerator);
        message.over18 !== undefined && (obj.over18 = message.over18);
        message.headerTitle !== undefined && (obj.headerTitle = message.headerTitle);
        message.description !== undefined && (obj.description = message.description);
        message.isChatPostFeatureEnabled !== undefined && (obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled);
        message.submitLinkLabel !== undefined && (obj.submitLinkLabel = message.submitLinkLabel);
        message.userFlairTextColor !== undefined && (obj.userFlairTextColor = message.userFlairTextColor);
        message.restrictCommenting !== undefined && (obj.restrictCommenting = message.restrictCommenting);
        message.userFlairCssClass !== undefined && (obj.userFlairCssClass = message.userFlairCssClass);
        message.allowImages !== undefined && (obj.allowImages = message.allowImages);
        message.lang !== undefined && (obj.lang = message.lang);
        message.whitelistStatus !== undefined && (obj.whitelistStatus = message.whitelistStatus);
        message.url !== undefined && (obj.url = message.url);
        message.createdUtc !== undefined && (obj.createdUtc = message.createdUtc);
        message.bannerSize !== undefined && (obj.bannerSize = message.bannerSize);
        message.mobileBannerImage !== undefined && (obj.mobileBannerImage = message.mobileBannerImage);
        message.userIsContributor !== undefined && (obj.userIsContributor = message.userIsContributor);
        message.allowPredictionsTournament !== undefined &&
            (obj.allowPredictionsTournament = message.allowPredictionsTournament);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutResponse_AboutData();
        message.userFlairBackgroundColor = object.userFlairBackgroundColor ?? undefined;
        message.submitTextHtml = object.submitTextHtml ?? undefined;
        message.restrictPosting = object.restrictPosting ?? undefined;
        message.userIsBanned = object.userIsBanned ?? undefined;
        message.freeFormReports = object.freeFormReports ?? undefined;
        message.wikiEnabled = object.wikiEnabled ?? undefined;
        message.userIsMuted = object.userIsMuted ?? undefined;
        message.userCanFlairInSr = object.userCanFlairInSr ?? undefined;
        message.displayName = object.displayName ?? undefined;
        message.headerImg = object.headerImg ?? undefined;
        message.title = object.title ?? undefined;
        message.allowGalleries = object.allowGalleries ?? undefined;
        message.iconSize = object.iconSize ?? undefined;
        message.primaryColor = object.primaryColor ?? undefined;
        message.activeUserCount = object.activeUserCount ?? undefined;
        message.iconImg = object.iconImg ?? undefined;
        message.displayNamePrefixed = object.displayNamePrefixed ?? undefined;
        message.accountsActive = object.accountsActive ?? undefined;
        message.publicTraffic = object.publicTraffic ?? undefined;
        message.subscribers = object.subscribers ?? undefined;
        message.userFlairRichtext = object.userFlairRichtext?.map((e) => UserFlairRichtext.fromPartial(e)) || [];
        message.name = object.name ?? undefined;
        message.quarantine = object.quarantine ?? undefined;
        message.hideAds = object.hideAds ?? undefined;
        message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? undefined;
        message.emojisEnabled = object.emojisEnabled ?? undefined;
        message.advertiserCategory = object.advertiserCategory ?? undefined;
        message.publicDescription = object.publicDescription ?? undefined;
        message.commentScoreHideMins = object.commentScoreHideMins ?? undefined;
        message.allowPredictions = object.allowPredictions ?? undefined;
        message.userHasFavorited = object.userHasFavorited ?? undefined;
        message.userFlairTemplateId = object.userFlairTemplateId ?? undefined;
        message.communityIcon = object.communityIcon ?? undefined;
        message.bannerBackgroundImage = object.bannerBackgroundImage ?? undefined;
        message.originalContentTagEnabled = object.originalContentTagEnabled ?? undefined;
        message.communityReviewed = object.communityReviewed ?? undefined;
        message.submitText = object.submitText ?? undefined;
        message.descriptionHtml = object.descriptionHtml ?? undefined;
        message.spoilersEnabled = object.spoilersEnabled ?? undefined;
        message.commentContributionSettings =
            (object.commentContributionSettings !== undefined && object.commentContributionSettings !== null)
                ? CommentContributionSettings.fromPartial(object.commentContributionSettings)
                : undefined;
        message.allowTalks = object.allowTalks ?? undefined;
        message.headerSize = object.headerSize ?? undefined;
        message.userFlairPosition = object.userFlairPosition ?? undefined;
        message.allOriginalContent = object.allOriginalContent ?? undefined;
        message.collectionsEnabled = object.collectionsEnabled ?? undefined;
        message.isEnrolledInNewModmail = object.isEnrolledInNewModmail ?? undefined;
        message.keyColor = object.keyColor ?? undefined;
        message.eventPostsEnabled = object.eventPostsEnabled ?? undefined;
        message.canAssignUserFlair = object.canAssignUserFlair ?? undefined;
        message.created = object.created ?? undefined;
        message.wls = object.wls ?? undefined;
        message.showMediaPreview = object.showMediaPreview ?? undefined;
        message.submissionType = object.submissionType ?? undefined;
        message.userIsSubscriber = object.userIsSubscriber ?? undefined;
        message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
        message.allowVideogifs = object.allowVideogifs ?? undefined;
        message.shouldArchivePosts = object.shouldArchivePosts ?? undefined;
        message.userFlairType = object.userFlairType ?? undefined;
        message.allowPolls = object.allowPolls ?? undefined;
        message.collapseDeletedComments = object.collapseDeletedComments ?? undefined;
        message.coins = object.coins ?? undefined;
        message.emojisCustomSize = object.emojisCustomSize ?? undefined;
        message.publicDescriptionHtml = object.publicDescriptionHtml ?? undefined;
        message.allowVideos = object.allowVideos ?? undefined;
        message.isCrosspostableSubreddit = object.isCrosspostableSubreddit ?? undefined;
        message.notificationLevel = object.notificationLevel ?? undefined;
        message.shouldShowMediaInCommentsSetting = object.shouldShowMediaInCommentsSetting ?? undefined;
        message.canAssignLinkFlair = object.canAssignLinkFlair ?? undefined;
        message.hasMenuWidget = object.hasMenuWidget ?? undefined;
        message.accountsActiveIsFuzzed = object.accountsActiveIsFuzzed ?? undefined;
        message.allowPredictionContributors = object.allowPredictionContributors ?? undefined;
        message.submitTextLabel = object.submitTextLabel ?? undefined;
        message.linkFlairPosition = object.linkFlairPosition ?? undefined;
        message.userSrFlairEnabled = object.userSrFlairEnabled ?? undefined;
        message.userFlairEnabledInSr = object.userFlairEnabledInSr ?? undefined;
        message.allowChatPostCreation = object.allowChatPostCreation ?? undefined;
        message.allowDiscovery = object.allowDiscovery ?? undefined;
        message.acceptFollowers = object.acceptFollowers ?? undefined;
        message.userSrThemeEnabled = object.userSrThemeEnabled ?? undefined;
        message.linkFlairEnabled = object.linkFlairEnabled ?? undefined;
        message.disableContributorRequests = object.disableContributorRequests ?? undefined;
        message.subredditType = object.subredditType ?? undefined;
        message.suggestedCommentSort = object.suggestedCommentSort ?? undefined;
        message.bannerImg = object.bannerImg ?? undefined;
        message.userFlairText = object.userFlairText ?? undefined;
        message.bannerBackgroundColor = object.bannerBackgroundColor ?? undefined;
        message.showMedia = object.showMedia ?? undefined;
        message.id = object.id ?? undefined;
        message.userIsModerator = object.userIsModerator ?? undefined;
        message.over18 = object.over18 ?? undefined;
        message.headerTitle = object.headerTitle ?? undefined;
        message.description = object.description ?? undefined;
        message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? undefined;
        message.submitLinkLabel = object.submitLinkLabel ?? undefined;
        message.userFlairTextColor = object.userFlairTextColor ?? undefined;
        message.restrictCommenting = object.restrictCommenting ?? undefined;
        message.userFlairCssClass = object.userFlairCssClass ?? undefined;
        message.allowImages = object.allowImages ?? undefined;
        message.lang = object.lang ?? undefined;
        message.whitelistStatus = object.whitelistStatus ?? undefined;
        message.url = object.url ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.bannerSize = object.bannerSize ?? undefined;
        message.mobileBannerImage = object.mobileBannerImage ?? undefined;
        message.userIsContributor = object.userIsContributor ?? undefined;
        message.allowPredictionsTournament = object.allowPredictionsTournament ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutResponse.AboutData", SubredditAboutResponse_AboutData);
function createBaseSubredditAboutEditResponse() {
    return { kind: undefined, data: undefined };
}
export const SubredditAboutEditResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            SubredditAboutEditResponse_SubredditSettings.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutEditResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = SubredditAboutEditResponse_SubredditSettings.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? SubredditAboutEditResponse_SubredditSettings.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? SubredditAboutEditResponse_SubredditSettings.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutEditResponse();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? SubredditAboutEditResponse_SubredditSettings.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse", SubredditAboutEditResponse);
function createBaseSubredditAboutEditResponse_SubredditSettings() {
    return {
        defaultSet: undefined,
        toxicityThresholdChatLevel: undefined,
        crowdControlChatLevel: undefined,
        restrictPosting: undefined,
        publicDescription: undefined,
        subredditId: undefined,
        allowImages: undefined,
        freeFormReports: undefined,
        domain: undefined,
        originalContentTagEnabled: undefined,
        showMedia: undefined,
        excludeBannedModqueue: undefined,
        shouldArchivePosts: undefined,
        submitText: undefined,
        spamLinks: undefined,
        title: undefined,
        collapseDeletedComments: undefined,
        wikimode: undefined,
        over18: undefined,
        allowVideos: undefined,
        allowGalleries: undefined,
        crowdControlLevel: undefined,
        banEvasionThreshold: undefined,
        crowdControlMode: undefined,
        welcomeMessageEnabled: undefined,
        welcomeMessageText: undefined,
        suggestedCommentSort: undefined,
        disableContributorRequests: undefined,
        allowTalks: undefined,
        description: undefined,
        submitLinkLabel: undefined,
        spoilersEnabled: undefined,
        allowPostCrossposts: undefined,
        spamComments: undefined,
        publicTraffic: undefined,
        restrictCommenting: undefined,
        allowPolls: undefined,
        commentContributionSettings: undefined,
        submitTextLabel: undefined,
        commentScoreHideMins: undefined,
        allOriginalContent: undefined,
        spamSelfposts: undefined,
        keyColor: undefined,
        language: undefined,
        newPinnedPostPnsEnabled: undefined,
        hideAds: undefined,
        predictionLeaderboardEntryType: undefined,
        headerHoverText: undefined,
        wikiEditAge: undefined,
        allowChatPostCreation: undefined,
        allowPredictionContributors: undefined,
        allowDiscovery: undefined,
        acceptFollowers: undefined,
        crowdControlPostLevel: undefined,
        allowPredictionsTournament: undefined,
        wikiEditKarma: undefined,
        showMediaPreview: undefined,
        crowdControlFilter: undefined,
        subredditType: undefined,
        allowPredictions: undefined,
        userFlairPnsEnabled: undefined,
        contentOptions: undefined,
    };
}
export const SubredditAboutEditResponse_SubredditSettings = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse.SubredditSettings",
    encode(message, writer = _m0.Writer.create()) {
        if (message.defaultSet !== undefined) {
            BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
        }
        if (message.toxicityThresholdChatLevel !== undefined) {
            Int32Value.encode({ value: message.toxicityThresholdChatLevel }, writer.uint32(18).fork()).ldelim();
        }
        if (message.crowdControlChatLevel !== undefined) {
            Int32Value.encode({ value: message.crowdControlChatLevel }, writer.uint32(26).fork()).ldelim();
        }
        if (message.restrictPosting !== undefined) {
            BoolValue.encode({ value: message.restrictPosting }, writer.uint32(34).fork()).ldelim();
        }
        if (message.publicDescription !== undefined) {
            StringValue.encode({ value: message.publicDescription }, writer.uint32(42).fork()).ldelim();
        }
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(50).fork()).ldelim();
        }
        if (message.allowImages !== undefined) {
            BoolValue.encode({ value: message.allowImages }, writer.uint32(58).fork()).ldelim();
        }
        if (message.freeFormReports !== undefined) {
            BoolValue.encode({ value: message.freeFormReports }, writer.uint32(66).fork()).ldelim();
        }
        if (message.domain !== undefined) {
            StringValue.encode({ value: message.domain }, writer.uint32(74).fork()).ldelim();
        }
        if (message.originalContentTagEnabled !== undefined) {
            BoolValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(82).fork()).ldelim();
        }
        if (message.showMedia !== undefined) {
            BoolValue.encode({ value: message.showMedia }, writer.uint32(90).fork()).ldelim();
        }
        if (message.excludeBannedModqueue !== undefined) {
            BoolValue.encode({ value: message.excludeBannedModqueue }, writer.uint32(98).fork()).ldelim();
        }
        if (message.shouldArchivePosts !== undefined) {
            BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(106).fork()).ldelim();
        }
        if (message.submitText !== undefined) {
            StringValue.encode({ value: message.submitText }, writer.uint32(114).fork()).ldelim();
        }
        if (message.spamLinks !== undefined) {
            StringValue.encode({ value: message.spamLinks }, writer.uint32(122).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(130).fork()).ldelim();
        }
        if (message.collapseDeletedComments !== undefined) {
            BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(138).fork()).ldelim();
        }
        if (message.wikimode !== undefined) {
            StringValue.encode({ value: message.wikimode }, writer.uint32(146).fork()).ldelim();
        }
        if (message.over18 !== undefined) {
            BoolValue.encode({ value: message.over18 }, writer.uint32(154).fork()).ldelim();
        }
        if (message.allowVideos !== undefined) {
            BoolValue.encode({ value: message.allowVideos }, writer.uint32(162).fork()).ldelim();
        }
        if (message.allowGalleries !== undefined) {
            BoolValue.encode({ value: message.allowGalleries }, writer.uint32(170).fork()).ldelim();
        }
        if (message.crowdControlLevel !== undefined) {
            Int32Value.encode({ value: message.crowdControlLevel }, writer.uint32(178).fork()).ldelim();
        }
        if (message.banEvasionThreshold !== undefined) {
            Int32Value.encode({ value: message.banEvasionThreshold }, writer.uint32(186).fork()).ldelim();
        }
        if (message.crowdControlMode !== undefined) {
            BoolValue.encode({ value: message.crowdControlMode }, writer.uint32(194).fork()).ldelim();
        }
        if (message.welcomeMessageEnabled !== undefined) {
            BoolValue.encode({ value: message.welcomeMessageEnabled }, writer.uint32(202).fork()).ldelim();
        }
        if (message.welcomeMessageText !== undefined) {
            StringValue.encode({ value: message.welcomeMessageText }, writer.uint32(210).fork()).ldelim();
        }
        if (message.suggestedCommentSort !== undefined) {
            BoolValue.encode({ value: message.suggestedCommentSort }, writer.uint32(218).fork()).ldelim();
        }
        if (message.disableContributorRequests !== undefined) {
            BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(226).fork()).ldelim();
        }
        if (message.allowTalks !== undefined) {
            BoolValue.encode({ value: message.allowTalks }, writer.uint32(234).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(242).fork()).ldelim();
        }
        if (message.submitLinkLabel !== undefined) {
            StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(250).fork()).ldelim();
        }
        if (message.spoilersEnabled !== undefined) {
            BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(258).fork()).ldelim();
        }
        if (message.allowPostCrossposts !== undefined) {
            BoolValue.encode({ value: message.allowPostCrossposts }, writer.uint32(266).fork()).ldelim();
        }
        if (message.spamComments !== undefined) {
            StringValue.encode({ value: message.spamComments }, writer.uint32(274).fork()).ldelim();
        }
        if (message.publicTraffic !== undefined) {
            BoolValue.encode({ value: message.publicTraffic }, writer.uint32(282).fork()).ldelim();
        }
        if (message.restrictCommenting !== undefined) {
            BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(290).fork()).ldelim();
        }
        if (message.allowPolls !== undefined) {
            BoolValue.encode({ value: message.allowPolls }, writer.uint32(298).fork()).ldelim();
        }
        if (message.commentContributionSettings !== undefined) {
            CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(306).fork()).ldelim();
        }
        if (message.submitTextLabel !== undefined) {
            StringValue.encode({ value: message.submitTextLabel }, writer.uint32(314).fork()).ldelim();
        }
        if (message.commentScoreHideMins !== undefined) {
            Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(322).fork()).ldelim();
        }
        if (message.allOriginalContent !== undefined) {
            BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(330).fork()).ldelim();
        }
        if (message.spamSelfposts !== undefined) {
            StringValue.encode({ value: message.spamSelfposts }, writer.uint32(338).fork()).ldelim();
        }
        if (message.keyColor !== undefined) {
            StringValue.encode({ value: message.keyColor }, writer.uint32(346).fork()).ldelim();
        }
        if (message.language !== undefined) {
            StringValue.encode({ value: message.language }, writer.uint32(354).fork()).ldelim();
        }
        if (message.newPinnedPostPnsEnabled !== undefined) {
            BoolValue.encode({ value: message.newPinnedPostPnsEnabled }, writer.uint32(362).fork()).ldelim();
        }
        if (message.hideAds !== undefined) {
            BoolValue.encode({ value: message.hideAds }, writer.uint32(370).fork()).ldelim();
        }
        if (message.predictionLeaderboardEntryType !== undefined) {
            Int32Value.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(378).fork()).ldelim();
        }
        if (message.headerHoverText !== undefined) {
            StringValue.encode({ value: message.headerHoverText }, writer.uint32(386).fork()).ldelim();
        }
        if (message.wikiEditAge !== undefined) {
            Int32Value.encode({ value: message.wikiEditAge }, writer.uint32(394).fork()).ldelim();
        }
        if (message.allowChatPostCreation !== undefined) {
            BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(402).fork()).ldelim();
        }
        if (message.allowPredictionContributors !== undefined) {
            BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(410).fork()).ldelim();
        }
        if (message.allowDiscovery !== undefined) {
            BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(418).fork()).ldelim();
        }
        if (message.acceptFollowers !== undefined) {
            BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(426).fork()).ldelim();
        }
        if (message.crowdControlPostLevel !== undefined) {
            Int32Value.encode({ value: message.crowdControlPostLevel }, writer.uint32(434).fork()).ldelim();
        }
        if (message.allowPredictionsTournament !== undefined) {
            BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(442).fork()).ldelim();
        }
        if (message.wikiEditKarma !== undefined) {
            Int32Value.encode({ value: message.wikiEditKarma }, writer.uint32(450).fork()).ldelim();
        }
        if (message.showMediaPreview !== undefined) {
            BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(458).fork()).ldelim();
        }
        if (message.crowdControlFilter !== undefined) {
            BoolValue.encode({ value: message.crowdControlFilter }, writer.uint32(466).fork()).ldelim();
        }
        if (message.subredditType !== undefined) {
            StringValue.encode({ value: message.subredditType }, writer.uint32(474).fork()).ldelim();
        }
        if (message.allowPredictions !== undefined) {
            BoolValue.encode({ value: message.allowPredictions }, writer.uint32(482).fork()).ldelim();
        }
        if (message.userFlairPnsEnabled !== undefined) {
            BoolValue.encode({ value: message.userFlairPnsEnabled }, writer.uint32(490).fork()).ldelim();
        }
        if (message.contentOptions !== undefined) {
            StringValue.encode({ value: message.contentOptions }, writer.uint32(498).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutEditResponse_SubredditSettings();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.toxicityThresholdChatLevel = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.crowdControlChatLevel = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.domain = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.originalContentTagEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.excludeBannedModqueue = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.submitText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.spamLinks = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.wikimode = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.over18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.crowdControlLevel = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.banEvasionThreshold = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.crowdControlMode = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.welcomeMessageEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 26:
                    message.welcomeMessageText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 27:
                    message.suggestedCommentSort = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 28:
                    message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 29:
                    message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 30:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 31:
                    message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 32:
                    message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 33:
                    message.allowPostCrossposts = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 34:
                    message.spamComments = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 35:
                    message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 36:
                    message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 37:
                    message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 38:
                    message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
                    break;
                case 39:
                    message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 40:
                    message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 41:
                    message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 42:
                    message.spamSelfposts = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 43:
                    message.keyColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 44:
                    message.language = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 45:
                    message.newPinnedPostPnsEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 46:
                    message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 47:
                    message.predictionLeaderboardEntryType = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 48:
                    message.headerHoverText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 49:
                    message.wikiEditAge = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 50:
                    message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 51:
                    message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 52:
                    message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 53:
                    message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 54:
                    message.crowdControlPostLevel = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 55:
                    message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 56:
                    message.wikiEditKarma = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 57:
                    message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 58:
                    message.crowdControlFilter = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 59:
                    message.subredditType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 60:
                    message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 61:
                    message.userFlairPnsEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 62:
                    message.contentOptions = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultSet: isSet(object.defaultSet) ? Boolean(object.defaultSet) : undefined,
            toxicityThresholdChatLevel: isSet(object.toxicityThresholdChatLevel)
                ? Number(object.toxicityThresholdChatLevel)
                : undefined,
            crowdControlChatLevel: isSet(object.crowdControlChatLevel) ? Number(object.crowdControlChatLevel) : undefined,
            restrictPosting: isSet(object.restrictPosting) ? Boolean(object.restrictPosting) : undefined,
            publicDescription: isSet(object.publicDescription) ? String(object.publicDescription) : undefined,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            allowImages: isSet(object.allowImages) ? Boolean(object.allowImages) : undefined,
            freeFormReports: isSet(object.freeFormReports) ? Boolean(object.freeFormReports) : undefined,
            domain: isSet(object.domain) ? String(object.domain) : undefined,
            originalContentTagEnabled: isSet(object.originalContentTagEnabled)
                ? Boolean(object.originalContentTagEnabled)
                : undefined,
            showMedia: isSet(object.showMedia) ? Boolean(object.showMedia) : undefined,
            excludeBannedModqueue: isSet(object.excludeBannedModqueue) ? Boolean(object.excludeBannedModqueue) : undefined,
            shouldArchivePosts: isSet(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : undefined,
            submitText: isSet(object.submitText) ? String(object.submitText) : undefined,
            spamLinks: isSet(object.spamLinks) ? String(object.spamLinks) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            collapseDeletedComments: isSet(object.collapseDeletedComments)
                ? Boolean(object.collapseDeletedComments)
                : undefined,
            wikimode: isSet(object.wikimode) ? String(object.wikimode) : undefined,
            over18: isSet(object.over18) ? Boolean(object.over18) : undefined,
            allowVideos: isSet(object.allowVideos) ? Boolean(object.allowVideos) : undefined,
            allowGalleries: isSet(object.allowGalleries) ? Boolean(object.allowGalleries) : undefined,
            crowdControlLevel: isSet(object.crowdControlLevel) ? Number(object.crowdControlLevel) : undefined,
            banEvasionThreshold: isSet(object.banEvasionThreshold) ? Number(object.banEvasionThreshold) : undefined,
            crowdControlMode: isSet(object.crowdControlMode) ? Boolean(object.crowdControlMode) : undefined,
            welcomeMessageEnabled: isSet(object.welcomeMessageEnabled) ? Boolean(object.welcomeMessageEnabled) : undefined,
            welcomeMessageText: isSet(object.welcomeMessageText) ? String(object.welcomeMessageText) : undefined,
            suggestedCommentSort: isSet(object.suggestedCommentSort) ? Boolean(object.suggestedCommentSort) : undefined,
            disableContributorRequests: isSet(object.disableContributorRequests)
                ? Boolean(object.disableContributorRequests)
                : undefined,
            allowTalks: isSet(object.allowTalks) ? Boolean(object.allowTalks) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            submitLinkLabel: isSet(object.submitLinkLabel) ? String(object.submitLinkLabel) : undefined,
            spoilersEnabled: isSet(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : undefined,
            allowPostCrossposts: isSet(object.allowPostCrossposts) ? Boolean(object.allowPostCrossposts) : undefined,
            spamComments: isSet(object.spamComments) ? String(object.spamComments) : undefined,
            publicTraffic: isSet(object.publicTraffic) ? Boolean(object.publicTraffic) : undefined,
            restrictCommenting: isSet(object.restrictCommenting) ? Boolean(object.restrictCommenting) : undefined,
            allowPolls: isSet(object.allowPolls) ? Boolean(object.allowPolls) : undefined,
            commentContributionSettings: isSet(object.commentContributionSettings)
                ? CommentContributionSettings.fromJSON(object.commentContributionSettings)
                : undefined,
            submitTextLabel: isSet(object.submitTextLabel) ? String(object.submitTextLabel) : undefined,
            commentScoreHideMins: isSet(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : undefined,
            allOriginalContent: isSet(object.allOriginalContent) ? Boolean(object.allOriginalContent) : undefined,
            spamSelfposts: isSet(object.spamSelfposts) ? String(object.spamSelfposts) : undefined,
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : undefined,
            language: isSet(object.language) ? String(object.language) : undefined,
            newPinnedPostPnsEnabled: isSet(object.newPinnedPostPnsEnabled)
                ? Boolean(object.newPinnedPostPnsEnabled)
                : undefined,
            hideAds: isSet(object.hideAds) ? Boolean(object.hideAds) : undefined,
            predictionLeaderboardEntryType: isSet(object.predictionLeaderboardEntryType)
                ? Number(object.predictionLeaderboardEntryType)
                : undefined,
            headerHoverText: isSet(object.headerHoverText) ? String(object.headerHoverText) : undefined,
            wikiEditAge: isSet(object.wikiEditAge) ? Number(object.wikiEditAge) : undefined,
            allowChatPostCreation: isSet(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : undefined,
            allowPredictionContributors: isSet(object.allowPredictionContributors)
                ? Boolean(object.allowPredictionContributors)
                : undefined,
            allowDiscovery: isSet(object.allowDiscovery) ? Boolean(object.allowDiscovery) : undefined,
            acceptFollowers: isSet(object.acceptFollowers) ? Boolean(object.acceptFollowers) : undefined,
            crowdControlPostLevel: isSet(object.crowdControlPostLevel) ? Number(object.crowdControlPostLevel) : undefined,
            allowPredictionsTournament: isSet(object.allowPredictionsTournament)
                ? Boolean(object.allowPredictionsTournament)
                : undefined,
            wikiEditKarma: isSet(object.wikiEditKarma) ? Number(object.wikiEditKarma) : undefined,
            showMediaPreview: isSet(object.showMediaPreview) ? Boolean(object.showMediaPreview) : undefined,
            crowdControlFilter: isSet(object.crowdControlFilter) ? Boolean(object.crowdControlFilter) : undefined,
            subredditType: isSet(object.subredditType) ? String(object.subredditType) : undefined,
            allowPredictions: isSet(object.allowPredictions) ? Boolean(object.allowPredictions) : undefined,
            userFlairPnsEnabled: isSet(object.userFlairPnsEnabled) ? Boolean(object.userFlairPnsEnabled) : undefined,
            contentOptions: isSet(object.contentOptions) ? String(object.contentOptions) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.defaultSet !== undefined && (obj.defaultSet = message.defaultSet);
        message.toxicityThresholdChatLevel !== undefined &&
            (obj.toxicityThresholdChatLevel = message.toxicityThresholdChatLevel);
        message.crowdControlChatLevel !== undefined && (obj.crowdControlChatLevel = message.crowdControlChatLevel);
        message.restrictPosting !== undefined && (obj.restrictPosting = message.restrictPosting);
        message.publicDescription !== undefined && (obj.publicDescription = message.publicDescription);
        message.subredditId !== undefined && (obj.subredditId = message.subredditId);
        message.allowImages !== undefined && (obj.allowImages = message.allowImages);
        message.freeFormReports !== undefined && (obj.freeFormReports = message.freeFormReports);
        message.domain !== undefined && (obj.domain = message.domain);
        message.originalContentTagEnabled !== undefined &&
            (obj.originalContentTagEnabled = message.originalContentTagEnabled);
        message.showMedia !== undefined && (obj.showMedia = message.showMedia);
        message.excludeBannedModqueue !== undefined && (obj.excludeBannedModqueue = message.excludeBannedModqueue);
        message.shouldArchivePosts !== undefined && (obj.shouldArchivePosts = message.shouldArchivePosts);
        message.submitText !== undefined && (obj.submitText = message.submitText);
        message.spamLinks !== undefined && (obj.spamLinks = message.spamLinks);
        message.title !== undefined && (obj.title = message.title);
        message.collapseDeletedComments !== undefined && (obj.collapseDeletedComments = message.collapseDeletedComments);
        message.wikimode !== undefined && (obj.wikimode = message.wikimode);
        message.over18 !== undefined && (obj.over18 = message.over18);
        message.allowVideos !== undefined && (obj.allowVideos = message.allowVideos);
        message.allowGalleries !== undefined && (obj.allowGalleries = message.allowGalleries);
        message.crowdControlLevel !== undefined && (obj.crowdControlLevel = message.crowdControlLevel);
        message.banEvasionThreshold !== undefined && (obj.banEvasionThreshold = message.banEvasionThreshold);
        message.crowdControlMode !== undefined && (obj.crowdControlMode = message.crowdControlMode);
        message.welcomeMessageEnabled !== undefined && (obj.welcomeMessageEnabled = message.welcomeMessageEnabled);
        message.welcomeMessageText !== undefined && (obj.welcomeMessageText = message.welcomeMessageText);
        message.suggestedCommentSort !== undefined && (obj.suggestedCommentSort = message.suggestedCommentSort);
        message.disableContributorRequests !== undefined &&
            (obj.disableContributorRequests = message.disableContributorRequests);
        message.allowTalks !== undefined && (obj.allowTalks = message.allowTalks);
        message.description !== undefined && (obj.description = message.description);
        message.submitLinkLabel !== undefined && (obj.submitLinkLabel = message.submitLinkLabel);
        message.spoilersEnabled !== undefined && (obj.spoilersEnabled = message.spoilersEnabled);
        message.allowPostCrossposts !== undefined && (obj.allowPostCrossposts = message.allowPostCrossposts);
        message.spamComments !== undefined && (obj.spamComments = message.spamComments);
        message.publicTraffic !== undefined && (obj.publicTraffic = message.publicTraffic);
        message.restrictCommenting !== undefined && (obj.restrictCommenting = message.restrictCommenting);
        message.allowPolls !== undefined && (obj.allowPolls = message.allowPolls);
        message.commentContributionSettings !== undefined &&
            (obj.commentContributionSettings = message.commentContributionSettings
                ? CommentContributionSettings.toJSON(message.commentContributionSettings)
                : undefined);
        message.submitTextLabel !== undefined && (obj.submitTextLabel = message.submitTextLabel);
        message.commentScoreHideMins !== undefined && (obj.commentScoreHideMins = message.commentScoreHideMins);
        message.allOriginalContent !== undefined && (obj.allOriginalContent = message.allOriginalContent);
        message.spamSelfposts !== undefined && (obj.spamSelfposts = message.spamSelfposts);
        message.keyColor !== undefined && (obj.keyColor = message.keyColor);
        message.language !== undefined && (obj.language = message.language);
        message.newPinnedPostPnsEnabled !== undefined && (obj.newPinnedPostPnsEnabled = message.newPinnedPostPnsEnabled);
        message.hideAds !== undefined && (obj.hideAds = message.hideAds);
        message.predictionLeaderboardEntryType !== undefined &&
            (obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType);
        message.headerHoverText !== undefined && (obj.headerHoverText = message.headerHoverText);
        message.wikiEditAge !== undefined && (obj.wikiEditAge = message.wikiEditAge);
        message.allowChatPostCreation !== undefined && (obj.allowChatPostCreation = message.allowChatPostCreation);
        message.allowPredictionContributors !== undefined &&
            (obj.allowPredictionContributors = message.allowPredictionContributors);
        message.allowDiscovery !== undefined && (obj.allowDiscovery = message.allowDiscovery);
        message.acceptFollowers !== undefined && (obj.acceptFollowers = message.acceptFollowers);
        message.crowdControlPostLevel !== undefined && (obj.crowdControlPostLevel = message.crowdControlPostLevel);
        message.allowPredictionsTournament !== undefined &&
            (obj.allowPredictionsTournament = message.allowPredictionsTournament);
        message.wikiEditKarma !== undefined && (obj.wikiEditKarma = message.wikiEditKarma);
        message.showMediaPreview !== undefined && (obj.showMediaPreview = message.showMediaPreview);
        message.crowdControlFilter !== undefined && (obj.crowdControlFilter = message.crowdControlFilter);
        message.subredditType !== undefined && (obj.subredditType = message.subredditType);
        message.allowPredictions !== undefined && (obj.allowPredictions = message.allowPredictions);
        message.userFlairPnsEnabled !== undefined && (obj.userFlairPnsEnabled = message.userFlairPnsEnabled);
        message.contentOptions !== undefined && (obj.contentOptions = message.contentOptions);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutEditResponse_SubredditSettings();
        message.defaultSet = object.defaultSet ?? undefined;
        message.toxicityThresholdChatLevel = object.toxicityThresholdChatLevel ?? undefined;
        message.crowdControlChatLevel = object.crowdControlChatLevel ?? undefined;
        message.restrictPosting = object.restrictPosting ?? undefined;
        message.publicDescription = object.publicDescription ?? undefined;
        message.subredditId = object.subredditId ?? undefined;
        message.allowImages = object.allowImages ?? undefined;
        message.freeFormReports = object.freeFormReports ?? undefined;
        message.domain = object.domain ?? undefined;
        message.originalContentTagEnabled = object.originalContentTagEnabled ?? undefined;
        message.showMedia = object.showMedia ?? undefined;
        message.excludeBannedModqueue = object.excludeBannedModqueue ?? undefined;
        message.shouldArchivePosts = object.shouldArchivePosts ?? undefined;
        message.submitText = object.submitText ?? undefined;
        message.spamLinks = object.spamLinks ?? undefined;
        message.title = object.title ?? undefined;
        message.collapseDeletedComments = object.collapseDeletedComments ?? undefined;
        message.wikimode = object.wikimode ?? undefined;
        message.over18 = object.over18 ?? undefined;
        message.allowVideos = object.allowVideos ?? undefined;
        message.allowGalleries = object.allowGalleries ?? undefined;
        message.crowdControlLevel = object.crowdControlLevel ?? undefined;
        message.banEvasionThreshold = object.banEvasionThreshold ?? undefined;
        message.crowdControlMode = object.crowdControlMode ?? undefined;
        message.welcomeMessageEnabled = object.welcomeMessageEnabled ?? undefined;
        message.welcomeMessageText = object.welcomeMessageText ?? undefined;
        message.suggestedCommentSort = object.suggestedCommentSort ?? undefined;
        message.disableContributorRequests = object.disableContributorRequests ?? undefined;
        message.allowTalks = object.allowTalks ?? undefined;
        message.description = object.description ?? undefined;
        message.submitLinkLabel = object.submitLinkLabel ?? undefined;
        message.spoilersEnabled = object.spoilersEnabled ?? undefined;
        message.allowPostCrossposts = object.allowPostCrossposts ?? undefined;
        message.spamComments = object.spamComments ?? undefined;
        message.publicTraffic = object.publicTraffic ?? undefined;
        message.restrictCommenting = object.restrictCommenting ?? undefined;
        message.allowPolls = object.allowPolls ?? undefined;
        message.commentContributionSettings =
            (object.commentContributionSettings !== undefined && object.commentContributionSettings !== null)
                ? CommentContributionSettings.fromPartial(object.commentContributionSettings)
                : undefined;
        message.submitTextLabel = object.submitTextLabel ?? undefined;
        message.commentScoreHideMins = object.commentScoreHideMins ?? undefined;
        message.allOriginalContent = object.allOriginalContent ?? undefined;
        message.spamSelfposts = object.spamSelfposts ?? undefined;
        message.keyColor = object.keyColor ?? undefined;
        message.language = object.language ?? undefined;
        message.newPinnedPostPnsEnabled = object.newPinnedPostPnsEnabled ?? undefined;
        message.hideAds = object.hideAds ?? undefined;
        message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? undefined;
        message.headerHoverText = object.headerHoverText ?? undefined;
        message.wikiEditAge = object.wikiEditAge ?? undefined;
        message.allowChatPostCreation = object.allowChatPostCreation ?? undefined;
        message.allowPredictionContributors = object.allowPredictionContributors ?? undefined;
        message.allowDiscovery = object.allowDiscovery ?? undefined;
        message.acceptFollowers = object.acceptFollowers ?? undefined;
        message.crowdControlPostLevel = object.crowdControlPostLevel ?? undefined;
        message.allowPredictionsTournament = object.allowPredictionsTournament ?? undefined;
        message.wikiEditKarma = object.wikiEditKarma ?? undefined;
        message.showMediaPreview = object.showMediaPreview ?? undefined;
        message.crowdControlFilter = object.crowdControlFilter ?? undefined;
        message.subredditType = object.subredditType ?? undefined;
        message.allowPredictions = object.allowPredictions ?? undefined;
        message.userFlairPnsEnabled = object.userFlairPnsEnabled ?? undefined;
        message.contentOptions = object.contentOptions ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse.SubredditSettings", SubredditAboutEditResponse_SubredditSettings);
function createBaseSubredditAboutRulesResponse() {
    return { rules: [], siteRules: [], siteRulesFlow: [] };
}
export const SubredditAboutRulesResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.rules) {
            SubredditAboutRulesResponse_SubredditRule.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.siteRules) {
            StringValue.encode({ value: v }, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.siteRulesFlow) {
            SubredditAboutRulesResponse_RuleFlow.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutRulesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.rules.push(SubredditAboutRulesResponse_SubredditRule.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.siteRules.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 3:
                    message.siteRulesFlow.push(SubredditAboutRulesResponse_RuleFlow.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            rules: Array.isArray(object?.rules)
                ? object.rules.map((e) => SubredditAboutRulesResponse_SubredditRule.fromJSON(e))
                : [],
            siteRules: Array.isArray(object?.siteRules) ? object.siteRules.map((e) => String(e)) : [],
            siteRulesFlow: Array.isArray(object?.siteRulesFlow)
                ? object.siteRulesFlow.map((e) => SubredditAboutRulesResponse_RuleFlow.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rules) {
            obj.rules = message.rules.map((e) => e ? SubredditAboutRulesResponse_SubredditRule.toJSON(e) : undefined);
        }
        else {
            obj.rules = [];
        }
        if (message.siteRules) {
            obj.siteRules = message.siteRules.map((e) => e);
        }
        else {
            obj.siteRules = [];
        }
        if (message.siteRulesFlow) {
            obj.siteRulesFlow = message.siteRulesFlow.map((e) => e ? SubredditAboutRulesResponse_RuleFlow.toJSON(e) : undefined);
        }
        else {
            obj.siteRulesFlow = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutRulesResponse();
        message.rules = object.rules?.map((e) => SubredditAboutRulesResponse_SubredditRule.fromPartial(e)) || [];
        message.siteRules = object.siteRules?.map((e) => e) || [];
        message.siteRulesFlow = object.siteRulesFlow?.map((e) => SubredditAboutRulesResponse_RuleFlow.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse", SubredditAboutRulesResponse);
function createBaseSubredditAboutRulesResponse_SubredditRule() {
    return {
        kind: undefined,
        description: undefined,
        shortName: undefined,
        violationReason: undefined,
        createdUtc: undefined,
        priority: undefined,
        descriptionHtml: undefined,
    };
}
export const SubredditAboutRulesResponse_SubredditRule = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.SubredditRule",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(18).fork()).ldelim();
        }
        if (message.shortName !== undefined) {
            StringValue.encode({ value: message.shortName }, writer.uint32(26).fork()).ldelim();
        }
        if (message.violationReason !== undefined) {
            StringValue.encode({ value: message.violationReason }, writer.uint32(34).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(42).fork()).ldelim();
        }
        if (message.priority !== undefined) {
            Int32Value.encode({ value: message.priority }, writer.uint32(50).fork()).ldelim();
        }
        if (message.descriptionHtml !== undefined) {
            StringValue.encode({ value: message.descriptionHtml }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutRulesResponse_SubredditRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.shortName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.violationReason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.priority = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            shortName: isSet(object.shortName) ? String(object.shortName) : undefined,
            violationReason: isSet(object.violationReason) ? String(object.violationReason) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            priority: isSet(object.priority) ? Number(object.priority) : undefined,
            descriptionHtml: isSet(object.descriptionHtml) ? String(object.descriptionHtml) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.description !== undefined && (obj.description = message.description);
        message.shortName !== undefined && (obj.shortName = message.shortName);
        message.violationReason !== undefined && (obj.violationReason = message.violationReason);
        message.createdUtc !== undefined && (obj.createdUtc = message.createdUtc);
        message.priority !== undefined && (obj.priority = message.priority);
        message.descriptionHtml !== undefined && (obj.descriptionHtml = message.descriptionHtml);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutRulesResponse_SubredditRule();
        message.kind = object.kind ?? undefined;
        message.description = object.description ?? undefined;
        message.shortName = object.shortName ?? undefined;
        message.violationReason = object.violationReason ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.priority = object.priority ?? undefined;
        message.descriptionHtml = object.descriptionHtml ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.SubredditRule", SubredditAboutRulesResponse_SubredditRule);
function createBaseSubredditAboutRulesResponse_RuleFlow() {
    return {
        reasonTextToShow: undefined,
        reasonText: undefined,
        nextStepHeader: undefined,
        nextStepReasons: [],
        complaintButtonText: undefined,
        complaintUrl: undefined,
        complaintPageTitle: undefined,
        fileComplaint: undefined,
        complaintPrompt: undefined,
        canWriteNotes: undefined,
        isAbuseOfReportButton: undefined,
        notesInputTitle: undefined,
        usernamesInputTitle: undefined,
        canSpecifyUsernames: undefined,
        requestCrisisSupport: undefined,
        oneUsername: undefined,
    };
}
export const SubredditAboutRulesResponse_RuleFlow = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.RuleFlow",
    encode(message, writer = _m0.Writer.create()) {
        if (message.reasonTextToShow !== undefined) {
            StringValue.encode({ value: message.reasonTextToShow }, writer.uint32(10).fork()).ldelim();
        }
        if (message.reasonText !== undefined) {
            StringValue.encode({ value: message.reasonText }, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextStepHeader !== undefined) {
            StringValue.encode({ value: message.nextStepHeader }, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.nextStepReasons) {
            SubredditAboutRulesResponse_RuleFlow.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.complaintButtonText !== undefined) {
            StringValue.encode({ value: message.complaintButtonText }, writer.uint32(42).fork()).ldelim();
        }
        if (message.complaintUrl !== undefined) {
            StringValue.encode({ value: message.complaintUrl }, writer.uint32(50).fork()).ldelim();
        }
        if (message.complaintPageTitle !== undefined) {
            StringValue.encode({ value: message.complaintPageTitle }, writer.uint32(58).fork()).ldelim();
        }
        if (message.fileComplaint !== undefined) {
            BoolValue.encode({ value: message.fileComplaint }, writer.uint32(66).fork()).ldelim();
        }
        if (message.complaintPrompt !== undefined) {
            StringValue.encode({ value: message.complaintPrompt }, writer.uint32(74).fork()).ldelim();
        }
        if (message.canWriteNotes !== undefined) {
            BoolValue.encode({ value: message.canWriteNotes }, writer.uint32(82).fork()).ldelim();
        }
        if (message.isAbuseOfReportButton !== undefined) {
            BoolValue.encode({ value: message.isAbuseOfReportButton }, writer.uint32(90).fork()).ldelim();
        }
        if (message.notesInputTitle !== undefined) {
            StringValue.encode({ value: message.notesInputTitle }, writer.uint32(98).fork()).ldelim();
        }
        if (message.usernamesInputTitle !== undefined) {
            StringValue.encode({ value: message.usernamesInputTitle }, writer.uint32(106).fork()).ldelim();
        }
        if (message.canSpecifyUsernames !== undefined) {
            BoolValue.encode({ value: message.canSpecifyUsernames }, writer.uint32(114).fork()).ldelim();
        }
        if (message.requestCrisisSupport !== undefined) {
            BoolValue.encode({ value: message.requestCrisisSupport }, writer.uint32(122).fork()).ldelim();
        }
        if (message.oneUsername !== undefined) {
            BoolValue.encode({ value: message.oneUsername }, writer.uint32(130).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutRulesResponse_RuleFlow();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reasonTextToShow = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.reasonText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.nextStepHeader = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.nextStepReasons.push(SubredditAboutRulesResponse_RuleFlow.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.complaintButtonText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.complaintUrl = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.complaintPageTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.fileComplaint = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.complaintPrompt = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.canWriteNotes = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.isAbuseOfReportButton = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.notesInputTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.usernamesInputTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.canSpecifyUsernames = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.requestCrisisSupport = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.oneUsername = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            reasonTextToShow: isSet(object.reasonTextToShow) ? String(object.reasonTextToShow) : undefined,
            reasonText: isSet(object.reasonText) ? String(object.reasonText) : undefined,
            nextStepHeader: isSet(object.nextStepHeader) ? String(object.nextStepHeader) : undefined,
            nextStepReasons: Array.isArray(object?.nextStepReasons)
                ? object.nextStepReasons.map((e) => SubredditAboutRulesResponse_RuleFlow.fromJSON(e))
                : [],
            complaintButtonText: isSet(object.complaintButtonText) ? String(object.complaintButtonText) : undefined,
            complaintUrl: isSet(object.complaintUrl) ? String(object.complaintUrl) : undefined,
            complaintPageTitle: isSet(object.complaintPageTitle) ? String(object.complaintPageTitle) : undefined,
            fileComplaint: isSet(object.fileComplaint) ? Boolean(object.fileComplaint) : undefined,
            complaintPrompt: isSet(object.complaintPrompt) ? String(object.complaintPrompt) : undefined,
            canWriteNotes: isSet(object.canWriteNotes) ? Boolean(object.canWriteNotes) : undefined,
            isAbuseOfReportButton: isSet(object.isAbuseOfReportButton) ? Boolean(object.isAbuseOfReportButton) : undefined,
            notesInputTitle: isSet(object.notesInputTitle) ? String(object.notesInputTitle) : undefined,
            usernamesInputTitle: isSet(object.usernamesInputTitle) ? String(object.usernamesInputTitle) : undefined,
            canSpecifyUsernames: isSet(object.canSpecifyUsernames) ? Boolean(object.canSpecifyUsernames) : undefined,
            requestCrisisSupport: isSet(object.requestCrisisSupport) ? Boolean(object.requestCrisisSupport) : undefined,
            oneUsername: isSet(object.oneUsername) ? Boolean(object.oneUsername) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.reasonTextToShow !== undefined && (obj.reasonTextToShow = message.reasonTextToShow);
        message.reasonText !== undefined && (obj.reasonText = message.reasonText);
        message.nextStepHeader !== undefined && (obj.nextStepHeader = message.nextStepHeader);
        if (message.nextStepReasons) {
            obj.nextStepReasons = message.nextStepReasons.map((e) => e ? SubredditAboutRulesResponse_RuleFlow.toJSON(e) : undefined);
        }
        else {
            obj.nextStepReasons = [];
        }
        message.complaintButtonText !== undefined && (obj.complaintButtonText = message.complaintButtonText);
        message.complaintUrl !== undefined && (obj.complaintUrl = message.complaintUrl);
        message.complaintPageTitle !== undefined && (obj.complaintPageTitle = message.complaintPageTitle);
        message.fileComplaint !== undefined && (obj.fileComplaint = message.fileComplaint);
        message.complaintPrompt !== undefined && (obj.complaintPrompt = message.complaintPrompt);
        message.canWriteNotes !== undefined && (obj.canWriteNotes = message.canWriteNotes);
        message.isAbuseOfReportButton !== undefined && (obj.isAbuseOfReportButton = message.isAbuseOfReportButton);
        message.notesInputTitle !== undefined && (obj.notesInputTitle = message.notesInputTitle);
        message.usernamesInputTitle !== undefined && (obj.usernamesInputTitle = message.usernamesInputTitle);
        message.canSpecifyUsernames !== undefined && (obj.canSpecifyUsernames = message.canSpecifyUsernames);
        message.requestCrisisSupport !== undefined && (obj.requestCrisisSupport = message.requestCrisisSupport);
        message.oneUsername !== undefined && (obj.oneUsername = message.oneUsername);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutRulesResponse_RuleFlow();
        message.reasonTextToShow = object.reasonTextToShow ?? undefined;
        message.reasonText = object.reasonText ?? undefined;
        message.nextStepHeader = object.nextStepHeader ?? undefined;
        message.nextStepReasons = object.nextStepReasons?.map((e) => SubredditAboutRulesResponse_RuleFlow.fromPartial(e)) ||
            [];
        message.complaintButtonText = object.complaintButtonText ?? undefined;
        message.complaintUrl = object.complaintUrl ?? undefined;
        message.complaintPageTitle = object.complaintPageTitle ?? undefined;
        message.fileComplaint = object.fileComplaint ?? undefined;
        message.complaintPrompt = object.complaintPrompt ?? undefined;
        message.canWriteNotes = object.canWriteNotes ?? undefined;
        message.isAbuseOfReportButton = object.isAbuseOfReportButton ?? undefined;
        message.notesInputTitle = object.notesInputTitle ?? undefined;
        message.usernamesInputTitle = object.usernamesInputTitle ?? undefined;
        message.canSpecifyUsernames = object.canSpecifyUsernames ?? undefined;
        message.requestCrisisSupport = object.requestCrisisSupport ?? undefined;
        message.oneUsername = object.oneUsername ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.RuleFlow", SubredditAboutRulesResponse_RuleFlow);
function createBaseSubredditAboutTrafficResponse() {
    return { day: [], hour: [], month: [] };
}
export const SubredditAboutTrafficResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.day) {
            SubredditAboutTrafficResponse_Data.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.hour) {
            SubredditAboutTrafficResponse_Data.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.month) {
            SubredditAboutTrafficResponse_Data.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutTrafficResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.day.push(SubredditAboutTrafficResponse_Data.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.hour.push(SubredditAboutTrafficResponse_Data.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.month.push(SubredditAboutTrafficResponse_Data.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            day: Array.isArray(object?.day) ? object.day.map((e) => SubredditAboutTrafficResponse_Data.fromJSON(e)) : [],
            hour: Array.isArray(object?.hour)
                ? object.hour.map((e) => SubredditAboutTrafficResponse_Data.fromJSON(e))
                : [],
            month: Array.isArray(object?.month)
                ? object.month.map((e) => SubredditAboutTrafficResponse_Data.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.day) {
            obj.day = message.day.map((e) => e ? SubredditAboutTrafficResponse_Data.toJSON(e) : undefined);
        }
        else {
            obj.day = [];
        }
        if (message.hour) {
            obj.hour = message.hour.map((e) => e ? SubredditAboutTrafficResponse_Data.toJSON(e) : undefined);
        }
        else {
            obj.hour = [];
        }
        if (message.month) {
            obj.month = message.month.map((e) => e ? SubredditAboutTrafficResponse_Data.toJSON(e) : undefined);
        }
        else {
            obj.month = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutTrafficResponse();
        message.day = object.day?.map((e) => SubredditAboutTrafficResponse_Data.fromPartial(e)) || [];
        message.hour = object.hour?.map((e) => SubredditAboutTrafficResponse_Data.fromPartial(e)) || [];
        message.month = object.month?.map((e) => SubredditAboutTrafficResponse_Data.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse", SubredditAboutTrafficResponse);
function createBaseSubredditAboutTrafficResponse_Data() {
    return { values: [] };
}
export const SubredditAboutTrafficResponse_Data = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse.Data",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.values) {
            Int64Value.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAboutTrafficResponse_Data();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.values.push(Int64Value.decode(reader, reader.uint32()).value);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { values: Array.isArray(object?.values) ? object.values.map((e) => Number(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.values) {
            obj.values = message.values.map((e) => e);
        }
        else {
            obj.values = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAboutTrafficResponse_Data();
        message.values = object.values?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse.Data", SubredditAboutTrafficResponse_Data);
function createBaseStickyResponse() {
    return { kind: undefined, data: undefined };
}
export const StickyResponse = {
    $type: "devvit.plugin.redditapi.subreddits.StickyResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            StickyResponse_StickyResponseData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStickyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = StickyResponse_StickyResponseData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? StickyResponse_StickyResponseData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? StickyResponse_StickyResponseData.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStickyResponse();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? StickyResponse_StickyResponseData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyResponse", StickyResponse);
function createBaseStickyResponse_LinkData() {
    return {
        authorFlairBackgroundColor: undefined,
        approvedAtUtc: undefined,
        subreddit: undefined,
        selftext: undefined,
        userReports: [],
        saved: undefined,
        modReasonTitle: undefined,
        gilded: undefined,
        clicked: undefined,
        title: undefined,
        linkFlairRichtext: [],
        subredditNamePrefixed: undefined,
        hidden: undefined,
        pwls: undefined,
        linkFlairCssClass: undefined,
        downs: undefined,
        thumbnailHeight: undefined,
        topAwardedType: undefined,
        parentWhitelistStatus: undefined,
        hideScore: undefined,
        name: undefined,
        quarantine: undefined,
        linkFlairTextColor: undefined,
        upvoteRatio: undefined,
        ignoreReports: undefined,
        ups: undefined,
        domain: undefined,
        mediaEmbed: undefined,
        thumbnailWidth: undefined,
        authorFlairTemplateId: undefined,
        isOriginalContent: undefined,
        authorFullname: undefined,
        secureMedia: undefined,
        isRedditMediaDomain: undefined,
        isMeta: undefined,
        category: undefined,
        secureMediaEmbed: undefined,
        linkFlairText: undefined,
        canModPost: undefined,
        score: undefined,
        approvedBy: undefined,
        isCreatedFromAdsUi: undefined,
        authorPremium: undefined,
        thumbnail: undefined,
        edited: undefined,
        authorFlairCssClass: undefined,
        previousVisits: [],
        authorFlairRichtext: [],
        gildings: undefined,
        contentCategories: undefined,
        isSelf: undefined,
        subredditType: undefined,
        created: undefined,
        linkFlairType: undefined,
        wls: undefined,
        removedByCategory: undefined,
        bannedBy: undefined,
        authorFlairType: undefined,
        totalAwardsReceived: undefined,
        allowLiveComments: undefined,
        selftextHtml: undefined,
        likes: undefined,
        suggestedSort: undefined,
        bannedAtUtc: undefined,
        viewCount: undefined,
        archived: undefined,
        noFollow: undefined,
        spam: undefined,
        isCrosspostable: undefined,
        pinned: undefined,
        over18: undefined,
        allAwardings: [],
        awarders: [],
        mediaOnly: undefined,
        canGild: undefined,
        removed: undefined,
        spoiler: undefined,
        locked: undefined,
        authorFlairText: undefined,
        treatmentTags: [],
        rteMode: undefined,
        visited: undefined,
        removedBy: undefined,
        modNote: undefined,
        distinguished: undefined,
        subredditId: undefined,
        authorIsBlocked: undefined,
        modReasonBy: undefined,
        numReports: undefined,
        removalReason: undefined,
        linkFlairBackgroundColor: undefined,
        id: undefined,
        isRobotIndexable: undefined,
        numDuplicates: undefined,
        reportReasons: [],
        author: undefined,
        discussionType: undefined,
        numComments: undefined,
        sendReplies: undefined,
        media: undefined,
        contestMode: undefined,
        authorPatreonFlair: undefined,
        approved: undefined,
        authorFlairTextColor: undefined,
        permalink: undefined,
        whitelistStatus: undefined,
        stickied: undefined,
        url: undefined,
        subredditSubscribers: undefined,
        createdUtc: undefined,
        numCrossposts: undefined,
        modReports: [],
        isVideo: undefined,
    };
}
export const StickyResponse_LinkData = {
    $type: "devvit.plugin.redditapi.subreddits.StickyResponse.LinkData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.authorFlairBackgroundColor !== undefined) {
            StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(10).fork()).ldelim();
        }
        if (message.approvedAtUtc !== undefined) {
            Int32Value.encode({ value: message.approvedAtUtc }, writer.uint32(18).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(26).fork()).ldelim();
        }
        if (message.selftext !== undefined) {
            StringValue.encode({ value: message.selftext }, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.userReports) {
            StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
        }
        if (message.saved !== undefined) {
            BoolValue.encode({ value: message.saved }, writer.uint32(50).fork()).ldelim();
        }
        if (message.modReasonTitle !== undefined) {
            StringValue.encode({ value: message.modReasonTitle }, writer.uint32(58).fork()).ldelim();
        }
        if (message.gilded !== undefined) {
            Int64Value.encode({ value: message.gilded }, writer.uint32(66).fork()).ldelim();
        }
        if (message.clicked !== undefined) {
            BoolValue.encode({ value: message.clicked }, writer.uint32(74).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(82).fork()).ldelim();
        }
        for (const v of message.linkFlairRichtext) {
            StringValue.encode({ value: v }, writer.uint32(90).fork()).ldelim();
        }
        if (message.subredditNamePrefixed !== undefined) {
            StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(98).fork()).ldelim();
        }
        if (message.hidden !== undefined) {
            BoolValue.encode({ value: message.hidden }, writer.uint32(106).fork()).ldelim();
        }
        if (message.pwls !== undefined) {
            StringValue.encode({ value: message.pwls }, writer.uint32(114).fork()).ldelim();
        }
        if (message.linkFlairCssClass !== undefined) {
            StringValue.encode({ value: message.linkFlairCssClass }, writer.uint32(122).fork()).ldelim();
        }
        if (message.downs !== undefined) {
            Int64Value.encode({ value: message.downs }, writer.uint32(130).fork()).ldelim();
        }
        if (message.thumbnailHeight !== undefined) {
            Int32Value.encode({ value: message.thumbnailHeight }, writer.uint32(138).fork()).ldelim();
        }
        if (message.topAwardedType !== undefined) {
            StringValue.encode({ value: message.topAwardedType }, writer.uint32(146).fork()).ldelim();
        }
        if (message.parentWhitelistStatus !== undefined) {
            BoolValue.encode({ value: message.parentWhitelistStatus }, writer.uint32(154).fork()).ldelim();
        }
        if (message.hideScore !== undefined) {
            BoolValue.encode({ value: message.hideScore }, writer.uint32(162).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(170).fork()).ldelim();
        }
        if (message.quarantine !== undefined) {
            BoolValue.encode({ value: message.quarantine }, writer.uint32(178).fork()).ldelim();
        }
        if (message.linkFlairTextColor !== undefined) {
            StringValue.encode({ value: message.linkFlairTextColor }, writer.uint32(186).fork()).ldelim();
        }
        if (message.upvoteRatio !== undefined) {
            Int64Value.encode({ value: message.upvoteRatio }, writer.uint32(194).fork()).ldelim();
        }
        if (message.ignoreReports !== undefined) {
            BoolValue.encode({ value: message.ignoreReports }, writer.uint32(202).fork()).ldelim();
        }
        if (message.ups !== undefined) {
            Int64Value.encode({ value: message.ups }, writer.uint32(210).fork()).ldelim();
        }
        if (message.domain !== undefined) {
            StringValue.encode({ value: message.domain }, writer.uint32(218).fork()).ldelim();
        }
        if (message.mediaEmbed !== undefined) {
            MediaEmbed.encode(message.mediaEmbed, writer.uint32(226).fork()).ldelim();
        }
        if (message.thumbnailWidth !== undefined) {
            Int32Value.encode({ value: message.thumbnailWidth }, writer.uint32(234).fork()).ldelim();
        }
        if (message.authorFlairTemplateId !== undefined) {
            StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(242).fork()).ldelim();
        }
        if (message.isOriginalContent !== undefined) {
            BoolValue.encode({ value: message.isOriginalContent }, writer.uint32(250).fork()).ldelim();
        }
        if (message.authorFullname !== undefined) {
            StringValue.encode({ value: message.authorFullname }, writer.uint32(258).fork()).ldelim();
        }
        if (message.secureMedia !== undefined) {
            BoolValue.encode({ value: message.secureMedia }, writer.uint32(266).fork()).ldelim();
        }
        if (message.isRedditMediaDomain !== undefined) {
            BoolValue.encode({ value: message.isRedditMediaDomain }, writer.uint32(274).fork()).ldelim();
        }
        if (message.isMeta !== undefined) {
            BoolValue.encode({ value: message.isMeta }, writer.uint32(282).fork()).ldelim();
        }
        if (message.category !== undefined) {
            StringValue.encode({ value: message.category }, writer.uint32(290).fork()).ldelim();
        }
        if (message.secureMediaEmbed !== undefined) {
            MediaEmbed.encode(message.secureMediaEmbed, writer.uint32(298).fork()).ldelim();
        }
        if (message.linkFlairText !== undefined) {
            StringValue.encode({ value: message.linkFlairText }, writer.uint32(306).fork()).ldelim();
        }
        if (message.canModPost !== undefined) {
            BoolValue.encode({ value: message.canModPost }, writer.uint32(314).fork()).ldelim();
        }
        if (message.score !== undefined) {
            Int64Value.encode({ value: message.score }, writer.uint32(322).fork()).ldelim();
        }
        if (message.approvedBy !== undefined) {
            StringValue.encode({ value: message.approvedBy }, writer.uint32(330).fork()).ldelim();
        }
        if (message.isCreatedFromAdsUi !== undefined) {
            BoolValue.encode({ value: message.isCreatedFromAdsUi }, writer.uint32(338).fork()).ldelim();
        }
        if (message.authorPremium !== undefined) {
            BoolValue.encode({ value: message.authorPremium }, writer.uint32(346).fork()).ldelim();
        }
        if (message.thumbnail !== undefined) {
            StringValue.encode({ value: message.thumbnail }, writer.uint32(354).fork()).ldelim();
        }
        if (message.edited !== undefined) {
            BoolValue.encode({ value: message.edited }, writer.uint32(362).fork()).ldelim();
        }
        if (message.authorFlairCssClass !== undefined) {
            StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(370).fork()).ldelim();
        }
        for (const v of message.previousVisits) {
            Int64Value.encode({ value: v }, writer.uint32(378).fork()).ldelim();
        }
        for (const v of message.authorFlairRichtext) {
            StringValue.encode({ value: v }, writer.uint32(386).fork()).ldelim();
        }
        if (message.gildings !== undefined) {
            Any.encode(message.gildings, writer.uint32(394).fork()).ldelim();
        }
        if (message.contentCategories !== undefined) {
            StringValue.encode({ value: message.contentCategories }, writer.uint32(402).fork()).ldelim();
        }
        if (message.isSelf !== undefined) {
            BoolValue.encode({ value: message.isSelf }, writer.uint32(410).fork()).ldelim();
        }
        if (message.subredditType !== undefined) {
            StringValue.encode({ value: message.subredditType }, writer.uint32(418).fork()).ldelim();
        }
        if (message.created !== undefined) {
            Int64Value.encode({ value: message.created }, writer.uint32(426).fork()).ldelim();
        }
        if (message.linkFlairType !== undefined) {
            StringValue.encode({ value: message.linkFlairType }, writer.uint32(434).fork()).ldelim();
        }
        if (message.wls !== undefined) {
            StringValue.encode({ value: message.wls }, writer.uint32(442).fork()).ldelim();
        }
        if (message.removedByCategory !== undefined) {
            StringValue.encode({ value: message.removedByCategory }, writer.uint32(450).fork()).ldelim();
        }
        if (message.bannedBy !== undefined) {
            StringValue.encode({ value: message.bannedBy }, writer.uint32(458).fork()).ldelim();
        }
        if (message.authorFlairType !== undefined) {
            StringValue.encode({ value: message.authorFlairType }, writer.uint32(466).fork()).ldelim();
        }
        if (message.totalAwardsReceived !== undefined) {
            Int64Value.encode({ value: message.totalAwardsReceived }, writer.uint32(474).fork()).ldelim();
        }
        if (message.allowLiveComments !== undefined) {
            BoolValue.encode({ value: message.allowLiveComments }, writer.uint32(482).fork()).ldelim();
        }
        if (message.selftextHtml !== undefined) {
            StringValue.encode({ value: message.selftextHtml }, writer.uint32(490).fork()).ldelim();
        }
        if (message.likes !== undefined) {
            BoolValue.encode({ value: message.likes }, writer.uint32(498).fork()).ldelim();
        }
        if (message.suggestedSort !== undefined) {
            StringValue.encode({ value: message.suggestedSort }, writer.uint32(506).fork()).ldelim();
        }
        if (message.bannedAtUtc !== undefined) {
            Int32Value.encode({ value: message.bannedAtUtc }, writer.uint32(514).fork()).ldelim();
        }
        if (message.viewCount !== undefined) {
            Int32Value.encode({ value: message.viewCount }, writer.uint32(522).fork()).ldelim();
        }
        if (message.archived !== undefined) {
            BoolValue.encode({ value: message.archived }, writer.uint32(530).fork()).ldelim();
        }
        if (message.noFollow !== undefined) {
            BoolValue.encode({ value: message.noFollow }, writer.uint32(538).fork()).ldelim();
        }
        if (message.spam !== undefined) {
            BoolValue.encode({ value: message.spam }, writer.uint32(546).fork()).ldelim();
        }
        if (message.isCrosspostable !== undefined) {
            BoolValue.encode({ value: message.isCrosspostable }, writer.uint32(554).fork()).ldelim();
        }
        if (message.pinned !== undefined) {
            BoolValue.encode({ value: message.pinned }, writer.uint32(562).fork()).ldelim();
        }
        if (message.over18 !== undefined) {
            BoolValue.encode({ value: message.over18 }, writer.uint32(570).fork()).ldelim();
        }
        for (const v of message.allAwardings) {
            Any.encode(v, writer.uint32(578).fork()).ldelim();
        }
        for (const v of message.awarders) {
            StringValue.encode({ value: v }, writer.uint32(586).fork()).ldelim();
        }
        if (message.mediaOnly !== undefined) {
            BoolValue.encode({ value: message.mediaOnly }, writer.uint32(594).fork()).ldelim();
        }
        if (message.canGild !== undefined) {
            BoolValue.encode({ value: message.canGild }, writer.uint32(602).fork()).ldelim();
        }
        if (message.removed !== undefined) {
            BoolValue.encode({ value: message.removed }, writer.uint32(610).fork()).ldelim();
        }
        if (message.spoiler !== undefined) {
            BoolValue.encode({ value: message.spoiler }, writer.uint32(618).fork()).ldelim();
        }
        if (message.locked !== undefined) {
            BoolValue.encode({ value: message.locked }, writer.uint32(626).fork()).ldelim();
        }
        if (message.authorFlairText !== undefined) {
            StringValue.encode({ value: message.authorFlairText }, writer.uint32(634).fork()).ldelim();
        }
        for (const v of message.treatmentTags) {
            Any.encode(v, writer.uint32(642).fork()).ldelim();
        }
        if (message.rteMode !== undefined) {
            StringValue.encode({ value: message.rteMode }, writer.uint32(650).fork()).ldelim();
        }
        if (message.visited !== undefined) {
            BoolValue.encode({ value: message.visited }, writer.uint32(658).fork()).ldelim();
        }
        if (message.removedBy !== undefined) {
            StringValue.encode({ value: message.removedBy }, writer.uint32(666).fork()).ldelim();
        }
        if (message.modNote !== undefined) {
            StringValue.encode({ value: message.modNote }, writer.uint32(674).fork()).ldelim();
        }
        if (message.distinguished !== undefined) {
            StringValue.encode({ value: message.distinguished }, writer.uint32(682).fork()).ldelim();
        }
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(690).fork()).ldelim();
        }
        if (message.authorIsBlocked !== undefined) {
            BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(698).fork()).ldelim();
        }
        if (message.modReasonBy !== undefined) {
            StringValue.encode({ value: message.modReasonBy }, writer.uint32(706).fork()).ldelim();
        }
        if (message.numReports !== undefined) {
            Int64Value.encode({ value: message.numReports }, writer.uint32(714).fork()).ldelim();
        }
        if (message.removalReason !== undefined) {
            StringValue.encode({ value: message.removalReason }, writer.uint32(722).fork()).ldelim();
        }
        if (message.linkFlairBackgroundColor !== undefined) {
            StringValue.encode({ value: message.linkFlairBackgroundColor }, writer.uint32(730).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(738).fork()).ldelim();
        }
        if (message.isRobotIndexable !== undefined) {
            BoolValue.encode({ value: message.isRobotIndexable }, writer.uint32(746).fork()).ldelim();
        }
        if (message.numDuplicates !== undefined) {
            Int32Value.encode({ value: message.numDuplicates }, writer.uint32(754).fork()).ldelim();
        }
        for (const v of message.reportReasons) {
            Any.encode(v, writer.uint32(762).fork()).ldelim();
        }
        if (message.author !== undefined) {
            StringValue.encode({ value: message.author }, writer.uint32(770).fork()).ldelim();
        }
        if (message.discussionType !== undefined) {
            StringValue.encode({ value: message.discussionType }, writer.uint32(778).fork()).ldelim();
        }
        if (message.numComments !== undefined) {
            Int64Value.encode({ value: message.numComments }, writer.uint32(786).fork()).ldelim();
        }
        if (message.sendReplies !== undefined) {
            BoolValue.encode({ value: message.sendReplies }, writer.uint32(794).fork()).ldelim();
        }
        if (message.media !== undefined) {
            StringValue.encode({ value: message.media }, writer.uint32(802).fork()).ldelim();
        }
        if (message.contestMode !== undefined) {
            BoolValue.encode({ value: message.contestMode }, writer.uint32(810).fork()).ldelim();
        }
        if (message.authorPatreonFlair !== undefined) {
            BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(818).fork()).ldelim();
        }
        if (message.approved !== undefined) {
            BoolValue.encode({ value: message.approved }, writer.uint32(826).fork()).ldelim();
        }
        if (message.authorFlairTextColor !== undefined) {
            StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(834).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(842).fork()).ldelim();
        }
        if (message.whitelistStatus !== undefined) {
            BoolValue.encode({ value: message.whitelistStatus }, writer.uint32(850).fork()).ldelim();
        }
        if (message.stickied !== undefined) {
            BoolValue.encode({ value: message.stickied }, writer.uint32(858).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(866).fork()).ldelim();
        }
        if (message.subredditSubscribers !== undefined) {
            Int64Value.encode({ value: message.subredditSubscribers }, writer.uint32(874).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(882).fork()).ldelim();
        }
        if (message.numCrossposts !== undefined) {
            Int64Value.encode({ value: message.numCrossposts }, writer.uint32(890).fork()).ldelim();
        }
        for (const v of message.modReports) {
            Any.encode(v, writer.uint32(898).fork()).ldelim();
        }
        if (message.isVideo !== undefined) {
            BoolValue.encode({ value: message.isVideo }, writer.uint32(906).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStickyResponse_LinkData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.approvedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.selftext = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.userReports.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 6:
                    message.saved = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.gilded = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.clicked = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.linkFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 12:
                    message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.hidden = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.pwls = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.linkFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.downs = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.thumbnailHeight = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.parentWhitelistStatus = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.hideScore = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.linkFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.upvoteRatio = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 26:
                    message.ups = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 27:
                    message.domain = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 28:
                    message.mediaEmbed = MediaEmbed.decode(reader, reader.uint32());
                    break;
                case 29:
                    message.thumbnailWidth = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 30:
                    message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 31:
                    message.isOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 32:
                    message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 33:
                    message.secureMedia = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 34:
                    message.isRedditMediaDomain = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 35:
                    message.isMeta = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 36:
                    message.category = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 37:
                    message.secureMediaEmbed = MediaEmbed.decode(reader, reader.uint32());
                    break;
                case 38:
                    message.linkFlairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 39:
                    message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 40:
                    message.score = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 41:
                    message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 42:
                    message.isCreatedFromAdsUi = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 43:
                    message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 44:
                    message.thumbnail = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 45:
                    message.edited = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 46:
                    message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 47:
                    message.previousVisits.push(Int64Value.decode(reader, reader.uint32()).value);
                    break;
                case 48:
                    message.authorFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 49:
                    message.gildings = Any.decode(reader, reader.uint32());
                    break;
                case 50:
                    message.contentCategories = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 51:
                    message.isSelf = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 52:
                    message.subredditType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 53:
                    message.created = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 54:
                    message.linkFlairType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 55:
                    message.wls = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 56:
                    message.removedByCategory = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 57:
                    message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 58:
                    message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 59:
                    message.totalAwardsReceived = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 60:
                    message.allowLiveComments = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 61:
                    message.selftextHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 62:
                    message.likes = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 63:
                    message.suggestedSort = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 64:
                    message.bannedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 65:
                    message.viewCount = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 66:
                    message.archived = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 67:
                    message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 68:
                    message.spam = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 69:
                    message.isCrosspostable = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 70:
                    message.pinned = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 71:
                    message.over18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 72:
                    message.allAwardings.push(Any.decode(reader, reader.uint32()));
                    break;
                case 73:
                    message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 74:
                    message.mediaOnly = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 75:
                    message.canGild = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 76:
                    message.removed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 77:
                    message.spoiler = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 78:
                    message.locked = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 79:
                    message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 80:
                    message.treatmentTags.push(Any.decode(reader, reader.uint32()));
                    break;
                case 81:
                    message.rteMode = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 82:
                    message.visited = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 83:
                    message.removedBy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 84:
                    message.modNote = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 85:
                    message.distinguished = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 86:
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 87:
                    message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 88:
                    message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 89:
                    message.numReports = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 90:
                    message.removalReason = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 91:
                    message.linkFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 92:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 93:
                    message.isRobotIndexable = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 94:
                    message.numDuplicates = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 95:
                    message.reportReasons.push(Any.decode(reader, reader.uint32()));
                    break;
                case 96:
                    message.author = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 97:
                    message.discussionType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 98:
                    message.numComments = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 99:
                    message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 100:
                    message.media = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 101:
                    message.contestMode = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 102:
                    message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 103:
                    message.approved = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 104:
                    message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 105:
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 106:
                    message.whitelistStatus = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 107:
                    message.stickied = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 108:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 109:
                    message.subredditSubscribers = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 110:
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 111:
                    message.numCrossposts = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 112:
                    message.modReports.push(Any.decode(reader, reader.uint32()));
                    break;
                case 113:
                    message.isVideo = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            authorFlairBackgroundColor: isSet(object.authorFlairBackgroundColor)
                ? String(object.authorFlairBackgroundColor)
                : undefined,
            approvedAtUtc: isSet(object.approvedAtUtc) ? Number(object.approvedAtUtc) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            selftext: isSet(object.selftext) ? String(object.selftext) : undefined,
            userReports: Array.isArray(object?.userReports) ? object.userReports.map((e) => String(e)) : [],
            saved: isSet(object.saved) ? Boolean(object.saved) : undefined,
            modReasonTitle: isSet(object.modReasonTitle) ? String(object.modReasonTitle) : undefined,
            gilded: isSet(object.gilded) ? Number(object.gilded) : undefined,
            clicked: isSet(object.clicked) ? Boolean(object.clicked) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            linkFlairRichtext: Array.isArray(object?.linkFlairRichtext)
                ? object.linkFlairRichtext.map((e) => String(e))
                : [],
            subredditNamePrefixed: isSet(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : undefined,
            hidden: isSet(object.hidden) ? Boolean(object.hidden) : undefined,
            pwls: isSet(object.pwls) ? String(object.pwls) : undefined,
            linkFlairCssClass: isSet(object.linkFlairCssClass) ? String(object.linkFlairCssClass) : undefined,
            downs: isSet(object.downs) ? Number(object.downs) : undefined,
            thumbnailHeight: isSet(object.thumbnailHeight) ? Number(object.thumbnailHeight) : undefined,
            topAwardedType: isSet(object.topAwardedType) ? String(object.topAwardedType) : undefined,
            parentWhitelistStatus: isSet(object.parentWhitelistStatus) ? Boolean(object.parentWhitelistStatus) : undefined,
            hideScore: isSet(object.hideScore) ? Boolean(object.hideScore) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            quarantine: isSet(object.quarantine) ? Boolean(object.quarantine) : undefined,
            linkFlairTextColor: isSet(object.linkFlairTextColor) ? String(object.linkFlairTextColor) : undefined,
            upvoteRatio: isSet(object.upvoteRatio) ? Number(object.upvoteRatio) : undefined,
            ignoreReports: isSet(object.ignoreReports) ? Boolean(object.ignoreReports) : undefined,
            ups: isSet(object.ups) ? Number(object.ups) : undefined,
            domain: isSet(object.domain) ? String(object.domain) : undefined,
            mediaEmbed: isSet(object.mediaEmbed) ? MediaEmbed.fromJSON(object.mediaEmbed) : undefined,
            thumbnailWidth: isSet(object.thumbnailWidth) ? Number(object.thumbnailWidth) : undefined,
            authorFlairTemplateId: isSet(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : undefined,
            isOriginalContent: isSet(object.isOriginalContent) ? Boolean(object.isOriginalContent) : undefined,
            authorFullname: isSet(object.authorFullname) ? String(object.authorFullname) : undefined,
            secureMedia: isSet(object.secureMedia) ? Boolean(object.secureMedia) : undefined,
            isRedditMediaDomain: isSet(object.isRedditMediaDomain) ? Boolean(object.isRedditMediaDomain) : undefined,
            isMeta: isSet(object.isMeta) ? Boolean(object.isMeta) : undefined,
            category: isSet(object.category) ? String(object.category) : undefined,
            secureMediaEmbed: isSet(object.secureMediaEmbed) ? MediaEmbed.fromJSON(object.secureMediaEmbed) : undefined,
            linkFlairText: isSet(object.linkFlairText) ? String(object.linkFlairText) : undefined,
            canModPost: isSet(object.canModPost) ? Boolean(object.canModPost) : undefined,
            score: isSet(object.score) ? Number(object.score) : undefined,
            approvedBy: isSet(object.approvedBy) ? String(object.approvedBy) : undefined,
            isCreatedFromAdsUi: isSet(object.isCreatedFromAdsUi) ? Boolean(object.isCreatedFromAdsUi) : undefined,
            authorPremium: isSet(object.authorPremium) ? Boolean(object.authorPremium) : undefined,
            thumbnail: isSet(object.thumbnail) ? String(object.thumbnail) : undefined,
            edited: isSet(object.edited) ? Boolean(object.edited) : undefined,
            authorFlairCssClass: isSet(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : undefined,
            previousVisits: Array.isArray(object?.previousVisits) ? object.previousVisits.map((e) => Number(e)) : [],
            authorFlairRichtext: Array.isArray(object?.authorFlairRichtext)
                ? object.authorFlairRichtext.map((e) => String(e))
                : [],
            gildings: isSet(object.gildings) ? Any.fromJSON(object.gildings) : undefined,
            contentCategories: isSet(object.contentCategories) ? String(object.contentCategories) : undefined,
            isSelf: isSet(object.isSelf) ? Boolean(object.isSelf) : undefined,
            subredditType: isSet(object.subredditType) ? String(object.subredditType) : undefined,
            created: isSet(object.created) ? Number(object.created) : undefined,
            linkFlairType: isSet(object.linkFlairType) ? String(object.linkFlairType) : undefined,
            wls: isSet(object.wls) ? String(object.wls) : undefined,
            removedByCategory: isSet(object.removedByCategory) ? String(object.removedByCategory) : undefined,
            bannedBy: isSet(object.bannedBy) ? String(object.bannedBy) : undefined,
            authorFlairType: isSet(object.authorFlairType) ? String(object.authorFlairType) : undefined,
            totalAwardsReceived: isSet(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : undefined,
            allowLiveComments: isSet(object.allowLiveComments) ? Boolean(object.allowLiveComments) : undefined,
            selftextHtml: isSet(object.selftextHtml) ? String(object.selftextHtml) : undefined,
            likes: isSet(object.likes) ? Boolean(object.likes) : undefined,
            suggestedSort: isSet(object.suggestedSort) ? String(object.suggestedSort) : undefined,
            bannedAtUtc: isSet(object.bannedAtUtc) ? Number(object.bannedAtUtc) : undefined,
            viewCount: isSet(object.viewCount) ? Number(object.viewCount) : undefined,
            archived: isSet(object.archived) ? Boolean(object.archived) : undefined,
            noFollow: isSet(object.noFollow) ? Boolean(object.noFollow) : undefined,
            spam: isSet(object.spam) ? Boolean(object.spam) : undefined,
            isCrosspostable: isSet(object.isCrosspostable) ? Boolean(object.isCrosspostable) : undefined,
            pinned: isSet(object.pinned) ? Boolean(object.pinned) : undefined,
            over18: isSet(object.over18) ? Boolean(object.over18) : undefined,
            allAwardings: Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Any.fromJSON(e)) : [],
            awarders: Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
            mediaOnly: isSet(object.mediaOnly) ? Boolean(object.mediaOnly) : undefined,
            canGild: isSet(object.canGild) ? Boolean(object.canGild) : undefined,
            removed: isSet(object.removed) ? Boolean(object.removed) : undefined,
            spoiler: isSet(object.spoiler) ? Boolean(object.spoiler) : undefined,
            locked: isSet(object.locked) ? Boolean(object.locked) : undefined,
            authorFlairText: isSet(object.authorFlairText) ? String(object.authorFlairText) : undefined,
            treatmentTags: Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => Any.fromJSON(e)) : [],
            rteMode: isSet(object.rteMode) ? String(object.rteMode) : undefined,
            visited: isSet(object.visited) ? Boolean(object.visited) : undefined,
            removedBy: isSet(object.removedBy) ? String(object.removedBy) : undefined,
            modNote: isSet(object.modNote) ? String(object.modNote) : undefined,
            distinguished: isSet(object.distinguished) ? String(object.distinguished) : undefined,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            authorIsBlocked: isSet(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : undefined,
            modReasonBy: isSet(object.modReasonBy) ? String(object.modReasonBy) : undefined,
            numReports: isSet(object.numReports) ? Number(object.numReports) : undefined,
            removalReason: isSet(object.removalReason) ? String(object.removalReason) : undefined,
            linkFlairBackgroundColor: isSet(object.linkFlairBackgroundColor)
                ? String(object.linkFlairBackgroundColor)
                : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            isRobotIndexable: isSet(object.isRobotIndexable) ? Boolean(object.isRobotIndexable) : undefined,
            numDuplicates: isSet(object.numDuplicates) ? Number(object.numDuplicates) : undefined,
            reportReasons: Array.isArray(object?.reportReasons) ? object.reportReasons.map((e) => Any.fromJSON(e)) : [],
            author: isSet(object.author) ? String(object.author) : undefined,
            discussionType: isSet(object.discussionType) ? String(object.discussionType) : undefined,
            numComments: isSet(object.numComments) ? Number(object.numComments) : undefined,
            sendReplies: isSet(object.sendReplies) ? Boolean(object.sendReplies) : undefined,
            media: isSet(object.media) ? String(object.media) : undefined,
            contestMode: isSet(object.contestMode) ? Boolean(object.contestMode) : undefined,
            authorPatreonFlair: isSet(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : undefined,
            approved: isSet(object.approved) ? Boolean(object.approved) : undefined,
            authorFlairTextColor: isSet(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            whitelistStatus: isSet(object.whitelistStatus) ? Boolean(object.whitelistStatus) : undefined,
            stickied: isSet(object.stickied) ? Boolean(object.stickied) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            subredditSubscribers: isSet(object.subredditSubscribers) ? Number(object.subredditSubscribers) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            numCrossposts: isSet(object.numCrossposts) ? Number(object.numCrossposts) : undefined,
            modReports: Array.isArray(object?.modReports) ? object.modReports.map((e) => Any.fromJSON(e)) : [],
            isVideo: isSet(object.isVideo) ? Boolean(object.isVideo) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.authorFlairBackgroundColor !== undefined &&
            (obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor);
        message.approvedAtUtc !== undefined && (obj.approvedAtUtc = message.approvedAtUtc);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.selftext !== undefined && (obj.selftext = message.selftext);
        if (message.userReports) {
            obj.userReports = message.userReports.map((e) => e);
        }
        else {
            obj.userReports = [];
        }
        message.saved !== undefined && (obj.saved = message.saved);
        message.modReasonTitle !== undefined && (obj.modReasonTitle = message.modReasonTitle);
        message.gilded !== undefined && (obj.gilded = message.gilded);
        message.clicked !== undefined && (obj.clicked = message.clicked);
        message.title !== undefined && (obj.title = message.title);
        if (message.linkFlairRichtext) {
            obj.linkFlairRichtext = message.linkFlairRichtext.map((e) => e);
        }
        else {
            obj.linkFlairRichtext = [];
        }
        message.subredditNamePrefixed !== undefined && (obj.subredditNamePrefixed = message.subredditNamePrefixed);
        message.hidden !== undefined && (obj.hidden = message.hidden);
        message.pwls !== undefined && (obj.pwls = message.pwls);
        message.linkFlairCssClass !== undefined && (obj.linkFlairCssClass = message.linkFlairCssClass);
        message.downs !== undefined && (obj.downs = message.downs);
        message.thumbnailHeight !== undefined && (obj.thumbnailHeight = message.thumbnailHeight);
        message.topAwardedType !== undefined && (obj.topAwardedType = message.topAwardedType);
        message.parentWhitelistStatus !== undefined && (obj.parentWhitelistStatus = message.parentWhitelistStatus);
        message.hideScore !== undefined && (obj.hideScore = message.hideScore);
        message.name !== undefined && (obj.name = message.name);
        message.quarantine !== undefined && (obj.quarantine = message.quarantine);
        message.linkFlairTextColor !== undefined && (obj.linkFlairTextColor = message.linkFlairTextColor);
        message.upvoteRatio !== undefined && (obj.upvoteRatio = message.upvoteRatio);
        message.ignoreReports !== undefined && (obj.ignoreReports = message.ignoreReports);
        message.ups !== undefined && (obj.ups = message.ups);
        message.domain !== undefined && (obj.domain = message.domain);
        message.mediaEmbed !== undefined &&
            (obj.mediaEmbed = message.mediaEmbed ? MediaEmbed.toJSON(message.mediaEmbed) : undefined);
        message.thumbnailWidth !== undefined && (obj.thumbnailWidth = message.thumbnailWidth);
        message.authorFlairTemplateId !== undefined && (obj.authorFlairTemplateId = message.authorFlairTemplateId);
        message.isOriginalContent !== undefined && (obj.isOriginalContent = message.isOriginalContent);
        message.authorFullname !== undefined && (obj.authorFullname = message.authorFullname);
        message.secureMedia !== undefined && (obj.secureMedia = message.secureMedia);
        message.isRedditMediaDomain !== undefined && (obj.isRedditMediaDomain = message.isRedditMediaDomain);
        message.isMeta !== undefined && (obj.isMeta = message.isMeta);
        message.category !== undefined && (obj.category = message.category);
        message.secureMediaEmbed !== undefined &&
            (obj.secureMediaEmbed = message.secureMediaEmbed ? MediaEmbed.toJSON(message.secureMediaEmbed) : undefined);
        message.linkFlairText !== undefined && (obj.linkFlairText = message.linkFlairText);
        message.canModPost !== undefined && (obj.canModPost = message.canModPost);
        message.score !== undefined && (obj.score = message.score);
        message.approvedBy !== undefined && (obj.approvedBy = message.approvedBy);
        message.isCreatedFromAdsUi !== undefined && (obj.isCreatedFromAdsUi = message.isCreatedFromAdsUi);
        message.authorPremium !== undefined && (obj.authorPremium = message.authorPremium);
        message.thumbnail !== undefined && (obj.thumbnail = message.thumbnail);
        message.edited !== undefined && (obj.edited = message.edited);
        message.authorFlairCssClass !== undefined && (obj.authorFlairCssClass = message.authorFlairCssClass);
        if (message.previousVisits) {
            obj.previousVisits = message.previousVisits.map((e) => e);
        }
        else {
            obj.previousVisits = [];
        }
        if (message.authorFlairRichtext) {
            obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => e);
        }
        else {
            obj.authorFlairRichtext = [];
        }
        message.gildings !== undefined && (obj.gildings = message.gildings ? Any.toJSON(message.gildings) : undefined);
        message.contentCategories !== undefined && (obj.contentCategories = message.contentCategories);
        message.isSelf !== undefined && (obj.isSelf = message.isSelf);
        message.subredditType !== undefined && (obj.subredditType = message.subredditType);
        message.created !== undefined && (obj.created = message.created);
        message.linkFlairType !== undefined && (obj.linkFlairType = message.linkFlairType);
        message.wls !== undefined && (obj.wls = message.wls);
        message.removedByCategory !== undefined && (obj.removedByCategory = message.removedByCategory);
        message.bannedBy !== undefined && (obj.bannedBy = message.bannedBy);
        message.authorFlairType !== undefined && (obj.authorFlairType = message.authorFlairType);
        message.totalAwardsReceived !== undefined && (obj.totalAwardsReceived = message.totalAwardsReceived);
        message.allowLiveComments !== undefined && (obj.allowLiveComments = message.allowLiveComments);
        message.selftextHtml !== undefined && (obj.selftextHtml = message.selftextHtml);
        message.likes !== undefined && (obj.likes = message.likes);
        message.suggestedSort !== undefined && (obj.suggestedSort = message.suggestedSort);
        message.bannedAtUtc !== undefined && (obj.bannedAtUtc = message.bannedAtUtc);
        message.viewCount !== undefined && (obj.viewCount = message.viewCount);
        message.archived !== undefined && (obj.archived = message.archived);
        message.noFollow !== undefined && (obj.noFollow = message.noFollow);
        message.spam !== undefined && (obj.spam = message.spam);
        message.isCrosspostable !== undefined && (obj.isCrosspostable = message.isCrosspostable);
        message.pinned !== undefined && (obj.pinned = message.pinned);
        message.over18 !== undefined && (obj.over18 = message.over18);
        if (message.allAwardings) {
            obj.allAwardings = message.allAwardings.map((e) => e ? Any.toJSON(e) : undefined);
        }
        else {
            obj.allAwardings = [];
        }
        if (message.awarders) {
            obj.awarders = message.awarders.map((e) => e);
        }
        else {
            obj.awarders = [];
        }
        message.mediaOnly !== undefined && (obj.mediaOnly = message.mediaOnly);
        message.canGild !== undefined && (obj.canGild = message.canGild);
        message.removed !== undefined && (obj.removed = message.removed);
        message.spoiler !== undefined && (obj.spoiler = message.spoiler);
        message.locked !== undefined && (obj.locked = message.locked);
        message.authorFlairText !== undefined && (obj.authorFlairText = message.authorFlairText);
        if (message.treatmentTags) {
            obj.treatmentTags = message.treatmentTags.map((e) => e ? Any.toJSON(e) : undefined);
        }
        else {
            obj.treatmentTags = [];
        }
        message.rteMode !== undefined && (obj.rteMode = message.rteMode);
        message.visited !== undefined && (obj.visited = message.visited);
        message.removedBy !== undefined && (obj.removedBy = message.removedBy);
        message.modNote !== undefined && (obj.modNote = message.modNote);
        message.distinguished !== undefined && (obj.distinguished = message.distinguished);
        message.subredditId !== undefined && (obj.subredditId = message.subredditId);
        message.authorIsBlocked !== undefined && (obj.authorIsBlocked = message.authorIsBlocked);
        message.modReasonBy !== undefined && (obj.modReasonBy = message.modReasonBy);
        message.numReports !== undefined && (obj.numReports = message.numReports);
        message.removalReason !== undefined && (obj.removalReason = message.removalReason);
        message.linkFlairBackgroundColor !== undefined && (obj.linkFlairBackgroundColor = message.linkFlairBackgroundColor);
        message.id !== undefined && (obj.id = message.id);
        message.isRobotIndexable !== undefined && (obj.isRobotIndexable = message.isRobotIndexable);
        message.numDuplicates !== undefined && (obj.numDuplicates = message.numDuplicates);
        if (message.reportReasons) {
            obj.reportReasons = message.reportReasons.map((e) => e ? Any.toJSON(e) : undefined);
        }
        else {
            obj.reportReasons = [];
        }
        message.author !== undefined && (obj.author = message.author);
        message.discussionType !== undefined && (obj.discussionType = message.discussionType);
        message.numComments !== undefined && (obj.numComments = message.numComments);
        message.sendReplies !== undefined && (obj.sendReplies = message.sendReplies);
        message.media !== undefined && (obj.media = message.media);
        message.contestMode !== undefined && (obj.contestMode = message.contestMode);
        message.authorPatreonFlair !== undefined && (obj.authorPatreonFlair = message.authorPatreonFlair);
        message.approved !== undefined && (obj.approved = message.approved);
        message.authorFlairTextColor !== undefined && (obj.authorFlairTextColor = message.authorFlairTextColor);
        message.permalink !== undefined && (obj.permalink = message.permalink);
        message.whitelistStatus !== undefined && (obj.whitelistStatus = message.whitelistStatus);
        message.stickied !== undefined && (obj.stickied = message.stickied);
        message.url !== undefined && (obj.url = message.url);
        message.subredditSubscribers !== undefined && (obj.subredditSubscribers = message.subredditSubscribers);
        message.createdUtc !== undefined && (obj.createdUtc = message.createdUtc);
        message.numCrossposts !== undefined && (obj.numCrossposts = message.numCrossposts);
        if (message.modReports) {
            obj.modReports = message.modReports.map((e) => e ? Any.toJSON(e) : undefined);
        }
        else {
            obj.modReports = [];
        }
        message.isVideo !== undefined && (obj.isVideo = message.isVideo);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStickyResponse_LinkData();
        message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? undefined;
        message.approvedAtUtc = object.approvedAtUtc ?? undefined;
        message.subreddit = object.subreddit ?? undefined;
        message.selftext = object.selftext ?? undefined;
        message.userReports = object.userReports?.map((e) => e) || [];
        message.saved = object.saved ?? undefined;
        message.modReasonTitle = object.modReasonTitle ?? undefined;
        message.gilded = object.gilded ?? undefined;
        message.clicked = object.clicked ?? undefined;
        message.title = object.title ?? undefined;
        message.linkFlairRichtext = object.linkFlairRichtext?.map((e) => e) || [];
        message.subredditNamePrefixed = object.subredditNamePrefixed ?? undefined;
        message.hidden = object.hidden ?? undefined;
        message.pwls = object.pwls ?? undefined;
        message.linkFlairCssClass = object.linkFlairCssClass ?? undefined;
        message.downs = object.downs ?? undefined;
        message.thumbnailHeight = object.thumbnailHeight ?? undefined;
        message.topAwardedType = object.topAwardedType ?? undefined;
        message.parentWhitelistStatus = object.parentWhitelistStatus ?? undefined;
        message.hideScore = object.hideScore ?? undefined;
        message.name = object.name ?? undefined;
        message.quarantine = object.quarantine ?? undefined;
        message.linkFlairTextColor = object.linkFlairTextColor ?? undefined;
        message.upvoteRatio = object.upvoteRatio ?? undefined;
        message.ignoreReports = object.ignoreReports ?? undefined;
        message.ups = object.ups ?? undefined;
        message.domain = object.domain ?? undefined;
        message.mediaEmbed = (object.mediaEmbed !== undefined && object.mediaEmbed !== null)
            ? MediaEmbed.fromPartial(object.mediaEmbed)
            : undefined;
        message.thumbnailWidth = object.thumbnailWidth ?? undefined;
        message.authorFlairTemplateId = object.authorFlairTemplateId ?? undefined;
        message.isOriginalContent = object.isOriginalContent ?? undefined;
        message.authorFullname = object.authorFullname ?? undefined;
        message.secureMedia = object.secureMedia ?? undefined;
        message.isRedditMediaDomain = object.isRedditMediaDomain ?? undefined;
        message.isMeta = object.isMeta ?? undefined;
        message.category = object.category ?? undefined;
        message.secureMediaEmbed = (object.secureMediaEmbed !== undefined && object.secureMediaEmbed !== null)
            ? MediaEmbed.fromPartial(object.secureMediaEmbed)
            : undefined;
        message.linkFlairText = object.linkFlairText ?? undefined;
        message.canModPost = object.canModPost ?? undefined;
        message.score = object.score ?? undefined;
        message.approvedBy = object.approvedBy ?? undefined;
        message.isCreatedFromAdsUi = object.isCreatedFromAdsUi ?? undefined;
        message.authorPremium = object.authorPremium ?? undefined;
        message.thumbnail = object.thumbnail ?? undefined;
        message.edited = object.edited ?? undefined;
        message.authorFlairCssClass = object.authorFlairCssClass ?? undefined;
        message.previousVisits = object.previousVisits?.map((e) => e) || [];
        message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => e) || [];
        message.gildings = (object.gildings !== undefined && object.gildings !== null)
            ? Any.fromPartial(object.gildings)
            : undefined;
        message.contentCategories = object.contentCategories ?? undefined;
        message.isSelf = object.isSelf ?? undefined;
        message.subredditType = object.subredditType ?? undefined;
        message.created = object.created ?? undefined;
        message.linkFlairType = object.linkFlairType ?? undefined;
        message.wls = object.wls ?? undefined;
        message.removedByCategory = object.removedByCategory ?? undefined;
        message.bannedBy = object.bannedBy ?? undefined;
        message.authorFlairType = object.authorFlairType ?? undefined;
        message.totalAwardsReceived = object.totalAwardsReceived ?? undefined;
        message.allowLiveComments = object.allowLiveComments ?? undefined;
        message.selftextHtml = object.selftextHtml ?? undefined;
        message.likes = object.likes ?? undefined;
        message.suggestedSort = object.suggestedSort ?? undefined;
        message.bannedAtUtc = object.bannedAtUtc ?? undefined;
        message.viewCount = object.viewCount ?? undefined;
        message.archived = object.archived ?? undefined;
        message.noFollow = object.noFollow ?? undefined;
        message.spam = object.spam ?? undefined;
        message.isCrosspostable = object.isCrosspostable ?? undefined;
        message.pinned = object.pinned ?? undefined;
        message.over18 = object.over18 ?? undefined;
        message.allAwardings = object.allAwardings?.map((e) => Any.fromPartial(e)) || [];
        message.awarders = object.awarders?.map((e) => e) || [];
        message.mediaOnly = object.mediaOnly ?? undefined;
        message.canGild = object.canGild ?? undefined;
        message.removed = object.removed ?? undefined;
        message.spoiler = object.spoiler ?? undefined;
        message.locked = object.locked ?? undefined;
        message.authorFlairText = object.authorFlairText ?? undefined;
        message.treatmentTags = object.treatmentTags?.map((e) => Any.fromPartial(e)) || [];
        message.rteMode = object.rteMode ?? undefined;
        message.visited = object.visited ?? undefined;
        message.removedBy = object.removedBy ?? undefined;
        message.modNote = object.modNote ?? undefined;
        message.distinguished = object.distinguished ?? undefined;
        message.subredditId = object.subredditId ?? undefined;
        message.authorIsBlocked = object.authorIsBlocked ?? undefined;
        message.modReasonBy = object.modReasonBy ?? undefined;
        message.numReports = object.numReports ?? undefined;
        message.removalReason = object.removalReason ?? undefined;
        message.linkFlairBackgroundColor = object.linkFlairBackgroundColor ?? undefined;
        message.id = object.id ?? undefined;
        message.isRobotIndexable = object.isRobotIndexable ?? undefined;
        message.numDuplicates = object.numDuplicates ?? undefined;
        message.reportReasons = object.reportReasons?.map((e) => Any.fromPartial(e)) || [];
        message.author = object.author ?? undefined;
        message.discussionType = object.discussionType ?? undefined;
        message.numComments = object.numComments ?? undefined;
        message.sendReplies = object.sendReplies ?? undefined;
        message.media = object.media ?? undefined;
        message.contestMode = object.contestMode ?? undefined;
        message.authorPatreonFlair = object.authorPatreonFlair ?? undefined;
        message.approved = object.approved ?? undefined;
        message.authorFlairTextColor = object.authorFlairTextColor ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.whitelistStatus = object.whitelistStatus ?? undefined;
        message.stickied = object.stickied ?? undefined;
        message.url = object.url ?? undefined;
        message.subredditSubscribers = object.subredditSubscribers ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.numCrossposts = object.numCrossposts ?? undefined;
        message.modReports = object.modReports?.map((e) => Any.fromPartial(e)) || [];
        message.isVideo = object.isVideo ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyResponse.LinkData", StickyResponse_LinkData);
function createBaseStickyResponse_WrappedStickyListing() {
    return { kind: undefined, data: undefined };
}
export const StickyResponse_WrappedStickyListing = {
    $type: "devvit.plugin.redditapi.subreddits.StickyResponse.WrappedStickyListing",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            StickyResponse_LinkData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStickyResponse_WrappedStickyListing();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = StickyResponse_LinkData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? StickyResponse_LinkData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined && (obj.data = message.data ? StickyResponse_LinkData.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStickyResponse_WrappedStickyListing();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? StickyResponse_LinkData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyResponse.WrappedStickyListing", StickyResponse_WrappedStickyListing);
function createBaseStickyResponse_StickyResponseData() {
    return {
        after: undefined,
        before: undefined,
        dist: undefined,
        modhash: undefined,
        geoFilter: undefined,
        children: [],
    };
}
export const StickyResponse_StickyResponseData = {
    $type: "devvit.plugin.redditapi.subreddits.StickyResponse.StickyResponseData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.dist !== undefined) {
            Int32Value.encode({ value: message.dist }, writer.uint32(26).fork()).ldelim();
        }
        if (message.modhash !== undefined) {
            StringValue.encode({ value: message.modhash }, writer.uint32(34).fork()).ldelim();
        }
        if (message.geoFilter !== undefined) {
            StringValue.encode({ value: message.geoFilter }, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.children) {
            StickyResponse_WrappedStickyListing.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStickyResponse_StickyResponseData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.dist = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.modhash = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.geoFilter = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.children.push(StickyResponse_WrappedStickyListing.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            dist: isSet(object.dist) ? Number(object.dist) : undefined,
            modhash: isSet(object.modhash) ? String(object.modhash) : undefined,
            geoFilter: isSet(object.geoFilter) ? String(object.geoFilter) : undefined,
            children: Array.isArray(object?.children)
                ? object.children.map((e) => StickyResponse_WrappedStickyListing.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.dist !== undefined && (obj.dist = message.dist);
        message.modhash !== undefined && (obj.modhash = message.modhash);
        message.geoFilter !== undefined && (obj.geoFilter = message.geoFilter);
        if (message.children) {
            obj.children = message.children.map((e) => e ? StickyResponse_WrappedStickyListing.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStickyResponse_StickyResponseData();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.dist = object.dist ?? undefined;
        message.modhash = object.modhash ?? undefined;
        message.geoFilter = object.geoFilter ?? undefined;
        message.children = object.children?.map((e) => StickyResponse_WrappedStickyListing.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyResponse.StickyResponseData", StickyResponse_StickyResponseData);
function createBaseFullSubredditObject() {
    return {
        userFlairBackgroundColor: undefined,
        submitTextHtml: undefined,
        restrictPosting: undefined,
        userIsBanned: undefined,
        freeFormReports: undefined,
        wikiEnabled: undefined,
        userIsMuted: undefined,
        userCanFlairInSr: undefined,
        displayName: undefined,
        headerImg: undefined,
        title: undefined,
        allowGalleries: undefined,
        iconSize: [],
        primaryColor: undefined,
        activeUserCount: undefined,
        iconImg: undefined,
        displayNamePrefixed: undefined,
        accountsActive: undefined,
        publicTraffic: undefined,
        subscribers: undefined,
        userFlairRichtext: [],
        videostreamLinksCount: undefined,
        name: undefined,
        quarantine: undefined,
        hideAds: undefined,
        predictionLeaderboardEntryType: undefined,
        emojisEnabled: undefined,
        advertiserCategory: undefined,
        publicDescription: undefined,
        commentScoreHideMins: undefined,
        allowPredictions: undefined,
        userHasFavorited: undefined,
        userFlairTemplateId: undefined,
        communityIcon: undefined,
        bannerBackgroundImage: undefined,
        originalContentTagEnabled: undefined,
        communityReviewed: undefined,
        submitText: undefined,
        descriptionHtml: undefined,
        spoilersEnabled: undefined,
        commentContributionSettings: undefined,
        allowTalks: undefined,
        headerSize: [],
        userFlairPosition: undefined,
        allOriginalContent: undefined,
        hasMenuWidget: undefined,
        isEnrolledInNewModmail: undefined,
        keyColor: undefined,
        canAssignUserFlair: undefined,
        created: undefined,
        wls: undefined,
        showMediaPreview: undefined,
        submissionType: undefined,
        userIsSubscriber: undefined,
        allowedMediaInComments: [],
        allowVideogifs: undefined,
        shouldArchivePosts: undefined,
        userFlairType: undefined,
        allowPolls: undefined,
        collapseDeletedComments: undefined,
        emojisCustomSize: [],
        publicDescriptionHtml: undefined,
        allowVideos: undefined,
        isCrosspostableSubreddit: undefined,
        notificationLevel: undefined,
        shouldShowMediaInCommentsSetting: undefined,
        canAssignLinkFlair: undefined,
        accountsActiveIsFuzzed: undefined,
        allowPredictionContributors: undefined,
        submitTextLabel: undefined,
        linkFlairPosition: undefined,
        userSrFlairEnabled: undefined,
        userFlairEnabledInSr: undefined,
        allowChatPostCreation: undefined,
        allowDiscovery: undefined,
        acceptFollowers: undefined,
        userSrThemeEnabled: undefined,
        linkFlairEnabled: undefined,
        disableContributorRequests: undefined,
        subredditType: undefined,
        suggestedCommentSort: undefined,
        bannerImg: undefined,
        userFlairText: undefined,
        contentCategory: undefined,
        bannerBackgroundColor: undefined,
        showMedia: undefined,
        id: undefined,
        userIsModerator: undefined,
        over18: undefined,
        headerTitle: undefined,
        description: undefined,
        isChatPostFeatureEnabled: undefined,
        submitLinkLabel: undefined,
        userFlairTextColor: undefined,
        restrictCommenting: undefined,
        userFlairCssClass: undefined,
        allowImages: undefined,
        lang: undefined,
        whitelistStatus: undefined,
        url: undefined,
        createdUtc: undefined,
        bannerSize: [],
        mobileBannerImage: undefined,
        userIsContributor: undefined,
        allowPredictionsTournament: undefined,
    };
}
export const FullSubredditObject = {
    $type: "devvit.plugin.redditapi.subreddits.FullSubredditObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.userFlairBackgroundColor !== undefined) {
            StringValue.encode({ value: message.userFlairBackgroundColor }, writer.uint32(10).fork()).ldelim();
        }
        if (message.submitTextHtml !== undefined) {
            StringValue.encode({ value: message.submitTextHtml }, writer.uint32(18).fork()).ldelim();
        }
        if (message.restrictPosting !== undefined) {
            BoolValue.encode({ value: message.restrictPosting }, writer.uint32(26).fork()).ldelim();
        }
        if (message.userIsBanned !== undefined) {
            BoolValue.encode({ value: message.userIsBanned }, writer.uint32(34).fork()).ldelim();
        }
        if (message.freeFormReports !== undefined) {
            BoolValue.encode({ value: message.freeFormReports }, writer.uint32(42).fork()).ldelim();
        }
        if (message.wikiEnabled !== undefined) {
            BoolValue.encode({ value: message.wikiEnabled }, writer.uint32(50).fork()).ldelim();
        }
        if (message.userIsMuted !== undefined) {
            BoolValue.encode({ value: message.userIsMuted }, writer.uint32(58).fork()).ldelim();
        }
        if (message.userCanFlairInSr !== undefined) {
            BoolValue.encode({ value: message.userCanFlairInSr }, writer.uint32(66).fork()).ldelim();
        }
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(74).fork()).ldelim();
        }
        if (message.headerImg !== undefined) {
            StringValue.encode({ value: message.headerImg }, writer.uint32(82).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(90).fork()).ldelim();
        }
        if (message.allowGalleries !== undefined) {
            BoolValue.encode({ value: message.allowGalleries }, writer.uint32(98).fork()).ldelim();
        }
        for (const v of message.iconSize) {
            Int64Value.encode({ value: v }, writer.uint32(106).fork()).ldelim();
        }
        if (message.primaryColor !== undefined) {
            StringValue.encode({ value: message.primaryColor }, writer.uint32(114).fork()).ldelim();
        }
        if (message.activeUserCount !== undefined) {
            Int64Value.encode({ value: message.activeUserCount }, writer.uint32(122).fork()).ldelim();
        }
        if (message.iconImg !== undefined) {
            StringValue.encode({ value: message.iconImg }, writer.uint32(130).fork()).ldelim();
        }
        if (message.displayNamePrefixed !== undefined) {
            StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(138).fork()).ldelim();
        }
        if (message.accountsActive !== undefined) {
            Int64Value.encode({ value: message.accountsActive }, writer.uint32(146).fork()).ldelim();
        }
        if (message.publicTraffic !== undefined) {
            BoolValue.encode({ value: message.publicTraffic }, writer.uint32(154).fork()).ldelim();
        }
        if (message.subscribers !== undefined) {
            Int64Value.encode({ value: message.subscribers }, writer.uint32(162).fork()).ldelim();
        }
        for (const v of message.userFlairRichtext) {
            StringValue.encode({ value: v }, writer.uint32(170).fork()).ldelim();
        }
        if (message.videostreamLinksCount !== undefined) {
            Int64Value.encode({ value: message.videostreamLinksCount }, writer.uint32(178).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(186).fork()).ldelim();
        }
        if (message.quarantine !== undefined) {
            BoolValue.encode({ value: message.quarantine }, writer.uint32(194).fork()).ldelim();
        }
        if (message.hideAds !== undefined) {
            BoolValue.encode({ value: message.hideAds }, writer.uint32(202).fork()).ldelim();
        }
        if (message.predictionLeaderboardEntryType !== undefined) {
            StringValue.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(210).fork()).ldelim();
        }
        if (message.emojisEnabled !== undefined) {
            BoolValue.encode({ value: message.emojisEnabled }, writer.uint32(218).fork()).ldelim();
        }
        if (message.advertiserCategory !== undefined) {
            StringValue.encode({ value: message.advertiserCategory }, writer.uint32(226).fork()).ldelim();
        }
        if (message.publicDescription !== undefined) {
            StringValue.encode({ value: message.publicDescription }, writer.uint32(234).fork()).ldelim();
        }
        if (message.commentScoreHideMins !== undefined) {
            Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(242).fork()).ldelim();
        }
        if (message.allowPredictions !== undefined) {
            BoolValue.encode({ value: message.allowPredictions }, writer.uint32(250).fork()).ldelim();
        }
        if (message.userHasFavorited !== undefined) {
            BoolValue.encode({ value: message.userHasFavorited }, writer.uint32(258).fork()).ldelim();
        }
        if (message.userFlairTemplateId !== undefined) {
            StringValue.encode({ value: message.userFlairTemplateId }, writer.uint32(266).fork()).ldelim();
        }
        if (message.communityIcon !== undefined) {
            StringValue.encode({ value: message.communityIcon }, writer.uint32(274).fork()).ldelim();
        }
        if (message.bannerBackgroundImage !== undefined) {
            StringValue.encode({ value: message.bannerBackgroundImage }, writer.uint32(282).fork()).ldelim();
        }
        if (message.originalContentTagEnabled !== undefined) {
            BoolValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(290).fork()).ldelim();
        }
        if (message.communityReviewed !== undefined) {
            BoolValue.encode({ value: message.communityReviewed }, writer.uint32(298).fork()).ldelim();
        }
        if (message.submitText !== undefined) {
            StringValue.encode({ value: message.submitText }, writer.uint32(314).fork()).ldelim();
        }
        if (message.descriptionHtml !== undefined) {
            StringValue.encode({ value: message.descriptionHtml }, writer.uint32(322).fork()).ldelim();
        }
        if (message.spoilersEnabled !== undefined) {
            BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(330).fork()).ldelim();
        }
        if (message.commentContributionSettings !== undefined) {
            CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(338).fork()).ldelim();
        }
        if (message.allowTalks !== undefined) {
            BoolValue.encode({ value: message.allowTalks }, writer.uint32(346).fork()).ldelim();
        }
        for (const v of message.headerSize) {
            Int64Value.encode({ value: v }, writer.uint32(354).fork()).ldelim();
        }
        if (message.userFlairPosition !== undefined) {
            StringValue.encode({ value: message.userFlairPosition }, writer.uint32(362).fork()).ldelim();
        }
        if (message.allOriginalContent !== undefined) {
            BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(370).fork()).ldelim();
        }
        if (message.hasMenuWidget !== undefined) {
            BoolValue.encode({ value: message.hasMenuWidget }, writer.uint32(378).fork()).ldelim();
        }
        if (message.isEnrolledInNewModmail !== undefined) {
            BoolValue.encode({ value: message.isEnrolledInNewModmail }, writer.uint32(386).fork()).ldelim();
        }
        if (message.keyColor !== undefined) {
            StringValue.encode({ value: message.keyColor }, writer.uint32(394).fork()).ldelim();
        }
        if (message.canAssignUserFlair !== undefined) {
            BoolValue.encode({ value: message.canAssignUserFlair }, writer.uint32(402).fork()).ldelim();
        }
        if (message.created !== undefined) {
            Int64Value.encode({ value: message.created }, writer.uint32(410).fork()).ldelim();
        }
        if (message.wls !== undefined) {
            Int32Value.encode({ value: message.wls }, writer.uint32(418).fork()).ldelim();
        }
        if (message.showMediaPreview !== undefined) {
            BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(426).fork()).ldelim();
        }
        if (message.submissionType !== undefined) {
            StringValue.encode({ value: message.submissionType }, writer.uint32(434).fork()).ldelim();
        }
        if (message.userIsSubscriber !== undefined) {
            BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(442).fork()).ldelim();
        }
        for (const v of message.allowedMediaInComments) {
            StringValue.encode({ value: v }, writer.uint32(450).fork()).ldelim();
        }
        if (message.allowVideogifs !== undefined) {
            BoolValue.encode({ value: message.allowVideogifs }, writer.uint32(458).fork()).ldelim();
        }
        if (message.shouldArchivePosts !== undefined) {
            BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(466).fork()).ldelim();
        }
        if (message.userFlairType !== undefined) {
            StringValue.encode({ value: message.userFlairType }, writer.uint32(474).fork()).ldelim();
        }
        if (message.allowPolls !== undefined) {
            BoolValue.encode({ value: message.allowPolls }, writer.uint32(482).fork()).ldelim();
        }
        if (message.collapseDeletedComments !== undefined) {
            BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(490).fork()).ldelim();
        }
        for (const v of message.emojisCustomSize) {
            Int64Value.encode({ value: v }, writer.uint32(498).fork()).ldelim();
        }
        if (message.publicDescriptionHtml !== undefined) {
            StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(506).fork()).ldelim();
        }
        if (message.allowVideos !== undefined) {
            BoolValue.encode({ value: message.allowVideos }, writer.uint32(514).fork()).ldelim();
        }
        if (message.isCrosspostableSubreddit !== undefined) {
            BoolValue.encode({ value: message.isCrosspostableSubreddit }, writer.uint32(522).fork()).ldelim();
        }
        if (message.notificationLevel !== undefined) {
            StringValue.encode({ value: message.notificationLevel }, writer.uint32(530).fork()).ldelim();
        }
        if (message.shouldShowMediaInCommentsSetting !== undefined) {
            BoolValue.encode({ value: message.shouldShowMediaInCommentsSetting }, writer.uint32(538).fork()).ldelim();
        }
        if (message.canAssignLinkFlair !== undefined) {
            BoolValue.encode({ value: message.canAssignLinkFlair }, writer.uint32(546).fork()).ldelim();
        }
        if (message.accountsActiveIsFuzzed !== undefined) {
            BoolValue.encode({ value: message.accountsActiveIsFuzzed }, writer.uint32(554).fork()).ldelim();
        }
        if (message.allowPredictionContributors !== undefined) {
            BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(562).fork()).ldelim();
        }
        if (message.submitTextLabel !== undefined) {
            StringValue.encode({ value: message.submitTextLabel }, writer.uint32(570).fork()).ldelim();
        }
        if (message.linkFlairPosition !== undefined) {
            StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(578).fork()).ldelim();
        }
        if (message.userSrFlairEnabled !== undefined) {
            BoolValue.encode({ value: message.userSrFlairEnabled }, writer.uint32(586).fork()).ldelim();
        }
        if (message.userFlairEnabledInSr !== undefined) {
            BoolValue.encode({ value: message.userFlairEnabledInSr }, writer.uint32(594).fork()).ldelim();
        }
        if (message.allowChatPostCreation !== undefined) {
            BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(602).fork()).ldelim();
        }
        if (message.allowDiscovery !== undefined) {
            BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(610).fork()).ldelim();
        }
        if (message.acceptFollowers !== undefined) {
            BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(618).fork()).ldelim();
        }
        if (message.userSrThemeEnabled !== undefined) {
            BoolValue.encode({ value: message.userSrThemeEnabled }, writer.uint32(626).fork()).ldelim();
        }
        if (message.linkFlairEnabled !== undefined) {
            BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(634).fork()).ldelim();
        }
        if (message.disableContributorRequests !== undefined) {
            BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(642).fork()).ldelim();
        }
        if (message.subredditType !== undefined) {
            StringValue.encode({ value: message.subredditType }, writer.uint32(650).fork()).ldelim();
        }
        if (message.suggestedCommentSort !== undefined) {
            StringValue.encode({ value: message.suggestedCommentSort }, writer.uint32(658).fork()).ldelim();
        }
        if (message.bannerImg !== undefined) {
            StringValue.encode({ value: message.bannerImg }, writer.uint32(666).fork()).ldelim();
        }
        if (message.userFlairText !== undefined) {
            StringValue.encode({ value: message.userFlairText }, writer.uint32(674).fork()).ldelim();
        }
        if (message.contentCategory !== undefined) {
            StringValue.encode({ value: message.contentCategory }, writer.uint32(682).fork()).ldelim();
        }
        if (message.bannerBackgroundColor !== undefined) {
            StringValue.encode({ value: message.bannerBackgroundColor }, writer.uint32(690).fork()).ldelim();
        }
        if (message.showMedia !== undefined) {
            BoolValue.encode({ value: message.showMedia }, writer.uint32(698).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(706).fork()).ldelim();
        }
        if (message.userIsModerator !== undefined) {
            BoolValue.encode({ value: message.userIsModerator }, writer.uint32(714).fork()).ldelim();
        }
        if (message.over18 !== undefined) {
            BoolValue.encode({ value: message.over18 }, writer.uint32(722).fork()).ldelim();
        }
        if (message.headerTitle !== undefined) {
            StringValue.encode({ value: message.headerTitle }, writer.uint32(730).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(738).fork()).ldelim();
        }
        if (message.isChatPostFeatureEnabled !== undefined) {
            BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(746).fork()).ldelim();
        }
        if (message.submitLinkLabel !== undefined) {
            StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(754).fork()).ldelim();
        }
        if (message.userFlairTextColor !== undefined) {
            StringValue.encode({ value: message.userFlairTextColor }, writer.uint32(762).fork()).ldelim();
        }
        if (message.restrictCommenting !== undefined) {
            BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(770).fork()).ldelim();
        }
        if (message.userFlairCssClass !== undefined) {
            StringValue.encode({ value: message.userFlairCssClass }, writer.uint32(778).fork()).ldelim();
        }
        if (message.allowImages !== undefined) {
            BoolValue.encode({ value: message.allowImages }, writer.uint32(786).fork()).ldelim();
        }
        if (message.lang !== undefined) {
            StringValue.encode({ value: message.lang }, writer.uint32(794).fork()).ldelim();
        }
        if (message.whitelistStatus !== undefined) {
            StringValue.encode({ value: message.whitelistStatus }, writer.uint32(802).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(810).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(818).fork()).ldelim();
        }
        for (const v of message.bannerSize) {
            Int32Value.encode({ value: v }, writer.uint32(826).fork()).ldelim();
        }
        if (message.mobileBannerImage !== undefined) {
            StringValue.encode({ value: message.mobileBannerImage }, writer.uint32(834).fork()).ldelim();
        }
        if (message.userIsContributor !== undefined) {
            BoolValue.encode({ value: message.userIsContributor }, writer.uint32(842).fork()).ldelim();
        }
        if (message.allowPredictionsTournament !== undefined) {
            BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(850).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullSubredditObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.wikiEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.userCanFlairInSr = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.headerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.iconSize.push(Int64Value.decode(reader, reader.uint32()).value);
                    break;
                case 14:
                    message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.activeUserCount = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.iconImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.accountsActive = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.userFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 22:
                    message.videostreamLinksCount = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 26:
                    message.predictionLeaderboardEntryType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 27:
                    message.emojisEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 28:
                    message.advertiserCategory = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 29:
                    message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 30:
                    message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 31:
                    message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 32:
                    message.userHasFavorited = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 33:
                    message.userFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 34:
                    message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 35:
                    message.bannerBackgroundImage = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 36:
                    message.originalContentTagEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 37:
                    message.communityReviewed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 39:
                    message.submitText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 40:
                    message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 41:
                    message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 42:
                    message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
                    break;
                case 43:
                    message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 44:
                    message.headerSize.push(Int64Value.decode(reader, reader.uint32()).value);
                    break;
                case 45:
                    message.userFlairPosition = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 46:
                    message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 47:
                    message.hasMenuWidget = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 48:
                    message.isEnrolledInNewModmail = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 49:
                    message.keyColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 50:
                    message.canAssignUserFlair = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 51:
                    message.created = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 52:
                    message.wls = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 53:
                    message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 54:
                    message.submissionType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 55:
                    message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 56:
                    message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 57:
                    message.allowVideogifs = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 58:
                    message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 59:
                    message.userFlairType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 60:
                    message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 61:
                    message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 62:
                    message.emojisCustomSize.push(Int64Value.decode(reader, reader.uint32()).value);
                    break;
                case 63:
                    message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 64:
                    message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 65:
                    message.isCrosspostableSubreddit = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 66:
                    message.notificationLevel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 67:
                    message.shouldShowMediaInCommentsSetting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 68:
                    message.canAssignLinkFlair = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 69:
                    message.accountsActiveIsFuzzed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 70:
                    message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 71:
                    message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 72:
                    message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 73:
                    message.userSrFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 74:
                    message.userFlairEnabledInSr = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 75:
                    message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 76:
                    message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 77:
                    message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 78:
                    message.userSrThemeEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 79:
                    message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 80:
                    message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 81:
                    message.subredditType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 82:
                    message.suggestedCommentSort = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 83:
                    message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 84:
                    message.userFlairText = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 85:
                    message.contentCategory = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 86:
                    message.bannerBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 87:
                    message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 88:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 89:
                    message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 90:
                    message.over18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 91:
                    message.headerTitle = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 92:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 93:
                    message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 94:
                    message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 95:
                    message.userFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 96:
                    message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 97:
                    message.userFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 98:
                    message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 99:
                    message.lang = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 100:
                    message.whitelistStatus = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 101:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 102:
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 103:
                    message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
                    break;
                case 104:
                    message.mobileBannerImage = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 105:
                    message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 106:
                    message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            userFlairBackgroundColor: isSet(object.userFlairBackgroundColor)
                ? String(object.userFlairBackgroundColor)
                : undefined,
            submitTextHtml: isSet(object.submitTextHtml) ? String(object.submitTextHtml) : undefined,
            restrictPosting: isSet(object.restrictPosting) ? Boolean(object.restrictPosting) : undefined,
            userIsBanned: isSet(object.userIsBanned) ? Boolean(object.userIsBanned) : undefined,
            freeFormReports: isSet(object.freeFormReports) ? Boolean(object.freeFormReports) : undefined,
            wikiEnabled: isSet(object.wikiEnabled) ? Boolean(object.wikiEnabled) : undefined,
            userIsMuted: isSet(object.userIsMuted) ? Boolean(object.userIsMuted) : undefined,
            userCanFlairInSr: isSet(object.userCanFlairInSr) ? Boolean(object.userCanFlairInSr) : undefined,
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            headerImg: isSet(object.headerImg) ? String(object.headerImg) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            allowGalleries: isSet(object.allowGalleries) ? Boolean(object.allowGalleries) : undefined,
            iconSize: Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
            primaryColor: isSet(object.primaryColor) ? String(object.primaryColor) : undefined,
            activeUserCount: isSet(object.activeUserCount) ? Number(object.activeUserCount) : undefined,
            iconImg: isSet(object.iconImg) ? String(object.iconImg) : undefined,
            displayNamePrefixed: isSet(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : undefined,
            accountsActive: isSet(object.accountsActive) ? Number(object.accountsActive) : undefined,
            publicTraffic: isSet(object.publicTraffic) ? Boolean(object.publicTraffic) : undefined,
            subscribers: isSet(object.subscribers) ? Number(object.subscribers) : undefined,
            userFlairRichtext: Array.isArray(object?.userFlairRichtext)
                ? object.userFlairRichtext.map((e) => String(e))
                : [],
            videostreamLinksCount: isSet(object.videostreamLinksCount) ? Number(object.videostreamLinksCount) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            quarantine: isSet(object.quarantine) ? Boolean(object.quarantine) : undefined,
            hideAds: isSet(object.hideAds) ? Boolean(object.hideAds) : undefined,
            predictionLeaderboardEntryType: isSet(object.predictionLeaderboardEntryType)
                ? String(object.predictionLeaderboardEntryType)
                : undefined,
            emojisEnabled: isSet(object.emojisEnabled) ? Boolean(object.emojisEnabled) : undefined,
            advertiserCategory: isSet(object.advertiserCategory) ? String(object.advertiserCategory) : undefined,
            publicDescription: isSet(object.publicDescription) ? String(object.publicDescription) : undefined,
            commentScoreHideMins: isSet(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : undefined,
            allowPredictions: isSet(object.allowPredictions) ? Boolean(object.allowPredictions) : undefined,
            userHasFavorited: isSet(object.userHasFavorited) ? Boolean(object.userHasFavorited) : undefined,
            userFlairTemplateId: isSet(object.userFlairTemplateId) ? String(object.userFlairTemplateId) : undefined,
            communityIcon: isSet(object.communityIcon) ? String(object.communityIcon) : undefined,
            bannerBackgroundImage: isSet(object.bannerBackgroundImage) ? String(object.bannerBackgroundImage) : undefined,
            originalContentTagEnabled: isSet(object.originalContentTagEnabled)
                ? Boolean(object.originalContentTagEnabled)
                : undefined,
            communityReviewed: isSet(object.communityReviewed) ? Boolean(object.communityReviewed) : undefined,
            submitText: isSet(object.submitText) ? String(object.submitText) : undefined,
            descriptionHtml: isSet(object.descriptionHtml) ? String(object.descriptionHtml) : undefined,
            spoilersEnabled: isSet(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : undefined,
            commentContributionSettings: isSet(object.commentContributionSettings)
                ? CommentContributionSettings.fromJSON(object.commentContributionSettings)
                : undefined,
            allowTalks: isSet(object.allowTalks) ? Boolean(object.allowTalks) : undefined,
            headerSize: Array.isArray(object?.headerSize) ? object.headerSize.map((e) => Number(e)) : [],
            userFlairPosition: isSet(object.userFlairPosition) ? String(object.userFlairPosition) : undefined,
            allOriginalContent: isSet(object.allOriginalContent) ? Boolean(object.allOriginalContent) : undefined,
            hasMenuWidget: isSet(object.hasMenuWidget) ? Boolean(object.hasMenuWidget) : undefined,
            isEnrolledInNewModmail: isSet(object.isEnrolledInNewModmail) ? Boolean(object.isEnrolledInNewModmail) : undefined,
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : undefined,
            canAssignUserFlair: isSet(object.canAssignUserFlair) ? Boolean(object.canAssignUserFlair) : undefined,
            created: isSet(object.created) ? Number(object.created) : undefined,
            wls: isSet(object.wls) ? Number(object.wls) : undefined,
            showMediaPreview: isSet(object.showMediaPreview) ? Boolean(object.showMediaPreview) : undefined,
            submissionType: isSet(object.submissionType) ? String(object.submissionType) : undefined,
            userIsSubscriber: isSet(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : undefined,
            allowedMediaInComments: Array.isArray(object?.allowedMediaInComments)
                ? object.allowedMediaInComments.map((e) => String(e))
                : [],
            allowVideogifs: isSet(object.allowVideogifs) ? Boolean(object.allowVideogifs) : undefined,
            shouldArchivePosts: isSet(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : undefined,
            userFlairType: isSet(object.userFlairType) ? String(object.userFlairType) : undefined,
            allowPolls: isSet(object.allowPolls) ? Boolean(object.allowPolls) : undefined,
            collapseDeletedComments: isSet(object.collapseDeletedComments)
                ? Boolean(object.collapseDeletedComments)
                : undefined,
            emojisCustomSize: Array.isArray(object?.emojisCustomSize)
                ? object.emojisCustomSize.map((e) => Number(e))
                : [],
            publicDescriptionHtml: isSet(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : undefined,
            allowVideos: isSet(object.allowVideos) ? Boolean(object.allowVideos) : undefined,
            isCrosspostableSubreddit: isSet(object.isCrosspostableSubreddit)
                ? Boolean(object.isCrosspostableSubreddit)
                : undefined,
            notificationLevel: isSet(object.notificationLevel) ? String(object.notificationLevel) : undefined,
            shouldShowMediaInCommentsSetting: isSet(object.shouldShowMediaInCommentsSetting)
                ? Boolean(object.shouldShowMediaInCommentsSetting)
                : undefined,
            canAssignLinkFlair: isSet(object.canAssignLinkFlair) ? Boolean(object.canAssignLinkFlair) : undefined,
            accountsActiveIsFuzzed: isSet(object.accountsActiveIsFuzzed) ? Boolean(object.accountsActiveIsFuzzed) : undefined,
            allowPredictionContributors: isSet(object.allowPredictionContributors)
                ? Boolean(object.allowPredictionContributors)
                : undefined,
            submitTextLabel: isSet(object.submitTextLabel) ? String(object.submitTextLabel) : undefined,
            linkFlairPosition: isSet(object.linkFlairPosition) ? String(object.linkFlairPosition) : undefined,
            userSrFlairEnabled: isSet(object.userSrFlairEnabled) ? Boolean(object.userSrFlairEnabled) : undefined,
            userFlairEnabledInSr: isSet(object.userFlairEnabledInSr) ? Boolean(object.userFlairEnabledInSr) : undefined,
            allowChatPostCreation: isSet(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : undefined,
            allowDiscovery: isSet(object.allowDiscovery) ? Boolean(object.allowDiscovery) : undefined,
            acceptFollowers: isSet(object.acceptFollowers) ? Boolean(object.acceptFollowers) : undefined,
            userSrThemeEnabled: isSet(object.userSrThemeEnabled) ? Boolean(object.userSrThemeEnabled) : undefined,
            linkFlairEnabled: isSet(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : undefined,
            disableContributorRequests: isSet(object.disableContributorRequests)
                ? Boolean(object.disableContributorRequests)
                : undefined,
            subredditType: isSet(object.subredditType) ? String(object.subredditType) : undefined,
            suggestedCommentSort: isSet(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : undefined,
            bannerImg: isSet(object.bannerImg) ? String(object.bannerImg) : undefined,
            userFlairText: isSet(object.userFlairText) ? String(object.userFlairText) : undefined,
            contentCategory: isSet(object.contentCategory) ? String(object.contentCategory) : undefined,
            bannerBackgroundColor: isSet(object.bannerBackgroundColor) ? String(object.bannerBackgroundColor) : undefined,
            showMedia: isSet(object.showMedia) ? Boolean(object.showMedia) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            userIsModerator: isSet(object.userIsModerator) ? Boolean(object.userIsModerator) : undefined,
            over18: isSet(object.over18) ? Boolean(object.over18) : undefined,
            headerTitle: isSet(object.headerTitle) ? String(object.headerTitle) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            isChatPostFeatureEnabled: isSet(object.isChatPostFeatureEnabled)
                ? Boolean(object.isChatPostFeatureEnabled)
                : undefined,
            submitLinkLabel: isSet(object.submitLinkLabel) ? String(object.submitLinkLabel) : undefined,
            userFlairTextColor: isSet(object.userFlairTextColor) ? String(object.userFlairTextColor) : undefined,
            restrictCommenting: isSet(object.restrictCommenting) ? Boolean(object.restrictCommenting) : undefined,
            userFlairCssClass: isSet(object.userFlairCssClass) ? String(object.userFlairCssClass) : undefined,
            allowImages: isSet(object.allowImages) ? Boolean(object.allowImages) : undefined,
            lang: isSet(object.lang) ? String(object.lang) : undefined,
            whitelistStatus: isSet(object.whitelistStatus) ? String(object.whitelistStatus) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            bannerSize: Array.isArray(object?.bannerSize)
                ? object.bannerSize.map((e) => Number(e))
                : [],
            mobileBannerImage: isSet(object.mobileBannerImage) ? String(object.mobileBannerImage) : undefined,
            userIsContributor: isSet(object.userIsContributor) ? Boolean(object.userIsContributor) : undefined,
            allowPredictionsTournament: isSet(object.allowPredictionsTournament)
                ? Boolean(object.allowPredictionsTournament)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.userFlairBackgroundColor !== undefined && (obj.userFlairBackgroundColor = message.userFlairBackgroundColor);
        message.submitTextHtml !== undefined && (obj.submitTextHtml = message.submitTextHtml);
        message.restrictPosting !== undefined && (obj.restrictPosting = message.restrictPosting);
        message.userIsBanned !== undefined && (obj.userIsBanned = message.userIsBanned);
        message.freeFormReports !== undefined && (obj.freeFormReports = message.freeFormReports);
        message.wikiEnabled !== undefined && (obj.wikiEnabled = message.wikiEnabled);
        message.userIsMuted !== undefined && (obj.userIsMuted = message.userIsMuted);
        message.userCanFlairInSr !== undefined && (obj.userCanFlairInSr = message.userCanFlairInSr);
        message.displayName !== undefined && (obj.displayName = message.displayName);
        message.headerImg !== undefined && (obj.headerImg = message.headerImg);
        message.title !== undefined && (obj.title = message.title);
        message.allowGalleries !== undefined && (obj.allowGalleries = message.allowGalleries);
        if (message.iconSize) {
            obj.iconSize = message.iconSize.map((e) => e);
        }
        else {
            obj.iconSize = [];
        }
        message.primaryColor !== undefined && (obj.primaryColor = message.primaryColor);
        message.activeUserCount !== undefined && (obj.activeUserCount = message.activeUserCount);
        message.iconImg !== undefined && (obj.iconImg = message.iconImg);
        message.displayNamePrefixed !== undefined && (obj.displayNamePrefixed = message.displayNamePrefixed);
        message.accountsActive !== undefined && (obj.accountsActive = message.accountsActive);
        message.publicTraffic !== undefined && (obj.publicTraffic = message.publicTraffic);
        message.subscribers !== undefined && (obj.subscribers = message.subscribers);
        if (message.userFlairRichtext) {
            obj.userFlairRichtext = message.userFlairRichtext.map((e) => e);
        }
        else {
            obj.userFlairRichtext = [];
        }
        message.videostreamLinksCount !== undefined && (obj.videostreamLinksCount = message.videostreamLinksCount);
        message.name !== undefined && (obj.name = message.name);
        message.quarantine !== undefined && (obj.quarantine = message.quarantine);
        message.hideAds !== undefined && (obj.hideAds = message.hideAds);
        message.predictionLeaderboardEntryType !== undefined &&
            (obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType);
        message.emojisEnabled !== undefined && (obj.emojisEnabled = message.emojisEnabled);
        message.advertiserCategory !== undefined && (obj.advertiserCategory = message.advertiserCategory);
        message.publicDescription !== undefined && (obj.publicDescription = message.publicDescription);
        message.commentScoreHideMins !== undefined && (obj.commentScoreHideMins = message.commentScoreHideMins);
        message.allowPredictions !== undefined && (obj.allowPredictions = message.allowPredictions);
        message.userHasFavorited !== undefined && (obj.userHasFavorited = message.userHasFavorited);
        message.userFlairTemplateId !== undefined && (obj.userFlairTemplateId = message.userFlairTemplateId);
        message.communityIcon !== undefined && (obj.communityIcon = message.communityIcon);
        message.bannerBackgroundImage !== undefined && (obj.bannerBackgroundImage = message.bannerBackgroundImage);
        message.originalContentTagEnabled !== undefined &&
            (obj.originalContentTagEnabled = message.originalContentTagEnabled);
        message.communityReviewed !== undefined && (obj.communityReviewed = message.communityReviewed);
        message.submitText !== undefined && (obj.submitText = message.submitText);
        message.descriptionHtml !== undefined && (obj.descriptionHtml = message.descriptionHtml);
        message.spoilersEnabled !== undefined && (obj.spoilersEnabled = message.spoilersEnabled);
        message.commentContributionSettings !== undefined &&
            (obj.commentContributionSettings = message.commentContributionSettings
                ? CommentContributionSettings.toJSON(message.commentContributionSettings)
                : undefined);
        message.allowTalks !== undefined && (obj.allowTalks = message.allowTalks);
        if (message.headerSize) {
            obj.headerSize = message.headerSize.map((e) => e);
        }
        else {
            obj.headerSize = [];
        }
        message.userFlairPosition !== undefined && (obj.userFlairPosition = message.userFlairPosition);
        message.allOriginalContent !== undefined && (obj.allOriginalContent = message.allOriginalContent);
        message.hasMenuWidget !== undefined && (obj.hasMenuWidget = message.hasMenuWidget);
        message.isEnrolledInNewModmail !== undefined && (obj.isEnrolledInNewModmail = message.isEnrolledInNewModmail);
        message.keyColor !== undefined && (obj.keyColor = message.keyColor);
        message.canAssignUserFlair !== undefined && (obj.canAssignUserFlair = message.canAssignUserFlair);
        message.created !== undefined && (obj.created = message.created);
        message.wls !== undefined && (obj.wls = message.wls);
        message.showMediaPreview !== undefined && (obj.showMediaPreview = message.showMediaPreview);
        message.submissionType !== undefined && (obj.submissionType = message.submissionType);
        message.userIsSubscriber !== undefined && (obj.userIsSubscriber = message.userIsSubscriber);
        if (message.allowedMediaInComments) {
            obj.allowedMediaInComments = message.allowedMediaInComments.map((e) => e);
        }
        else {
            obj.allowedMediaInComments = [];
        }
        message.allowVideogifs !== undefined && (obj.allowVideogifs = message.allowVideogifs);
        message.shouldArchivePosts !== undefined && (obj.shouldArchivePosts = message.shouldArchivePosts);
        message.userFlairType !== undefined && (obj.userFlairType = message.userFlairType);
        message.allowPolls !== undefined && (obj.allowPolls = message.allowPolls);
        message.collapseDeletedComments !== undefined && (obj.collapseDeletedComments = message.collapseDeletedComments);
        if (message.emojisCustomSize) {
            obj.emojisCustomSize = message.emojisCustomSize.map((e) => e);
        }
        else {
            obj.emojisCustomSize = [];
        }
        message.publicDescriptionHtml !== undefined && (obj.publicDescriptionHtml = message.publicDescriptionHtml);
        message.allowVideos !== undefined && (obj.allowVideos = message.allowVideos);
        message.isCrosspostableSubreddit !== undefined && (obj.isCrosspostableSubreddit = message.isCrosspostableSubreddit);
        message.notificationLevel !== undefined && (obj.notificationLevel = message.notificationLevel);
        message.shouldShowMediaInCommentsSetting !== undefined &&
            (obj.shouldShowMediaInCommentsSetting = message.shouldShowMediaInCommentsSetting);
        message.canAssignLinkFlair !== undefined && (obj.canAssignLinkFlair = message.canAssignLinkFlair);
        message.accountsActiveIsFuzzed !== undefined && (obj.accountsActiveIsFuzzed = message.accountsActiveIsFuzzed);
        message.allowPredictionContributors !== undefined &&
            (obj.allowPredictionContributors = message.allowPredictionContributors);
        message.submitTextLabel !== undefined && (obj.submitTextLabel = message.submitTextLabel);
        message.linkFlairPosition !== undefined && (obj.linkFlairPosition = message.linkFlairPosition);
        message.userSrFlairEnabled !== undefined && (obj.userSrFlairEnabled = message.userSrFlairEnabled);
        message.userFlairEnabledInSr !== undefined && (obj.userFlairEnabledInSr = message.userFlairEnabledInSr);
        message.allowChatPostCreation !== undefined && (obj.allowChatPostCreation = message.allowChatPostCreation);
        message.allowDiscovery !== undefined && (obj.allowDiscovery = message.allowDiscovery);
        message.acceptFollowers !== undefined && (obj.acceptFollowers = message.acceptFollowers);
        message.userSrThemeEnabled !== undefined && (obj.userSrThemeEnabled = message.userSrThemeEnabled);
        message.linkFlairEnabled !== undefined && (obj.linkFlairEnabled = message.linkFlairEnabled);
        message.disableContributorRequests !== undefined &&
            (obj.disableContributorRequests = message.disableContributorRequests);
        message.subredditType !== undefined && (obj.subredditType = message.subredditType);
        message.suggestedCommentSort !== undefined && (obj.suggestedCommentSort = message.suggestedCommentSort);
        message.bannerImg !== undefined && (obj.bannerImg = message.bannerImg);
        message.userFlairText !== undefined && (obj.userFlairText = message.userFlairText);
        message.contentCategory !== undefined && (obj.contentCategory = message.contentCategory);
        message.bannerBackgroundColor !== undefined && (obj.bannerBackgroundColor = message.bannerBackgroundColor);
        message.showMedia !== undefined && (obj.showMedia = message.showMedia);
        message.id !== undefined && (obj.id = message.id);
        message.userIsModerator !== undefined && (obj.userIsModerator = message.userIsModerator);
        message.over18 !== undefined && (obj.over18 = message.over18);
        message.headerTitle !== undefined && (obj.headerTitle = message.headerTitle);
        message.description !== undefined && (obj.description = message.description);
        message.isChatPostFeatureEnabled !== undefined && (obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled);
        message.submitLinkLabel !== undefined && (obj.submitLinkLabel = message.submitLinkLabel);
        message.userFlairTextColor !== undefined && (obj.userFlairTextColor = message.userFlairTextColor);
        message.restrictCommenting !== undefined && (obj.restrictCommenting = message.restrictCommenting);
        message.userFlairCssClass !== undefined && (obj.userFlairCssClass = message.userFlairCssClass);
        message.allowImages !== undefined && (obj.allowImages = message.allowImages);
        message.lang !== undefined && (obj.lang = message.lang);
        message.whitelistStatus !== undefined && (obj.whitelistStatus = message.whitelistStatus);
        message.url !== undefined && (obj.url = message.url);
        message.createdUtc !== undefined && (obj.createdUtc = message.createdUtc);
        if (message.bannerSize) {
            obj.bannerSize = message.bannerSize.map((e) => e);
        }
        else {
            obj.bannerSize = [];
        }
        message.mobileBannerImage !== undefined && (obj.mobileBannerImage = message.mobileBannerImage);
        message.userIsContributor !== undefined && (obj.userIsContributor = message.userIsContributor);
        message.allowPredictionsTournament !== undefined &&
            (obj.allowPredictionsTournament = message.allowPredictionsTournament);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFullSubredditObject();
        message.userFlairBackgroundColor = object.userFlairBackgroundColor ?? undefined;
        message.submitTextHtml = object.submitTextHtml ?? undefined;
        message.restrictPosting = object.restrictPosting ?? undefined;
        message.userIsBanned = object.userIsBanned ?? undefined;
        message.freeFormReports = object.freeFormReports ?? undefined;
        message.wikiEnabled = object.wikiEnabled ?? undefined;
        message.userIsMuted = object.userIsMuted ?? undefined;
        message.userCanFlairInSr = object.userCanFlairInSr ?? undefined;
        message.displayName = object.displayName ?? undefined;
        message.headerImg = object.headerImg ?? undefined;
        message.title = object.title ?? undefined;
        message.allowGalleries = object.allowGalleries ?? undefined;
        message.iconSize = object.iconSize?.map((e) => e) || [];
        message.primaryColor = object.primaryColor ?? undefined;
        message.activeUserCount = object.activeUserCount ?? undefined;
        message.iconImg = object.iconImg ?? undefined;
        message.displayNamePrefixed = object.displayNamePrefixed ?? undefined;
        message.accountsActive = object.accountsActive ?? undefined;
        message.publicTraffic = object.publicTraffic ?? undefined;
        message.subscribers = object.subscribers ?? undefined;
        message.userFlairRichtext = object.userFlairRichtext?.map((e) => e) || [];
        message.videostreamLinksCount = object.videostreamLinksCount ?? undefined;
        message.name = object.name ?? undefined;
        message.quarantine = object.quarantine ?? undefined;
        message.hideAds = object.hideAds ?? undefined;
        message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? undefined;
        message.emojisEnabled = object.emojisEnabled ?? undefined;
        message.advertiserCategory = object.advertiserCategory ?? undefined;
        message.publicDescription = object.publicDescription ?? undefined;
        message.commentScoreHideMins = object.commentScoreHideMins ?? undefined;
        message.allowPredictions = object.allowPredictions ?? undefined;
        message.userHasFavorited = object.userHasFavorited ?? undefined;
        message.userFlairTemplateId = object.userFlairTemplateId ?? undefined;
        message.communityIcon = object.communityIcon ?? undefined;
        message.bannerBackgroundImage = object.bannerBackgroundImage ?? undefined;
        message.originalContentTagEnabled = object.originalContentTagEnabled ?? undefined;
        message.communityReviewed = object.communityReviewed ?? undefined;
        message.submitText = object.submitText ?? undefined;
        message.descriptionHtml = object.descriptionHtml ?? undefined;
        message.spoilersEnabled = object.spoilersEnabled ?? undefined;
        message.commentContributionSettings =
            (object.commentContributionSettings !== undefined && object.commentContributionSettings !== null)
                ? CommentContributionSettings.fromPartial(object.commentContributionSettings)
                : undefined;
        message.allowTalks = object.allowTalks ?? undefined;
        message.headerSize = object.headerSize?.map((e) => e) || [];
        message.userFlairPosition = object.userFlairPosition ?? undefined;
        message.allOriginalContent = object.allOriginalContent ?? undefined;
        message.hasMenuWidget = object.hasMenuWidget ?? undefined;
        message.isEnrolledInNewModmail = object.isEnrolledInNewModmail ?? undefined;
        message.keyColor = object.keyColor ?? undefined;
        message.canAssignUserFlair = object.canAssignUserFlair ?? undefined;
        message.created = object.created ?? undefined;
        message.wls = object.wls ?? undefined;
        message.showMediaPreview = object.showMediaPreview ?? undefined;
        message.submissionType = object.submissionType ?? undefined;
        message.userIsSubscriber = object.userIsSubscriber ?? undefined;
        message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
        message.allowVideogifs = object.allowVideogifs ?? undefined;
        message.shouldArchivePosts = object.shouldArchivePosts ?? undefined;
        message.userFlairType = object.userFlairType ?? undefined;
        message.allowPolls = object.allowPolls ?? undefined;
        message.collapseDeletedComments = object.collapseDeletedComments ?? undefined;
        message.emojisCustomSize = object.emojisCustomSize?.map((e) => e) || [];
        message.publicDescriptionHtml = object.publicDescriptionHtml ?? undefined;
        message.allowVideos = object.allowVideos ?? undefined;
        message.isCrosspostableSubreddit = object.isCrosspostableSubreddit ?? undefined;
        message.notificationLevel = object.notificationLevel ?? undefined;
        message.shouldShowMediaInCommentsSetting = object.shouldShowMediaInCommentsSetting ?? undefined;
        message.canAssignLinkFlair = object.canAssignLinkFlair ?? undefined;
        message.accountsActiveIsFuzzed = object.accountsActiveIsFuzzed ?? undefined;
        message.allowPredictionContributors = object.allowPredictionContributors ?? undefined;
        message.submitTextLabel = object.submitTextLabel ?? undefined;
        message.linkFlairPosition = object.linkFlairPosition ?? undefined;
        message.userSrFlairEnabled = object.userSrFlairEnabled ?? undefined;
        message.userFlairEnabledInSr = object.userFlairEnabledInSr ?? undefined;
        message.allowChatPostCreation = object.allowChatPostCreation ?? undefined;
        message.allowDiscovery = object.allowDiscovery ?? undefined;
        message.acceptFollowers = object.acceptFollowers ?? undefined;
        message.userSrThemeEnabled = object.userSrThemeEnabled ?? undefined;
        message.linkFlairEnabled = object.linkFlairEnabled ?? undefined;
        message.disableContributorRequests = object.disableContributorRequests ?? undefined;
        message.subredditType = object.subredditType ?? undefined;
        message.suggestedCommentSort = object.suggestedCommentSort ?? undefined;
        message.bannerImg = object.bannerImg ?? undefined;
        message.userFlairText = object.userFlairText ?? undefined;
        message.contentCategory = object.contentCategory ?? undefined;
        message.bannerBackgroundColor = object.bannerBackgroundColor ?? undefined;
        message.showMedia = object.showMedia ?? undefined;
        message.id = object.id ?? undefined;
        message.userIsModerator = object.userIsModerator ?? undefined;
        message.over18 = object.over18 ?? undefined;
        message.headerTitle = object.headerTitle ?? undefined;
        message.description = object.description ?? undefined;
        message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? undefined;
        message.submitLinkLabel = object.submitLinkLabel ?? undefined;
        message.userFlairTextColor = object.userFlairTextColor ?? undefined;
        message.restrictCommenting = object.restrictCommenting ?? undefined;
        message.userFlairCssClass = object.userFlairCssClass ?? undefined;
        message.allowImages = object.allowImages ?? undefined;
        message.lang = object.lang ?? undefined;
        message.whitelistStatus = object.whitelistStatus ?? undefined;
        message.url = object.url ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.bannerSize = object.bannerSize?.map((e) => e) || [];
        message.mobileBannerImage = object.mobileBannerImage ?? undefined;
        message.userIsContributor = object.userIsContributor ?? undefined;
        message.allowPredictionsTournament = object.allowPredictionsTournament ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.FullSubredditObject", FullSubredditObject);
function createBaseSubredditsSearchResponse() {
    return { kind: undefined, data: undefined };
}
export const SubredditsSearchResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            SubredditsSearchResponse_WrappedSubredditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsSearchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = SubredditsSearchResponse_WrappedSubredditObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? SubredditsSearchResponse_WrappedSubredditObject.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? SubredditsSearchResponse_WrappedSubredditObject.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditsSearchResponse();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? SubredditsSearchResponse_WrappedSubredditObject.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditsSearchResponse", SubredditsSearchResponse);
function createBaseSubredditsSearchResponse_WrappedSubredditObject() {
    return { after: undefined, before: undefined, dist: undefined, geoFilter: undefined, children: [] };
}
export const SubredditsSearchResponse_WrappedSubredditObject = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.dist !== undefined) {
            Int32Value.encode({ value: message.dist }, writer.uint32(26).fork()).ldelim();
        }
        if (message.geoFilter !== undefined) {
            StringValue.encode({ value: message.geoFilter }, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.children) {
            SubredditsSearchResponse_WrappedSubredditObject_SubredditData.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsSearchResponse_WrappedSubredditObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.dist = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.geoFilter = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.children.push(SubredditsSearchResponse_WrappedSubredditObject_SubredditData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            dist: isSet(object.dist) ? Number(object.dist) : undefined,
            geoFilter: isSet(object.geoFilter) ? String(object.geoFilter) : undefined,
            children: Array.isArray(object?.children)
                ? object.children.map((e) => SubredditsSearchResponse_WrappedSubredditObject_SubredditData.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.before !== undefined && (obj.before = message.before);
        message.dist !== undefined && (obj.dist = message.dist);
        message.geoFilter !== undefined && (obj.geoFilter = message.geoFilter);
        if (message.children) {
            obj.children = message.children.map((e) => e ? SubredditsSearchResponse_WrappedSubredditObject_SubredditData.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditsSearchResponse_WrappedSubredditObject();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.dist = object.dist ?? undefined;
        message.geoFilter = object.geoFilter ?? undefined;
        message.children =
            object.children?.map((e) => SubredditsSearchResponse_WrappedSubredditObject_SubredditData.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject", SubredditsSearchResponse_WrappedSubredditObject);
function createBaseSubredditsSearchResponse_WrappedSubredditObject_SubredditData() {
    return { kind: undefined, data: undefined };
}
export const SubredditsSearchResponse_WrappedSubredditObject_SubredditData = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject.SubredditData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            FullSubredditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsSearchResponse_WrappedSubredditObject_SubredditData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = FullSubredditObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? FullSubredditObject.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined && (obj.data = message.data ? FullSubredditObject.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditsSearchResponse_WrappedSubredditObject_SubredditData();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? FullSubredditObject.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject.SubredditData", SubredditsSearchResponse_WrappedSubredditObject_SubredditData);
function createBaseUserSearchResponse() {
    return { kind: undefined, data: undefined };
}
export const UserSearchResponse = {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            UserSearchResponse_AccData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserSearchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = UserSearchResponse_AccData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? UserSearchResponse_AccData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? UserSearchResponse_AccData.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUserSearchResponse();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? UserSearchResponse_AccData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse", UserSearchResponse);
function createBaseUserSearchResponse_AccData() {
    return {
        after: undefined,
        dist: undefined,
        modhash: undefined,
        geoFilter: undefined,
        children: [],
        before: undefined,
    };
}
export const UserSearchResponse_AccData = {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.dist !== undefined) {
            Int64Value.encode({ value: message.dist }, writer.uint32(18).fork()).ldelim();
        }
        if (message.modhash !== undefined) {
            StringValue.encode({ value: message.modhash }, writer.uint32(26).fork()).ldelim();
        }
        if (message.geoFilter !== undefined) {
            StringValue.encode({ value: message.geoFilter }, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.children) {
            UserSearchResponse_Account.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserSearchResponse_AccData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.dist = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.modhash = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.geoFilter = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.children.push(UserSearchResponse_Account.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            dist: isSet(object.dist) ? Number(object.dist) : undefined,
            modhash: isSet(object.modhash) ? String(object.modhash) : undefined,
            geoFilter: isSet(object.geoFilter) ? String(object.geoFilter) : undefined,
            children: Array.isArray(object?.children)
                ? object.children.map((e) => UserSearchResponse_Account.fromJSON(e))
                : [],
            before: isSet(object.before) ? String(object.before) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.after !== undefined && (obj.after = message.after);
        message.dist !== undefined && (obj.dist = message.dist);
        message.modhash !== undefined && (obj.modhash = message.modhash);
        message.geoFilter !== undefined && (obj.geoFilter = message.geoFilter);
        if (message.children) {
            obj.children = message.children.map((e) => e ? UserSearchResponse_Account.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        message.before !== undefined && (obj.before = message.before);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUserSearchResponse_AccData();
        message.after = object.after ?? undefined;
        message.dist = object.dist ?? undefined;
        message.modhash = object.modhash ?? undefined;
        message.geoFilter = object.geoFilter ?? undefined;
        message.children = object.children?.map((e) => UserSearchResponse_Account.fromPartial(e)) || [];
        message.before = object.before ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse.AccData", UserSearchResponse_AccData);
function createBaseUserSearchResponse_Account() {
    return { kind: undefined, data: undefined };
}
export const UserSearchResponse_Account = {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.Account",
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== undefined) {
            StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            UserSearchResponse_AccountData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserSearchResponse_Account();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.data = UserSearchResponse_AccountData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kind: isSet(object.kind) ? String(object.kind) : undefined,
            data: isSet(object.data) ? UserSearchResponse_AccountData.fromJSON(object.data) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = message.kind);
        message.data !== undefined &&
            (obj.data = message.data ? UserSearchResponse_AccountData.toJSON(message.data) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUserSearchResponse_Account();
        message.kind = object.kind ?? undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? UserSearchResponse_AccountData.fromPartial(object.data)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse.Account", UserSearchResponse_Account);
function createBaseUserSearchResponse_AccountData() {
    return {
        isEmployee: undefined,
        isFriend: undefined,
        snoovatarSize: [],
        id: undefined,
        verified: undefined,
        isGold: undefined,
        isMod: undefined,
        hasVerifiedEmail: undefined,
        iconImg: undefined,
        hideFromRobots: undefined,
        linkKarma: undefined,
        acceptChats: undefined,
        isBlocked: undefined,
        prefShowSnoovatar: undefined,
        name: undefined,
        created: undefined,
        createdUtc: undefined,
        snoovatarImg: undefined,
        commentKarma: undefined,
        acceptFollowers: undefined,
        hasSubscribed: undefined,
        acceptPms: undefined,
        isSuspended: undefined,
        subreddit: undefined,
    };
}
export const UserSearchResponse_AccountData = {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isEmployee !== undefined) {
            BoolValue.encode({ value: message.isEmployee }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isFriend !== undefined) {
            BoolValue.encode({ value: message.isFriend }, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.snoovatarSize) {
            Int32Value.encode({ value: v }, writer.uint32(26).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(34).fork()).ldelim();
        }
        if (message.verified !== undefined) {
            BoolValue.encode({ value: message.verified }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isGold !== undefined) {
            BoolValue.encode({ value: message.isGold }, writer.uint32(50).fork()).ldelim();
        }
        if (message.isMod !== undefined) {
            BoolValue.encode({ value: message.isMod }, writer.uint32(58).fork()).ldelim();
        }
        if (message.hasVerifiedEmail !== undefined) {
            BoolValue.encode({ value: message.hasVerifiedEmail }, writer.uint32(66).fork()).ldelim();
        }
        if (message.iconImg !== undefined) {
            StringValue.encode({ value: message.iconImg }, writer.uint32(74).fork()).ldelim();
        }
        if (message.hideFromRobots !== undefined) {
            BoolValue.encode({ value: message.hideFromRobots }, writer.uint32(82).fork()).ldelim();
        }
        if (message.linkKarma !== undefined) {
            Int32Value.encode({ value: message.linkKarma }, writer.uint32(90).fork()).ldelim();
        }
        if (message.acceptChats !== undefined) {
            BoolValue.encode({ value: message.acceptChats }, writer.uint32(98).fork()).ldelim();
        }
        if (message.isBlocked !== undefined) {
            BoolValue.encode({ value: message.isBlocked }, writer.uint32(106).fork()).ldelim();
        }
        if (message.prefShowSnoovatar !== undefined) {
            BoolValue.encode({ value: message.prefShowSnoovatar }, writer.uint32(114).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(122).fork()).ldelim();
        }
        if (message.created !== undefined) {
            Int64Value.encode({ value: message.created }, writer.uint32(130).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int64Value.encode({ value: message.createdUtc }, writer.uint32(138).fork()).ldelim();
        }
        if (message.snoovatarImg !== undefined) {
            StringValue.encode({ value: message.snoovatarImg }, writer.uint32(146).fork()).ldelim();
        }
        if (message.commentKarma !== undefined) {
            Int64Value.encode({ value: message.commentKarma }, writer.uint32(154).fork()).ldelim();
        }
        if (message.acceptFollowers !== undefined) {
            BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(162).fork()).ldelim();
        }
        if (message.hasSubscribed !== undefined) {
            BoolValue.encode({ value: message.hasSubscribed }, writer.uint32(170).fork()).ldelim();
        }
        if (message.acceptPms !== undefined) {
            BoolValue.encode({ value: message.acceptPms }, writer.uint32(178).fork()).ldelim();
        }
        if (message.isSuspended !== undefined) {
            BoolValue.encode({ value: message.isSuspended }, writer.uint32(186).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            UserSearchResponse_AccountData_Subreddit.encode(message.subreddit, writer.uint32(194).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserSearchResponse_AccountData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isEmployee = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.isFriend = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.snoovatarSize.push(Int32Value.decode(reader, reader.uint32()).value);
                    break;
                case 4:
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.verified = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.isGold = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.isMod = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.hasVerifiedEmail = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.iconImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.hideFromRobots = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.linkKarma = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.acceptChats = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.isBlocked = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.prefShowSnoovatar = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 15:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.created = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 17:
                    message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.snoovatarImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.commentKarma = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.hasSubscribed = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 22:
                    message.acceptPms = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.isSuspended = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.subreddit = UserSearchResponse_AccountData_Subreddit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isEmployee: isSet(object.isEmployee) ? Boolean(object.isEmployee) : undefined,
            isFriend: isSet(object.isFriend) ? Boolean(object.isFriend) : undefined,
            snoovatarSize: Array.isArray(object?.snoovatarSize) ? object.snoovatarSize.map((e) => Number(e)) : [],
            id: isSet(object.id) ? String(object.id) : undefined,
            verified: isSet(object.verified) ? Boolean(object.verified) : undefined,
            isGold: isSet(object.isGold) ? Boolean(object.isGold) : undefined,
            isMod: isSet(object.isMod) ? Boolean(object.isMod) : undefined,
            hasVerifiedEmail: isSet(object.hasVerifiedEmail) ? Boolean(object.hasVerifiedEmail) : undefined,
            iconImg: isSet(object.iconImg) ? String(object.iconImg) : undefined,
            hideFromRobots: isSet(object.hideFromRobots) ? Boolean(object.hideFromRobots) : undefined,
            linkKarma: isSet(object.linkKarma) ? Number(object.linkKarma) : undefined,
            acceptChats: isSet(object.acceptChats) ? Boolean(object.acceptChats) : undefined,
            isBlocked: isSet(object.isBlocked) ? Boolean(object.isBlocked) : undefined,
            prefShowSnoovatar: isSet(object.prefShowSnoovatar) ? Boolean(object.prefShowSnoovatar) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            created: isSet(object.created) ? Number(object.created) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            snoovatarImg: isSet(object.snoovatarImg) ? String(object.snoovatarImg) : undefined,
            commentKarma: isSet(object.commentKarma) ? Number(object.commentKarma) : undefined,
            acceptFollowers: isSet(object.acceptFollowers) ? Boolean(object.acceptFollowers) : undefined,
            hasSubscribed: isSet(object.hasSubscribed) ? Boolean(object.hasSubscribed) : undefined,
            acceptPms: isSet(object.acceptPms) ? Boolean(object.acceptPms) : undefined,
            isSuspended: isSet(object.isSuspended) ? Boolean(object.isSuspended) : undefined,
            subreddit: isSet(object.subreddit)
                ? UserSearchResponse_AccountData_Subreddit.fromJSON(object.subreddit)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.isEmployee !== undefined && (obj.isEmployee = message.isEmployee);
        message.isFriend !== undefined && (obj.isFriend = message.isFriend);
        if (message.snoovatarSize) {
            obj.snoovatarSize = message.snoovatarSize.map((e) => e);
        }
        else {
            obj.snoovatarSize = [];
        }
        message.id !== undefined && (obj.id = message.id);
        message.verified !== undefined && (obj.verified = message.verified);
        message.isGold !== undefined && (obj.isGold = message.isGold);
        message.isMod !== undefined && (obj.isMod = message.isMod);
        message.hasVerifiedEmail !== undefined && (obj.hasVerifiedEmail = message.hasVerifiedEmail);
        message.iconImg !== undefined && (obj.iconImg = message.iconImg);
        message.hideFromRobots !== undefined && (obj.hideFromRobots = message.hideFromRobots);
        message.linkKarma !== undefined && (obj.linkKarma = message.linkKarma);
        message.acceptChats !== undefined && (obj.acceptChats = message.acceptChats);
        message.isBlocked !== undefined && (obj.isBlocked = message.isBlocked);
        message.prefShowSnoovatar !== undefined && (obj.prefShowSnoovatar = message.prefShowSnoovatar);
        message.name !== undefined && (obj.name = message.name);
        message.created !== undefined && (obj.created = message.created);
        message.createdUtc !== undefined && (obj.createdUtc = message.createdUtc);
        message.snoovatarImg !== undefined && (obj.snoovatarImg = message.snoovatarImg);
        message.commentKarma !== undefined && (obj.commentKarma = message.commentKarma);
        message.acceptFollowers !== undefined && (obj.acceptFollowers = message.acceptFollowers);
        message.hasSubscribed !== undefined && (obj.hasSubscribed = message.hasSubscribed);
        message.acceptPms !== undefined && (obj.acceptPms = message.acceptPms);
        message.isSuspended !== undefined && (obj.isSuspended = message.isSuspended);
        message.subreddit !== undefined && (obj.subreddit = message.subreddit
            ? UserSearchResponse_AccountData_Subreddit.toJSON(message.subreddit)
            : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUserSearchResponse_AccountData();
        message.isEmployee = object.isEmployee ?? undefined;
        message.isFriend = object.isFriend ?? undefined;
        message.snoovatarSize = object.snoovatarSize?.map((e) => e) || [];
        message.id = object.id ?? undefined;
        message.verified = object.verified ?? undefined;
        message.isGold = object.isGold ?? undefined;
        message.isMod = object.isMod ?? undefined;
        message.hasVerifiedEmail = object.hasVerifiedEmail ?? undefined;
        message.iconImg = object.iconImg ?? undefined;
        message.hideFromRobots = object.hideFromRobots ?? undefined;
        message.linkKarma = object.linkKarma ?? undefined;
        message.acceptChats = object.acceptChats ?? undefined;
        message.isBlocked = object.isBlocked ?? undefined;
        message.prefShowSnoovatar = object.prefShowSnoovatar ?? undefined;
        message.name = object.name ?? undefined;
        message.created = object.created ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.snoovatarImg = object.snoovatarImg ?? undefined;
        message.commentKarma = object.commentKarma ?? undefined;
        message.acceptFollowers = object.acceptFollowers ?? undefined;
        message.hasSubscribed = object.hasSubscribed ?? undefined;
        message.acceptPms = object.acceptPms ?? undefined;
        message.isSuspended = object.isSuspended ?? undefined;
        message.subreddit = (object.subreddit !== undefined && object.subreddit !== null)
            ? UserSearchResponse_AccountData_Subreddit.fromPartial(object.subreddit)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData", UserSearchResponse_AccountData);
function createBaseUserSearchResponse_AccountData_Subreddit() {
    return {
        defaultSet: undefined,
        userIsContributor: undefined,
        bannerImg: undefined,
        allowedMediaInComments: [],
        userIsBanned: undefined,
        freeFormReports: undefined,
        communityIcon: undefined,
        showMedia: undefined,
        iconColor: undefined,
        userIsMuted: undefined,
        displayName: undefined,
        headerImg: undefined,
        title: undefined,
        previousNames: [],
        over18: undefined,
        iconSize: [],
        primaryColor: undefined,
        iconImg: undefined,
        description: undefined,
        submitLinkLabel: undefined,
        headerSize: [],
        restrictPosting: undefined,
        restrictCommenting: undefined,
        subscribers: undefined,
        submitTextLabel: undefined,
        isDefaultIcon: undefined,
        linkFlairPosition: undefined,
        displayNamePrefixed: undefined,
        keyColor: undefined,
        name: undefined,
        isDefaultBanner: undefined,
        url: undefined,
        quarantine: undefined,
        bannerSize: [],
        userIsModerator: undefined,
        acceptFollowers: undefined,
        publicDescription: undefined,
        linkFlairEnabled: undefined,
        disableContributorRequests: undefined,
        subredditType: undefined,
        userIsSubscriber: undefined,
    };
}
export const UserSearchResponse_AccountData_Subreddit = {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData.Subreddit",
    encode(message, writer = _m0.Writer.create()) {
        if (message.defaultSet !== undefined) {
            BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
        }
        if (message.userIsContributor !== undefined) {
            BoolValue.encode({ value: message.userIsContributor }, writer.uint32(18).fork()).ldelim();
        }
        if (message.bannerImg !== undefined) {
            StringValue.encode({ value: message.bannerImg }, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.allowedMediaInComments) {
            StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
        }
        if (message.userIsBanned !== undefined) {
            BoolValue.encode({ value: message.userIsBanned }, writer.uint32(42).fork()).ldelim();
        }
        if (message.freeFormReports !== undefined) {
            BoolValue.encode({ value: message.freeFormReports }, writer.uint32(50).fork()).ldelim();
        }
        if (message.communityIcon !== undefined) {
            StringValue.encode({ value: message.communityIcon }, writer.uint32(58).fork()).ldelim();
        }
        if (message.showMedia !== undefined) {
            BoolValue.encode({ value: message.showMedia }, writer.uint32(66).fork()).ldelim();
        }
        if (message.iconColor !== undefined) {
            StringValue.encode({ value: message.iconColor }, writer.uint32(74).fork()).ldelim();
        }
        if (message.userIsMuted !== undefined) {
            BoolValue.encode({ value: message.userIsMuted }, writer.uint32(82).fork()).ldelim();
        }
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(90).fork()).ldelim();
        }
        if (message.headerImg !== undefined) {
            StringValue.encode({ value: message.headerImg }, writer.uint32(98).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(106).fork()).ldelim();
        }
        for (const v of message.previousNames) {
            StringValue.encode({ value: v }, writer.uint32(114).fork()).ldelim();
        }
        if (message.over18 !== undefined) {
            BoolValue.encode({ value: message.over18 }, writer.uint32(122).fork()).ldelim();
        }
        for (const v of message.iconSize) {
            Int32Value.encode({ value: v }, writer.uint32(130).fork()).ldelim();
        }
        if (message.primaryColor !== undefined) {
            StringValue.encode({ value: message.primaryColor }, writer.uint32(138).fork()).ldelim();
        }
        if (message.iconImg !== undefined) {
            StringValue.encode({ value: message.iconImg }, writer.uint32(146).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(154).fork()).ldelim();
        }
        if (message.submitLinkLabel !== undefined) {
            StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(162).fork()).ldelim();
        }
        for (const v of message.headerSize) {
            Int32Value.encode({ value: v }, writer.uint32(170).fork()).ldelim();
        }
        if (message.restrictPosting !== undefined) {
            BoolValue.encode({ value: message.restrictPosting }, writer.uint32(178).fork()).ldelim();
        }
        if (message.restrictCommenting !== undefined) {
            BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(186).fork()).ldelim();
        }
        if (message.subscribers !== undefined) {
            Int64Value.encode({ value: message.subscribers }, writer.uint32(194).fork()).ldelim();
        }
        if (message.submitTextLabel !== undefined) {
            StringValue.encode({ value: message.submitTextLabel }, writer.uint32(202).fork()).ldelim();
        }
        if (message.isDefaultIcon !== undefined) {
            BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(210).fork()).ldelim();
        }
        if (message.linkFlairPosition !== undefined) {
            StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(218).fork()).ldelim();
        }
        if (message.displayNamePrefixed !== undefined) {
            StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(226).fork()).ldelim();
        }
        if (message.keyColor !== undefined) {
            StringValue.encode({ value: message.keyColor }, writer.uint32(234).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(242).fork()).ldelim();
        }
        if (message.isDefaultBanner !== undefined) {
            BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(250).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(258).fork()).ldelim();
        }
        if (message.quarantine !== undefined) {
            BoolValue.encode({ value: message.quarantine }, writer.uint32(266).fork()).ldelim();
        }
        for (const v of message.bannerSize) {
            Int32Value.encode({ value: v }, writer.uint32(274).fork()).ldelim();
        }
        if (message.userIsModerator !== undefined) {
            BoolValue.encode({ value: message.userIsModerator }, writer.uint32(282).fork()).ldelim();
        }
        if (message.acceptFollowers !== undefined) {
            BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(290).fork()).ldelim();
        }
        if (message.publicDescription !== undefined) {
            StringValue.encode({ value: message.publicDescription }, writer.uint32(298).fork()).ldelim();
        }
        if (message.linkFlairEnabled !== undefined) {
            BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(306).fork()).ldelim();
        }
        if (message.disableContributorRequests !== undefined) {
            BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(314).fork()).ldelim();
        }
        if (message.subredditType !== undefined) {
            StringValue.encode({ value: message.subredditType }, writer.uint32(322).fork()).ldelim();
        }
        if (message.userIsSubscriber !== undefined) {
            BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(330).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserSearchResponse_AccountData_Subreddit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 5:
                    message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 8:
                    message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.iconColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 10:
                    message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 11:
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 12:
                    message.headerImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 13:
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 14:
                    message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
                    break;
                case 15:
                    message.over18 = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 16:
                    message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
                    break;
                case 17:
                    message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 18:
                    message.iconImg = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 19:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 20:
                    message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 21:
                    message.headerSize.push(Int32Value.decode(reader, reader.uint32()).value);
                    break;
                case 22:
                    message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 23:
                    message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 24:
                    message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
                    break;
                case 25:
                    message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 26:
                    message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 27:
                    message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 28:
                    message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 29:
                    message.keyColor = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 30:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 31:
                    message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 32:
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 33:
                    message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 34:
                    message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
                    break;
                case 35:
                    message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 36:
                    message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 37:
                    message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 38:
                    message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 39:
                    message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 40:
                    message.subredditType = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 41:
                    message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultSet: isSet(object.defaultSet) ? Boolean(object.defaultSet) : undefined,
            userIsContributor: isSet(object.userIsContributor) ? Boolean(object.userIsContributor) : undefined,
            bannerImg: isSet(object.bannerImg) ? String(object.bannerImg) : undefined,
            allowedMediaInComments: Array.isArray(object?.allowedMediaInComments)
                ? object.allowedMediaInComments.map((e) => String(e))
                : [],
            userIsBanned: isSet(object.userIsBanned) ? Boolean(object.userIsBanned) : undefined,
            freeFormReports: isSet(object.freeFormReports) ? Boolean(object.freeFormReports) : undefined,
            communityIcon: isSet(object.communityIcon) ? String(object.communityIcon) : undefined,
            showMedia: isSet(object.showMedia) ? Boolean(object.showMedia) : undefined,
            iconColor: isSet(object.iconColor) ? String(object.iconColor) : undefined,
            userIsMuted: isSet(object.userIsMuted) ? Boolean(object.userIsMuted) : undefined,
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            headerImg: isSet(object.headerImg) ? String(object.headerImg) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            previousNames: Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
            over18: isSet(object.over18) ? Boolean(object.over18) : undefined,
            iconSize: Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
            primaryColor: isSet(object.primaryColor) ? String(object.primaryColor) : undefined,
            iconImg: isSet(object.iconImg) ? String(object.iconImg) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            submitLinkLabel: isSet(object.submitLinkLabel) ? String(object.submitLinkLabel) : undefined,
            headerSize: Array.isArray(object?.headerSize) ? object.headerSize.map((e) => Number(e)) : [],
            restrictPosting: isSet(object.restrictPosting) ? Boolean(object.restrictPosting) : undefined,
            restrictCommenting: isSet(object.restrictCommenting) ? Boolean(object.restrictCommenting) : undefined,
            subscribers: isSet(object.subscribers) ? Number(object.subscribers) : undefined,
            submitTextLabel: isSet(object.submitTextLabel) ? String(object.submitTextLabel) : undefined,
            isDefaultIcon: isSet(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : undefined,
            linkFlairPosition: isSet(object.linkFlairPosition) ? String(object.linkFlairPosition) : undefined,
            displayNamePrefixed: isSet(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : undefined,
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            isDefaultBanner: isSet(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            quarantine: isSet(object.quarantine) ? Boolean(object.quarantine) : undefined,
            bannerSize: Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
            userIsModerator: isSet(object.userIsModerator) ? Boolean(object.userIsModerator) : undefined,
            acceptFollowers: isSet(object.acceptFollowers) ? Boolean(object.acceptFollowers) : undefined,
            publicDescription: isSet(object.publicDescription) ? String(object.publicDescription) : undefined,
            linkFlairEnabled: isSet(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : undefined,
            disableContributorRequests: isSet(object.disableContributorRequests)
                ? Boolean(object.disableContributorRequests)
                : undefined,
            subredditType: isSet(object.subredditType) ? String(object.subredditType) : undefined,
            userIsSubscriber: isSet(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.defaultSet !== undefined && (obj.defaultSet = message.defaultSet);
        message.userIsContributor !== undefined && (obj.userIsContributor = message.userIsContributor);
        message.bannerImg !== undefined && (obj.bannerImg = message.bannerImg);
        if (message.allowedMediaInComments) {
            obj.allowedMediaInComments = message.allowedMediaInComments.map((e) => e);
        }
        else {
            obj.allowedMediaInComments = [];
        }
        message.userIsBanned !== undefined && (obj.userIsBanned = message.userIsBanned);
        message.freeFormReports !== undefined && (obj.freeFormReports = message.freeFormReports);
        message.communityIcon !== undefined && (obj.communityIcon = message.communityIcon);
        message.showMedia !== undefined && (obj.showMedia = message.showMedia);
        message.iconColor !== undefined && (obj.iconColor = message.iconColor);
        message.userIsMuted !== undefined && (obj.userIsMuted = message.userIsMuted);
        message.displayName !== undefined && (obj.displayName = message.displayName);
        message.headerImg !== undefined && (obj.headerImg = message.headerImg);
        message.title !== undefined && (obj.title = message.title);
        if (message.previousNames) {
            obj.previousNames = message.previousNames.map((e) => e);
        }
        else {
            obj.previousNames = [];
        }
        message.over18 !== undefined && (obj.over18 = message.over18);
        if (message.iconSize) {
            obj.iconSize = message.iconSize.map((e) => e);
        }
        else {
            obj.iconSize = [];
        }
        message.primaryColor !== undefined && (obj.primaryColor = message.primaryColor);
        message.iconImg !== undefined && (obj.iconImg = message.iconImg);
        message.description !== undefined && (obj.description = message.description);
        message.submitLinkLabel !== undefined && (obj.submitLinkLabel = message.submitLinkLabel);
        if (message.headerSize) {
            obj.headerSize = message.headerSize.map((e) => e);
        }
        else {
            obj.headerSize = [];
        }
        message.restrictPosting !== undefined && (obj.restrictPosting = message.restrictPosting);
        message.restrictCommenting !== undefined && (obj.restrictCommenting = message.restrictCommenting);
        message.subscribers !== undefined && (obj.subscribers = message.subscribers);
        message.submitTextLabel !== undefined && (obj.submitTextLabel = message.submitTextLabel);
        message.isDefaultIcon !== undefined && (obj.isDefaultIcon = message.isDefaultIcon);
        message.linkFlairPosition !== undefined && (obj.linkFlairPosition = message.linkFlairPosition);
        message.displayNamePrefixed !== undefined && (obj.displayNamePrefixed = message.displayNamePrefixed);
        message.keyColor !== undefined && (obj.keyColor = message.keyColor);
        message.name !== undefined && (obj.name = message.name);
        message.isDefaultBanner !== undefined && (obj.isDefaultBanner = message.isDefaultBanner);
        message.url !== undefined && (obj.url = message.url);
        message.quarantine !== undefined && (obj.quarantine = message.quarantine);
        if (message.bannerSize) {
            obj.bannerSize = message.bannerSize.map((e) => e);
        }
        else {
            obj.bannerSize = [];
        }
        message.userIsModerator !== undefined && (obj.userIsModerator = message.userIsModerator);
        message.acceptFollowers !== undefined && (obj.acceptFollowers = message.acceptFollowers);
        message.publicDescription !== undefined && (obj.publicDescription = message.publicDescription);
        message.linkFlairEnabled !== undefined && (obj.linkFlairEnabled = message.linkFlairEnabled);
        message.disableContributorRequests !== undefined &&
            (obj.disableContributorRequests = message.disableContributorRequests);
        message.subredditType !== undefined && (obj.subredditType = message.subredditType);
        message.userIsSubscriber !== undefined && (obj.userIsSubscriber = message.userIsSubscriber);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUserSearchResponse_AccountData_Subreddit();
        message.defaultSet = object.defaultSet ?? undefined;
        message.userIsContributor = object.userIsContributor ?? undefined;
        message.bannerImg = object.bannerImg ?? undefined;
        message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
        message.userIsBanned = object.userIsBanned ?? undefined;
        message.freeFormReports = object.freeFormReports ?? undefined;
        message.communityIcon = object.communityIcon ?? undefined;
        message.showMedia = object.showMedia ?? undefined;
        message.iconColor = object.iconColor ?? undefined;
        message.userIsMuted = object.userIsMuted ?? undefined;
        message.displayName = object.displayName ?? undefined;
        message.headerImg = object.headerImg ?? undefined;
        message.title = object.title ?? undefined;
        message.previousNames = object.previousNames?.map((e) => e) || [];
        message.over18 = object.over18 ?? undefined;
        message.iconSize = object.iconSize?.map((e) => e) || [];
        message.primaryColor = object.primaryColor ?? undefined;
        message.iconImg = object.iconImg ?? undefined;
        message.description = object.description ?? undefined;
        message.submitLinkLabel = object.submitLinkLabel ?? undefined;
        message.headerSize = object.headerSize?.map((e) => e) || [];
        message.restrictPosting = object.restrictPosting ?? undefined;
        message.restrictCommenting = object.restrictCommenting ?? undefined;
        message.subscribers = object.subscribers ?? undefined;
        message.submitTextLabel = object.submitTextLabel ?? undefined;
        message.isDefaultIcon = object.isDefaultIcon ?? undefined;
        message.linkFlairPosition = object.linkFlairPosition ?? undefined;
        message.displayNamePrefixed = object.displayNamePrefixed ?? undefined;
        message.keyColor = object.keyColor ?? undefined;
        message.name = object.name ?? undefined;
        message.isDefaultBanner = object.isDefaultBanner ?? undefined;
        message.url = object.url ?? undefined;
        message.quarantine = object.quarantine ?? undefined;
        message.bannerSize = object.bannerSize?.map((e) => e) || [];
        message.userIsModerator = object.userIsModerator ?? undefined;
        message.acceptFollowers = object.acceptFollowers ?? undefined;
        message.publicDescription = object.publicDescription ?? undefined;
        message.linkFlairEnabled = object.linkFlairEnabled ?? undefined;
        message.disableContributorRequests = object.disableContributorRequests ?? undefined;
        message.subredditType = object.subredditType ?? undefined;
        message.userIsSubscriber = object.userIsSubscriber ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData.Subreddit", UserSearchResponse_AccountData_Subreddit);
function createBaseSubredditAddRemovalReasonRequest() {
    return { subreddit: "", message: "", title: "" };
}
export const SubredditAddRemovalReasonRequest = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.title !== "") {
            writer.uint32(26).string(message.title);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAddRemovalReasonRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.title = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : "",
            message: isSet(object.message) ? String(object.message) : "",
            title: isSet(object.title) ? String(object.title) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        message.message !== undefined && (obj.message = message.message);
        message.title !== undefined && (obj.title = message.title);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAddRemovalReasonRequest();
        message.subreddit = object.subreddit ?? "";
        message.message = object.message ?? "";
        message.title = object.title ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonRequest", SubredditAddRemovalReasonRequest);
function createBaseSubredditAddRemovalReasonResponse() {
    return { id: "" };
}
export const SubredditAddRemovalReasonResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditAddRemovalReasonResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditAddRemovalReasonResponse();
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonResponse", SubredditAddRemovalReasonResponse);
function createBaseSubredditGetRemovalReasonsRequest() {
    return { subreddit: "" };
}
export const SubredditGetRemovalReasonsRequest = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditGetRemovalReasonsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subreddit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { subreddit: isSet(object.subreddit) ? String(object.subreddit) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.subreddit !== undefined && (obj.subreddit = message.subreddit);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditGetRemovalReasonsRequest();
        message.subreddit = object.subreddit ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsRequest", SubredditGetRemovalReasonsRequest);
function createBaseSubredditGetRemovalReasonsResponse() {
    return { data: {}, order: [] };
}
export const SubredditGetRemovalReasonsResponse = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.data).forEach(([key, value]) => {
            SubredditGetRemovalReasonsResponse_DataEntry.encode({ key: key, value }, writer.uint32(10).fork())
                .ldelim();
        });
        for (const v of message.order) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditGetRemovalReasonsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = SubredditGetRemovalReasonsResponse_DataEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.data[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    message.order.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            data: isObject(object.data)
                ? Object.entries(object.data).reduce((acc, [key, value]) => {
                    acc[key] = SubredditGetRemovalReasonsResponse_SubredditRemovalReason.fromJSON(value);
                    return acc;
                }, {})
                : {},
            order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        obj.data = {};
        if (message.data) {
            Object.entries(message.data).forEach(([k, v]) => {
                obj.data[k] = SubredditGetRemovalReasonsResponse_SubredditRemovalReason.toJSON(v);
            });
        }
        if (message.order) {
            obj.order = message.order.map((e) => e);
        }
        else {
            obj.order = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditGetRemovalReasonsResponse();
        message.data = Object.entries(object.data ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SubredditGetRemovalReasonsResponse_SubredditRemovalReason.fromPartial(value);
            }
            return acc;
        }, {});
        message.order = object.order?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse", SubredditGetRemovalReasonsResponse);
function createBaseSubredditGetRemovalReasonsResponse_SubredditRemovalReason() {
    return { id: "", message: "", title: "" };
}
export const SubredditGetRemovalReasonsResponse_SubredditRemovalReason = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse.SubredditRemovalReason",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.title !== "") {
            writer.uint32(26).string(message.title);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditGetRemovalReasonsResponse_SubredditRemovalReason();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.title = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            message: isSet(object.message) ? String(object.message) : "",
            title: isSet(object.title) ? String(object.title) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.message !== undefined && (obj.message = message.message);
        message.title !== undefined && (obj.title = message.title);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditGetRemovalReasonsResponse_SubredditRemovalReason();
        message.id = object.id ?? "";
        message.message = object.message ?? "";
        message.title = object.title ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse.SubredditRemovalReason", SubredditGetRemovalReasonsResponse_SubredditRemovalReason);
function createBaseSubredditGetRemovalReasonsResponse_DataEntry() {
    return { key: "", value: undefined };
}
export const SubredditGetRemovalReasonsResponse_DataEntry = {
    $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse.DataEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SubredditGetRemovalReasonsResponse_SubredditRemovalReason.encode(message.value, writer.uint32(18).fork())
                .ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditGetRemovalReasonsResponse_DataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = SubredditGetRemovalReasonsResponse_SubredditRemovalReason.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value)
                ? SubredditGetRemovalReasonsResponse_SubredditRemovalReason.fromJSON(object.value)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value
            ? SubredditGetRemovalReasonsResponse_SubredditRemovalReason.toJSON(message.value)
            : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubredditGetRemovalReasonsResponse_DataEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SubredditGetRemovalReasonsResponse_SubredditRemovalReason.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse.DataEntry", SubredditGetRemovalReasonsResponse_DataEntry);
var globalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
