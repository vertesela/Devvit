/**
 * #scheduler.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Empty } from '../../../google/protobuf/empty.js';
import { Timestamp } from '../../../google/protobuf/timestamp.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
import { ScheduledAction } from '../../actor/scheduler/action.js';
import { Strings } from '../../runtime/runtime_common.js';
export var StorableAction_State;
(function (StorableAction_State) {
    StorableAction_State[StorableAction_State["WAITING"] = 0] = "WAITING";
    StorableAction_State[StorableAction_State["CANCELED"] = 1] = "CANCELED";
    StorableAction_State[StorableAction_State["FAILED"] = 2] = "FAILED";
    StorableAction_State[StorableAction_State["DELIVERED"] = 3] = "DELIVERED";
    StorableAction_State[StorableAction_State["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(StorableAction_State || (StorableAction_State = {}));
export function storableAction_StateFromJSON(object) {
    switch (object) {
        case 0:
        case "WAITING":
            return StorableAction_State.WAITING;
        case 1:
        case "CANCELED":
            return StorableAction_State.CANCELED;
        case 2:
        case "FAILED":
            return StorableAction_State.FAILED;
        case 3:
        case "DELIVERED":
            return StorableAction_State.DELIVERED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return StorableAction_State.UNRECOGNIZED;
    }
}
export function storableAction_StateToJSON(object) {
    switch (object) {
        case StorableAction_State.WAITING:
            return 0;
        case StorableAction_State.CANCELED:
            return 1;
        case StorableAction_State.FAILED:
            return 2;
        case StorableAction_State.DELIVERED:
            return 3;
        case StorableAction_State.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseScheduledActionRequest() {
    return { when: undefined, cron: undefined, action: undefined };
}
export const ScheduledActionRequest = {
    $type: "devvit.plugin.scheduler.ScheduledActionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.when !== undefined) {
            Timestamp.encode(toTimestamp(message.when), writer.uint32(10).fork()).ldelim();
        }
        if (message.cron !== undefined) {
            writer.uint32(18).string(message.cron);
        }
        if (message.action !== undefined) {
            ScheduledAction.encode(message.action, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseScheduledActionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.when = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.cron = reader.string();
                    break;
                case 3:
                    message.action = ScheduledAction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            when: isSet(object.when) ? fromJsonTimestamp(object.when) : undefined,
            cron: isSet(object.cron) ? String(object.cron) : undefined,
            action: isSet(object.action) ? ScheduledAction.fromJSON(object.action) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.when !== undefined && (obj.when = message.when.toISOString());
        message.cron !== undefined && (obj.cron = message.cron);
        message.action !== undefined && (obj.action = message.action ? ScheduledAction.toJSON(message.action) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseScheduledActionRequest();
        message.when = object.when ?? undefined;
        message.cron = object.cron ?? undefined;
        message.action = (object.action !== undefined && object.action !== null)
            ? ScheduledAction.fromPartial(object.action)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.scheduler.ScheduledActionRequest", ScheduledActionRequest);
function createBaseScheduledActionResponse() {
    return { id: "" };
}
export const ScheduledActionResponse = {
    $type: "devvit.plugin.scheduler.ScheduledActionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseScheduledActionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseScheduledActionResponse();
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.scheduler.ScheduledActionResponse", ScheduledActionResponse);
function createBaseCancelActionRequest() {
    return { id: "" };
}
export const CancelActionRequest = {
    $type: "devvit.plugin.scheduler.CancelActionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCancelActionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseCancelActionRequest();
        message.id = object.id ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.scheduler.CancelActionRequest", CancelActionRequest);
function createBaseStorableAction() {
    return { id: "", actorHostname: "", request: undefined, metadata: {}, state: undefined };
}
export const StorableAction = {
    $type: "devvit.plugin.scheduler.StorableAction",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.actorHostname !== "") {
            writer.uint32(18).string(message.actorHostname);
        }
        if (message.request !== undefined) {
            ScheduledActionRequest.encode(message.request, writer.uint32(26).fork()).ldelim();
        }
        Object.entries(message.metadata).forEach(([key, value]) => {
            StorableAction_MetadataEntry.encode({ key: key, value }, writer.uint32(74).fork()).ldelim();
        });
        if (message.state !== undefined) {
            writer.uint32(80).int32(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStorableAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.actorHostname = reader.string();
                    break;
                case 3:
                    message.request = ScheduledActionRequest.decode(reader, reader.uint32());
                    break;
                case 9:
                    const entry9 = StorableAction_MetadataEntry.decode(reader, reader.uint32());
                    if (entry9.value !== undefined) {
                        message.metadata[entry9.key] = entry9.value;
                    }
                    break;
                case 10:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            actorHostname: isSet(object.actorHostname) ? String(object.actorHostname) : "",
            request: isSet(object.request) ? ScheduledActionRequest.fromJSON(object.request) : undefined,
            metadata: isObject(object.metadata)
                ? Object.entries(object.metadata).reduce((acc, [key, value]) => {
                    acc[key] = Strings.fromJSON(value);
                    return acc;
                }, {})
                : {},
            state: isSet(object.state) ? storableAction_StateFromJSON(object.state) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.actorHostname !== undefined && (obj.actorHostname = message.actorHostname);
        message.request !== undefined &&
            (obj.request = message.request ? ScheduledActionRequest.toJSON(message.request) : undefined);
        obj.metadata = {};
        if (message.metadata) {
            Object.entries(message.metadata).forEach(([k, v]) => {
                obj.metadata[k] = Strings.toJSON(v);
            });
        }
        message.state !== undefined &&
            (obj.state = message.state !== undefined ? storableAction_StateToJSON(message.state) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStorableAction();
        message.id = object.id ?? "";
        message.actorHostname = object.actorHostname ?? "";
        message.request = (object.request !== undefined && object.request !== null)
            ? ScheduledActionRequest.fromPartial(object.request)
            : undefined;
        message.metadata = Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = Strings.fromPartial(value);
            }
            return acc;
        }, {});
        message.state = object.state ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.scheduler.StorableAction", StorableAction);
function createBaseStorableAction_MetadataEntry() {
    return { key: "", value: undefined };
}
export const StorableAction_MetadataEntry = {
    $type: "devvit.plugin.scheduler.StorableAction.MetadataEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Strings.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStorableAction_MetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = Strings.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? Strings.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? Strings.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseStorableAction_MetadataEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? Strings.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.scheduler.StorableAction.MetadataEntry", StorableAction_MetadataEntry);
function createBaseListActionRequest() {
    return { before: undefined, after: undefined };
}
export const ListActionRequest = {
    $type: "devvit.plugin.scheduler.ListActionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.before !== undefined) {
            Timestamp.encode(toTimestamp(message.before), writer.uint32(10).fork()).ldelim();
        }
        if (message.after !== undefined) {
            Timestamp.encode(toTimestamp(message.after), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListActionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.before = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.after = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            before: isSet(object.before) ? fromJsonTimestamp(object.before) : undefined,
            after: isSet(object.after) ? fromJsonTimestamp(object.after) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.before !== undefined && (obj.before = message.before.toISOString());
        message.after !== undefined && (obj.after = message.after.toISOString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseListActionRequest();
        message.before = object.before ?? undefined;
        message.after = object.after ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.scheduler.ListActionRequest", ListActionRequest);
function createBaseGetActionResponse() {
    return { id: "", request: undefined };
}
export const GetActionResponse = {
    $type: "devvit.plugin.scheduler.GetActionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.request !== undefined) {
            ScheduledActionRequest.encode(message.request, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetActionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.request = ScheduledActionRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            request: isSet(object.request) ? ScheduledActionRequest.fromJSON(object.request) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.request !== undefined &&
            (obj.request = message.request ? ScheduledActionRequest.toJSON(message.request) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetActionResponse();
        message.id = object.id ?? "";
        message.request = (object.request !== undefined && object.request !== null)
            ? ScheduledActionRequest.fromPartial(object.request)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.scheduler.GetActionResponse", GetActionResponse);
function createBaseListActionResponse() {
    return { actions: [] };
}
export const ListActionResponse = {
    $type: "devvit.plugin.scheduler.ListActionResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actions) {
            GetActionResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListActionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(GetActionResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actions: Array.isArray(object?.actions) ? object.actions.map((e) => GetActionResponse.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.actions) {
            obj.actions = message.actions.map((e) => e ? GetActionResponse.toJSON(e) : undefined);
        }
        else {
            obj.actions = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseListActionResponse();
        message.actions = object.actions?.map((e) => GetActionResponse.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.plugin.scheduler.ListActionResponse", ListActionResponse);
export class SchedulerClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || "devvit.plugin.scheduler.Scheduler";
        this.rpc = rpc;
        this.Schedule = this.Schedule.bind(this);
        this.Cancel = this.Cancel.bind(this);
        this.List = this.List.bind(this);
    }
    Schedule(request) {
        const data = ScheduledActionRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Schedule", data);
        return promise.then((data) => ScheduledActionResponse.decode(new _m0.Reader(data)));
    }
    Cancel(request) {
        const data = CancelActionRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Cancel", data);
        return promise.then((data) => Empty.decode(new _m0.Reader(data)));
    }
    List(request) {
        const data = ListActionRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "List", data);
        return promise.then((data) => ListActionResponse.decode(new _m0.Reader(data)));
    }
}
export const SchedulerDefinition = {
    name: "Scheduler",
    fullName: "devvit.plugin.scheduler.Scheduler",
    methods: {
        /** This schedules an action */
        schedule: {
            name: "Schedule",
            requestType: ScheduledActionRequest,
            requestStream: false,
            responseType: ScheduledActionResponse,
            responseStream: false,
            options: {},
        },
        /** This cancels any scheduled action */
        cancel: {
            name: "Cancel",
            requestType: CancelActionRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** This lists all scheduled actions for this installation. */
        list: {
            name: "List",
            requestType: ListActionRequest,
            requestStream: false,
            responseType: ListActionResponse,
            responseStream: false,
            options: {},
        },
    },
};
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
