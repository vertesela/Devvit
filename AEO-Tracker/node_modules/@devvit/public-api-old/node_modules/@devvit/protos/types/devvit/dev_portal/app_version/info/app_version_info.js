/**
 * #app_version_info.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Timestamp } from '../../../../google/protobuf/timestamp.js';
import { Int32Value } from '../../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
export var VersionVisibility;
(function (VersionVisibility) {
    VersionVisibility[VersionVisibility["PUBLIC"] = 0] = "PUBLIC";
    VersionVisibility[VersionVisibility["PRIVATE"] = 1] = "PRIVATE";
    VersionVisibility[VersionVisibility["UNLISTED"] = 2] = "UNLISTED";
    VersionVisibility[VersionVisibility["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VersionVisibility || (VersionVisibility = {}));
export function versionVisibilityFromJSON(object) {
    switch (object) {
        case 0:
        case "PUBLIC":
            return VersionVisibility.PUBLIC;
        case 1:
        case "PRIVATE":
            return VersionVisibility.PRIVATE;
        case 2:
        case "UNLISTED":
            return VersionVisibility.UNLISTED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return VersionVisibility.UNRECOGNIZED;
    }
}
export function versionVisibilityToJSON(object) {
    switch (object) {
        case VersionVisibility.PUBLIC:
            return 0;
        case VersionVisibility.PRIVATE:
            return 1;
        case VersionVisibility.UNLISTED:
            return 2;
        case VersionVisibility.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var BuildStatus;
(function (BuildStatus) {
    BuildStatus[BuildStatus["BUILDING"] = 0] = "BUILDING";
    BuildStatus[BuildStatus["READY"] = 1] = "READY";
    BuildStatus[BuildStatus["FAILED"] = 2] = "FAILED";
    BuildStatus[BuildStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BuildStatus || (BuildStatus = {}));
export function buildStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "BUILDING":
            return BuildStatus.BUILDING;
        case 1:
        case "READY":
            return BuildStatus.READY;
        case 2:
        case "FAILED":
            return BuildStatus.FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BuildStatus.UNRECOGNIZED;
    }
}
export function buildStatusToJSON(object) {
    switch (object) {
        case BuildStatus.BUILDING:
            return 0;
        case BuildStatus.READY:
            return 1;
        case BuildStatus.FAILED:
            return 2;
        case BuildStatus.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var ReviewStatus;
(function (ReviewStatus) {
    ReviewStatus[ReviewStatus["NOT_SUBMITTED"] = 0] = "NOT_SUBMITTED";
    ReviewStatus[ReviewStatus["PENDING"] = 1] = "PENDING";
    ReviewStatus[ReviewStatus["APPROVED"] = 2] = "APPROVED";
    ReviewStatus[ReviewStatus["DENIED"] = 3] = "DENIED";
    ReviewStatus[ReviewStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ReviewStatus || (ReviewStatus = {}));
export function reviewStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "NOT_SUBMITTED":
            return ReviewStatus.NOT_SUBMITTED;
        case 1:
        case "PENDING":
            return ReviewStatus.PENDING;
        case 2:
        case "APPROVED":
            return ReviewStatus.APPROVED;
        case 3:
        case "DENIED":
            return ReviewStatus.DENIED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ReviewStatus.UNRECOGNIZED;
    }
}
export function reviewStatusToJSON(object) {
    switch (object) {
        case ReviewStatus.NOT_SUBMITTED:
            return 0;
        case ReviewStatus.PENDING:
            return 1;
        case ReviewStatus.APPROVED:
            return 2;
        case ReviewStatus.DENIED:
            return 3;
        case ReviewStatus.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var InstallationType;
(function (InstallationType) {
    InstallationType[InstallationType["USER"] = 0] = "USER";
    InstallationType[InstallationType["SUBREDDIT"] = 1] = "SUBREDDIT";
    InstallationType[InstallationType["SUBREDDIT_GLOBAL"] = 2] = "SUBREDDIT_GLOBAL";
    InstallationType[InstallationType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InstallationType || (InstallationType = {}));
export function installationTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "USER":
            return InstallationType.USER;
        case 1:
        case "SUBREDDIT":
            return InstallationType.SUBREDDIT;
        case 2:
        case "SUBREDDIT_GLOBAL":
            return InstallationType.SUBREDDIT_GLOBAL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return InstallationType.UNRECOGNIZED;
    }
}
export function installationTypeToJSON(object) {
    switch (object) {
        case InstallationType.USER:
            return 0;
        case InstallationType.SUBREDDIT:
            return 1;
        case InstallationType.SUBREDDIT_GLOBAL:
            return 2;
        case InstallationType.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var ComputePool;
(function (ComputePool) {
    ComputePool[ComputePool["LOW"] = 0] = "LOW";
    ComputePool[ComputePool["MEDIUM"] = 1] = "MEDIUM";
    ComputePool[ComputePool["HIGH"] = 2] = "HIGH";
    ComputePool[ComputePool["RESTRICTED"] = 3] = "RESTRICTED";
    ComputePool[ComputePool["INTERNAL"] = 4] = "INTERNAL";
    ComputePool[ComputePool["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ComputePool || (ComputePool = {}));
export function computePoolFromJSON(object) {
    switch (object) {
        case 0:
        case "LOW":
            return ComputePool.LOW;
        case 1:
        case "MEDIUM":
            return ComputePool.MEDIUM;
        case 2:
        case "HIGH":
            return ComputePool.HIGH;
        case 3:
        case "RESTRICTED":
            return ComputePool.RESTRICTED;
        case 4:
        case "INTERNAL":
            return ComputePool.INTERNAL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ComputePool.UNRECOGNIZED;
    }
}
export function computePoolToJSON(object) {
    switch (object) {
        case ComputePool.LOW:
            return 0;
        case ComputePool.MEDIUM:
            return 1;
        case ComputePool.HIGH:
            return 2;
        case ComputePool.RESTRICTED:
            return 3;
        case ComputePool.INTERNAL:
            return 4;
        case ComputePool.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseOptionalVersionVisibility() {
    return { value: 0 };
}
export const OptionalVersionVisibility = {
    $type: "devvit.dev_portal.app_version.info.OptionalVersionVisibility",
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== 0) {
            writer.uint32(8).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOptionalVersionVisibility();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? versionVisibilityFromJSON(object.value) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = versionVisibilityToJSON(message.value));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseOptionalVersionVisibility();
        message.value = object.value ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.info.OptionalVersionVisibility", OptionalVersionVisibility);
function createBaseAppVersionInfo() {
    return {
        id: "",
        visibility: 0,
        validInstallTypes: [],
        majorVersion: 0,
        minorVersion: 0,
        patchVersion: 0,
        prereleaseVersion: undefined,
        uploadedAt: undefined,
        buildStatus: 0,
        builtAt: undefined,
        about: "",
        hasCustomSettings: false,
        pool: 0,
        reviewStatus: undefined,
    };
}
export const AppVersionInfo = {
    $type: "devvit.dev_portal.app_version.info.AppVersionInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.visibility !== 0) {
            writer.uint32(16).int32(message.visibility);
        }
        writer.uint32(34).fork();
        for (const v of message.validInstallTypes) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.majorVersion !== 0) {
            writer.uint32(40).int32(message.majorVersion);
        }
        if (message.minorVersion !== 0) {
            writer.uint32(48).int32(message.minorVersion);
        }
        if (message.patchVersion !== 0) {
            writer.uint32(56).int32(message.patchVersion);
        }
        if (message.prereleaseVersion !== undefined) {
            Int32Value.encode({ value: message.prereleaseVersion }, writer.uint32(66).fork()).ldelim();
        }
        if (message.uploadedAt !== undefined) {
            Timestamp.encode(toTimestamp(message.uploadedAt), writer.uint32(74).fork()).ldelim();
        }
        if (message.buildStatus !== 0) {
            writer.uint32(80).int32(message.buildStatus);
        }
        if (message.builtAt !== undefined) {
            Timestamp.encode(toTimestamp(message.builtAt), writer.uint32(90).fork()).ldelim();
        }
        if (message.about !== "") {
            writer.uint32(98).string(message.about);
        }
        if (message.hasCustomSettings === true) {
            writer.uint32(104).bool(message.hasCustomSettings);
        }
        if (message.pool !== 0) {
            writer.uint32(112).int32(message.pool);
        }
        if (message.reviewStatus !== undefined) {
            writer.uint32(120).int32(message.reviewStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppVersionInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.visibility = reader.int32();
                    break;
                case 4:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.validInstallTypes.push(reader.int32());
                        }
                    }
                    else {
                        message.validInstallTypes.push(reader.int32());
                    }
                    break;
                case 5:
                    message.majorVersion = reader.int32();
                    break;
                case 6:
                    message.minorVersion = reader.int32();
                    break;
                case 7:
                    message.patchVersion = reader.int32();
                    break;
                case 8:
                    message.prereleaseVersion = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.uploadedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.buildStatus = reader.int32();
                    break;
                case 11:
                    message.builtAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.about = reader.string();
                    break;
                case 13:
                    message.hasCustomSettings = reader.bool();
                    break;
                case 14:
                    message.pool = reader.int32();
                    break;
                case 15:
                    message.reviewStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            visibility: isSet(object.visibility) ? versionVisibilityFromJSON(object.visibility) : 0,
            validInstallTypes: Array.isArray(object?.validInstallTypes)
                ? object.validInstallTypes.map((e) => installationTypeFromJSON(e))
                : [],
            majorVersion: isSet(object.majorVersion) ? Number(object.majorVersion) : 0,
            minorVersion: isSet(object.minorVersion) ? Number(object.minorVersion) : 0,
            patchVersion: isSet(object.patchVersion) ? Number(object.patchVersion) : 0,
            prereleaseVersion: isSet(object.prereleaseVersion) ? Number(object.prereleaseVersion) : undefined,
            uploadedAt: isSet(object.uploadedAt) ? fromJsonTimestamp(object.uploadedAt) : undefined,
            buildStatus: isSet(object.buildStatus) ? buildStatusFromJSON(object.buildStatus) : 0,
            builtAt: isSet(object.builtAt) ? fromJsonTimestamp(object.builtAt) : undefined,
            about: isSet(object.about) ? String(object.about) : "",
            hasCustomSettings: isSet(object.hasCustomSettings) ? Boolean(object.hasCustomSettings) : false,
            pool: isSet(object.pool) ? computePoolFromJSON(object.pool) : 0,
            reviewStatus: isSet(object.reviewStatus) ? reviewStatusFromJSON(object.reviewStatus) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.visibility !== undefined && (obj.visibility = versionVisibilityToJSON(message.visibility));
        if (message.validInstallTypes) {
            obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
        }
        else {
            obj.validInstallTypes = [];
        }
        message.majorVersion !== undefined && (obj.majorVersion = Math.round(message.majorVersion));
        message.minorVersion !== undefined && (obj.minorVersion = Math.round(message.minorVersion));
        message.patchVersion !== undefined && (obj.patchVersion = Math.round(message.patchVersion));
        message.prereleaseVersion !== undefined && (obj.prereleaseVersion = message.prereleaseVersion);
        message.uploadedAt !== undefined && (obj.uploadedAt = message.uploadedAt.toISOString());
        message.buildStatus !== undefined && (obj.buildStatus = buildStatusToJSON(message.buildStatus));
        message.builtAt !== undefined && (obj.builtAt = message.builtAt.toISOString());
        message.about !== undefined && (obj.about = message.about);
        message.hasCustomSettings !== undefined && (obj.hasCustomSettings = message.hasCustomSettings);
        message.pool !== undefined && (obj.pool = computePoolToJSON(message.pool));
        message.reviewStatus !== undefined &&
            (obj.reviewStatus = message.reviewStatus !== undefined ? reviewStatusToJSON(message.reviewStatus) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppVersionInfo();
        message.id = object.id ?? "";
        message.visibility = object.visibility ?? 0;
        message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
        message.majorVersion = object.majorVersion ?? 0;
        message.minorVersion = object.minorVersion ?? 0;
        message.patchVersion = object.patchVersion ?? 0;
        message.prereleaseVersion = object.prereleaseVersion ?? undefined;
        message.uploadedAt = object.uploadedAt ?? undefined;
        message.buildStatus = object.buildStatus ?? 0;
        message.builtAt = object.builtAt ?? undefined;
        message.about = object.about ?? "";
        message.hasCustomSettings = object.hasCustomSettings ?? false;
        message.pool = object.pool ?? 0;
        message.reviewStatus = object.reviewStatus ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app_version.info.AppVersionInfo", AppVersionInfo);
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
