/**
 * #block.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { BlockAction, BlockAlignment, BlockBorder, BlockColor, BlockSize, BlockSizes } from './attributes.js';
import { blockAnimationDirectionFromJSON, blockAnimationDirectionToJSON, blockAnimationLoopModeFromJSON, blockAnimationLoopModeToJSON, blockAnimationTypeFromJSON, blockAnimationTypeToJSON, blockAvatarBackgroundFromJSON, blockAvatarBackgroundToJSON, blockAvatarFacingFromJSON, blockAvatarFacingToJSON, blockAvatarSizeFromJSON, blockAvatarSizeToJSON, blockButtonAppearanceFromJSON, blockButtonAppearanceToJSON, blockButtonSizeFromJSON, blockButtonSizeToJSON, blockFullSnooSizeFromJSON, blockFullSnooSizeToJSON, blockGapFromJSON, blockGapToJSON, blockIconSizeFromJSON, blockIconSizeToJSON, blockImageResizeModeFromJSON, blockImageResizeModeToJSON, blockPaddingFromJSON, blockPaddingToJSON, blockRadiusFromJSON, blockRadiusToJSON, blockSpacerShapeFromJSON, blockSpacerShapeToJSON, blockSpacerSizeFromJSON, blockSpacerSizeToJSON, blockStackDirectionFromJSON, blockStackDirectionToJSON, blockTextOutlineFromJSON, blockTextOutlineToJSON, blockTextOverflowFromJSON, blockTextOverflowToJSON, blockTextSizeFromJSON, blockTextSizeToJSON, blockTextStyleFromJSON, blockTextStyleToJSON, blockTextWeightFromJSON, blockTextWeightToJSON, blockTypeFromJSON, blockTypeToJSON, } from './enums.js';
function createBaseBlock() {
    return { type: 0, size: undefined, sizes: undefined, config: undefined, actions: [] };
}
export const Block = {
    $type: "devvit.ui.block_kit.v1beta.Block",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.size !== undefined) {
            BlockSize.encode(message.size, writer.uint32(18).fork()).ldelim();
        }
        if (message.sizes !== undefined) {
            BlockSizes.encode(message.sizes, writer.uint32(42).fork()).ldelim();
        }
        if (message.config !== undefined) {
            BlockConfig.encode(message.config, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.actions) {
            BlockAction.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlock();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.size = BlockSize.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.sizes = BlockSizes.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.config = BlockConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.actions.push(BlockAction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? blockTypeFromJSON(object.type) : 0,
            size: isSet(object.size) ? BlockSize.fromJSON(object.size) : undefined,
            sizes: isSet(object.sizes) ? BlockSizes.fromJSON(object.sizes) : undefined,
            config: isSet(object.config) ? BlockConfig.fromJSON(object.config) : undefined,
            actions: Array.isArray(object?.actions) ? object.actions.map((e) => BlockAction.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = blockTypeToJSON(message.type));
        message.size !== undefined && (obj.size = message.size ? BlockSize.toJSON(message.size) : undefined);
        message.sizes !== undefined && (obj.sizes = message.sizes ? BlockSizes.toJSON(message.sizes) : undefined);
        message.config !== undefined && (obj.config = message.config ? BlockConfig.toJSON(message.config) : undefined);
        if (message.actions) {
            obj.actions = message.actions.map((e) => e ? BlockAction.toJSON(e) : undefined);
        }
        else {
            obj.actions = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlock();
        message.type = object.type ?? 0;
        message.size = (object.size !== undefined && object.size !== null) ? BlockSize.fromPartial(object.size) : undefined;
        message.sizes = (object.sizes !== undefined && object.sizes !== null)
            ? BlockSizes.fromPartial(object.sizes)
            : undefined;
        message.config = (object.config !== undefined && object.config !== null)
            ? BlockConfig.fromPartial(object.config)
            : undefined;
        message.actions = object.actions?.map((e) => BlockAction.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.Block", Block);
function createBaseBlockConfig() {
    return {
        rootConfig: undefined,
        stackConfig: undefined,
        textConfig: undefined,
        buttonConfig: undefined,
        imageConfig: undefined,
        spacerConfig: undefined,
        iconConfig: undefined,
        avatarConfig: undefined,
        fullsnooConfig: undefined,
        animationConfig: undefined,
        webviewConfig: undefined,
    };
}
export const BlockConfig = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig",
    encode(message, writer = _m0.Writer.create()) {
        if (message.rootConfig !== undefined) {
            BlockConfig_Root.encode(message.rootConfig, writer.uint32(10).fork()).ldelim();
        }
        if (message.stackConfig !== undefined) {
            BlockConfig_Stack.encode(message.stackConfig, writer.uint32(18).fork()).ldelim();
        }
        if (message.textConfig !== undefined) {
            BlockConfig_Text.encode(message.textConfig, writer.uint32(26).fork()).ldelim();
        }
        if (message.buttonConfig !== undefined) {
            BlockConfig_Button.encode(message.buttonConfig, writer.uint32(34).fork()).ldelim();
        }
        if (message.imageConfig !== undefined) {
            BlockConfig_Image.encode(message.imageConfig, writer.uint32(42).fork()).ldelim();
        }
        if (message.spacerConfig !== undefined) {
            BlockConfig_Spacer.encode(message.spacerConfig, writer.uint32(50).fork()).ldelim();
        }
        if (message.iconConfig !== undefined) {
            BlockConfig_Icon.encode(message.iconConfig, writer.uint32(58).fork()).ldelim();
        }
        if (message.avatarConfig !== undefined) {
            BlockConfig_Avatar.encode(message.avatarConfig, writer.uint32(66).fork()).ldelim();
        }
        if (message.fullsnooConfig !== undefined) {
            BlockConfig_FullSnoo.encode(message.fullsnooConfig, writer.uint32(74).fork()).ldelim();
        }
        if (message.animationConfig !== undefined) {
            BlockConfig_Animation.encode(message.animationConfig, writer.uint32(82).fork()).ldelim();
        }
        if (message.webviewConfig !== undefined) {
            BlockConfig_WebView.encode(message.webviewConfig, writer.uint32(802).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.rootConfig = BlockConfig_Root.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stackConfig = BlockConfig_Stack.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.textConfig = BlockConfig_Text.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.buttonConfig = BlockConfig_Button.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.imageConfig = BlockConfig_Image.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.spacerConfig = BlockConfig_Spacer.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.iconConfig = BlockConfig_Icon.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.avatarConfig = BlockConfig_Avatar.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.fullsnooConfig = BlockConfig_FullSnoo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.animationConfig = BlockConfig_Animation.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.webviewConfig = BlockConfig_WebView.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            rootConfig: isSet(object.rootConfig) ? BlockConfig_Root.fromJSON(object.rootConfig) : undefined,
            stackConfig: isSet(object.stackConfig) ? BlockConfig_Stack.fromJSON(object.stackConfig) : undefined,
            textConfig: isSet(object.textConfig) ? BlockConfig_Text.fromJSON(object.textConfig) : undefined,
            buttonConfig: isSet(object.buttonConfig) ? BlockConfig_Button.fromJSON(object.buttonConfig) : undefined,
            imageConfig: isSet(object.imageConfig) ? BlockConfig_Image.fromJSON(object.imageConfig) : undefined,
            spacerConfig: isSet(object.spacerConfig) ? BlockConfig_Spacer.fromJSON(object.spacerConfig) : undefined,
            iconConfig: isSet(object.iconConfig) ? BlockConfig_Icon.fromJSON(object.iconConfig) : undefined,
            avatarConfig: isSet(object.avatarConfig) ? BlockConfig_Avatar.fromJSON(object.avatarConfig) : undefined,
            fullsnooConfig: isSet(object.fullsnooConfig) ? BlockConfig_FullSnoo.fromJSON(object.fullsnooConfig) : undefined,
            animationConfig: isSet(object.animationConfig)
                ? BlockConfig_Animation.fromJSON(object.animationConfig)
                : undefined,
            webviewConfig: isSet(object.webviewConfig) ? BlockConfig_WebView.fromJSON(object.webviewConfig) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.rootConfig !== undefined &&
            (obj.rootConfig = message.rootConfig ? BlockConfig_Root.toJSON(message.rootConfig) : undefined);
        message.stackConfig !== undefined &&
            (obj.stackConfig = message.stackConfig ? BlockConfig_Stack.toJSON(message.stackConfig) : undefined);
        message.textConfig !== undefined &&
            (obj.textConfig = message.textConfig ? BlockConfig_Text.toJSON(message.textConfig) : undefined);
        message.buttonConfig !== undefined &&
            (obj.buttonConfig = message.buttonConfig ? BlockConfig_Button.toJSON(message.buttonConfig) : undefined);
        message.imageConfig !== undefined &&
            (obj.imageConfig = message.imageConfig ? BlockConfig_Image.toJSON(message.imageConfig) : undefined);
        message.spacerConfig !== undefined &&
            (obj.spacerConfig = message.spacerConfig ? BlockConfig_Spacer.toJSON(message.spacerConfig) : undefined);
        message.iconConfig !== undefined &&
            (obj.iconConfig = message.iconConfig ? BlockConfig_Icon.toJSON(message.iconConfig) : undefined);
        message.avatarConfig !== undefined &&
            (obj.avatarConfig = message.avatarConfig ? BlockConfig_Avatar.toJSON(message.avatarConfig) : undefined);
        message.fullsnooConfig !== undefined &&
            (obj.fullsnooConfig = message.fullsnooConfig ? BlockConfig_FullSnoo.toJSON(message.fullsnooConfig) : undefined);
        message.animationConfig !== undefined &&
            (obj.animationConfig = message.animationConfig
                ? BlockConfig_Animation.toJSON(message.animationConfig)
                : undefined);
        message.webviewConfig !== undefined &&
            (obj.webviewConfig = message.webviewConfig ? BlockConfig_WebView.toJSON(message.webviewConfig) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig();
        message.rootConfig = (object.rootConfig !== undefined && object.rootConfig !== null)
            ? BlockConfig_Root.fromPartial(object.rootConfig)
            : undefined;
        message.stackConfig = (object.stackConfig !== undefined && object.stackConfig !== null)
            ? BlockConfig_Stack.fromPartial(object.stackConfig)
            : undefined;
        message.textConfig = (object.textConfig !== undefined && object.textConfig !== null)
            ? BlockConfig_Text.fromPartial(object.textConfig)
            : undefined;
        message.buttonConfig = (object.buttonConfig !== undefined && object.buttonConfig !== null)
            ? BlockConfig_Button.fromPartial(object.buttonConfig)
            : undefined;
        message.imageConfig = (object.imageConfig !== undefined && object.imageConfig !== null)
            ? BlockConfig_Image.fromPartial(object.imageConfig)
            : undefined;
        message.spacerConfig = (object.spacerConfig !== undefined && object.spacerConfig !== null)
            ? BlockConfig_Spacer.fromPartial(object.spacerConfig)
            : undefined;
        message.iconConfig = (object.iconConfig !== undefined && object.iconConfig !== null)
            ? BlockConfig_Icon.fromPartial(object.iconConfig)
            : undefined;
        message.avatarConfig = (object.avatarConfig !== undefined && object.avatarConfig !== null)
            ? BlockConfig_Avatar.fromPartial(object.avatarConfig)
            : undefined;
        message.fullsnooConfig = (object.fullsnooConfig !== undefined && object.fullsnooConfig !== null)
            ? BlockConfig_FullSnoo.fromPartial(object.fullsnooConfig)
            : undefined;
        message.animationConfig = (object.animationConfig !== undefined && object.animationConfig !== null)
            ? BlockConfig_Animation.fromPartial(object.animationConfig)
            : undefined;
        message.webviewConfig = (object.webviewConfig !== undefined && object.webviewConfig !== null)
            ? BlockConfig_WebView.fromPartial(object.webviewConfig)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig", BlockConfig);
function createBaseBlockConfig_Root() {
    return { children: [], height: 0 };
}
export const BlockConfig_Root = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Root",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.children) {
            Block.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.height !== 0) {
            writer.uint32(16).int32(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_Root();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.children.push(Block.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.height = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            children: Array.isArray(object?.children) ? object.children.map((e) => Block.fromJSON(e)) : [],
            height: isSet(object.height) ? Number(object.height) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.children) {
            obj.children = message.children.map((e) => e ? Block.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        message.height !== undefined && (obj.height = Math.round(message.height));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_Root();
        message.children = object.children?.map((e) => Block.fromPartial(e)) || [];
        message.height = object.height ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Root", BlockConfig_Root);
function createBaseBlockConfig_Stack() {
    return {
        direction: 0,
        children: [],
        reverse: undefined,
        alignment: undefined,
        padding: undefined,
        gap: undefined,
        border: undefined,
        cornerRadius: undefined,
        backgroundColor: undefined,
        backgroundColors: undefined,
    };
}
export const BlockConfig_Stack = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Stack",
    encode(message, writer = _m0.Writer.create()) {
        if (message.direction !== 0) {
            writer.uint32(8).int32(message.direction);
        }
        for (const v of message.children) {
            Block.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.reverse !== undefined) {
            writer.uint32(24).bool(message.reverse);
        }
        if (message.alignment !== undefined) {
            BlockAlignment.encode(message.alignment, writer.uint32(34).fork()).ldelim();
        }
        if (message.padding !== undefined) {
            writer.uint32(40).int32(message.padding);
        }
        if (message.gap !== undefined) {
            writer.uint32(48).int32(message.gap);
        }
        if (message.border !== undefined) {
            BlockBorder.encode(message.border, writer.uint32(58).fork()).ldelim();
        }
        if (message.cornerRadius !== undefined) {
            writer.uint32(64).int32(message.cornerRadius);
        }
        if (message.backgroundColor !== undefined) {
            writer.uint32(74).string(message.backgroundColor);
        }
        if (message.backgroundColors !== undefined) {
            BlockColor.encode(message.backgroundColors, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_Stack();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.direction = reader.int32();
                    break;
                case 2:
                    message.children.push(Block.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.reverse = reader.bool();
                    break;
                case 4:
                    message.alignment = BlockAlignment.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.padding = reader.int32();
                    break;
                case 6:
                    message.gap = reader.int32();
                    break;
                case 7:
                    message.border = BlockBorder.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.cornerRadius = reader.int32();
                    break;
                case 9:
                    message.backgroundColor = reader.string();
                    break;
                case 10:
                    message.backgroundColors = BlockColor.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            direction: isSet(object.direction) ? blockStackDirectionFromJSON(object.direction) : 0,
            children: Array.isArray(object?.children) ? object.children.map((e) => Block.fromJSON(e)) : [],
            reverse: isSet(object.reverse) ? Boolean(object.reverse) : undefined,
            alignment: isSet(object.alignment) ? BlockAlignment.fromJSON(object.alignment) : undefined,
            padding: isSet(object.padding) ? blockPaddingFromJSON(object.padding) : undefined,
            gap: isSet(object.gap) ? blockGapFromJSON(object.gap) : undefined,
            border: isSet(object.border) ? BlockBorder.fromJSON(object.border) : undefined,
            cornerRadius: isSet(object.cornerRadius) ? blockRadiusFromJSON(object.cornerRadius) : undefined,
            backgroundColor: isSet(object.backgroundColor) ? String(object.backgroundColor) : undefined,
            backgroundColors: isSet(object.backgroundColors) ? BlockColor.fromJSON(object.backgroundColors) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.direction !== undefined && (obj.direction = blockStackDirectionToJSON(message.direction));
        if (message.children) {
            obj.children = message.children.map((e) => e ? Block.toJSON(e) : undefined);
        }
        else {
            obj.children = [];
        }
        message.reverse !== undefined && (obj.reverse = message.reverse);
        message.alignment !== undefined &&
            (obj.alignment = message.alignment ? BlockAlignment.toJSON(message.alignment) : undefined);
        message.padding !== undefined &&
            (obj.padding = message.padding !== undefined ? blockPaddingToJSON(message.padding) : undefined);
        message.gap !== undefined && (obj.gap = message.gap !== undefined ? blockGapToJSON(message.gap) : undefined);
        message.border !== undefined && (obj.border = message.border ? BlockBorder.toJSON(message.border) : undefined);
        message.cornerRadius !== undefined &&
            (obj.cornerRadius = message.cornerRadius !== undefined ? blockRadiusToJSON(message.cornerRadius) : undefined);
        message.backgroundColor !== undefined && (obj.backgroundColor = message.backgroundColor);
        message.backgroundColors !== undefined &&
            (obj.backgroundColors = message.backgroundColors ? BlockColor.toJSON(message.backgroundColors) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_Stack();
        message.direction = object.direction ?? 0;
        message.children = object.children?.map((e) => Block.fromPartial(e)) || [];
        message.reverse = object.reverse ?? undefined;
        message.alignment = (object.alignment !== undefined && object.alignment !== null)
            ? BlockAlignment.fromPartial(object.alignment)
            : undefined;
        message.padding = object.padding ?? undefined;
        message.gap = object.gap ?? undefined;
        message.border = (object.border !== undefined && object.border !== null)
            ? BlockBorder.fromPartial(object.border)
            : undefined;
        message.cornerRadius = object.cornerRadius ?? undefined;
        message.backgroundColor = object.backgroundColor ?? undefined;
        message.backgroundColors = (object.backgroundColors !== undefined && object.backgroundColors !== null)
            ? BlockColor.fromPartial(object.backgroundColors)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Stack", BlockConfig_Stack);
function createBaseBlockConfig_Text() {
    return {
        text: "",
        size: undefined,
        weight: undefined,
        color: undefined,
        alignment: undefined,
        outline: undefined,
        style: undefined,
        selectable: undefined,
        colors: undefined,
        wrap: undefined,
        overflow: undefined,
    };
}
export const BlockConfig_Text = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Text",
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== "") {
            writer.uint32(10).string(message.text);
        }
        if (message.size !== undefined) {
            writer.uint32(16).int32(message.size);
        }
        if (message.weight !== undefined) {
            writer.uint32(24).int32(message.weight);
        }
        if (message.color !== undefined) {
            writer.uint32(34).string(message.color);
        }
        if (message.alignment !== undefined) {
            BlockAlignment.encode(message.alignment, writer.uint32(42).fork()).ldelim();
        }
        if (message.outline !== undefined) {
            writer.uint32(48).int32(message.outline);
        }
        if (message.style !== undefined) {
            writer.uint32(56).int32(message.style);
        }
        if (message.selectable !== undefined) {
            writer.uint32(64).bool(message.selectable);
        }
        if (message.colors !== undefined) {
            BlockColor.encode(message.colors, writer.uint32(74).fork()).ldelim();
        }
        if (message.wrap !== undefined) {
            writer.uint32(80).bool(message.wrap);
        }
        if (message.overflow !== undefined) {
            writer.uint32(88).int32(message.overflow);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_Text();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    message.size = reader.int32();
                    break;
                case 3:
                    message.weight = reader.int32();
                    break;
                case 4:
                    message.color = reader.string();
                    break;
                case 5:
                    message.alignment = BlockAlignment.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.outline = reader.int32();
                    break;
                case 7:
                    message.style = reader.int32();
                    break;
                case 8:
                    message.selectable = reader.bool();
                    break;
                case 9:
                    message.colors = BlockColor.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.wrap = reader.bool();
                    break;
                case 11:
                    message.overflow = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            text: isSet(object.text) ? String(object.text) : "",
            size: isSet(object.size) ? blockTextSizeFromJSON(object.size) : undefined,
            weight: isSet(object.weight) ? blockTextWeightFromJSON(object.weight) : undefined,
            color: isSet(object.color) ? String(object.color) : undefined,
            alignment: isSet(object.alignment) ? BlockAlignment.fromJSON(object.alignment) : undefined,
            outline: isSet(object.outline) ? blockTextOutlineFromJSON(object.outline) : undefined,
            style: isSet(object.style) ? blockTextStyleFromJSON(object.style) : undefined,
            selectable: isSet(object.selectable) ? Boolean(object.selectable) : undefined,
            colors: isSet(object.colors) ? BlockColor.fromJSON(object.colors) : undefined,
            wrap: isSet(object.wrap) ? Boolean(object.wrap) : undefined,
            overflow: isSet(object.overflow) ? blockTextOverflowFromJSON(object.overflow) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.text !== undefined && (obj.text = message.text);
        message.size !== undefined &&
            (obj.size = message.size !== undefined ? blockTextSizeToJSON(message.size) : undefined);
        message.weight !== undefined &&
            (obj.weight = message.weight !== undefined ? blockTextWeightToJSON(message.weight) : undefined);
        message.color !== undefined && (obj.color = message.color);
        message.alignment !== undefined &&
            (obj.alignment = message.alignment ? BlockAlignment.toJSON(message.alignment) : undefined);
        message.outline !== undefined &&
            (obj.outline = message.outline !== undefined ? blockTextOutlineToJSON(message.outline) : undefined);
        message.style !== undefined &&
            (obj.style = message.style !== undefined ? blockTextStyleToJSON(message.style) : undefined);
        message.selectable !== undefined && (obj.selectable = message.selectable);
        message.colors !== undefined && (obj.colors = message.colors ? BlockColor.toJSON(message.colors) : undefined);
        message.wrap !== undefined && (obj.wrap = message.wrap);
        message.overflow !== undefined &&
            (obj.overflow = message.overflow !== undefined ? blockTextOverflowToJSON(message.overflow) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_Text();
        message.text = object.text ?? "";
        message.size = object.size ?? undefined;
        message.weight = object.weight ?? undefined;
        message.color = object.color ?? undefined;
        message.alignment = (object.alignment !== undefined && object.alignment !== null)
            ? BlockAlignment.fromPartial(object.alignment)
            : undefined;
        message.outline = object.outline ?? undefined;
        message.style = object.style ?? undefined;
        message.selectable = object.selectable ?? undefined;
        message.colors = (object.colors !== undefined && object.colors !== null)
            ? BlockColor.fromPartial(object.colors)
            : undefined;
        message.wrap = object.wrap ?? undefined;
        message.overflow = object.overflow ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Text", BlockConfig_Text);
function createBaseBlockConfig_Button() {
    return {
        text: undefined,
        icon: undefined,
        buttonSize: undefined,
        buttonAppearance: undefined,
        textColor: undefined,
        backgroundColor: undefined,
        disabled: undefined,
        textColors: undefined,
        backgroundColors: undefined,
    };
}
export const BlockConfig_Button = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Button",
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== undefined) {
            writer.uint32(10).string(message.text);
        }
        if (message.icon !== undefined) {
            writer.uint32(18).string(message.icon);
        }
        if (message.buttonSize !== undefined) {
            writer.uint32(24).int32(message.buttonSize);
        }
        if (message.buttonAppearance !== undefined) {
            writer.uint32(32).int32(message.buttonAppearance);
        }
        if (message.textColor !== undefined) {
            writer.uint32(42).string(message.textColor);
        }
        if (message.backgroundColor !== undefined) {
            writer.uint32(50).string(message.backgroundColor);
        }
        if (message.disabled !== undefined) {
            writer.uint32(56).bool(message.disabled);
        }
        if (message.textColors !== undefined) {
            BlockColor.encode(message.textColors, writer.uint32(66).fork()).ldelim();
        }
        if (message.backgroundColors !== undefined) {
            BlockColor.encode(message.backgroundColors, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_Button();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    message.icon = reader.string();
                    break;
                case 3:
                    message.buttonSize = reader.int32();
                    break;
                case 4:
                    message.buttonAppearance = reader.int32();
                    break;
                case 5:
                    message.textColor = reader.string();
                    break;
                case 6:
                    message.backgroundColor = reader.string();
                    break;
                case 7:
                    message.disabled = reader.bool();
                    break;
                case 8:
                    message.textColors = BlockColor.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.backgroundColors = BlockColor.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            text: isSet(object.text) ? String(object.text) : undefined,
            icon: isSet(object.icon) ? String(object.icon) : undefined,
            buttonSize: isSet(object.buttonSize) ? blockButtonSizeFromJSON(object.buttonSize) : undefined,
            buttonAppearance: isSet(object.buttonAppearance)
                ? blockButtonAppearanceFromJSON(object.buttonAppearance)
                : undefined,
            textColor: isSet(object.textColor) ? String(object.textColor) : undefined,
            backgroundColor: isSet(object.backgroundColor) ? String(object.backgroundColor) : undefined,
            disabled: isSet(object.disabled) ? Boolean(object.disabled) : undefined,
            textColors: isSet(object.textColors) ? BlockColor.fromJSON(object.textColors) : undefined,
            backgroundColors: isSet(object.backgroundColors) ? BlockColor.fromJSON(object.backgroundColors) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.text !== undefined && (obj.text = message.text);
        message.icon !== undefined && (obj.icon = message.icon);
        message.buttonSize !== undefined &&
            (obj.buttonSize = message.buttonSize !== undefined ? blockButtonSizeToJSON(message.buttonSize) : undefined);
        message.buttonAppearance !== undefined && (obj.buttonAppearance = message.buttonAppearance !== undefined
            ? blockButtonAppearanceToJSON(message.buttonAppearance)
            : undefined);
        message.textColor !== undefined && (obj.textColor = message.textColor);
        message.backgroundColor !== undefined && (obj.backgroundColor = message.backgroundColor);
        message.disabled !== undefined && (obj.disabled = message.disabled);
        message.textColors !== undefined &&
            (obj.textColors = message.textColors ? BlockColor.toJSON(message.textColors) : undefined);
        message.backgroundColors !== undefined &&
            (obj.backgroundColors = message.backgroundColors ? BlockColor.toJSON(message.backgroundColors) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_Button();
        message.text = object.text ?? undefined;
        message.icon = object.icon ?? undefined;
        message.buttonSize = object.buttonSize ?? undefined;
        message.buttonAppearance = object.buttonAppearance ?? undefined;
        message.textColor = object.textColor ?? undefined;
        message.backgroundColor = object.backgroundColor ?? undefined;
        message.disabled = object.disabled ?? undefined;
        message.textColors = (object.textColors !== undefined && object.textColors !== null)
            ? BlockColor.fromPartial(object.textColors)
            : undefined;
        message.backgroundColors = (object.backgroundColors !== undefined && object.backgroundColors !== null)
            ? BlockColor.fromPartial(object.backgroundColors)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Button", BlockConfig_Button);
function createBaseBlockConfig_Image() {
    return { url: "", width: 0, height: 0, description: undefined, resizeMode: undefined };
}
export const BlockConfig_Image = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Image",
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        if (message.width !== 0) {
            writer.uint32(16).int32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(24).int32(message.height);
        }
        if (message.description !== undefined) {
            writer.uint32(34).string(message.description);
        }
        if (message.resizeMode !== undefined) {
            writer.uint32(40).int32(message.resizeMode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_Image();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.width = reader.int32();
                    break;
                case 3:
                    message.height = reader.int32();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    message.resizeMode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            url: isSet(object.url) ? String(object.url) : "",
            width: isSet(object.width) ? Number(object.width) : 0,
            height: isSet(object.height) ? Number(object.height) : 0,
            description: isSet(object.description) ? String(object.description) : undefined,
            resizeMode: isSet(object.resizeMode) ? blockImageResizeModeFromJSON(object.resizeMode) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        message.width !== undefined && (obj.width = Math.round(message.width));
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.description !== undefined && (obj.description = message.description);
        message.resizeMode !== undefined &&
            (obj.resizeMode = message.resizeMode !== undefined ? blockImageResizeModeToJSON(message.resizeMode) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_Image();
        message.url = object.url ?? "";
        message.width = object.width ?? 0;
        message.height = object.height ?? 0;
        message.description = object.description ?? undefined;
        message.resizeMode = object.resizeMode ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Image", BlockConfig_Image);
function createBaseBlockConfig_Spacer() {
    return { size: undefined, shape: undefined };
}
export const BlockConfig_Spacer = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Spacer",
    encode(message, writer = _m0.Writer.create()) {
        if (message.size !== undefined) {
            writer.uint32(8).int32(message.size);
        }
        if (message.shape !== undefined) {
            writer.uint32(16).int32(message.shape);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_Spacer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.size = reader.int32();
                    break;
                case 2:
                    message.shape = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            size: isSet(object.size) ? blockSpacerSizeFromJSON(object.size) : undefined,
            shape: isSet(object.shape) ? blockSpacerShapeFromJSON(object.shape) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.size !== undefined &&
            (obj.size = message.size !== undefined ? blockSpacerSizeToJSON(message.size) : undefined);
        message.shape !== undefined &&
            (obj.shape = message.shape !== undefined ? blockSpacerShapeToJSON(message.shape) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_Spacer();
        message.size = object.size ?? undefined;
        message.shape = object.shape ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Spacer", BlockConfig_Spacer);
function createBaseBlockConfig_Icon() {
    return { icon: "", color: undefined, size: undefined, colors: undefined };
}
export const BlockConfig_Icon = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Icon",
    encode(message, writer = _m0.Writer.create()) {
        if (message.icon !== "") {
            writer.uint32(10).string(message.icon);
        }
        if (message.color !== undefined) {
            writer.uint32(18).string(message.color);
        }
        if (message.size !== undefined) {
            writer.uint32(24).int32(message.size);
        }
        if (message.colors !== undefined) {
            BlockColor.encode(message.colors, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_Icon();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.icon = reader.string();
                    break;
                case 2:
                    message.color = reader.string();
                    break;
                case 3:
                    message.size = reader.int32();
                    break;
                case 4:
                    message.colors = BlockColor.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            icon: isSet(object.icon) ? String(object.icon) : "",
            color: isSet(object.color) ? String(object.color) : undefined,
            size: isSet(object.size) ? blockIconSizeFromJSON(object.size) : undefined,
            colors: isSet(object.colors) ? BlockColor.fromJSON(object.colors) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.icon !== undefined && (obj.icon = message.icon);
        message.color !== undefined && (obj.color = message.color);
        message.size !== undefined &&
            (obj.size = message.size !== undefined ? blockIconSizeToJSON(message.size) : undefined);
        message.colors !== undefined && (obj.colors = message.colors ? BlockColor.toJSON(message.colors) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_Icon();
        message.icon = object.icon ?? "";
        message.color = object.color ?? undefined;
        message.size = object.size ?? undefined;
        message.colors = (object.colors !== undefined && object.colors !== null)
            ? BlockColor.fromPartial(object.colors)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Icon", BlockConfig_Icon);
function createBaseBlockConfig_Avatar() {
    return { thingId: "", facing: undefined, size: undefined, background: undefined };
}
export const BlockConfig_Avatar = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Avatar",
    encode(message, writer = _m0.Writer.create()) {
        if (message.thingId !== "") {
            writer.uint32(10).string(message.thingId);
        }
        if (message.facing !== undefined) {
            writer.uint32(16).int32(message.facing);
        }
        if (message.size !== undefined) {
            writer.uint32(24).int32(message.size);
        }
        if (message.background !== undefined) {
            writer.uint32(32).int32(message.background);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_Avatar();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.thingId = reader.string();
                    break;
                case 2:
                    message.facing = reader.int32();
                    break;
                case 3:
                    message.size = reader.int32();
                    break;
                case 4:
                    message.background = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            thingId: isSet(object.thingId) ? String(object.thingId) : "",
            facing: isSet(object.facing) ? blockAvatarFacingFromJSON(object.facing) : undefined,
            size: isSet(object.size) ? blockAvatarSizeFromJSON(object.size) : undefined,
            background: isSet(object.background) ? blockAvatarBackgroundFromJSON(object.background) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.thingId !== undefined && (obj.thingId = message.thingId);
        message.facing !== undefined &&
            (obj.facing = message.facing !== undefined ? blockAvatarFacingToJSON(message.facing) : undefined);
        message.size !== undefined &&
            (obj.size = message.size !== undefined ? blockAvatarSizeToJSON(message.size) : undefined);
        message.background !== undefined &&
            (obj.background = message.background !== undefined ? blockAvatarBackgroundToJSON(message.background) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_Avatar();
        message.thingId = object.thingId ?? "";
        message.facing = object.facing ?? undefined;
        message.size = object.size ?? undefined;
        message.background = object.background ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Avatar", BlockConfig_Avatar);
function createBaseBlockConfig_FullSnoo() {
    return { userId: "", facing: undefined, size: undefined };
}
export const BlockConfig_FullSnoo = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.FullSnoo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.facing !== undefined) {
            writer.uint32(16).int32(message.facing);
        }
        if (message.size !== undefined) {
            writer.uint32(24).int32(message.size);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_FullSnoo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.facing = reader.int32();
                    break;
                case 3:
                    message.size = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            userId: isSet(object.userId) ? String(object.userId) : "",
            facing: isSet(object.facing) ? blockAvatarFacingFromJSON(object.facing) : undefined,
            size: isSet(object.size) ? blockFullSnooSizeFromJSON(object.size) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.userId !== undefined && (obj.userId = message.userId);
        message.facing !== undefined &&
            (obj.facing = message.facing !== undefined ? blockAvatarFacingToJSON(message.facing) : undefined);
        message.size !== undefined &&
            (obj.size = message.size !== undefined ? blockFullSnooSizeToJSON(message.size) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_FullSnoo();
        message.userId = object.userId ?? "";
        message.facing = object.facing ?? undefined;
        message.size = object.size ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.FullSnoo", BlockConfig_FullSnoo);
function createBaseBlockConfig_Animation() {
    return {
        url: "",
        width: 0,
        height: 0,
        type: 0,
        loop: undefined,
        loopMode: undefined,
        autoplay: undefined,
        speed: undefined,
        direction: undefined,
    };
}
export const BlockConfig_Animation = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Animation",
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        if (message.width !== 0) {
            writer.uint32(16).int32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(24).int32(message.height);
        }
        if (message.type !== 0) {
            writer.uint32(32).int32(message.type);
        }
        if (message.loop !== undefined) {
            writer.uint32(40).bool(message.loop);
        }
        if (message.loopMode !== undefined) {
            writer.uint32(48).int32(message.loopMode);
        }
        if (message.autoplay !== undefined) {
            writer.uint32(56).bool(message.autoplay);
        }
        if (message.speed !== undefined) {
            writer.uint32(69).float(message.speed);
        }
        if (message.direction !== undefined) {
            writer.uint32(72).int32(message.direction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_Animation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.width = reader.int32();
                    break;
                case 3:
                    message.height = reader.int32();
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                case 5:
                    message.loop = reader.bool();
                    break;
                case 6:
                    message.loopMode = reader.int32();
                    break;
                case 7:
                    message.autoplay = reader.bool();
                    break;
                case 8:
                    message.speed = reader.float();
                    break;
                case 9:
                    message.direction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            url: isSet(object.url) ? String(object.url) : "",
            width: isSet(object.width) ? Number(object.width) : 0,
            height: isSet(object.height) ? Number(object.height) : 0,
            type: isSet(object.type) ? blockAnimationTypeFromJSON(object.type) : 0,
            loop: isSet(object.loop) ? Boolean(object.loop) : undefined,
            loopMode: isSet(object.loopMode) ? blockAnimationLoopModeFromJSON(object.loopMode) : undefined,
            autoplay: isSet(object.autoplay) ? Boolean(object.autoplay) : undefined,
            speed: isSet(object.speed) ? Number(object.speed) : undefined,
            direction: isSet(object.direction) ? blockAnimationDirectionFromJSON(object.direction) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        message.width !== undefined && (obj.width = Math.round(message.width));
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.type !== undefined && (obj.type = blockAnimationTypeToJSON(message.type));
        message.loop !== undefined && (obj.loop = message.loop);
        message.loopMode !== undefined &&
            (obj.loopMode = message.loopMode !== undefined ? blockAnimationLoopModeToJSON(message.loopMode) : undefined);
        message.autoplay !== undefined && (obj.autoplay = message.autoplay);
        message.speed !== undefined && (obj.speed = message.speed);
        message.direction !== undefined &&
            (obj.direction = message.direction !== undefined ? blockAnimationDirectionToJSON(message.direction) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_Animation();
        message.url = object.url ?? "";
        message.width = object.width ?? 0;
        message.height = object.height ?? 0;
        message.type = object.type ?? 0;
        message.loop = object.loop ?? undefined;
        message.loopMode = object.loopMode ?? undefined;
        message.autoplay = object.autoplay ?? undefined;
        message.speed = object.speed ?? undefined;
        message.direction = object.direction ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Animation", BlockConfig_Animation);
function createBaseBlockConfig_WebView() {
    return { url: "" };
}
export const BlockConfig_WebView = {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.WebView",
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockConfig_WebView();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { url: isSet(object.url) ? String(object.url) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockConfig_WebView();
        message.url = object.url ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.WebView", BlockConfig_WebView);
function isSet(value) {
    return value !== null && value !== undefined;
}
