var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ConsoleLogger_logger;
import { Severity, } from '@devvit/protos';
import { Log } from '../../lib/loggers/Log.js';
// to-do: Log either needs to be more easily configurable, probably dynamically,
// or ConsoleLogger shouldn't use it. Users want to be enable their own verbose
// logs irrespective of the rest of the system.
export const defaultConsole = Log;
export const voidConsole = Object.freeze({
    debug() { },
    error() { },
    info() { },
    verbose() { },
    warn() { },
});
const levelBySeverity = Object.freeze({
    [Severity.DEBUG]: 'debug',
    [Severity.ERROR]: 'error',
    [Severity.INFO]: 'info',
    [Severity.UNRECOGNIZED]: 'info',
    [Severity.VERBOSE]: 'verbose',
    [Severity.WARN]: 'warn',
});
/** Console API-ish logger plugin. */
export class ConsoleLogger {
    constructor(logger = defaultConsole) {
        _ConsoleLogger_logger.set(this, void 0);
        __classPrivateFieldSet(this, _ConsoleLogger_logger, logger, "f");
    }
    async Error(log) {
        const origin = [
            log.lineNumber == null ? undefined : `line ${log.lineNumber}`,
            log.columnNumber == null ? undefined : `column ${log.columnNumber}`,
            log.fileName == null ? undefined : `file ${log.fileName}`,
        ]
            .filter(Boolean)
            .join(', ');
        const str = [`${log.name}; ${log.message}`, origin, log.stack].filter(Boolean).join('\n');
        // to-do: Don't use Log here. Someone needs to tack on the hostname since
        // ConsoleLogger usually runs in the main thread.
        __classPrivateFieldGet(this, _ConsoleLogger_logger, "f").error(str);
        return {};
    }
    async Event() {
        // Event logging is too chatty for even verbose. Don't print to console.
        return {};
    }
    async Log(log) {
        const level = levelBySeverity[log.severity];
        __classPrivateFieldGet(this, _ConsoleLogger_logger, "f")[level](log.message);
        return {};
    }
}
_ConsoleLogger_logger = new WeakMap();
