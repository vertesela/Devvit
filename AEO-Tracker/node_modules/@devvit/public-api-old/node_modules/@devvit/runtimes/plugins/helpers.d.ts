import { Metadata } from '@devvit/protos';
import { JSONValue } from '@devvit/shared-types/json.js';
import { Interceptable } from 'undici';
type ExpectedObj = {
    path: string;
    method: string;
    expectedBody?: JSONValue;
    expectedError?: string;
    status?: number;
    error?: JSONValue | null;
};
export declare function mockPath(pool: Interceptable, expectedObj: ExpectedObj): any;
export declare function getNestedProp(root: any, propName: string): any;
export declare function getMetadata(withAuth?: boolean): Metadata;
/**
 * @param headers - The headers object from the request
 * @param key - The header key to get. This function tries to be case-insensitive, so it will
 *             try to find the header key first using the original case, and if that fails,
 *             it will try again using the lower case version of the key.
 */
export declare function getHeader(headers: Record<string, string> | string[], key: string): string;
export declare function decodeAndParse(arr: Uint8Array): Object;
export declare function decodeAndParseFormData(arr: Uint8Array): Object;
/**
 * Undici's Interceptable.intercept() method arguments define `path` as string | RegEx | Function
 * to give different levels of control over how paths are intercepted and mocked. Since raw_json=1
 * is dynamically added to every API request the exact string matcher no longer works since
 * /foo != /foo?raw_json=1.  Each API has a concrete path but variable query parameters, so we
 * can safely match on just the path by stripping the query parameters off before comparing.
 */
export declare function pathMatcher(expectedPath: string): (path: string) => boolean;
export {};
//# sourceMappingURL=helpers.d.ts.map