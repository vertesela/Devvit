var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DependencyGraph_children, _DependencyGraph_parents, _DependencyGraph_getChildren, _DependencyGraph_getID;
export class DependencyGraph {
    constructor(idFunc, childrenFunc) {
        _DependencyGraph_children.set(this, void 0);
        _DependencyGraph_parents.set(this, void 0);
        _DependencyGraph_getChildren.set(this, void 0);
        _DependencyGraph_getID.set(this, void 0);
        __classPrivateFieldSet(this, _DependencyGraph_getID, idFunc, "f");
        __classPrivateFieldSet(this, _DependencyGraph_getChildren, childrenFunc, "f");
        __classPrivateFieldSet(this, _DependencyGraph_children, {}, "f");
        __classPrivateFieldSet(this, _DependencyGraph_parents, {}, "f");
    }
    addNode(element, parent) {
        var _a;
        const elementID = __classPrivateFieldGet(this, _DependencyGraph_getID, "f").call(this, element);
        const children = __classPrivateFieldGet(this, _DependencyGraph_getChildren, "f").call(this, element);
        // If the element is already present, there's nothing new to load
        if (__classPrivateFieldGet(this, _DependencyGraph_parents, "f")[elementID]) {
            if (parent != null) {
                __classPrivateFieldGet(this, _DependencyGraph_parents, "f")[elementID].add(parent);
            }
            return new Set();
        }
        const nodesAdded = children.reduce((added, node) => {
            return new Set([...added, ...this.addNode(node, elementID)]);
        }, new Set([element]));
        __classPrivateFieldGet(this, _DependencyGraph_children, "f")[elementID] = new Set(children.map(__classPrivateFieldGet(this, _DependencyGraph_getID, "f")));
        (_a = __classPrivateFieldGet(this, _DependencyGraph_parents, "f"))[elementID] ?? (_a[elementID] = new Set());
        if (parent) {
            __classPrivateFieldGet(this, _DependencyGraph_parents, "f")[elementID].add(parent);
        }
        return nodesAdded;
    }
    has(id) {
        return !!__classPrivateFieldGet(this, _DependencyGraph_parents, "f")[id];
    }
    size() {
        return Object.keys(__classPrivateFieldGet(this, _DependencyGraph_parents, "f")).length;
    }
    deleteRoots(roots) {
        return [...roots].reduce((deleted, root) => {
            return new Set([...deleted, ...this.deleteNode(root)]);
        }, new Set());
    }
    findRoots(id) {
        // Navigate up to roots from `id`
        // TODO: This will currently not work with cyclic families.
        // - e.g. A -> B -> C -> A
        const roots = new Set();
        const ancestors = [id];
        while (ancestors.length > 0) {
            const currentHostname = ancestors.shift();
            const parents = __classPrivateFieldGet(this, _DependencyGraph_parents, "f")[currentHostname];
            if (parents) {
                if (parents.size === 0) {
                    roots.add(currentHostname);
                }
                else {
                    ancestors.push(...parents);
                }
            }
        }
        return roots;
    }
    deleteNode(id) {
        const parents = __classPrivateFieldGet(this, _DependencyGraph_parents, "f")[id];
        for (const parent of parents) {
            __classPrivateFieldGet(this, _DependencyGraph_children, "f")[parent].delete(id);
        }
        // Traverse down the tree and store a de-duped set of all ids as `entries`
        const entries = new Set();
        const descendants = [id];
        while (descendants.length > 0) {
            const currentID = descendants.shift();
            if (!entries.has(currentID)) {
                descendants.push(...[...(__classPrivateFieldGet(this, _DependencyGraph_children, "f")[currentID] ?? [])].filter((childID) => {
                    // Delete the child's parent entry for the current ID
                    __classPrivateFieldGet(this, _DependencyGraph_parents, "f")[childID]?.delete(currentID);
                    // Only delete if there are no parents
                    return __classPrivateFieldGet(this, _DependencyGraph_parents, "f")[childID].size === 0;
                }));
                entries.add(currentID);
            }
        }
        // Extract and return only entries with all parents in the list of entries
        return new Set([...entries].map((e) => {
            delete __classPrivateFieldGet(this, _DependencyGraph_parents, "f")[e];
            delete __classPrivateFieldGet(this, _DependencyGraph_children, "f")[e];
            return e;
        }));
    }
}
_DependencyGraph_children = new WeakMap(), _DependencyGraph_parents = new WeakMap(), _DependencyGraph_getChildren = new WeakMap(), _DependencyGraph_getID = new WeakMap();
