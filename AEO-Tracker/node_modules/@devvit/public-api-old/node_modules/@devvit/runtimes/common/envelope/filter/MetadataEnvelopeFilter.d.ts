import { Envelope, Metadata } from '@devvit/protos';
import { Disposer } from 'lru-cache';
import { Namespace } from '../Namespace.js';
import { EnvelopeFilter } from './EnvelopeFilter.js';
interface MetadataStoreRecord {
    /** The aggregated metadata for downstream requests. */
    readonly metadata: Readonly<Metadata>;
    /** (Debugging) Most recently set envelope. */
    readonly log: string;
}
/**
 * Metadata mutations for all filtered envelopes.
 *
 * It's usually correct to transform envelopes in a filter, not the
 * CentralDispatcher. In native runtimes, the only envelopes that pass through
 * the dispatcher are 1) unfiltered envelopes from the runtime for the
 * supervisor like Load/Unload(), and 2) envelopes to be filtered. For 2, these
 * are Envelopes that arrive in the CentralDispatcher as Envelopes wrapped in
 * Envelopes! In this case, the Envelope we actually care about transforming is
 * the payload, but the changes the CentralDispatcher makes like setting the
 * Envelope.id only apply to the outer Envelope, not the wrapped inner payload.
 */
export declare class MetadataEnvelopeFilter implements EnvelopeFilter {
    #private;
    constructor(namespace: Readonly<Namespace>, onStoreEvicting?: Disposer<string, MetadataStoreRecord>, size?: number);
    filter(envelope: Envelope): Promise<Envelope>;
}
export {};
//# sourceMappingURL=MetadataEnvelopeFilter.d.ts.map