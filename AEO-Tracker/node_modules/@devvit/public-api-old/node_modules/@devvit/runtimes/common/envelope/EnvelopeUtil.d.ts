import { Definition, Envelope, Metadata, MethodDefinition, UnknownMessage } from '@devvit/protos';
import { JSONValue } from '@devvit/shared-types/json.js';
import { Observer } from 'rxjs';
/**
 * Debug-only assertion for identifying envelopes that would fail a
 * [structured clone] in Worker.postMessage(). The dispatcher does not use
 * [transferrable objects] for [postMessage() transfers] any yet.
 *
 * A failing envelope is likely due to an `any` typed Envelope.message (eg, due
 * to compounding interactions with JSON.parse(), Object.values(), `as any`,
 * etc).
 *
 * postMessage() failures usually look like:
 *
 * ```
 * DOMException [DataCloneError]: encode(message, writer = _m0.Writer.create()) {
 *     if (message.severity !== 0) {
 *       writer.uint32...<omitted>... } could not be cloned.
 *   at Worker.postMessage (node:internal/worker:341:5)
 * ```
 *
 * [structured clone]: https://developer.mozilla.org/en-US/docs/Web/API/structuredClone
 * [transferrable objects]: https://developer.mozilla.org/en-US/docs/Glossary/Transferable_objects
 * [postMessage() transfers]: https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage#parameters
 */
export declare function assertEnvelopePostable(envelope: Readonly<Envelope>): void;
export declare function envelopeAsError(envelope: Envelope): Error;
/**
 * Gets a value from metadata
 */
export declare function getFromMetadata(key: string, metadata: Metadata | undefined): string | undefined;
export declare function extractMetadataTraceID(metadata: Metadata | undefined): string | undefined;
export declare function envelopeMethod<T extends Definition>(def: T, name: keyof T['methods'] & string): string;
/**
 * Return the method's `name` from an Envelope's `method`
 * @see {@link MethodDefinition.name}
 * @see {@link Envelope.method}
 * @param envelope
 */
export declare function envelopeMethodToName(envelope: Envelope): string;
/**
 * Return the service's `fullName` from an Envelope's `method`
 * @see {@link Definition.fullName}
 * @see {@link Envelope.method}
 * @param envelope
 */
export declare function envelopeMethodToServiceName(envelope: Envelope): string;
export declare function requestMessageToJSON(message: UnknownMessage, method: MethodDefinition): JSONValue | undefined;
export declare function responseMessageToJSON(message: UnknownMessage, method: MethodDefinition): JSONValue | undefined;
export declare function requestMessageFromJSON(envelope: Envelope, method: MethodDefinition): UnknownMessage | undefined;
export declare function responseMessageFromJSON(envelope: Envelope, method: MethodDefinition): UnknownMessage | undefined;
export declare function requestMessageToBinary(message: UnknownMessage, method: MethodDefinition): string | undefined;
export declare function requestMessageFromBinary(envelope: Envelope, method: MethodDefinition): UnknownMessage | undefined;
export declare function responseMessageToBinary(message: UnknownMessage, method: MethodDefinition): string | undefined;
export declare function responseMessageFromBinary(envelope: Envelope, method: MethodDefinition): UnknownMessage | undefined;
/**
 * Sends an envelope's message (Envelope.message) to a stream, usually a
 * subscriber.
 */
export declare function sendEnvelopeMessageToStream(envelope: Readonly<Envelope>, stream: Observer<UnknownMessage>): void;
export declare namespace EnvelopeUtil {
    /**
     * Format basic envelope identification for error messages. Includes source,
     * destination, truncated stream ID, and method-ish.
     *
     * The output of this function may be used in production logs. Do not print
     * sensitive information.
     *
     * This is not a stable API.
     */
    function toLogString(envelope: Readonly<Envelope>): string;
}
//# sourceMappingURL=EnvelopeUtil.d.ts.map