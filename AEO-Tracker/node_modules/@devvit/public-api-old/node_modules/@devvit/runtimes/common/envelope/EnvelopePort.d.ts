import { Envelope } from '@devvit/protos';
export type EnvelopeEvent = MessageEvent<Envelope>;
export type EnvelopeEventListener = (event: EnvelopeEvent) => void;
/**
 * A slightly more strongly typed version of a subset of the Worker and
 * MessagePort interface, usually a Window or a Worker.
 *
 * EnvelopePorts are constrained to be a subset of MessagePort as we cannot
 * alter Window or Worker implementations. Ports are expected to be in a started
 * state and never to be used as a message bus. That is, every EnvelopePort is
 * expected to have exactly one listener. If multiple listeners were to
 * subscribe to the same port, an infinite loop can be created where neither
 * listener knows how to resolve the other's Envelope destination and posts the
 * message back to the same port which invokes the other listener and the cycle
 * repeats.
 *
 * So long as only listener exists on the port, it is directional. Confusingly,
 * Worker is a channel that adheres to the MessagePort interface. When
 * Worker.addEventListener() is invoked from the main thread, it establishes one
 * distinct port on the Window side. When invoked from a Worker thread, another
 * distinct port on Worker side is created. Calling Worker.postMessage() on one
 * side is only listenable on the other and vice-versa. That is, messages don't
 * echo back to the poster because Worker is a channel with two ports, not a
 * bus.
 *
 * EnvelopeDispatchers are buses.
 *
 * terminate() is only present on some implementations such as Worker. Window
 * and MessagePort, for example, do not implement terminate().
 * MessagePort.close() is not currently advertised as this would close a Window
 * GUI.
 */
export interface EnvelopePort {
    postMessage(envelope: Envelope): void;
    onmessage: EnvelopeEventListener | null;
    terminate?(): void;
}
//# sourceMappingURL=EnvelopePort.d.ts.map