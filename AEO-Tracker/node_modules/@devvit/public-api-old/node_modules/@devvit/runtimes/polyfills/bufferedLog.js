/**
 * creates a logging function that writes into the given buffer with the following format:
 *
 * struct LogBuffer {
 *   uint32_t used_bytes;
 *   LogEntry entries[];
 * };
 *
 * struct LogEntry {
 *   LogType type;
 *   uint32_t entry_bytes;
 *   uint8_t utf8_bytes[];
 * };
 *
 * If the buffer is ever full, the log function calls the given "flush" function, which
 * is expected to process each entry in the buffer. After flush the buffer will be reset/reused
 *
 * If a single log message is too large for the entire buffer, the message will be truncated
 * to the largest size that the buffer can support.
 *
 * The function expects the flush function to be the rare case and optimizes for the non-flush
 * case.
 */
export const makeBufferedLogFunction = (buffer, flush) => {
    const encoder = new TextEncoder();
    return function log(type, logmsg, alreadyFlushed = false) {
        const data = new DataView(buffer);
        let logOffset = data.getUint32(0, true);
        // the buffer starts zero'd, but we have to at least store the offset itself
        if (logOffset < 4) {
            logOffset = 4;
        }
        // store the log type
        data.setUint8(logOffset, type);
        logOffset += 1;
        // Save some space to write the message size (in bytes)
        const sizeStoragePosition = logOffset;
        logOffset += 4;
        // store the message itself, encoding it as UTF-8
        const result = encoder.encodeInto(logmsg, new Uint8Array(buffer, logOffset));
        // check if the message was written entirely, if not, flush and try again
        if (result.read !== logmsg.length) {
            // retry after a flush
            if (!alreadyFlushed) {
                flush();
                data.setUint32(0, 0, true); // reset the buffer for further logging
                log(type, logmsg, true);
                return;
            }
            // in the rare case that a message is *still* too large after a flush,
            // it's too large for the buffer. We proceed and truncate the message
            // to whatever is currently written
        }
        // TODO: figure out when/how this is possible. Why can this field be undefined
        if (result.written == null) {
            throw Error('Unexpected');
        }
        // write the size back, increment the offset
        data.setUint32(sizeStoragePosition, result.written, true);
        logOffset += result.written;
        // complete the transaction by writing the log offset back into the buffer
        data.setUint32(0, logOffset, true);
    };
};
