import type { JSONValue, RedisClient } from '../../index.js';
export type CacheEntry = {
    value: JSONValue | null;
    expires: number;
    error: string | null;
    errorTime: number | null;
    checkedAt: number;
    errorCount: number;
};
export type Clock = {
    now(): Date;
};
export declare const SystemClock: Clock;
export type CacheOptions = {
    /**
     * Time to live in milliseconds.
     */
    ttl: number;
    /**
     * Key to use for caching.
     */
    key: string;
};
export type LocalCache = {
    [key: string]: CacheEntry;
};
export declare function _namespaced(key: string): string;
export declare function _lock(key: string): string;
export declare const retryLimit = 3;
export declare const clientRetryDelay = 1000;
export declare const allowStaleFor = 30000;
type WithLocalCache = {
    __cache?: LocalCache;
};
/**
 * Refactored out into a class to allow for easier testing and clarity of purpose.
 *
 * This class is responsible for managing the caching of promises. It is a layered cache, meaning it will first check
 * the local cache, then the redis cache, and finally the source of truth. It will also handle refreshing the cache according
 * to the TTL and error handling.
 *
 * Please note that in order to prevent a stampede of requests to the source of truth, we use a lock in redis to ensure only one
 * request is made to the source of truth at a time.  If the lock is obtained, the cache will be updated and the lock will be released.
 *
 * Additionally, we use a polling mechanism to fetch the cache if the lock is not obtained.  This is to prevent unnecessary errors.
 *
 * Finally, we also want to prevent stampedes against redis for the lock election and the retries.  We use a ramping probability to ease in the
 * attempts to get the lock, and not every error will trigger a retry.
 *
 * This means that the cache will be eventually consistent, but will not be immediately consistent. This is a tradeoff we are willing to make.
 * Additionally, this means that the TTL is not precice.  The cache may be updated a bit more often than the TTL, but it will not be updated less often.
 *
 */
export declare class PromiseCache {
    #private;
    constructor(redis: RedisClient, state: WithLocalCache, clock?: Clock);
    /**
     * This is the public API for the cache.  Call this method to cache a promise.
     *
     * @param closure
     * @param options
     * @returns
     */
    cache<T extends JSONValue>(closure: () => Promise<T>, options: CacheOptions): Promise<T>;
}
export {};
//# sourceMappingURL=promise_cache.d.ts.map