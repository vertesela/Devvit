import { BanInfo_BanInfoAction as BanInfo_BanInfoAction_2 } from '../../../reddit/common.js';
import { BlockActionType as BlockActionType_2 } from '../../../../../index.js';
import { BlockAnimationDirection as BlockAnimationDirection_2 } from '../../../../../index.js';
import { BlockAnimationLoopMode as BlockAnimationLoopMode_2 } from '../../../../../index.js';
import { BlockAnimationType as BlockAnimationType_2 } from '../../../../../index.js';
import { BlockAvatarBackground as BlockAvatarBackground_2 } from '../../../../../index.js';
import { BlockAvatarFacing as BlockAvatarFacing_2 } from '../../../../../index.js';
import { BlockAvatarSize as BlockAvatarSize_2 } from '../../../../../index.js';
import { BlockBorderWidth as BlockBorderWidth_2 } from '../../../../../index.js';
import { BlockButtonAppearance as BlockButtonAppearance_2 } from '../../../../../index.js';
import { BlockButtonSize as BlockButtonSize_2 } from '../../../../../index.js';
import { BlockFullSnooSize as BlockFullSnooSize_2 } from '../../../../../index.js';
import { BlockGap as BlockGap_2 } from '../../../../../index.js';
import { BlockHorizontalAlignment as BlockHorizontalAlignment_2 } from '../../../../../index.js';
import { BlockIconSize as BlockIconSize_2 } from '../../../../../index.js';
import { BlockImageResizeMode as BlockImageResizeMode_2 } from '../../../../../index.js';
import { BlockPadding as BlockPadding_2 } from '../../../../../index.js';
import { BlockRadius as BlockRadius_2 } from '../../../../../index.js';
import { BlockSizeUnit as BlockSizeUnit_2 } from '../../../../../index.js';
import { BlockSpacerShape as BlockSpacerShape_2 } from '../../../../../index.js';
import { BlockSpacerSize as BlockSpacerSize_2 } from '../../../../../index.js';
import { BlockStackDirection as BlockStackDirection_2 } from '../../../../../index.js';
import { BlockTextOutline as BlockTextOutline_2 } from '../../../../../index.js';
import { BlockTextOverflow as BlockTextOverflow_2 } from '../../../../../index.js';
import { BlockTextSize as BlockTextSize_2 } from '../../../../../index.js';
import { BlockTextStyle as BlockTextStyle_2 } from '../../../../../index.js';
import { BlockTextWeight as BlockTextWeight_2 } from '../../../../../index.js';
import { BlockType as BlockType_2 } from '../../../../../index.js';
import { BlockVerticalAlignment as BlockVerticalAlignment_2 } from '../../../../../index.js';
import { ConfigFieldType as ConfigFieldType_2 } from '../actor/user_configurable/user_configurable.js';
import { CrowdControlLevel as CrowdControlLevel_2 } from '../../../reddit/v2alpha/postv2.js';
import { CrowdControlLevel as CrowdControlLevel_3 } from '../../reddit/v2alpha/postv2.js';
import { DeletionReason as DeletionReason_2 } from '../../../events/v1alpha/events.js';
import { DeletionReason as DeletionReason_3 } from '../../events/v1alpha/events.js';
import { DistinguishType as DistinguishType_2 } from '../../../reddit/v2alpha/postv2.js';
import { DistinguishType as DistinguishType_3 } from '../../reddit/v2alpha/postv2.js';
import { EffectType as EffectType_2 } from '../../../ui/effects/v1alpha/effect.js';
import { EventSource as EventSource_3 } from '../../../events/v1alpha/events.js';
import { EventSource as EventSource_4 } from '../../events/v1alpha/events.js';
import { FormFieldType as FormFieldType_2 } from '../../../../../index.js';
import { InstallationType as InstallationType_2 } from '../../../../community.js';
import _m0 from 'protobufjs/minimal.js';
import { Minify as Minify_2 } from './buildpack_common.js';
import { Minify as Minify_3 } from '../buildpack/buildpack_common.js';
import { Observable } from 'rxjs';
import { RealtimeSubscriptionStatus as RealtimeSubscriptionStatus_2 } from '../../../../../index.js';
import { SubredditRating as SubredditRating_2 } from '../../../reddit/v2alpha/subredditv2.js';
import { SubredditRating as SubredditRating_3 } from '../../reddit/v2alpha/subredditv2.js';
import { SubredditType as SubredditType_3 } from '../../../reddit/v2alpha/subredditv2.js';
import { SubredditType as SubredditType_4 } from '../../reddit/v2alpha/subredditv2.js';
import { ThingType as ThingType_2 } from '../../reddit/thing_type.js';
import { ToastAppearance as ToastAppearance_2 } from '../../../ui/toast/toast.js';
import { UpgradeStrategy as UpgradeStrategy_2 } from '../../dev_portal/installation/installation.js';

declare interface AboutLocationRequest {
    /** thing id (e.g t1_15bfi0) */
    after?: string | undefined;
    /** thing id (e.g t1_15bfi0) */
    before?: string | undefined;
    count?: number | undefined;
    /** the maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    location: string;
    /** one of (links, comments, chat_comments) */
    only?: string | undefined;
    /** (optional) the string all */
    show?: string | undefined;
    /** subreddit name without the r/ */
    subreddit: string;
}

declare const AboutLocationRequest: {
    $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest";
    encode(message: AboutLocationRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AboutLocationRequest;
    fromJSON(object: any): AboutLocationRequest;
    toJSON(message: AboutLocationRequest): unknown;
    create(base?: DeepPartial_2<AboutLocationRequest>): AboutLocationRequest;
    fromPartial(object: DeepPartial_2<AboutLocationRequest>): AboutLocationRequest;
};

export declare enum AboutLocations {
    Reports = "reports",
    Spam = "spam",
    Modqueue = "modqueue",
    Unmoderated = "unmoderated",
    Edited = "edited"
}

/** Requests */
declare interface AboutLogRequest {
    /** a modaction thing uuid */
    after?: string | undefined;
    /** a modaction thing uuid */
    before?: string | undefined;
    count?: number | undefined;
    /** the maximum number of items desired (default: 25, maximum: 500) */
    limit?: number | undefined;
    /** (optional) the string all */
    show?: string | undefined;
    /** (optional) a moderator filter */
    mod?: string | undefined;
    /**
     * one of (banuser, unbanuser, spamlink, removelink, approvelink, spamcomment, removecomment,
     * approvecomment, addmoderator, showcomment, invitemoderator, uninvitemoderator,
     * acceptmoderatorinvite, removemoderator, addcontributor, removecontributor, editsettings,
     * editflair, distinguish, marknsfw, wikibanned, wikicontributor, wikiunbanned, wikipagelisted,
     * removewikicontributor, wikirevise, wikipermlevel, ignorereports, unignorereports,
     * setpermissions, setsuggestedsort, sticky, unsticky, setcontestmode, unsetcontestmode, lock,
     * unlock, muteuser, unmuteuser, createrule, editrule, reorderrules, deleterule, spoiler,
     * unspoiler, modmail_enrollment, community_styling, community_widgets, markoriginalcontent,
     * collections, events, hidden_award, add_community_topics, remove_community_topics,
     * create_scheduled_post, edit_scheduled_post, delete_scheduled_post, submit_scheduled_post,
     * edit_post_requirements, invitesubscriber, submit_content_rating_survey,
     * adjust_post_crowd_control_level, enable_post_crowd_control_filter,
     * disable_post_crowd_control_filter, deleteoverriddenclassification, overrideclassification,
     * reordermoderators, snoozereports, unsnoozereports, addnote, deletenote, addremovalreason,
     * createremovalreason, updateremovalreason, deleteremovalreason)
     */
    type?: string | undefined;
    /** subreddit name without the r/ */
    subreddit?: string | undefined;
}

declare const AboutLogRequest: {
    $type: "devvit.plugin.redditapi.moderation.AboutLogRequest";
    encode(message: AboutLogRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AboutLogRequest;
    fromJSON(object: any): AboutLogRequest;
    toJSON(message: AboutLogRequest): unknown;
    create(base?: DeepPartial_2<AboutLogRequest>): AboutLogRequest;
    fromPartial(object: DeepPartial_2<AboutLogRequest>): AboutLogRequest;
};

/** Responses */
declare interface AboutLogResponse {
    kind: string;
    data?: AboutLogResponse_AboutLogListing | undefined;
}

declare const AboutLogResponse: {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse";
    encode(message: AboutLogResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AboutLogResponse;
    fromJSON(object: any): AboutLogResponse;
    toJSON(message: AboutLogResponse): unknown;
    create(base?: DeepPartial_2<AboutLogResponse>): AboutLogResponse;
    fromPartial(object: DeepPartial_2<AboutLogResponse>): AboutLogResponse;
};

declare interface AboutLogResponse_AboutLogListing {
    after?: string | undefined;
    before?: string | undefined;
    children: AboutLogResponse_AboutLogListing_WrappedLogObject[];
    dist?: number | undefined;
}

declare const AboutLogResponse_AboutLogListing: {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing";
    encode(message: AboutLogResponse_AboutLogListing, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AboutLogResponse_AboutLogListing;
    fromJSON(object: any): AboutLogResponse_AboutLogListing;
    toJSON(message: AboutLogResponse_AboutLogListing): unknown;
    create(base?: DeepPartial_2<AboutLogResponse_AboutLogListing>): AboutLogResponse_AboutLogListing;
    fromPartial(object: DeepPartial_2<AboutLogResponse_AboutLogListing>): AboutLogResponse_AboutLogListing;
};

declare interface AboutLogResponse_AboutLogListing_WrappedLogObject {
    kind: string;
    data?: AboutLogResponse_LogObject | undefined;
}

declare const AboutLogResponse_AboutLogListing_WrappedLogObject: {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing.WrappedLogObject";
    encode(message: AboutLogResponse_AboutLogListing_WrappedLogObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AboutLogResponse_AboutLogListing_WrappedLogObject;
    fromJSON(object: any): AboutLogResponse_AboutLogListing_WrappedLogObject;
    toJSON(message: AboutLogResponse_AboutLogListing_WrappedLogObject): unknown;
    create(base?: DeepPartial_2<AboutLogResponse_AboutLogListing_WrappedLogObject>): AboutLogResponse_AboutLogListing_WrappedLogObject;
    fromPartial(object: DeepPartial_2<AboutLogResponse_AboutLogListing_WrappedLogObject>): AboutLogResponse_AboutLogListing_WrappedLogObject;
};

declare interface AboutLogResponse_LogObject {
    description?: string | undefined;
    targetBody?: string | undefined;
    modId36?: string | undefined;
    createdUtc?: number | undefined;
    subreddit?: string | undefined;
    targetTitle?: string | undefined;
    targetPermalink?: string | undefined;
    subredditNamePrefixed?: string | undefined;
    details?: string | undefined;
    action?: string | undefined;
    targetAuthor?: string | undefined;
    targetFullname?: string | undefined;
    srId36?: string | undefined;
    id?: string | undefined;
    mod?: string | undefined;
}

declare const AboutLogResponse_LogObject: {
    $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.LogObject";
    encode(message: AboutLogResponse_LogObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AboutLogResponse_LogObject;
    fromJSON(object: any): AboutLogResponse_LogObject;
    toJSON(message: AboutLogResponse_LogObject): unknown;
    create(base?: DeepPartial_2<AboutLogResponse_LogObject>): AboutLogResponse_LogObject;
    fromPartial(object: DeepPartial_2<AboutLogResponse_LogObject>): AboutLogResponse_LogObject;
};

declare type AboutSubredditHelperOptions<T extends AboutSubredditTypes> = Prettify<{
    type: T;
} & AboutLocationRequest>;

declare type AboutSubredditOptions<T extends AboutSubredditTypes> = Omit<AboutSubredditHelperOptions<T>, 'location' | 'subreddit'>;

export declare type AboutSubredditTypes = 'comment' | 'post' | 'all';

/** requests */
declare interface AboutWhereRequest {
    /** fullname of a thing */
    after?: string | undefined;
    /** fullname of a thing */
    before?: string | undefined;
    /** a positive integer (default: 0) */
    count?: number | undefined;
    /** the maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    /** (optional) the string all */
    show?: string | undefined;
    /** A valid, existing reddit username */
    user?: string | undefined;
    /** the name of the subreddit */
    subreddit?: string | undefined;
    /** one of "banned", "muted", "wikibanned", "contributors", "wikicontributors", or "moderators" */
    where: string;
}

declare const AboutWhereRequest: {
    $type: "devvit.plugin.redditapi.subreddits.AboutWhereRequest";
    encode(message: AboutWhereRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AboutWhereRequest;
    fromJSON(object: any): AboutWhereRequest;
    toJSON(message: AboutWhereRequest): unknown;
    create(base?: DeepPartial_11<AboutWhereRequest>): AboutWhereRequest;
    fromPartial(object: DeepPartial_11<AboutWhereRequest>): AboutWhereRequest;
};

declare interface AcceptInviteRequest {
    subredditName: string;
    appAccountId: string;
}

declare const AcceptInviteRequest: {
    $type: "devvit.gateway.utils.v1alpha.AcceptInviteRequest";
    encode(message: AcceptInviteRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AcceptInviteRequest;
    fromJSON(object: any): AcceptInviteRequest;
    toJSON(message: AcceptInviteRequest): unknown;
    create(base?: DeepPartial_26<AcceptInviteRequest>): AcceptInviteRequest;
    fromPartial(object: DeepPartial_26<AcceptInviteRequest>): AcceptInviteRequest;
};

declare interface AcceptInviteResponse {
}

declare const AcceptInviteResponse: {
    $type: "devvit.gateway.utils.v1alpha.AcceptInviteResponse";
    encode(_: AcceptInviteResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AcceptInviteResponse;
    fromJSON(_: any): AcceptInviteResponse;
    toJSON(_: AcceptInviteResponse): unknown;
    create(base?: DeepPartial_26<AcceptInviteResponse>): AcceptInviteResponse;
    fromPartial(_: DeepPartial_26<AcceptInviteResponse>): AcceptInviteResponse;
};

declare interface AcceptModeratorInviteRequest {
    /** subreddit name without the r/ */
    subreddit: string;
}

declare const AcceptModeratorInviteRequest: {
    $type: "devvit.plugin.redditapi.moderation.AcceptModeratorInviteRequest";
    encode(message: AcceptModeratorInviteRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AcceptModeratorInviteRequest;
    fromJSON(object: any): AcceptModeratorInviteRequest;
    toJSON(message: AcceptModeratorInviteRequest): unknown;
    create(base?: DeepPartial_2<AcceptModeratorInviteRequest>): AcceptModeratorInviteRequest;
    fromPartial(object: DeepPartial_2<AcceptModeratorInviteRequest>): AcceptModeratorInviteRequest;
};

declare interface AccessKeyPurgeRequest {
    /** the t2_ user id */
    userId: string;
    /** also purge the refresh key */
    includeRefresh: boolean;
}

declare const AccessKeyPurgeRequest: {
    $type: "devvit.gateway.utils.v1alpha.AccessKeyPurgeRequest";
    encode(message: AccessKeyPurgeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AccessKeyPurgeRequest;
    fromJSON(object: any): AccessKeyPurgeRequest;
    toJSON(message: AccessKeyPurgeRequest): unknown;
    create(base?: DeepPartial_26<AccessKeyPurgeRequest>): AccessKeyPurgeRequest;
    fromPartial(object: DeepPartial_26<AccessKeyPurgeRequest>): AccessKeyPurgeRequest;
};

declare interface AccountDelete {
    userId: string;
    deletedAt?: Date | undefined;
    user?: UserV2 | undefined;
}

declare const AccountDelete: {
    $type: "devvit.events.v1alpha.AccountDelete";
    encode(message: AccountDelete, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AccountDelete;
    fromJSON(object: any): AccountDelete;
    toJSON(message: AccountDelete): unknown;
    create(base?: DeepPartial_74<AccountDelete>): AccountDelete;
    fromPartial(object: DeepPartial_74<AccountDelete>): AccountDelete;
};

declare interface Ack {
    success: boolean;
    messages: string[];
}

declare const Ack: {
    $type: "devvit.runtime.Ack";
    encode(message: Ack, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Ack;
    fromJSON(object: any): Ack;
    toJSON(message: Ack): unknown;
    create(base?: DeepPartial<Ack>): Ack;
    fromPartial(object: DeepPartial<Ack>): Ack;
};

/**
 * Subclasses are expected to call config.init(), provides(), and uses(). It
 * is erroneous to not override the constructor. Override, invoke
 * `super(config)`, and call the Config APIs.
 */
declare abstract class Actor {
    constructor(config: Config);
}

/** Any Known Actor Definitions */
declare type ActorDefinition = AppSettingsDefinition | AssetResolverDefinition | BotDefinition | BuildPackDefinition | BuilderDefinition | BundleServiceDefinition | CacheUtilsDefinition | ClockDefinition | ContextActionDefinition | CustomActionsDefinition | CustomPostDefinition | CustomPostSnapshotResolverDefinition | DataApiAuthTokenIssuerDefinition | DataIntakerDefinition | DevvitProfilerDefinition | EnvelopeReceiverPortDefinition | FlairDefinition | GraphQLDefinition | HTTPDefinition | HelloDefinition | InspectorDefinition | InstallationSettingsDefinition | InstanceSettingsDefinition | KVStoreDefinition | LinkerDefinition | LinksAndCommentsDefinition | ListingsDefinition | LoggerDefinition | MediaServiceDefinition | ModInviteUtilsDefinition | ModNoteDefinition | ModerationDefinition | ModlogDefinition | NewModmailDefinition | OnAccountDeleteDefinition | OnAppInstallDefinition | OnAppUpgradeDefinition | OnCommentApproveDefinition | OnCommentCreateDefinition | OnCommentDeleteDefinition | OnCommentReportDefinition | OnCommentSubmitDefinition | OnCommentUpdateDefinition | OnModActionDefinition | OnModMailDefinition | OnPostApproveDefinition | OnPostCreateDefinition | OnPostDeleteDefinition | OnPostFlairUpdateDefinition | OnPostReportDefinition | OnPostSubmitDefinition | OnPostUpdateDefinition | OnSubredditSubscribeDefinition | PostCollectionsDefinition | PostFilterDefinition | PrivateMessagesDefinition | ProducerDefinition | RealtimeDefinition | RedditAPIV2Definition | RedisAPIDefinition | RemoteLogConsumerDefinition | RemoteLogPublisherDefinition | ResolverDefinition | SchedulerDefinition | SchedulerHandlerDefinition | SettingsDefinition | StreamBrokerDefinition | StreamsDefinition | SubredditMetadataResolverDefinition | SubredditsDefinition | TimerDefinition | TriggersDefinition | UIEventHandlerDefinition | UserConfigurableDefinition | UsersDefinition | V2EventsDefinition | WidgetsDefinition | WikiDefinition | WrapperTypesDefinition;

/** Map from any known actor name to their client. */
declare type ActorNameClientMap = {
    AppSettings: AppSettings;
    AssetResolver: AssetResolver;
    Bot: Bot;
    BuildPack: BuildPack;
    Builder: Builder;
    BundleService: BundleService;
    CacheUtils: CacheUtils;
    Clock: Clock;
    ContextAction: ContextAction;
    CustomActions: CustomActions;
    CustomPost: CustomPost;
    CustomPostSnapshotResolver: CustomPostSnapshotResolver;
    DataApiAuthTokenIssuer: DataApiAuthTokenIssuer;
    DataIntaker: DataIntaker;
    DevvitProfiler: DevvitProfiler;
    EnvelopeReceiverPort: EnvelopeReceiverPort;
    Flair: Flair_2;
    GraphQL: GraphQL;
    HTTP: HTTP;
    Hello: Hello;
    Inspector: Inspector;
    InstallationSettings: InstallationSettings;
    InstanceSettings: InstanceSettings;
    KVStore: KVStore_2;
    Linker: Linker;
    LinksAndComments: LinksAndComments;
    Listings: Listings;
    Logger: Logger;
    MediaService: MediaService;
    ModInviteUtils: ModInviteUtils;
    ModNote: ModNote_2;
    Moderation: Moderation;
    Modlog: Modlog;
    NewModmail: NewModmail;
    OnAccountDelete: OnAccountDelete;
    OnAppInstall: OnAppInstall;
    OnAppUpgrade: OnAppUpgrade;
    OnCommentApprove: OnCommentApprove;
    OnCommentCreate: OnCommentCreate;
    OnCommentDelete: OnCommentDelete;
    OnCommentReport: OnCommentReport;
    OnCommentSubmit: OnCommentSubmit;
    OnCommentUpdate: OnCommentUpdate;
    OnModAction: OnModAction;
    OnModMail: OnModMail;
    OnPostApprove: OnPostApprove;
    OnPostCreate: OnPostCreate;
    OnPostDelete: OnPostDelete;
    OnPostFlairUpdate: OnPostFlairUpdate;
    OnPostReport: OnPostReport;
    OnPostSubmit: OnPostSubmit;
    OnPostUpdate: OnPostUpdate;
    OnSubredditSubscribe: OnSubredditSubscribe;
    PostCollections: PostCollections;
    PostFilter: PostFilter;
    PrivateMessages: PrivateMessages;
    Producer: Producer;
    Realtime: Realtime;
    RedditAPIV2: RedditAPIV2;
    RedisAPI: RedisAPI;
    RemoteLogConsumer: RemoteLogConsumer;
    RemoteLogPublisher: RemoteLogPublisher;
    Resolver: Resolver;
    Scheduler: Scheduler_2;
    SchedulerHandler: SchedulerHandler;
    Settings: Settings;
    StreamBroker: StreamBroker;
    Streams: Streams;
    SubredditMetadataResolver: SubredditMetadataResolver;
    Subreddits: Subreddits;
    Timer: Timer;
    Triggers: Triggers;
    UIEventHandler: UIEventHandler;
    UserConfigurable: UserConfigurable;
    Users: Users;
    V2Events: V2Events;
    Widgets: Widgets;
    Wiki: Wiki;
    WrapperTypes: WrapperTypes;
};

/**
 * Bundle or plugin configuration. This config is usually set by Config.init()
 * but some plugins may configure differently.
 */
declare interface ActorSpec {
    /**
     * Bundle or plugin (PLUGIN_APP_NAME) name. This should be unique across app
     * actors. Usually just "main".
     */
    name: string;
    /** Bundle or plugin (PLUGIN_OWNER) owner. Eg, "spez". */
    owner: string;
    /** Bundle or plugin version. Eg, 1.2.3 or 1.2.3.0. */
    version: string;
}

declare const ActorSpec: {
    $type: "devvit.runtime.ActorSpec";
    encode(message: ActorSpec, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ActorSpec;
    fromJSON(object: any): ActorSpec;
    toJSON(message: ActorSpec): unknown;
    create(base?: DeepPartial_14<ActorSpec>): ActorSpec;
    fromPartial(object: DeepPartial_14<ActorSpec>): ActorSpec;
};

declare interface AddButtonWidgetRequest {
    subreddit: string;
    shortName: string;
    description: string;
    buttons: WidgetButton[];
    styles?: WidgetStyles | undefined;
}

declare const AddButtonWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.AddButtonWidgetRequest";
    encode(message: AddButtonWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddButtonWidgetRequest;
    fromJSON(object: any): AddButtonWidgetRequest;
    toJSON(message: AddButtonWidgetRequest): unknown;
    create(base?: DeepPartial_4<AddButtonWidgetRequest>): AddButtonWidgetRequest;
    fromPartial(object: DeepPartial_4<AddButtonWidgetRequest>): AddButtonWidgetRequest;
};

declare interface AddCalendarWidgetRequest {
    subreddit: string;
    configuration?: CalendarWidgetConfiguration | undefined;
    googleCalendarId: string;
    requiresSync: boolean;
    shortName: string;
    styles?: WidgetStyles | undefined;
}

declare const AddCalendarWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.AddCalendarWidgetRequest";
    encode(message: AddCalendarWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddCalendarWidgetRequest;
    fromJSON(object: any): AddCalendarWidgetRequest;
    toJSON(message: AddCalendarWidgetRequest): unknown;
    create(base?: DeepPartial_4<AddCalendarWidgetRequest>): AddCalendarWidgetRequest;
    fromPartial(object: DeepPartial_4<AddCalendarWidgetRequest>): AddCalendarWidgetRequest;
};

declare interface AddCommunityListWidgetRequest {
    subreddit: string;
    shortName: string;
    data: string[];
    styles?: WidgetStyles | undefined;
}

declare const AddCommunityListWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.AddCommunityListWidgetRequest";
    encode(message: AddCommunityListWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddCommunityListWidgetRequest;
    fromJSON(object: any): AddCommunityListWidgetRequest;
    toJSON(message: AddCommunityListWidgetRequest): unknown;
    create(base?: DeepPartial_4<AddCommunityListWidgetRequest>): AddCommunityListWidgetRequest;
    fromPartial(object: DeepPartial_4<AddCommunityListWidgetRequest>): AddCommunityListWidgetRequest;
};

declare interface AddCustomWidgetRequest {
    subreddit: string;
    shortName: string;
    text: string;
    height: number;
    css: string;
    imageData: WidgetImage[];
    styles?: WidgetStyles | undefined;
}

declare const AddCustomWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.AddCustomWidgetRequest";
    encode(message: AddCustomWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddCustomWidgetRequest;
    fromJSON(object: any): AddCustomWidgetRequest;
    toJSON(message: AddCustomWidgetRequest): unknown;
    create(base?: DeepPartial_4<AddCustomWidgetRequest>): AddCustomWidgetRequest;
    fromPartial(object: DeepPartial_4<AddCustomWidgetRequest>): AddCustomWidgetRequest;
};

declare interface AddImageWidgetRequest {
    subreddit: string;
    data: WidgetImage[];
    shortName: string;
    styles?: WidgetStyles | undefined;
}

declare const AddImageWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.AddImageWidgetRequest";
    encode(message: AddImageWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddImageWidgetRequest;
    fromJSON(object: any): AddImageWidgetRequest;
    toJSON(message: AddImageWidgetRequest): unknown;
    create(base?: DeepPartial_4<AddImageWidgetRequest>): AddImageWidgetRequest;
    fromPartial(object: DeepPartial_4<AddImageWidgetRequest>): AddImageWidgetRequest;
};

declare interface AddPostFlairWidgetRequest {
    subreddit: string;
    display: string;
    order: string[];
    shortName: string;
    styles?: WidgetStyles | undefined;
}

declare const AddPostFlairWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.AddPostFlairWidgetRequest";
    encode(message: AddPostFlairWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddPostFlairWidgetRequest;
    fromJSON(object: any): AddPostFlairWidgetRequest;
    toJSON(message: AddPostFlairWidgetRequest): unknown;
    create(base?: DeepPartial_4<AddPostFlairWidgetRequest>): AddPostFlairWidgetRequest;
    fromPartial(object: DeepPartial_4<AddPostFlairWidgetRequest>): AddPostFlairWidgetRequest;
};

declare interface AddPostToCollectionRequest {
    /** The id of the collection. */
    collectionId?: string | undefined;
    /** The t3_ id of post which should be added to the collection. */
    linkFullname?: string | undefined;
}

declare const AddPostToCollectionRequest: {
    $type: "devvit.plugin.redditapi.postcollections.AddPostToCollectionRequest";
    encode(message: AddPostToCollectionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddPostToCollectionRequest;
    fromJSON(object: any): AddPostToCollectionRequest;
    toJSON(message: AddPostToCollectionRequest): unknown;
    create(base?: DeepPartial_81<AddPostToCollectionRequest>): AddPostToCollectionRequest;
    fromPartial(object: DeepPartial_81<AddPostToCollectionRequest>): AddPostToCollectionRequest;
};

export declare type AddRemovalNoteOptions = Prettify<PostRemovalNoteRequest>;

declare interface AddTextAreaWidgetRequest {
    subreddit: string;
    shortName: string;
    text: string;
    styles?: WidgetStyles | undefined;
}

declare const AddTextAreaWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.AddTextAreaWidgetRequest";
    encode(message: AddTextAreaWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddTextAreaWidgetRequest;
    fromJSON(object: any): AddTextAreaWidgetRequest;
    toJSON(message: AddTextAreaWidgetRequest): unknown;
    create(base?: DeepPartial_4<AddTextAreaWidgetRequest>): AddTextAreaWidgetRequest;
    fromPartial(object: DeepPartial_4<AddTextAreaWidgetRequest>): AddTextAreaWidgetRequest;
};

export declare type AddWidgetData = (AddImageWidgetRequest & {
    type: 'image';
}) | (AddCalendarWidgetRequest & {
    type: 'calendar';
}) | (AddTextAreaWidgetRequest & {
    type: 'textarea';
}) | (AddButtonWidgetRequest & {
    type: 'button';
}) | (AddCommunityListWidgetRequest & {
    type: 'community-list';
}) | (AddPostFlairWidgetRequest & {
    type: 'post-flair';
}) | (AddCustomWidgetRequest & {
    type: 'custom';
});

export declare const ALL_ICON_NAMES: readonly ["activity", "add-emoji", "add", "add-media", "add-to-feed", "admin", "align-center", "align-left", "align-right", "all", "appearance", "approve", "archived", "aspect-ratio", "aspect-rectangle", "attach", "audio", "author", "avatar-style", "award", "back", "ban", "best", "binoculars", "block", "blockchain", "bold", "bot", "boost", "bounce", "brand-awareness", "browse", "browser", "cake", "calendar", "camera", "caret-down", "caret-left", "caret-right", "caret-up", "chat", "chat-group", "chat-new", "checkbox-dismiss", "checkbox", "checkmark", "chrome", "clear", "close", "closed-captioning", "code-block", "code-inline", "coins-color-old", "coins-color", "coins", "collapse-left", "collapse-right", "collection", "comment", "comments", "community", "contest", "controversial", "crop", "crosspost", "crowd-control", "custom-feed", "customize", "day", "delete", "discover", "dismiss-all", "distinguish", "down-arrow", "down", "download", "downvote", "downvotes", "drag", "drugs", "duplicate", "edit", "effect", "embed", "emoji", "end-live-chat", "error", "expand-left", "expand-right", "external", "feed-video", "filter", "format", "forward", "gif-post", "heart", "help", "hide", "history", "home", "hot", "ignore-reports", "image-post", "inbox", "info", "invite", "italic", "join", "joined", "jump-down", "jump-up", "karma", "keyboard", "kick", "language", "leave", "left", "link", "link-post", "list-bulleted", "list-numbered", "live-chat", "live", "load", "location", "lock", "logout", "loop", "mark-read", "mask", "media-gallery", "meme", "menu", "message", "mic", "mic-mute", "mod", "mod-mail", "mod-mode", "mod-mute", "mod-overflow", "mod-queue", "mod-unmute", "music", "new", "night", "notification", "notification-frequent", "notification-off", "nsfw", "nsfw-language", "nsfw-violence", "original", "overflow-caret", "overflow-horizontal", "overflow-vertical", "pause", "payment", "peace", "pending-posts", "phone", "pin", "planet", "play", "poll-post", "popular", "posts", "powerup-color-outline", "powerup-fill-color", "powerup", "predictions", "premium", "privacy", "profile", "qa", "qr-code", "quarantined", "quote", "r-slash", "radio-button", "raise-hand", "random", "ratings-everyone", "ratings-mature", "ratings-nsfw", "ratings-violence", "refresh", "remove", "reply", "report", "reverse", "right", "rising", "rotate", "rotate-image", "rpan", "rules", "safari", "save", "saved", "search", "self", "send", "settings", "share-android", "share", "share-ios", "show", "side-menu", "skipback10", "skipforward10", "sort-az", "sort", "sort-price", "sort-za", "spam", "spoiler", "sponsored", "star", "statistics", "status-live", "sticker", "strikethrough", "subtract", "superscript", "swap-camera", "swipe-back", "swipe-down", "swipe", "swipe-up", "table", "tag", "tap", "telescope", "text", "text-post", "text-size", "toggle", "tools", "top", "topic-activism", "topic-addictionsupport", "topic-advice", "topic-animals", "topic-anime", "topic-art", "topic-beauty", "topic-business", "topic-careers", "topic-cars", "topic-celebrity", "topic-craftsdiy", "topic-crypto", "topic-culture", "topic-diy", "topic-entertainment", "topic-ethics", "topic-family", "topic-fashion", "topic", "topic-fitness", "topic-food", "topic-funny", "topic-gender", "topic-health", "topic-help", "topic-history", "topic-hobbies", "topic-homegarden", "topic-internet", "topic-law", "topic-learning", "topic-lifestyle", "topic-marketplace", "topic-mature", "topic-mensfashion", "topic-menshealth", "topic-meta", "topic-military", "topic-movies", "topic-music", "topic-news", "topic-other", "topic-outdoors", "topic-pets", "topic-photography", "topic-places", "topic-podcasts", "topic-politics", "topic-programming", "topic-reading", "topic-religion", "topic-science", "topic-sexorientation", "topic-sports", "topic-style", "topic-tabletop", "topic-technology", "topic-television", "topic-traumasupport", "topic-travel", "topic-videogaming", "topic-womensfashion", "topic-womenshealth", "translate", "trim", "u-slash", "unban", "undo", "unheart", "unlock", "unmod", "unpin", "unverified", "up-arrow", "up", "upload", "upvote", "upvotes", "user", "user-note", "users", "vault", "verified", "video-camera", "video-feed", "video-live-1", "video-live-fill-1", "video-live", "video-post", "video-thread", "video-transcription", "view-card", "view-classic", "view-compact", "view-grid", "views", "volume", "volume-mute", "wallet", "warning", "wiki-ban", "wiki", "wiki-unban", "world"];

export declare type AllIconName = typeof ALL_ICON_NAMES[number];

export declare type AllowableFlairContent = 'all' | 'emoji' | 'text';

declare interface AllowEditorRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
    /** The name of the wiki page. */
    page: string;
    /** Either "add" or "del". */
    act: string;
    /** The username of the user to allow or deny. */
    username: string;
}

declare const AllowEditorRequest: {
    $type: "devvit.plugin.redditapi.wiki.AllowEditorRequest";
    encode(message: AllowEditorRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AllowEditorRequest;
    fromJSON(object: any): AllowEditorRequest;
    toJSON(message: AllowEditorRequest): unknown;
    create(base?: DeepPartial_9<AllowEditorRequest>): AllowEditorRequest;
    fromPartial(object: DeepPartial_9<AllowEditorRequest>): AllowEditorRequest;
};

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *     // or ...
 *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
 *       foo = any.unpack(Foo.getDefaultInstance());
 *     }
 *
 *  Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 *  Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
 * name "y.z".
 *
 * JSON
 * ====
 * The JSON representation of an `Any` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field `@type` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       "@type": "type.googleapis.com/google.profile.Person",
 *       "firstName": <string>,
 *       "lastName": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * `value` which holds the custom JSON in addition to the `@type`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       "@type": "type.googleapis.com/google.protobuf.Duration",
 *       "value": "1.212s"
 *     }
 */
declare interface Any {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com. As of May 2023, there are no widely used type server
     * implementations and no plans to implement one.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    typeUrl: string;
    /** Must be a valid serialized protocol buffer of the above specified type. */
    value: Uint8Array;
}

declare const Any: {
    $type: "google.protobuf.Any";
    encode(message: Any, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Any;
    fromJSON(object: any): Any;
    toJSON(message: Any): unknown;
    create(base?: DeepPartial_30<Any>): Any;
    fromPartial(object: DeepPartial_30<Any>): Any;
};

/**
 * Method extension for specifying how to call a Reddit API endpoint. These
 * options are used for generating API client code.
 */
declare interface ApiClientConfig {
    /** 'GET', 'POST', 'PUT', 'DELETE', etc. */
    method: string;
    /**
     * The path of the API endpoint. Placeholders for variables MUST match names of fields in the input message.
     * For example:
     *   "/r/{subreddit}/api/delete_sr_img"
     * Only works if the input message has a string field named 'subreddit'.
     */
    path: string;
    requestBodyType: ApiClientConfig_BodyType;
    /**
     * If set to true, the parameter `api_type=json` will be sent to the reddit API with this request.
     * Note: in the current implementation, this only works for bodyType=FORM_SNAKE.
     */
    enforceJson: boolean;
    /**
     * Some requests involve sending a specific `kind` field that's not otherwise part of the
     * request message. If this field is specified, that will be included in the request.
     */
    requestKindValue: string;
}

declare const ApiClientConfig: {
    $type: "devvit.plugin.redditapi.common.ApiClientConfig";
    encode(message: ApiClientConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ApiClientConfig;
    fromJSON(object: any): ApiClientConfig;
    toJSON(message: ApiClientConfig): unknown;
    create(base?: DeepPartial_8<ApiClientConfig>): ApiClientConfig;
    fromPartial(object: DeepPartial_8<ApiClientConfig>): ApiClientConfig;
};

/** For methods with a request body, this specifies how the request body should be serialized. */
declare enum ApiClientConfig_BodyType {
    NONE = 0,
    JSON_CAMEL = 1,
    JSON_SNAKE = 2,
    FORM_CAMEL = 3,
    FORM_SNAKE = 4,
    UNRECOGNIZED = -1
}

declare function apiClientConfig_BodyTypeFromJSON(object: any): ApiClientConfig_BodyType;

declare function apiClientConfig_BodyTypeToJSON(object: ApiClientConfig_BodyType): number;

/** See DevvitGlobal and ContextDebugInfo. */
declare const enum AppDebug {
    /** Enable debug logging for blocks. */
    Blocks = "blocks",
    /**
     * Log the entire reified blocks JSX/XML tree on each render. Eg:
     *
     *   <hstack><text>hi world</text></hstack>
     */
    EmitSnapshots = "emitSnapshots",
    /** Log app state changes. */
    EmitState = "emitState",
    /** Enable runtime and dispatcher logging. */
    Runtime = "runtime",
    /** Enable debug logging for devvit-surface and dispatcher. */
    Surface = "surface",
    /** Enable debug logging for the useAsync() hook family. */
    UseAsync = "useAsync",
    /** Enable debug logging for useChannel() hook. */
    UseChannel = "useChannel"
}

/** The event name for when your app is installed */
export declare type AppInstall = 'AppInstall';

declare interface AppInstall_2 {
    subreddit?: SubredditV2 | undefined;
    installer?: UserV2 | undefined;
}

declare const AppInstall_2: {
    $type: "devvit.events.v1alpha.AppInstall";
    encode(message: AppInstall_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppInstall_2;
    fromJSON(object: any): AppInstall_2;
    toJSON(message: AppInstall_2): unknown;
    create(base?: DeepPartial_74<AppInstall_2>): AppInstall_2;
    fromPartial(object: DeepPartial_74<AppInstall_2>): AppInstall_2;
};

export declare type AppInstallDefinition = {
    event: AppInstall;
    onEvent: TriggerOnEventHandler<protos.AppInstall>;
};

declare interface AppPurgeRequest {
    appId: string;
}

declare const AppPurgeRequest: {
    $type: "devvit.gateway.utils.v1alpha.AppPurgeRequest";
    encode(message: AppPurgeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppPurgeRequest;
    fromJSON(object: any): AppPurgeRequest;
    toJSON(message: AppPurgeRequest): unknown;
    create(base?: DeepPartial_26<AppPurgeRequest>): AppPurgeRequest;
    fromPartial(object: DeepPartial_26<AppPurgeRequest>): AppPurgeRequest;
};

declare interface ApproveConversationResponse {
    conversations?: ConversationData_2 | undefined;
    messages: {
        [key: string]: MessageData_2;
    };
    user?: ConversationUserData_2 | undefined;
    modActions: {
        [key: string]: ModActionData_2;
    };
    /** error case */
    fields: string[];
    reason?: string | undefined;
    message?: string | undefined;
    explanation?: string | undefined;
}

declare const ApproveConversationResponse: {
    $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse";
    encode(message: ApproveConversationResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ApproveConversationResponse;
    fromJSON(object: any): ApproveConversationResponse;
    toJSON(message: ApproveConversationResponse): unknown;
    create(base?: DeepPartial_71<ApproveConversationResponse>): ApproveConversationResponse;
    fromPartial(object: DeepPartial_71<ApproveConversationResponse>): ApproveConversationResponse;
};

declare interface ApproveConversationResponse_MessagesEntry {
    key: string;
    value?: MessageData_2 | undefined;
}

declare const ApproveConversationResponse_MessagesEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.MessagesEntry";
    encode(message: ApproveConversationResponse_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ApproveConversationResponse_MessagesEntry;
    fromJSON(object: any): ApproveConversationResponse_MessagesEntry;
    toJSON(message: ApproveConversationResponse_MessagesEntry): unknown;
    create(base?: DeepPartial_71<ApproveConversationResponse_MessagesEntry>): ApproveConversationResponse_MessagesEntry;
    fromPartial(object: DeepPartial_71<ApproveConversationResponse_MessagesEntry>): ApproveConversationResponse_MessagesEntry;
};

declare interface ApproveConversationResponse_ModActionsEntry {
    key: string;
    value?: ModActionData_2 | undefined;
}

declare const ApproveConversationResponse_ModActionsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.ModActionsEntry";
    encode(message: ApproveConversationResponse_ModActionsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ApproveConversationResponse_ModActionsEntry;
    fromJSON(object: any): ApproveConversationResponse_ModActionsEntry;
    toJSON(message: ApproveConversationResponse_ModActionsEntry): unknown;
    create(base?: DeepPartial_71<ApproveConversationResponse_ModActionsEntry>): ApproveConversationResponse_ModActionsEntry;
    fromPartial(object: DeepPartial_71<ApproveConversationResponse_ModActionsEntry>): ApproveConversationResponse_ModActionsEntry;
};

/**
 * Define settings configured by the app dev when the app is uploaded.
 * App-level settings are available to every instance of your app within a single
 * app context.  For example, if creating a custom post app, every post will have access
 * to these settings.
 * Load the saved values with the Settings plugin.
 */
declare interface AppSettings {
    /** Requested by the platform when rendering the configure form upon installing this app */
    GetAppSettingsFields(request: GetFieldsRequest, metadata?: Metadata): Promise<GetFieldsResponse>;
    /** Called by the installation form before saving settings to allow for more advanced field validation */
    ValidateAppForm(request: ValidateFormRequest, metadata?: Metadata): Promise<ValidateFormResponse>;
}

declare class AppSettingsClientImpl implements AppSettings {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_67, opts?: {
        service?: string;
    });
    GetAppSettingsFields(request: GetFieldsRequest, metadata?: Metadata): Promise<GetFieldsResponse>;
    ValidateAppForm(request: ValidateFormRequest, metadata?: Metadata): Promise<ValidateFormResponse>;
}

/**
 * Define settings configured by the app dev when the app is uploaded.
 * App-level settings are available to every instance of your app within a single
 * app context.  For example, if creating a custom post app, every post will have access
 * to these settings.
 * Load the saved values with the Settings plugin.
 */
declare type AppSettingsDefinition = typeof AppSettingsDefinition;

declare const AppSettingsDefinition: {
    readonly name: "AppSettings";
    readonly fullName: "devvit.actor.settings.v1alpha.AppSettings";
    readonly methods: {
        /** Requested by the platform when rendering the configure form upon installing this app */
        readonly getAppSettingsFields: {
            readonly name: "GetAppSettingsFields";
            readonly requestType: {
                $type: "devvit.actor.settings.v1alpha.GetFieldsRequest";
                encode(message: GetFieldsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetFieldsRequest;
                fromJSON(object: any): GetFieldsRequest;
                toJSON(message: GetFieldsRequest): unknown;
                create(base?: {
                    editing?: boolean;
                } | undefined): GetFieldsRequest;
                fromPartial(object: {
                    editing?: boolean;
                }): GetFieldsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.settings.v1alpha.GetFieldsResponse";
                encode(message: GetFieldsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetFieldsResponse;
                fromJSON(object: any): GetFieldsResponse;
                toJSON(message: GetFieldsResponse): unknown;
                create(base?: {
                    fields?: {
                        fields?: {
                            fieldId?: string;
                            fieldType?: FormFieldType_2;
                            label?: string;
                            helpText?: string | undefined;
                            defaultValue?: {
                                fieldType?: FormFieldType_2;
                                isSecret?: boolean | undefined;
                                stringValue?: string | undefined;
                                numberValue?: number | undefined;
                                boolValue?: boolean | undefined;
                                listValue?: {
                                    itemType?: FormFieldType_2;
                                    items?: any[];
                                } | undefined;
                                selectionValue?: {
                                    values?: string[];
                                } | undefined;
                                groupValue?: {} | undefined;
                            } | undefined;
                            required?: boolean | undefined;
                            disabled?: boolean | undefined;
                            fieldConfig?: {
                                stringConfig?: {
                                    minLength?: number | undefined;
                                    maxLength?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                paragraphConfig?: {
                                    maxCharacters?: number | undefined;
                                    lineHeight?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                numberConfig?: {
                                    step?: number | undefined;
                                    min?: number | undefined;
                                    max?: number | undefined;
                                } | undefined;
                                booleanConfig?: {} | undefined;
                                listConfig?: {
                                    itemType?: FormFieldType_2;
                                    itemConfig?: any | undefined;
                                    minEntries?: number | undefined;
                                    maxEntries?: number | undefined;
                                    entryLabel?: string | undefined;
                                } | undefined;
                                selectionConfig?: {
                                    choices?: {
                                        label?: string;
                                        value?: string;
                                    }[];
                                    multiSelect?: boolean | undefined;
                                    minSelections?: number | undefined;
                                    maxSelections?: number | undefined;
                                    renderAsList?: boolean | undefined;
                                } | undefined;
                                groupConfig?: {
                                    fields?: any[];
                                } | undefined;
                            } | undefined;
                            isSecret?: boolean | undefined;
                        }[];
                        title?: string | undefined;
                        shortDescription?: string | undefined;
                        acceptLabel?: string | undefined;
                        cancelLabel?: string | undefined;
                        id?: string | undefined;
                    } | undefined;
                } | undefined): GetFieldsResponse;
                fromPartial(object: {
                    fields?: {
                        fields?: {
                            fieldId?: string;
                            fieldType?: FormFieldType_2;
                            label?: string;
                            helpText?: string | undefined;
                            defaultValue?: {
                                fieldType?: FormFieldType_2;
                                isSecret?: boolean | undefined;
                                stringValue?: string | undefined;
                                numberValue?: number | undefined;
                                boolValue?: boolean | undefined;
                                listValue?: {
                                    itemType?: FormFieldType_2;
                                    items?: any[];
                                } | undefined;
                                selectionValue?: {
                                    values?: string[];
                                } | undefined;
                                groupValue?: {} | undefined;
                            } | undefined;
                            required?: boolean | undefined;
                            disabled?: boolean | undefined;
                            fieldConfig?: {
                                stringConfig?: {
                                    minLength?: number | undefined;
                                    maxLength?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                paragraphConfig?: {
                                    maxCharacters?: number | undefined;
                                    lineHeight?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                numberConfig?: {
                                    step?: number | undefined;
                                    min?: number | undefined;
                                    max?: number | undefined;
                                } | undefined;
                                booleanConfig?: {} | undefined;
                                listConfig?: {
                                    itemType?: FormFieldType_2;
                                    itemConfig?: any | undefined;
                                    minEntries?: number | undefined;
                                    maxEntries?: number | undefined;
                                    entryLabel?: string | undefined;
                                } | undefined;
                                selectionConfig?: {
                                    choices?: {
                                        label?: string;
                                        value?: string;
                                    }[];
                                    multiSelect?: boolean | undefined;
                                    minSelections?: number | undefined;
                                    maxSelections?: number | undefined;
                                    renderAsList?: boolean | undefined;
                                } | undefined;
                                groupConfig?: {
                                    fields?: any[];
                                } | undefined;
                            } | undefined;
                            isSecret?: boolean | undefined;
                        }[];
                        title?: string | undefined;
                        shortDescription?: string | undefined;
                        acceptLabel?: string | undefined;
                        cancelLabel?: string | undefined;
                        id?: string | undefined;
                    } | undefined;
                }): GetFieldsResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Called by the installation form before saving settings to allow for more advanced field validation */
        readonly validateAppForm: {
            readonly name: "ValidateAppForm";
            readonly requestType: {
                $type: "devvit.actor.settings.v1alpha.ValidateFormRequest";
                encode(message: ValidateFormRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ValidateFormRequest;
                fromJSON(object: any): ValidateFormRequest;
                toJSON(message: ValidateFormRequest): unknown;
                create(base?: {
                    editing?: boolean;
                    fieldValues?: {
                        [x: string]: {
                            fieldType?: FormFieldType_2;
                            isSecret?: boolean | undefined;
                            stringValue?: string | undefined;
                            numberValue?: number | undefined;
                            boolValue?: boolean | undefined;
                            listValue?: {
                                itemType?: FormFieldType_2;
                                items?: any[];
                            } | undefined;
                            selectionValue?: {
                                values?: string[];
                            } | undefined;
                            groupValue?: {} | undefined;
                        } | undefined;
                    };
                } | undefined): ValidateFormRequest;
                fromPartial(object: {
                    editing?: boolean;
                    fieldValues?: {
                        [x: string]: {
                            fieldType?: FormFieldType_2;
                            isSecret?: boolean | undefined;
                            stringValue?: string | undefined;
                            numberValue?: number | undefined;
                            boolValue?: boolean | undefined;
                            listValue?: {
                                itemType?: FormFieldType_2;
                                items?: any[];
                            } | undefined;
                            selectionValue?: {
                                values?: string[];
                            } | undefined;
                            groupValue?: {} | undefined;
                        } | undefined;
                    };
                }): ValidateFormRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.settings.v1alpha.ValidateFormResponse";
                encode(message: ValidateFormResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ValidateFormResponse;
                fromJSON(object: any): ValidateFormResponse;
                toJSON(message: ValidateFormResponse): unknown;
                create(base?: {
                    success?: boolean;
                    errors?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): ValidateFormResponse;
                fromPartial(object: {
                    success?: boolean;
                    errors?: {
                        [x: string]: string | undefined;
                    };
                }): ValidateFormResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const AppSettingsServiceName = "devvit.actor.settings.v1alpha.AppSettings";

/** The event name for when your app is upgraded */
export declare type AppUpgrade = 'AppUpgrade';

declare interface AppUpgrade_2 {
    subreddit?: SubredditV2 | undefined;
    installer?: UserV2 | undefined;
}

declare const AppUpgrade_2: {
    $type: "devvit.events.v1alpha.AppUpgrade";
    encode(message: AppUpgrade_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppUpgrade_2;
    fromJSON(object: any): AppUpgrade_2;
    toJSON(message: AppUpgrade_2): unknown;
    create(base?: DeepPartial_74<AppUpgrade_2>): AppUpgrade_2;
    fromPartial(object: DeepPartial_74<AppUpgrade_2>): AppUpgrade_2;
};

export declare type AppUpgradeDefinition = {
    event: AppUpgrade;
    onEvent: TriggerOnEventHandler<protos.AppUpgrade>;
};

declare interface AppVersionPurgeRequest {
    appVersionId: string;
}

declare const AppVersionPurgeRequest: {
    $type: "devvit.gateway.utils.v1alpha.AppVersionPurgeRequest";
    encode(message: AppVersionPurgeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppVersionPurgeRequest;
    fromJSON(object: any): AppVersionPurgeRequest;
    toJSON(message: AppVersionPurgeRequest): unknown;
    create(base?: DeepPartial_26<AppVersionPurgeRequest>): AppVersionPurgeRequest;
    fromPartial(object: DeepPartial_26<AppVersionPurgeRequest>): AppVersionPurgeRequest;
};

declare interface ArchiveConversationResponse {
    /** @deprecated use `conversation` */
    conversations?: ConversationData_2 | undefined;
    messages: {
        [key: string]: MessageData_2;
    };
    modActions: {
        [key: string]: ModActionData_2;
    };
    conversation?: ConversationData_2 | undefined;
}

declare const ArchiveConversationResponse: {
    $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse";
    encode(message: ArchiveConversationResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ArchiveConversationResponse;
    fromJSON(object: any): ArchiveConversationResponse;
    toJSON(message: ArchiveConversationResponse): unknown;
    create(base?: DeepPartial_71<ArchiveConversationResponse>): ArchiveConversationResponse;
    fromPartial(object: DeepPartial_71<ArchiveConversationResponse>): ArchiveConversationResponse;
};

declare interface ArchiveConversationResponse_MessagesEntry {
    key: string;
    value?: MessageData_2 | undefined;
}

declare const ArchiveConversationResponse_MessagesEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.MessagesEntry";
    encode(message: ArchiveConversationResponse_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ArchiveConversationResponse_MessagesEntry;
    fromJSON(object: any): ArchiveConversationResponse_MessagesEntry;
    toJSON(message: ArchiveConversationResponse_MessagesEntry): unknown;
    create(base?: DeepPartial_71<ArchiveConversationResponse_MessagesEntry>): ArchiveConversationResponse_MessagesEntry;
    fromPartial(object: DeepPartial_71<ArchiveConversationResponse_MessagesEntry>): ArchiveConversationResponse_MessagesEntry;
};

declare interface ArchiveConversationResponse_ModActionsEntry {
    key: string;
    value?: ModActionData_2 | undefined;
}

declare const ArchiveConversationResponse_ModActionsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.ModActionsEntry";
    encode(message: ArchiveConversationResponse_ModActionsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ArchiveConversationResponse_ModActionsEntry;
    fromJSON(object: any): ArchiveConversationResponse_ModActionsEntry;
    toJSON(message: ArchiveConversationResponse_ModActionsEntry): unknown;
    create(base?: DeepPartial_71<ArchiveConversationResponse_ModActionsEntry>): ArchiveConversationResponse_ModActionsEntry;
    fromPartial(object: DeepPartial_71<ArchiveConversationResponse_ModActionsEntry>): ArchiveConversationResponse_ModActionsEntry;
};

declare interface Arg {
    str?: string | undefined;
    i32?: number | undefined;
    i64?: number | undefined;
}

declare const Arg: {
    $type: "devvit.actor.producer.Arg";
    encode(message: Arg, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Arg;
    fromJSON(object: any): Arg;
    toJSON(message: Arg): unknown;
    create(base?: DeepPartial_85<Arg>): Arg;
    fromPartial(object: DeepPartial_85<Arg>): Arg;
};

declare interface Args {
    elements: Arg[];
}

declare const Args: {
    $type: "devvit.actor.producer.Args";
    encode(message: Args, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Args;
    fromJSON(object: any): Args;
    toJSON(message: Args): unknown;
    create(base?: DeepPartial_85<Args>): Args;
    fromPartial(object: DeepPartial_85<Args>): Args;
};

/**
 * A map from the local file path of a media asset ("assets/file.png"), to either:
 * - If the relevant app version has finished uploading all its assets: its
 *     publicly accessible URL (https://i.redd.it/<ID>.png)
 * - If the relevant app version has not uploaded all its assets, or this is
 *     from the CLI which doesn't know the public URLs for any assets: the
 *     asset ID for the file as saved in dev-portal (NOT the media service ID).
 *     UUIDv4.
 * Note that this may be `undefined` if the bundle is old and/or there are no
 * assets associated with the app.
 */
declare type AssetMap = {
    [path: string]: string;
};

declare interface AssetResolver {
    /** Gets a public URL for a given asset */
    GetAssetURL(request: GetAssetURLRequest, metadata?: Metadata): Promise<GetAssetURLResponse>;
    /** Gets the public URLs for multiple assets at the same time */
    GetAssetURLs(request: GetMultipleAssetURLsRequest, metadata?: Metadata): Promise<GetMultipleAssetURLsResponse>;
}

declare class AssetResolverClientImpl implements AssetResolver {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_29, opts?: {
        service?: string;
    });
    GetAssetURL(request: GetAssetURLRequest, metadata?: Metadata): Promise<GetAssetURLResponse>;
    GetAssetURLs(request: GetMultipleAssetURLsRequest, metadata?: Metadata): Promise<GetMultipleAssetURLsResponse>;
}

declare type AssetResolverDefinition = typeof AssetResolverDefinition;

declare const AssetResolverDefinition: {
    readonly name: "AssetResolver";
    readonly fullName: "devvit.plugin.assetresolver.AssetResolver";
    readonly methods: {
        /** Gets a public URL for a given asset */
        readonly getAssetURL: {
            readonly name: "GetAssetURL";
            readonly requestType: {
                $type: "devvit.plugin.assetresolver.GetAssetURLRequest";
                encode(message: GetAssetURLRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetURLRequest;
                fromJSON(object: any): GetAssetURLRequest;
                toJSON(message: GetAssetURLRequest): unknown;
                create(base?: DeepPartial_19<GetAssetURLRequest>): GetAssetURLRequest;
                fromPartial(object: DeepPartial_19<GetAssetURLRequest>): GetAssetURLRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.assetresolver.GetAssetURLResponse";
                encode(message: GetAssetURLResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetURLResponse;
                fromJSON(object: any): GetAssetURLResponse;
                toJSON(message: GetAssetURLResponse): unknown;
                create(base?: DeepPartial_19<GetAssetURLResponse>): GetAssetURLResponse;
                fromPartial(object: DeepPartial_19<GetAssetURLResponse>): GetAssetURLResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Gets the public URLs for multiple assets at the same time */
        readonly getAssetURLs: {
            readonly name: "GetAssetURLs";
            readonly requestType: {
                $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsRequest";
                encode(message: GetMultipleAssetURLsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): GetMultipleAssetURLsRequest;
                fromJSON(object: any): GetMultipleAssetURLsRequest;
                toJSON(message: GetMultipleAssetURLsRequest): unknown;
                create(base?: DeepPartial_19<GetMultipleAssetURLsRequest>): GetMultipleAssetURLsRequest;
                fromPartial(object: DeepPartial_19<GetMultipleAssetURLsRequest>): GetMultipleAssetURLsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsResponse";
                encode(message: GetMultipleAssetURLsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): GetMultipleAssetURLsResponse;
                fromJSON(object: any): GetMultipleAssetURLsResponse;
                toJSON(message: GetMultipleAssetURLsResponse): unknown;
                create(base?: DeepPartial_19<GetMultipleAssetURLsResponse>): GetMultipleAssetURLsResponse;
                fromPartial(object: DeepPartial_19<GetMultipleAssetURLsResponse>): GetMultipleAssetURLsResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const AssetResolverServiceName = "devvit.plugin.assetresolver.AssetResolver";

declare class AssetsClient {
    #private;
    constructor();
    /**
     * Gets the public URLs for an asset.
     * @param assetPath A path, relative to the 'assets/' folder.
     * @returns The public URL for that asset (https://i.redd.it/<id>.<ext>)
     */
    getURL(assetPath: string): string;
    /**
     * Gets the public URLs for multiple assets.
     * @param assetPaths An array of paths, relative to the 'assets/' folder.
     * @returns A map of each asset path to its public URL (https://i.redd.it/<id>.<ext>)
     */
    getURL(assetPaths: string[]): AssetMap;
}

export declare type AsyncError = {
    message: string;
    details: string | null;
};

declare interface AsyncError_2 {
    message: string;
    /** Typically a stack trace */
    details: string;
}

declare const AsyncError_2: {
    $type: "devvit.ui.events.v1alpha.AsyncError";
    encode(message: AsyncError_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AsyncError_2;
    fromJSON(object: any): AsyncError_2;
    toJSON(message: AsyncError_2): unknown;
    create(base?: DeepPartial_49<AsyncError_2>): AsyncError_2;
    fromPartial(object: DeepPartial_49<AsyncError_2>): AsyncError_2;
};

declare type AsyncOptions = {
    /**
     * The data loader will re-run if the value of `depends` changes.
     */
    depends?: JSONValue;
    /**
     * If `enabled` is false, the data loader will not run.
     */
    enabled?: boolean;
};

declare interface AsyncRequest {
    requestId: string;
    data?: {
        [key: string]: any;
    } | undefined;
}

declare const AsyncRequest: {
    $type: "devvit.ui.events.v1alpha.AsyncRequest";
    encode(message: AsyncRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AsyncRequest;
    fromJSON(object: any): AsyncRequest;
    toJSON(message: AsyncRequest): unknown;
    create(base?: DeepPartial_49<AsyncRequest>): AsyncRequest;
    fromPartial(object: DeepPartial_49<AsyncRequest>): AsyncRequest;
};

declare interface AsyncResponse {
    requestId: string;
    data?: {
        [key: string]: any;
    } | undefined;
    error?: AsyncError_2 | undefined;
}

declare const AsyncResponse: {
    $type: "devvit.ui.events.v1alpha.AsyncResponse";
    encode(message: AsyncResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AsyncResponse;
    fromJSON(object: any): AsyncResponse;
    toJSON(message: AsyncResponse): unknown;
    create(base?: DeepPartial_49<AsyncResponse>): AsyncResponse;
    fromPartial(object: DeepPartial_49<AsyncResponse>): AsyncResponse;
};

export declare type AsyncUseStateInitializer<S> = () => Promise<S>;

declare interface AuthorFlairRichText {
    e?: string | undefined;
    t?: string | undefined;
}

declare const AuthorFlairRichText: {
    $type: "devvit.reddit.AuthorFlairRichText";
    encode(message: AuthorFlairRichText, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AuthorFlairRichText;
    fromJSON(object: any): AuthorFlairRichText;
    toJSON(message: AuthorFlairRichText): unknown;
    create(base?: DeepPartial_5<AuthorFlairRichText>): AuthorFlairRichText;
    fromPartial(object: DeepPartial_5<AuthorFlairRichText>): AuthorFlairRichText;
};

/** https://github.snooguts.net/reddit/reddit-service-award/blob/f102a254636cd403627cc1125fcccab52972ea6b/award/models/award.py */
declare interface Awarding {
    awardSubType?: string | undefined;
    awardType?: string | undefined;
    awardingsRequiredToGrantBenefits?: number | undefined;
    coinPrice?: number | undefined;
    coinReward?: number | undefined;
    count?: number | undefined;
    daysOfDripExtension?: number | undefined;
    daysOfPremium?: number | undefined;
    description?: string | undefined;
    endDate?: string | undefined;
    giverCoinReward?: number | undefined;
    iconFormat?: string | undefined;
    iconHeight?: number | undefined;
    iconUrl?: string | undefined;
    iconWidth?: number | undefined;
    id?: string | undefined;
    isEnabled?: boolean | undefined;
    isNew?: boolean | undefined;
    name?: string | undefined;
    pennyDonate?: number | undefined;
    pennyPrice?: number | undefined;
    resizedIcons: Awarding_Icon[];
    resizedStaticIcons: Awarding_Icon[];
    startDate?: string | undefined;
    staticIconHeight?: number | undefined;
    staticIconUrl?: string | undefined;
    staticIconWidth?: number | undefined;
    stickyDurationSeconds?: number | undefined;
    subredditCoinReward?: number | undefined;
    subredditId?: string | undefined;
    tiersByRequiredAwardings?: string | undefined;
}

declare const Awarding: {
    $type: "devvit.reddit.Awarding";
    encode(message: Awarding, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Awarding;
    fromJSON(object: any): Awarding;
    toJSON(message: Awarding): unknown;
    create(base?: DeepPartial_5<Awarding>): Awarding;
    fromPartial(object: DeepPartial_5<Awarding>): Awarding;
};

declare interface Awarding_Icon {
    height?: number | undefined;
    url?: string | undefined;
    width?: number | undefined;
}

declare const Awarding_Icon: {
    $type: "devvit.reddit.Awarding.Icon";
    encode(message: Awarding_Icon, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Awarding_Icon;
    fromJSON(object: any): Awarding_Icon;
    toJSON(message: Awarding_Icon): unknown;
    create(base?: DeepPartial_5<Awarding_Icon>): Awarding_Icon;
    fromPartial(object: DeepPartial_5<Awarding_Icon>): Awarding_Icon;
};

declare interface BanInfo {
    auto?: boolean | undefined;
    bannedAt?: number | undefined;
    banner?: string | undefined;
    moderatorBanned?: boolean | undefined;
    note?: string | undefined;
    unbanner?: string | undefined;
    unbannedAt?: number | undefined;
    resetUsed?: boolean | undefined;
    reasonId?: string | undefined;
    reasonTitle?: string | undefined;
    reasonMessage?: string | undefined;
    reasonBy?: string | undefined;
    modNote?: string | undefined;
    banAllTriggered?: boolean | undefined;
    subredditMessage?: string | undefined;
    removeAction: BanInfo_BanInfoAction;
}

declare const BanInfo: {
    $type: "devvit.reddit.BanInfo";
    encode(message: BanInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BanInfo;
    fromJSON(object: any): BanInfo;
    toJSON(message: BanInfo): unknown;
    create(base?: DeepPartial_5<BanInfo>): BanInfo;
    fromPartial(object: DeepPartial_5<BanInfo>): BanInfo;
};

declare enum BanInfo_BanInfoAction {
    UNKNOWN = 0,
    SPAM = 1,
    FILTER = 2,
    REMOVE = 3,
    UNRECOGNIZED = -1
}

declare function banInfo_BanInfoActionFromJSON(object: any): BanInfo_BanInfoAction;

declare function banInfo_BanInfoActionToJSON(object: BanInfo_BanInfoAction): number;

export declare type BanUserOptions = {
    username: string;
    subredditName: string;
    context?: string;
    message?: string;
    reason?: string;
    duration?: number;
    note?: string;
};

export declare type BanWikiContributorOptions = {
    username: string;
    subredditName: string;
    reason?: string;
    duration?: number;
    note?: string;
};

export declare type BaseContext = {
    /** The ID of the current subreddit */
    subredditId: string;
    /** The ID of the current post */
    postId?: string | undefined;
    /** The current user's ID if this event was triggered by a logged in user */
    userId?: string | undefined;
    /** The ID of the current app's account */
    appAccountId: string;
    /** The ID of the current comment */
    commentId?: string | undefined;
    /** Returns a JSON representation of the context */
    toJSON(): Omit<BaseContext, 'toJSON'>;
    /** More useful things, but probably not for the average developer */
    debug: ContextDebugInfo;
};

export declare type BaseField<ValueType> = {
    /** The name of the field. This will be used as the key in the `values` object when the form is submitted */
    name: string;
    /** The label of the field. This will be displayed to the user */
    label: string;
    /** An optional help text that will be displayed below the field */
    helpText?: string | undefined;
    /** If true the field will be required and the user will not be able to submit the form without filling it in */
    required?: boolean | undefined;
    /** If true the field will be disabled */
    disabled?: boolean | undefined;
    /** The default value of the field */
    defaultValue?: ValueType | undefined;
    /** This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. */
    scope?: SettingScopeType | undefined;
};

declare interface BasicConversationRequest {
    /** id36 of a modmail conversation id */
    conversationId: string;
}

declare const BasicConversationRequest: {
    $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
    encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BasicConversationRequest;
    fromJSON(object: any): BasicConversationRequest;
    toJSON(message: BasicConversationRequest): unknown;
    create(base?: DeepPartial_71<BasicConversationRequest>): BasicConversationRequest;
    fromPartial(object: DeepPartial_71<BasicConversationRequest>): BasicConversationRequest;
};

declare interface BasicConversationsRequest {
    /** comma seperated list of id36 of a modmail conversation ids */
    conversationIds: string;
}

declare const BasicConversationsRequest: {
    $type: "devvit.plugin.redditapi.newmodmail.BasicConversationsRequest";
    encode(message: BasicConversationsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BasicConversationsRequest;
    fromJSON(object: any): BasicConversationsRequest;
    toJSON(message: BasicConversationsRequest): unknown;
    create(base?: DeepPartial_71<BasicConversationsRequest>): BasicConversationsRequest;
    fromPartial(object: DeepPartial_71<BasicConversationsRequest>): BasicConversationsRequest;
};

declare interface BasicIdRequest {
    /**
     * Thing ID
     * @example "t1_abc123"
     */
    id: string;
}

declare const BasicIdRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
    encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BasicIdRequest;
    fromJSON(object: any): BasicIdRequest;
    toJSON(message: BasicIdRequest): unknown;
    create(base?: DeepPartial_64<BasicIdRequest>): BasicIdRequest;
    fromPartial(object: DeepPartial_64<BasicIdRequest>): BasicIdRequest;
};

declare interface BasicModerationIdRequest {
    id: string;
}

declare const BasicModerationIdRequest: {
    $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest";
    encode(message: BasicModerationIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BasicModerationIdRequest;
    fromJSON(object: any): BasicModerationIdRequest;
    toJSON(message: BasicModerationIdRequest): unknown;
    create(base?: DeepPartial_2<BasicModerationIdRequest>): BasicModerationIdRequest;
    fromPartial(object: DeepPartial_2<BasicModerationIdRequest>): BasicModerationIdRequest;
};

declare interface BasicSearchRequest {
    /** boolean value */
    exact?: boolean | undefined;
    /** boolean value */
    includeOver18?: boolean | undefined;
    /** boolean value */
    includeUnadvertisable?: boolean | undefined;
    /** a string up to 50 characters long, consisting of printable characters */
    query: string;
    /** a uuid */
    searchQueryId?: string | undefined;
    /** (optional) boolean value */
    typeaheadActive?: boolean | undefined;
}

declare const BasicSearchRequest: {
    $type: "devvit.plugin.redditapi.subreddits.BasicSearchRequest";
    encode(message: BasicSearchRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BasicSearchRequest;
    fromJSON(object: any): BasicSearchRequest;
    toJSON(message: BasicSearchRequest): unknown;
    create(base?: DeepPartial_11<BasicSearchRequest>): BasicSearchRequest;
    fromPartial(object: DeepPartial_11<BasicSearchRequest>): BasicSearchRequest;
};

declare interface BasicSubredditRequest {
    /** the name of the subreddit */
    subreddit: string;
}

declare const BasicSubredditRequest: {
    $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
    encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BasicSubredditRequest;
    fromJSON(object: any): BasicSubredditRequest;
    toJSON(message: BasicSubredditRequest): unknown;
    create(base?: DeepPartial_11<BasicSubredditRequest>): BasicSubredditRequest;
    fromPartial(object: DeepPartial_11<BasicSubredditRequest>): BasicSubredditRequest;
};

declare interface BasicWhereRequest {
    /** fullname of a thing */
    after?: string | undefined;
    /** fullname of a thing */
    before?: string | undefined;
    /** a positive integer (default: 0) */
    count?: number | undefined;
    /** the maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    /** (optional) the string all */
    show?: string | undefined;
    /**
     * SubredditsMineWhere: one of (subscriber, contributor, moderator, streams)
     * SubredditsWhere: one of (popular, new, gold, default)
     * UsersWhere: one of (popular, new)
     */
    where: string;
}

declare const BasicWhereRequest: {
    $type: "devvit.plugin.redditapi.subreddits.BasicWhereRequest";
    encode(message: BasicWhereRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BasicWhereRequest;
    fromJSON(object: any): BasicWhereRequest;
    toJSON(message: BasicWhereRequest): unknown;
    create(base?: DeepPartial_11<BasicWhereRequest>): BasicWhereRequest;
    fromPartial(object: DeepPartial_11<BasicWhereRequest>): BasicWhereRequest;
};

declare interface Block {
    type: BlockType;
    /**
     * @deprecated Use sizes instead
     * Common attributes
     *
     * @deprecated
     */
    size?: BlockSize | undefined;
    /** Size constraints */
    sizes?: BlockSizes | undefined;
    /** Block-specific config */
    config?: BlockConfig | undefined;
    /** List of possible actions */
    actions: BlockAction[];
    /**
     * Unique identifier for the block, if we have one.  This is designed to
     * facilitate component re-use.
     *
     * If this is not set, the block is considered to be a new instance of a
     * component, or the client may use heuristics to determine if the component
     * appears similar enough to reuse.
     */
    id?: string | undefined;
    /**
     * Key for the block, if we have one.  This is designed to handle
     * component re-ordering within a list or parent.
     *
     * Keys are not required to be unique, but they should be stable across
     * re-orderings of the same list or parent.
     */
    key?: string | undefined;
}

declare const Block: {
    $type: "devvit.ui.block_kit.v1beta.Block";
    encode(message: Block, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Block;
    fromJSON(object: any): Block;
    toJSON(message: Block): unknown;
    create(base?: DeepPartial_45<Block>): Block;
    fromPartial(object: DeepPartial_45<Block>): Block;
};

declare interface BlockAction {
    type: BlockActionType;
    id: string;
    data?: {
        [key: string]: any;
    } | undefined;
}

declare const BlockAction: {
    $type: "devvit.ui.block_kit.v1beta.BlockAction";
    encode(message: BlockAction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockAction;
    fromJSON(object: any): BlockAction;
    toJSON(message: BlockAction): unknown;
    create(base?: DeepPartial_44<BlockAction>): BlockAction;
    fromPartial(object: DeepPartial_44<BlockAction>): BlockAction;
};

declare enum BlockActionType {
    ACTION_CLICK = 0,
    ACTION_WEBVIEW = 100,
    UNRECOGNIZED = -1
}

declare function blockActionTypeFromJSON(object: any): BlockActionType;

declare function blockActionTypeToJSON(object: BlockActionType): number;

declare interface BlockAlignment {
    vertical?: BlockVerticalAlignment | undefined;
    horizontal?: BlockHorizontalAlignment | undefined;
}

declare const BlockAlignment: {
    $type: "devvit.ui.block_kit.v1beta.BlockAlignment";
    encode(message: BlockAlignment, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockAlignment;
    fromJSON(object: any): BlockAlignment;
    toJSON(message: BlockAlignment): unknown;
    create(base?: DeepPartial_44<BlockAlignment>): BlockAlignment;
    fromPartial(object: DeepPartial_44<BlockAlignment>): BlockAlignment;
};

declare enum BlockAnimationDirection {
    ANIM_DIR_FORWARD = 0,
    ANIM_DIR_BACKWARD = 1,
    UNRECOGNIZED = -1
}

declare function blockAnimationDirectionFromJSON(object: any): BlockAnimationDirection;

declare function blockAnimationDirectionToJSON(object: BlockAnimationDirection): number;

declare enum BlockAnimationLoopMode {
    ANIM_LOOP_REPEAT = 0,
    ANIM_LOOP_BOUNCE = 1,
    UNRECOGNIZED = -1
}

declare function blockAnimationLoopModeFromJSON(object: any): BlockAnimationLoopMode;

declare function blockAnimationLoopModeToJSON(object: BlockAnimationLoopMode): number;

declare enum BlockAnimationType {
    ANIM_LOTTIE = 0,
    UNRECOGNIZED = -1
}

declare function blockAnimationTypeFromJSON(object: any): BlockAnimationType;

declare function blockAnimationTypeToJSON(object: BlockAnimationType): number;

declare enum BlockAvatarBackground {
    AVATAR_BG_LIGHT = 0,
    AVATAR_BG_DARK = 1,
    UNRECOGNIZED = -1
}

declare function blockAvatarBackgroundFromJSON(object: any): BlockAvatarBackground;

declare function blockAvatarBackgroundToJSON(object: BlockAvatarBackground): number;

declare enum BlockAvatarFacing {
    AVATAR_FACING_LEFT = 0,
    AVATAR_FACING_RIGHT = 1,
    UNRECOGNIZED = -1
}

declare function blockAvatarFacingFromJSON(object: any): BlockAvatarFacing;

declare function blockAvatarFacingToJSON(object: BlockAvatarFacing): number;

declare enum BlockAvatarSize {
    AVATAR_SIZE_SMALL = 0,
    AVATAR_SIZE_XXSMALL = 1,
    AVATAR_SIZE_XSMALL = 2,
    AVATAR_SIZE_MEDIUM = 3,
    AVATAR_SIZE_LARGE = 4,
    AVATAR_SIZE_XLARGE = 5,
    AVATAR_SIZE_XXLARGE = 6,
    AVATAR_SIZE_XXXLARGE = 7,
    UNRECOGNIZED = -1
}

declare function blockAvatarSizeFromJSON(object: any): BlockAvatarSize;

declare function blockAvatarSizeToJSON(object: BlockAvatarSize): number;

declare interface BlockBorder {
    /**
     * @deprecated use colors instead
     *
     * @deprecated
     */
    color?: string | undefined;
    width?: BlockBorderWidth | undefined;
    colors?: BlockColor | undefined;
}

declare const BlockBorder: {
    $type: "devvit.ui.block_kit.v1beta.BlockBorder";
    encode(message: BlockBorder, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockBorder;
    fromJSON(object: any): BlockBorder;
    toJSON(message: BlockBorder): unknown;
    create(base?: DeepPartial_44<BlockBorder>): BlockBorder;
    fromPartial(object: DeepPartial_44<BlockBorder>): BlockBorder;
};

declare enum BlockBorderWidth {
    BORDER_WIDTH_NONE = 0,
    BORDER_WIDTH_THIN = 1,
    BORDER_WIDTH_THICK = 2,
    UNRECOGNIZED = -1
}

declare function blockBorderWidthFromJSON(object: any): BlockBorderWidth;

declare function blockBorderWidthToJSON(object: BlockBorderWidth): number;

declare enum BlockButtonAppearance {
    BUTTON_APPEARANCE_SECONDARY = 0,
    BUTTON_APPEARANCE_PRIMARY = 1,
    BUTTON_APPEARANCE_PLAIN = 2,
    BUTTON_APPEARANCE_BORDERED = 3,
    BUTTON_APPEARANCE_MEDIA = 4,
    BUTTON_APPEARANCE_DESTRUCTIVE = 5,
    BUTTON_APPEARANCE_CAUTION = 6,
    BUTTON_APPEARANCE_SUCCESS = 7,
    UNRECOGNIZED = -1
}

declare function blockButtonAppearanceFromJSON(object: any): BlockButtonAppearance;

declare function blockButtonAppearanceToJSON(object: BlockButtonAppearance): number;

declare enum BlockButtonSize {
    BUTTON_SIZE_MEDIUM = 0,
    BUTTON_SIZE_SMALL = 1,
    BUTTON_SIZE_LARGE = 2,
    UNRECOGNIZED = -1
}

declare function blockButtonSizeFromJSON(object: any): BlockButtonSize;

declare function blockButtonSizeToJSON(object: BlockButtonSize): number;

declare interface BlockColor {
    light?: string | undefined;
    dark?: string | undefined;
}

declare const BlockColor: {
    $type: "devvit.ui.block_kit.v1beta.BlockColor";
    encode(message: BlockColor, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockColor;
    fromJSON(object: any): BlockColor;
    toJSON(message: BlockColor): unknown;
    create(base?: DeepPartial_44<BlockColor>): BlockColor;
    fromPartial(object: DeepPartial_44<BlockColor>): BlockColor;
};

declare interface BlockConfig {
    rootConfig?: BlockConfig_Root | undefined;
    stackConfig?: BlockConfig_Stack | undefined;
    textConfig?: BlockConfig_Text | undefined;
    buttonConfig?: BlockConfig_Button | undefined;
    imageConfig?: BlockConfig_Image | undefined;
    spacerConfig?: BlockConfig_Spacer | undefined;
    iconConfig?: BlockConfig_Icon | undefined;
    avatarConfig?: BlockConfig_Avatar | undefined;
    fullsnooConfig?: BlockConfig_FullSnoo | undefined;
    animationConfig?: BlockConfig_Animation | undefined;
    webviewConfig?: BlockConfig_WebView | undefined;
}

declare const BlockConfig: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig";
    encode(message: BlockConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig;
    fromJSON(object: any): BlockConfig;
    toJSON(message: BlockConfig): unknown;
    create(base?: DeepPartial_45<BlockConfig>): BlockConfig;
    fromPartial(object: DeepPartial_45<BlockConfig>): BlockConfig;
};

declare interface BlockConfig_Animation {
    /** URL to the animation */
    url: string;
    /** Target width, in pixels */
    width: number;
    /** Target height, in pixels */
    height: number;
    /** Type of player needed */
    type: BlockAnimationType;
    /** Set loop mode. Defaults to true. */
    loop?: boolean | undefined;
    /** How looping should occur */
    loopMode?: BlockAnimationLoopMode | undefined;
    /** Autoplay the animation as soon as it's loaded */
    autoplay?: boolean | undefined;
    /** Playback speed multiplier, when supported by type */
    speed?: number | undefined;
    /** Play the animation forward or backward, when supported by type */
    direction?: BlockAnimationDirection | undefined;
}

declare const BlockConfig_Animation: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Animation";
    encode(message: BlockConfig_Animation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_Animation;
    fromJSON(object: any): BlockConfig_Animation;
    toJSON(message: BlockConfig_Animation): unknown;
    create(base?: DeepPartial_45<BlockConfig_Animation>): BlockConfig_Animation;
    fromPartial(object: DeepPartial_45<BlockConfig_Animation>): BlockConfig_Animation;
};

declare interface BlockConfig_Avatar {
    thingId: string;
    facing?: BlockAvatarFacing | undefined;
    size?: BlockAvatarSize | undefined;
    background?: BlockAvatarBackground | undefined;
}

declare const BlockConfig_Avatar: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Avatar";
    encode(message: BlockConfig_Avatar, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_Avatar;
    fromJSON(object: any): BlockConfig_Avatar;
    toJSON(message: BlockConfig_Avatar): unknown;
    create(base?: DeepPartial_45<BlockConfig_Avatar>): BlockConfig_Avatar;
    fromPartial(object: DeepPartial_45<BlockConfig_Avatar>): BlockConfig_Avatar;
};

declare interface BlockConfig_Button {
    text?: string | undefined;
    icon?: string | undefined;
    buttonSize?: BlockButtonSize | undefined;
    buttonAppearance?: BlockButtonAppearance | undefined;
    /**
     * @deprecated use text_colors instead
     *
     * @deprecated
     */
    textColor?: string | undefined;
    /**
     * @deprecated use background_colors instead
     *
     * @deprecated
     */
    backgroundColor?: string | undefined;
    disabled?: boolean | undefined;
    textColors?: BlockColor | undefined;
    backgroundColors?: BlockColor | undefined;
}

declare const BlockConfig_Button: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Button";
    encode(message: BlockConfig_Button, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_Button;
    fromJSON(object: any): BlockConfig_Button;
    toJSON(message: BlockConfig_Button): unknown;
    create(base?: DeepPartial_45<BlockConfig_Button>): BlockConfig_Button;
    fromPartial(object: DeepPartial_45<BlockConfig_Button>): BlockConfig_Button;
};

declare interface BlockConfig_FullSnoo {
    userId: string;
    facing?: BlockAvatarFacing | undefined;
    size?: BlockFullSnooSize | undefined;
}

declare const BlockConfig_FullSnoo: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.FullSnoo";
    encode(message: BlockConfig_FullSnoo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_FullSnoo;
    fromJSON(object: any): BlockConfig_FullSnoo;
    toJSON(message: BlockConfig_FullSnoo): unknown;
    create(base?: DeepPartial_45<BlockConfig_FullSnoo>): BlockConfig_FullSnoo;
    fromPartial(object: DeepPartial_45<BlockConfig_FullSnoo>): BlockConfig_FullSnoo;
};

declare interface BlockConfig_Icon {
    icon: string;
    /**
     * @deprecated use colors instead
     *
     * @deprecated
     */
    color?: string | undefined;
    size?: BlockIconSize | undefined;
    colors?: BlockColor | undefined;
}

declare const BlockConfig_Icon: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Icon";
    encode(message: BlockConfig_Icon, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_Icon;
    fromJSON(object: any): BlockConfig_Icon;
    toJSON(message: BlockConfig_Icon): unknown;
    create(base?: DeepPartial_45<BlockConfig_Icon>): BlockConfig_Icon;
    fromPartial(object: DeepPartial_45<BlockConfig_Icon>): BlockConfig_Icon;
};

declare interface BlockConfig_Image {
    /** URL to the image */
    url: string;
    /** Target width, in pixels */
    width: number;
    /** Target height, in pixels */
    height: number;
    /** Description for accessibility */
    description?: string | undefined;
    /** How to resize the image if the target resolution can't be achieved */
    resizeMode?: BlockImageResizeMode | undefined;
}

declare const BlockConfig_Image: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Image";
    encode(message: BlockConfig_Image, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_Image;
    fromJSON(object: any): BlockConfig_Image;
    toJSON(message: BlockConfig_Image): unknown;
    create(base?: DeepPartial_45<BlockConfig_Image>): BlockConfig_Image;
    fromPartial(object: DeepPartial_45<BlockConfig_Image>): BlockConfig_Image;
};

declare interface BlockConfig_Root {
    children: Block[];
    /** Height of the UI */
    height: number;
}

declare const BlockConfig_Root: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Root";
    encode(message: BlockConfig_Root, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_Root;
    fromJSON(object: any): BlockConfig_Root;
    toJSON(message: BlockConfig_Root): unknown;
    create(base?: DeepPartial_45<BlockConfig_Root>): BlockConfig_Root;
    fromPartial(object: DeepPartial_45<BlockConfig_Root>): BlockConfig_Root;
};

declare interface BlockConfig_Spacer {
    size?: BlockSpacerSize | undefined;
    shape?: BlockSpacerShape | undefined;
}

declare const BlockConfig_Spacer: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Spacer";
    encode(message: BlockConfig_Spacer, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_Spacer;
    fromJSON(object: any): BlockConfig_Spacer;
    toJSON(message: BlockConfig_Spacer): unknown;
    create(base?: DeepPartial_45<BlockConfig_Spacer>): BlockConfig_Spacer;
    fromPartial(object: DeepPartial_45<BlockConfig_Spacer>): BlockConfig_Spacer;
};

declare interface BlockConfig_Stack {
    /** How blocks should be laid out in this stack */
    direction: BlockStackDirection;
    /** Blocks to layout in the stack */
    children: Block[];
    /** Stack the child blocks in reverse order */
    reverse?: boolean | undefined;
    /** Horizontal and vertical alignment of elements within the stack */
    alignment?: BlockAlignment | undefined;
    /** Distance between child elements and the container border */
    padding?: BlockPadding | undefined;
    /** Distance between child elements */
    gap?: BlockGap | undefined;
    /** Display a border around the stack */
    border?: BlockBorder | undefined;
    /** Round the corners of the stack */
    cornerRadius?: BlockRadius | undefined;
    /**
     * Set a custom background color for the stack
     * @deprecated Use background_colors instead
     *
     * @deprecated
     */
    backgroundColor?: string | undefined;
    /** Set a custom background color for the stack */
    backgroundColors?: BlockColor | undefined;
}

declare const BlockConfig_Stack: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Stack";
    encode(message: BlockConfig_Stack, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_Stack;
    fromJSON(object: any): BlockConfig_Stack;
    toJSON(message: BlockConfig_Stack): unknown;
    create(base?: DeepPartial_45<BlockConfig_Stack>): BlockConfig_Stack;
    fromPartial(object: DeepPartial_45<BlockConfig_Stack>): BlockConfig_Stack;
};

declare interface BlockConfig_Text {
    text: string;
    size?: BlockTextSize | undefined;
    weight?: BlockTextWeight | undefined;
    /**
     * @deprecated use colors instead
     *
     * @deprecated
     */
    color?: string | undefined;
    alignment?: BlockAlignment | undefined;
    outline?: BlockTextOutline | undefined;
    style?: BlockTextStyle | undefined;
    selectable?: boolean | undefined;
    colors?: BlockColor | undefined;
    wrap?: boolean | undefined;
    overflow?: BlockTextOverflow | undefined;
}

declare const BlockConfig_Text: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.Text";
    encode(message: BlockConfig_Text, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_Text;
    fromJSON(object: any): BlockConfig_Text;
    toJSON(message: BlockConfig_Text): unknown;
    create(base?: DeepPartial_45<BlockConfig_Text>): BlockConfig_Text;
    fromPartial(object: DeepPartial_45<BlockConfig_Text>): BlockConfig_Text;
};

declare interface BlockConfig_WebView {
    /** URL to load in the webview */
    url: string;
    /** State to pass in to the webview */
    state?: {
        [key: string]: any;
    } | undefined;
}

declare const BlockConfig_WebView: {
    $type: "devvit.ui.block_kit.v1beta.BlockConfig.WebView";
    encode(message: BlockConfig_WebView, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfig_WebView;
    fromJSON(object: any): BlockConfig_WebView;
    toJSON(message: BlockConfig_WebView): unknown;
    create(base?: DeepPartial_45<BlockConfig_WebView>): BlockConfig_WebView;
    fromPartial(object: DeepPartial_45<BlockConfig_WebView>): BlockConfig_WebView;
};

export declare type BlockElement = {
    type: JSX.ComponentFunction | string | undefined;
    props: {
        [key: string]: unknown;
    } | undefined;
    children: JSX.Element[];
};

declare enum BlockFullSnooSize {
    FULLSNOO_SMALL = 0,
    FULLSNOO_XSMALL = 1,
    FULLSNOO_MEDIUM = 2,
    FULLSNOO_LARGE = 3,
    FULLSNOO_XLARGE = 4,
    FULLSNOO_XXLARGE = 5,
    UNRECOGNIZED = -1
}

declare function blockFullSnooSizeFromJSON(object: any): BlockFullSnooSize;

declare function blockFullSnooSizeToJSON(object: BlockFullSnooSize): number;

declare enum BlockGap {
    GAP_NONE = 0,
    GAP_SMALL = 1,
    GAP_MEDIUM = 2,
    GAP_LARGE = 3,
    UNRECOGNIZED = -1
}

declare function blockGapFromJSON(object: any): BlockGap;

declare function blockGapToJSON(object: BlockGap): number;

declare enum BlockHorizontalAlignment {
    ALIGN_START = 0,
    ALIGN_CENTER = 1,
    ALIGN_END = 2,
    UNRECOGNIZED = -1
}

declare function blockHorizontalAlignmentFromJSON(object: any): BlockHorizontalAlignment;

declare function blockHorizontalAlignmentToJSON(object: BlockHorizontalAlignment): number;

declare enum BlockIconSize {
    ICON_SIZE_MEDIUM = 0,
    ICON_SIZE_XSMALL = 1,
    ICON_SIZE_SMALL = 2,
    ICON_SIZE_LARGE = 3,
    UNRECOGNIZED = -1
}

declare function blockIconSizeFromJSON(object: any): BlockIconSize;

declare function blockIconSizeToJSON(object: BlockIconSize): number;

declare enum BlockImageResizeMode {
    IMAGE_RESIZE_FIT = 0,
    IMAGE_RESIZE_FILL = 1,
    IMAGE_RESIZE_COVER = 2,
    IMAGE_RESIZE_NONE = 3,
    IMAGE_RESIZE_SCALE_DOWN = 4,
    UNRECOGNIZED = -1
}

declare function blockImageResizeModeFromJSON(object: any): BlockImageResizeMode;

declare function blockImageResizeModeToJSON(object: BlockImageResizeMode): number;

/**
 * Server-side rendering event.  This is a signal to the server that it should
 * wait for all of the promises to resolve before sending the response.
 *
 * The default behavior is to send the response as soon as possible, and then
 * stream in the rest of the data as it becomes available.  This is usually
 * slower on first load, but faster on subsequent loads.
 *
 * On first load, the server is usually close to the database, so the
 * back-and-forth is relatively cheap compared to asking the client to initiate
 * a bunch of waterfalling requests to the server.
 */
declare interface BlockingRenderEvent {
}

declare const BlockingRenderEvent: {
    $type: "devvit.ui.events.v1alpha.BlockingRenderEvent";
    encode(_: BlockingRenderEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockingRenderEvent;
    fromJSON(_: any): BlockingRenderEvent;
    toJSON(_: BlockingRenderEvent): unknown;
    create(base?: DeepPartial_49<BlockingRenderEvent>): BlockingRenderEvent;
    fromPartial(_: DeepPartial_49<BlockingRenderEvent>): BlockingRenderEvent;
};

declare enum BlockPadding {
    PADDING_NONE = 0,
    PADDING_XSMALL = 1,
    PADDING_SMALL = 2,
    PADDING_MEDIUM = 3,
    PADDING_LARGE = 4,
    UNRECOGNIZED = -1
}

declare function blockPaddingFromJSON(object: any): BlockPadding;

declare function blockPaddingToJSON(object: BlockPadding): number;

/**
 * @mixin
 */
declare type BlockQuoteContainer<Context> = {
    /**
     * Append a Block Quote element
     * @param opts
     * @param cb scoped callback to add child elements to this Block Quote
     */
    blockQuote(opts: BlockQuoteOptions, cb: (blockQuote: BlockQuoteContext) => void): Context;
};

/**
 * @borrows ParagraphContainer
 */
declare interface BlockQuoteContext extends ParagraphContainer<BlockQuoteContext> {
}

declare type BlockQuoteOptions = {
    /**
     * Element for author attribution
     * @see {@link TextNode}
     * @example { author: makeUserLink({ username: 'spez', showPrefix: true }) }
     */
    author?: TextNode;
};

declare enum BlockRadius {
    RADIUS_NONE = 0,
    RADIUS_SMALL = 1,
    RADIUS_MEDIUM = 2,
    RADIUS_LARGE = 3,
    RADIUS_FULL = 100,
    UNRECOGNIZED = -1
}

declare function blockRadiusFromJSON(object: any): BlockRadius;

declare function blockRadiusToJSON(object: BlockRadius): number;

declare enum BlockRenderEventType {
    /** RENDER_INITIAL - First render of the UI on the user's device */
    RENDER_INITIAL = 0,
    /** RENDER_USER_ACTION - Render triggered by a user action */
    RENDER_USER_ACTION = 1,
    /** RENDER_EFFECT_EVENT - Render triggered as the result of an effect */
    RENDER_EFFECT_EVENT = 2,
    /** RENDER_CACHED - Render a version to be cached and used before the app can respond to RENDER_INITIAL */
    RENDER_CACHED = 3,
    UNRECOGNIZED = -1
}

declare function blockRenderEventTypeFromJSON(object: any): BlockRenderEventType;

declare function blockRenderEventTypeToJSON(object: BlockRenderEventType): number;

declare interface BlockRenderRequest {
    /** What triggered this render request */
    type: BlockRenderEventType;
    /**
     * ID to differentiate between similar events of the same type
     * such as an actionId for USER_ACTION events
     */
    id?: string | undefined;
    /** Additional data from the event, if any */
    data?: {
        [key: string]: any;
    } | undefined;
}

declare const BlockRenderRequest: {
    $type: "devvit.ui.block_kit.v1beta.BlockRenderRequest";
    encode(message: BlockRenderRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockRenderRequest;
    fromJSON(object: any): BlockRenderRequest;
    toJSON(message: BlockRenderRequest): unknown;
    create(base?: DeepPartial_42<BlockRenderRequest>): BlockRenderRequest;
    fromPartial(object: DeepPartial_42<BlockRenderRequest>): BlockRenderRequest;
};

declare interface BlockRenderResponse {
    /** A BLOCK_ROOT element */
    ui?: Block | undefined;
}

declare const BlockRenderResponse: {
    $type: "devvit.ui.block_kit.v1beta.BlockRenderResponse";
    encode(message: BlockRenderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockRenderResponse;
    fromJSON(object: any): BlockRenderResponse;
    toJSON(message: BlockRenderResponse): unknown;
    create(base?: DeepPartial_42<BlockRenderResponse>): BlockRenderResponse;
    fromPartial(object: DeepPartial_42<BlockRenderResponse>): BlockRenderResponse;
};

/** @deprecated Use BlockSizing */
declare interface BlockSize {
    /** Grow this element to fill any free space in the container */
    grow?: boolean | undefined;
    /** Width */
    width?: number | undefined;
    /** Unit of the width value */
    widthUnit?: BlockSizeUnit | undefined;
    /** Height */
    height?: number | undefined;
    /** Unit of the height value */
    heightUnit?: BlockSizeUnit | undefined;
}

declare const BlockSize: {
    $type: "devvit.ui.block_kit.v1beta.BlockSize";
    encode(message: BlockSize, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockSize;
    fromJSON(object: any): BlockSize;
    toJSON(message: BlockSize): unknown;
    create(base?: DeepPartial_44<BlockSize>): BlockSize;
    fromPartial(object: DeepPartial_44<BlockSize>): BlockSize;
};

declare interface BlockSizes {
    grow?: boolean | undefined;
    width?: BlockSizes_Dimension | undefined;
    height?: BlockSizes_Dimension | undefined;
}

declare const BlockSizes: {
    $type: "devvit.ui.block_kit.v1beta.BlockSizes";
    encode(message: BlockSizes, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockSizes;
    fromJSON(object: any): BlockSizes;
    toJSON(message: BlockSizes): unknown;
    create(base?: DeepPartial_44<BlockSizes>): BlockSizes;
    fromPartial(object: DeepPartial_44<BlockSizes>): BlockSizes;
};

declare interface BlockSizes_Dimension {
    value?: BlockSizes_Dimension_Value | undefined;
    min?: BlockSizes_Dimension_Value | undefined;
    max?: BlockSizes_Dimension_Value | undefined;
}

declare const BlockSizes_Dimension: {
    $type: "devvit.ui.block_kit.v1beta.BlockSizes.Dimension";
    encode(message: BlockSizes_Dimension, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockSizes_Dimension;
    fromJSON(object: any): BlockSizes_Dimension;
    toJSON(message: BlockSizes_Dimension): unknown;
    create(base?: DeepPartial_44<BlockSizes_Dimension>): BlockSizes_Dimension;
    fromPartial(object: DeepPartial_44<BlockSizes_Dimension>): BlockSizes_Dimension;
};

declare interface BlockSizes_Dimension_Value {
    value: number;
    unit: BlockSizeUnit;
}

declare const BlockSizes_Dimension_Value: {
    $type: "devvit.ui.block_kit.v1beta.BlockSizes.Dimension.Value";
    encode(message: BlockSizes_Dimension_Value, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockSizes_Dimension_Value;
    fromJSON(object: any): BlockSizes_Dimension_Value;
    toJSON(message: BlockSizes_Dimension_Value): unknown;
    create(base?: DeepPartial_44<BlockSizes_Dimension_Value>): BlockSizes_Dimension_Value;
    fromPartial(object: DeepPartial_44<BlockSizes_Dimension_Value>): BlockSizes_Dimension_Value;
};

declare enum BlockSizeUnit {
    SIZE_UNIT_PERCENT = 0,
    SIZE_UNIT_PIXELS = 1,
    UNRECOGNIZED = -1
}

declare function blockSizeUnitFromJSON(object: any): BlockSizeUnit;

declare function blockSizeUnitToJSON(object: BlockSizeUnit): number;

declare enum BlockSpacerShape {
    SPACER_INVISIBLE = 0,
    SPACER_THIN = 1,
    SPACER_SQUARE = 2,
    UNRECOGNIZED = -1
}

declare function blockSpacerShapeFromJSON(object: any): BlockSpacerShape;

declare function blockSpacerShapeToJSON(object: BlockSpacerShape): number;

declare enum BlockSpacerSize {
    SPACER_SMALL = 0,
    SPACER_XSMALL = 1,
    SPACER_MEDIUM = 2,
    SPACER_LARGE = 3,
    UNRECOGNIZED = -1
}

declare function blockSpacerSizeFromJSON(object: any): BlockSpacerSize;

declare function blockSpacerSizeToJSON(object: BlockSpacerSize): number;

declare enum BlockStackDirection {
    STACK_HORIZONTAL = 0,
    STACK_VERTICAL = 1,
    STACK_DEPTH = 2,
    UNRECOGNIZED = -1
}

declare function blockStackDirectionFromJSON(object: any): BlockStackDirection;

declare function blockStackDirectionToJSON(object: BlockStackDirection): number;

declare enum BlockTextOutline {
    TEXT_OUTLINE_NONE = 0,
    TEXT_OUTLINE_THIN = 1,
    TEXT_OUTLINE_THICK = 2,
    UNRECOGNIZED = -1
}

declare function blockTextOutlineFromJSON(object: any): BlockTextOutline;

declare function blockTextOutlineToJSON(object: BlockTextOutline): number;

declare enum BlockTextOverflow {
    TEXT_OVERFLOW_CLIP = 0,
    TEXT_OVERFLOW_ELLIPSE = 1,
    UNRECOGNIZED = -1
}

declare function blockTextOverflowFromJSON(object: any): BlockTextOverflow;

declare function blockTextOverflowToJSON(object: BlockTextOverflow): number;

declare enum BlockTextSize {
    TEXT_SIZE_MEDIUM = 0,
    TEXT_SIZE_XSMALL = 1,
    TEXT_SIZE_SMALL = 2,
    TEXT_SIZE_LARGE = 3,
    TEXT_SIZE_XLARGE = 4,
    TEXT_SIZE_XXLARGE = 5,
    UNRECOGNIZED = -1
}

declare function blockTextSizeFromJSON(object: any): BlockTextSize;

declare function blockTextSizeToJSON(object: BlockTextSize): number;

declare enum BlockTextStyle {
    TEXT_STYLE_BODY = 0,
    TEXT_STYLE_METADATA = 1,
    TEXT_STYLE_HEADING = 2,
    UNRECOGNIZED = -1
}

declare function blockTextStyleFromJSON(object: any): BlockTextStyle;

declare function blockTextStyleToJSON(object: BlockTextStyle): number;

declare enum BlockTextWeight {
    TEXT_WEIGHT_REGULAR = 0,
    TEXT_WEIGHT_BOLD = 1,
    UNRECOGNIZED = -1
}

declare function blockTextWeightFromJSON(object: any): BlockTextWeight;

declare function blockTextWeightToJSON(object: BlockTextWeight): number;

declare enum BlockType {
    BLOCK_ROOT = 0,
    BLOCK_STACK = 1,
    BLOCK_TEXT = 2,
    BLOCK_BUTTON = 3,
    BLOCK_IMAGE = 4,
    BLOCK_SPACER = 5,
    BLOCK_ICON = 6,
    BLOCK_AVATAR = 7,
    BLOCK_FULLSNOO = 8,
    BLOCK_ANIMATION = 9,
    /** BLOCK_WEBVIEW - elements 100+ are privileged */
    BLOCK_WEBVIEW = 100,
    UNRECOGNIZED = -1
}

declare function blockTypeFromJSON(object: any): BlockType;

declare function blockTypeToJSON(object: BlockType): number;

declare interface BlockUserRequest {
    /** account thing id e.g. 't3_15bfi0' */
    accountId?: string | undefined;
    /** a valid, existing reddit username */
    name?: string | undefined;
}

declare const BlockUserRequest: {
    $type: "devvit.plugin.redditapi.users.BlockUserRequest";
    encode(message: BlockUserRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockUserRequest;
    fromJSON(object: any): BlockUserRequest;
    toJSON(message: BlockUserRequest): unknown;
    create(base?: DeepPartial_100<BlockUserRequest>): BlockUserRequest;
    fromPartial(object: DeepPartial_100<BlockUserRequest>): BlockUserRequest;
};

declare interface BlockUserResponse {
    date?: number | undefined;
    iconImg?: string | undefined;
    id?: string | undefined;
    name?: string | undefined;
}

declare const BlockUserResponse: {
    $type: "devvit.plugin.redditapi.users.BlockUserResponse";
    encode(message: BlockUserResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockUserResponse;
    fromJSON(object: any): BlockUserResponse;
    toJSON(message: BlockUserResponse): unknown;
    create(base?: DeepPartial_100<BlockUserResponse>): BlockUserResponse;
    fromPartial(object: DeepPartial_100<BlockUserResponse>): BlockUserResponse;
};

declare enum BlockVerticalAlignment {
    ALIGN_TOP = 0,
    ALIGN_MIDDLE = 1,
    ALIGN_BOTTOM = 2,
    UNRECOGNIZED = -1
}

declare function blockVerticalAlignmentFromJSON(object: any): BlockVerticalAlignment;

declare function blockVerticalAlignmentToJSON(object: BlockVerticalAlignment): number;

/** A boolean field displayed as a toggle */
export declare type BooleanField = Prettify<Omit<BaseField<boolean>, 'required'> & FieldConfig_Boolean & {
    type: 'boolean';
}>;

/**
 * Wrapper message for `bool`.
 *
 * The JSON representation for `BoolValue` is JSON `true` and `false`.
 */
declare interface BoolValue {
    /** The bool value. */
    value: boolean;
}

declare const BoolValue: {
    $type: "google.protobuf.BoolValue";
    encode(message: BoolValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BoolValue;
    fromJSON(object: any): BoolValue;
    toJSON(message: BoolValue): unknown;
    create(base?: DeepPartial_69<BoolValue>): BoolValue;
    fromPartial(object: DeepPartial_69<BoolValue>): BoolValue;
};

/** Bootstraper used to load an actual Actor into the Worker */
declare interface BootstrapActor {
    /** Loads an Actor into the Worker and binds its service to a URL */
    LoadActor(request: LinkedBundle, metadata?: Metadata): Promise<Empty>;
    IsResponding(request: Empty, metadata?: Metadata): Promise<Empty>;
}

declare class BootstrapActorClientImpl implements BootstrapActor {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_10, opts?: {
        service?: string;
    });
    LoadActor(request: LinkedBundle, metadata?: Metadata): Promise<Empty>;
    IsResponding(request: Empty, metadata?: Metadata): Promise<Empty>;
}

/** Bootstraper used to load an actual Actor into the Worker */
declare type BootstrapActorDefinition = typeof BootstrapActorDefinition;

declare const BootstrapActorDefinition: {
    readonly name: "BootstrapActor";
    readonly fullName: "devvit.runtime.actor.BootstrapActor";
    readonly methods: {
        /** Loads an Actor into the Worker and binds its service to a URL */
        readonly loadActor: {
            readonly name: "LoadActor";
            readonly requestType: {
                $type: "devvit.runtime.LinkedBundle";
                encode(message: LinkedBundle, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): LinkedBundle;
                fromJSON(object: any): LinkedBundle;
                toJSON(message: LinkedBundle): unknown;
                create(base?: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): LinkedBundle;
                fromPartial(object: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                }): LinkedBundle;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly isResponding: {
            readonly name: "IsResponding";
            readonly requestType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const BootstrapActorServiceName = "devvit.runtime.actor.BootstrapActor";

declare interface Bot {
    GetCommands(request: Empty, metadata?: Metadata): Promise<CommandsList>;
    OnCommand(request: CommandRequest, metadata?: Metadata): Promise<Empty>;
}

declare class BotClientImpl implements Bot {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_41, opts?: {
        service?: string;
    });
    GetCommands(request: Empty, metadata?: Metadata): Promise<CommandsList>;
    OnCommand(request: CommandRequest, metadata?: Metadata): Promise<Empty>;
}

declare type BotDefinition = typeof BotDefinition;

declare const BotDefinition: {
    readonly name: "Bot";
    readonly fullName: "devvit.actor.bot.Bot";
    readonly methods: {
        readonly getCommands: {
            readonly name: "GetCommands";
            readonly requestType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.bot.CommandsList";
                encode(message: CommandsList, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): CommandsList;
                fromJSON(object: any): CommandsList;
                toJSON(message: CommandsList): unknown;
                create(base?: DeepPartial_21<CommandsList>): CommandsList;
                fromPartial(object: DeepPartial_21<CommandsList>): CommandsList;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly onCommand: {
            readonly name: "OnCommand";
            readonly requestType: {
                $type: "devvit.actor.bot.CommandRequest";
                encode(message: CommandRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): CommandRequest;
                fromJSON(object: any): CommandRequest;
                toJSON(message: CommandRequest): unknown;
                create(base?: DeepPartial_21<CommandRequest>): CommandRequest;
                fromPartial(object: DeepPartial_21<CommandRequest>): CommandRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const BotServiceName = "devvit.actor.bot.Bot";

declare interface Builder {
    /** Compiles and links user code into an output bundle, including an audit trail, if desired. */
    Build(request: CompileParams, metadata?: Metadata): Promise<BuildResponse>;
    /** Automatically rebuild when input files change. */
    Watch(request: CompileParams, metadata?: Metadata): Observable<BuildResponse>;
}

declare class BuilderClientImpl implements Builder {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_28, opts?: {
        service?: string;
    });
    Build(request: CompileParams, metadata?: Metadata): Promise<BuildResponse>;
    Watch(request: CompileParams, metadata?: Metadata): Observable<BuildResponse>;
}

declare type BuilderDefinition = typeof BuilderDefinition;

declare const BuilderDefinition: {
    readonly name: "Builder";
    readonly fullName: "devvit.plugin.builder.Builder";
    readonly methods: {
        /** Compiles and links user code into an output bundle, including an audit trail, if desired. */
        readonly build: {
            readonly name: "Build";
            readonly requestType: {
                $type: "devvit.plugin.buildpack.CompileParams";
                encode(message: CompileParams, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CompileParams;
                fromJSON(object: any): CompileParams;
                toJSON(message: CompileParams): unknown;
                create(base?: {
                    virtualFileSystem?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    filename?: string | undefined;
                    minify?: Minify_3;
                    info?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    includeAssets?: boolean;
                } | undefined): CompileParams;
                fromPartial(object: {
                    virtualFileSystem?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    filename?: string | undefined;
                    minify?: Minify_3;
                    info?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    includeAssets?: boolean;
                }): CompileParams;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.builder.BuildResponse";
                encode(message: BuildResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): BuildResponse;
                fromJSON(object: any): BuildResponse;
                toJSON(message: BuildResponse): unknown;
                create(base?: DeepPartial_24<BuildResponse>): BuildResponse;
                fromPartial(object: DeepPartial_24<BuildResponse>): BuildResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Automatically rebuild when input files change. */
        readonly watch: {
            readonly name: "Watch";
            readonly requestType: {
                $type: "devvit.plugin.buildpack.CompileParams";
                encode(message: CompileParams, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CompileParams;
                fromJSON(object: any): CompileParams;
                toJSON(message: CompileParams): unknown;
                create(base?: {
                    virtualFileSystem?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    filename?: string | undefined;
                    minify?: Minify_3;
                    info?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    includeAssets?: boolean;
                } | undefined): CompileParams;
                fromPartial(object: {
                    virtualFileSystem?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    filename?: string | undefined;
                    minify?: Minify_3;
                    info?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    includeAssets?: boolean;
                }): CompileParams;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.builder.BuildResponse";
                encode(message: BuildResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): BuildResponse;
                fromJSON(object: any): BuildResponse;
                toJSON(message: BuildResponse): unknown;
                create(base?: DeepPartial_24<BuildResponse>): BuildResponse;
                fromPartial(object: DeepPartial_24<BuildResponse>): BuildResponse;
            };
            readonly responseStream: true;
            readonly options: {};
        };
    };
};

declare const BuilderServiceName = "devvit.plugin.builder.Builder";

/** Detail about the tooling used to construct a LinkedBundle. */
declare interface BuildInfo {
    /** When the LinkedBundle was built. */
    created?: Date | undefined;
    /**
     * Notable package.json versions recorded at build time. Eg:
     *
     *   @devvit/protos  1.2.3
     *   @devvit/public-api  4.5.6
     *   @devvit/runtimes  7.8.9
     *   node  10.11.12
     */
    dependencies: {
        [key: string]: string;
    };
}

declare const BuildInfo: {
    $type: "devvit.runtime.BuildInfo";
    encode(message: BuildInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BuildInfo;
    fromJSON(object: any): BuildInfo;
    toJSON(message: BuildInfo): unknown;
    create(base?: DeepPartial_14<BuildInfo>): BuildInfo;
    fromPartial(object: DeepPartial_14<BuildInfo>): BuildInfo;
};

declare interface BuildInfo_DependenciesEntry {
    key: string;
    value: string;
}

declare const BuildInfo_DependenciesEntry: {
    $type: "devvit.runtime.BuildInfo.DependenciesEntry";
    encode(message: BuildInfo_DependenciesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BuildInfo_DependenciesEntry;
    fromJSON(object: any): BuildInfo_DependenciesEntry;
    toJSON(message: BuildInfo_DependenciesEntry): unknown;
    create(base?: DeepPartial_14<BuildInfo_DependenciesEntry>): BuildInfo_DependenciesEntry;
    fromPartial(object: DeepPartial_14<BuildInfo_DependenciesEntry>): BuildInfo_DependenciesEntry;
};

declare interface BuildPack {
    /** Compiles user code into an output bundle, including an audit trail, if desired. */
    Compile(request: CompileParams, metadata?: Metadata): Promise<CompileResponse>;
    /** Automatically rebundle when input files change. */
    Watch(request: CompileParams, metadata?: Metadata): Observable<CompileResponse>;
}

declare class BuildPackClientImpl implements BuildPack {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_27, opts?: {
        service?: string;
    });
    Compile(request: CompileParams, metadata?: Metadata): Promise<CompileResponse>;
    Watch(request: CompileParams, metadata?: Metadata): Observable<CompileResponse>;
}

declare type BuildPackDefinition = typeof BuildPackDefinition;

declare const BuildPackDefinition: {
    readonly name: "BuildPack";
    readonly fullName: "devvit.plugin.buildpack.BuildPack";
    readonly methods: {
        /** Compiles user code into an output bundle, including an audit trail, if desired. */
        readonly compile: {
            readonly name: "Compile";
            readonly requestType: {
                $type: "devvit.plugin.buildpack.CompileParams";
                encode(message: CompileParams, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CompileParams;
                fromJSON(object: any): CompileParams;
                toJSON(message: CompileParams): unknown;
                create(base?: {
                    virtualFileSystem?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    filename?: string | undefined;
                    minify?: Minify_2;
                    info?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    includeAssets?: boolean;
                } | undefined): CompileParams;
                fromPartial(object: {
                    virtualFileSystem?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    filename?: string | undefined;
                    minify?: Minify_2;
                    info?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    includeAssets?: boolean;
                }): CompileParams;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.buildpack.CompileResponse";
                encode(message: CompileResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CompileResponse;
                fromJSON(object: any): CompileResponse;
                toJSON(message: CompileResponse): unknown;
                create(base?: {
                    bundle?: {
                        code?: string;
                        dependencies?: {
                            actor?: {
                                name?: string;
                                owner?: string;
                                version?: string;
                            } | undefined;
                            hostname?: string;
                            provides?: {
                                actor?: {
                                    name?: string;
                                    owner?: string;
                                    version?: string;
                                } | undefined;
                                definition?: {
                                    fullName?: string;
                                    methods?: {
                                        fullName?: string;
                                        name?: string;
                                        requestStream?: boolean;
                                        responseStream?: boolean;
                                        requestType?: string;
                                        responseType?: string;
                                    }[];
                                    name?: string;
                                    version?: string;
                                } | undefined;
                                locations?: {
                                    allow?: string[];
                                    deny?: string[];
                                } | undefined;
                                partitionsBy?: string[];
                            }[];
                            uses?: {
                                name?: string | undefined;
                                owner?: string | undefined;
                                typeName?: string;
                                versions?: string | undefined;
                            }[];
                        } | undefined;
                        buildInfo?: {
                            created?: Date | undefined;
                            dependencies?: {
                                [x: string]: string | undefined;
                            };
                        } | undefined;
                        assets?: {
                            files?: {
                                path?: string;
                                content?: string;
                                isDirectory?: boolean;
                                isBase64?: boolean;
                            }[];
                        } | undefined;
                        assetIds?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    errors?: {
                        detail?: {
                            column?: number;
                            filename?: string;
                            line?: number;
                            suggestion?: string;
                            text?: string;
                        } | undefined;
                        text?: string;
                    }[];
                    warnings?: {
                        detail?: {
                            column?: number;
                            filename?: string;
                            line?: number;
                            suggestion?: string;
                            text?: string;
                        } | undefined;
                        text?: string;
                    }[];
                } | undefined): CompileResponse;
                fromPartial(object: {
                    bundle?: {
                        code?: string;
                        dependencies?: {
                            actor?: {
                                name?: string;
                                owner?: string;
                                version?: string;
                            } | undefined;
                            hostname?: string;
                            provides?: {
                                actor?: {
                                    name?: string;
                                    owner?: string;
                                    version?: string;
                                } | undefined;
                                definition?: {
                                    fullName?: string;
                                    methods?: {
                                        fullName?: string;
                                        name?: string;
                                        requestStream?: boolean;
                                        responseStream?: boolean;
                                        requestType?: string;
                                        responseType?: string;
                                    }[];
                                    name?: string;
                                    version?: string;
                                } | undefined;
                                locations?: {
                                    allow?: string[];
                                    deny?: string[];
                                } | undefined;
                                partitionsBy?: string[];
                            }[];
                            uses?: {
                                name?: string | undefined;
                                owner?: string | undefined;
                                typeName?: string;
                                versions?: string | undefined;
                            }[];
                        } | undefined;
                        buildInfo?: {
                            created?: Date | undefined;
                            dependencies?: {
                                [x: string]: string | undefined;
                            };
                        } | undefined;
                        assets?: {
                            files?: {
                                path?: string;
                                content?: string;
                                isDirectory?: boolean;
                                isBase64?: boolean;
                            }[];
                        } | undefined;
                        assetIds?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    errors?: {
                        detail?: {
                            column?: number;
                            filename?: string;
                            line?: number;
                            suggestion?: string;
                            text?: string;
                        } | undefined;
                        text?: string;
                    }[];
                    warnings?: {
                        detail?: {
                            column?: number;
                            filename?: string;
                            line?: number;
                            suggestion?: string;
                            text?: string;
                        } | undefined;
                        text?: string;
                    }[];
                }): CompileResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Automatically rebundle when input files change. */
        readonly watch: {
            readonly name: "Watch";
            readonly requestType: {
                $type: "devvit.plugin.buildpack.CompileParams";
                encode(message: CompileParams, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CompileParams;
                fromJSON(object: any): CompileParams;
                toJSON(message: CompileParams): unknown;
                create(base?: {
                    virtualFileSystem?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    filename?: string | undefined;
                    minify?: Minify_2;
                    info?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    includeAssets?: boolean;
                } | undefined): CompileParams;
                fromPartial(object: {
                    virtualFileSystem?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    filename?: string | undefined;
                    minify?: Minify_2;
                    info?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    includeAssets?: boolean;
                }): CompileParams;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.buildpack.CompileResponse";
                encode(message: CompileResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CompileResponse;
                fromJSON(object: any): CompileResponse;
                toJSON(message: CompileResponse): unknown;
                create(base?: {
                    bundle?: {
                        code?: string;
                        dependencies?: {
                            actor?: {
                                name?: string;
                                owner?: string;
                                version?: string;
                            } | undefined;
                            hostname?: string;
                            provides?: {
                                actor?: {
                                    name?: string;
                                    owner?: string;
                                    version?: string;
                                } | undefined;
                                definition?: {
                                    fullName?: string;
                                    methods?: {
                                        fullName?: string;
                                        name?: string;
                                        requestStream?: boolean;
                                        responseStream?: boolean;
                                        requestType?: string;
                                        responseType?: string;
                                    }[];
                                    name?: string;
                                    version?: string;
                                } | undefined;
                                locations?: {
                                    allow?: string[];
                                    deny?: string[];
                                } | undefined;
                                partitionsBy?: string[];
                            }[];
                            uses?: {
                                name?: string | undefined;
                                owner?: string | undefined;
                                typeName?: string;
                                versions?: string | undefined;
                            }[];
                        } | undefined;
                        buildInfo?: {
                            created?: Date | undefined;
                            dependencies?: {
                                [x: string]: string | undefined;
                            };
                        } | undefined;
                        assets?: {
                            files?: {
                                path?: string;
                                content?: string;
                                isDirectory?: boolean;
                                isBase64?: boolean;
                            }[];
                        } | undefined;
                        assetIds?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    errors?: {
                        detail?: {
                            column?: number;
                            filename?: string;
                            line?: number;
                            suggestion?: string;
                            text?: string;
                        } | undefined;
                        text?: string;
                    }[];
                    warnings?: {
                        detail?: {
                            column?: number;
                            filename?: string;
                            line?: number;
                            suggestion?: string;
                            text?: string;
                        } | undefined;
                        text?: string;
                    }[];
                } | undefined): CompileResponse;
                fromPartial(object: {
                    bundle?: {
                        code?: string;
                        dependencies?: {
                            actor?: {
                                name?: string;
                                owner?: string;
                                version?: string;
                            } | undefined;
                            hostname?: string;
                            provides?: {
                                actor?: {
                                    name?: string;
                                    owner?: string;
                                    version?: string;
                                } | undefined;
                                definition?: {
                                    fullName?: string;
                                    methods?: {
                                        fullName?: string;
                                        name?: string;
                                        requestStream?: boolean;
                                        responseStream?: boolean;
                                        requestType?: string;
                                        responseType?: string;
                                    }[];
                                    name?: string;
                                    version?: string;
                                } | undefined;
                                locations?: {
                                    allow?: string[];
                                    deny?: string[];
                                } | undefined;
                                partitionsBy?: string[];
                            }[];
                            uses?: {
                                name?: string | undefined;
                                owner?: string | undefined;
                                typeName?: string;
                                versions?: string | undefined;
                            }[];
                        } | undefined;
                        buildInfo?: {
                            created?: Date | undefined;
                            dependencies?: {
                                [x: string]: string | undefined;
                            };
                        } | undefined;
                        assets?: {
                            files?: {
                                path?: string;
                                content?: string;
                                isDirectory?: boolean;
                                isBase64?: boolean;
                            }[];
                        } | undefined;
                        assetIds?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    errors?: {
                        detail?: {
                            column?: number;
                            filename?: string;
                            line?: number;
                            suggestion?: string;
                            text?: string;
                        } | undefined;
                        text?: string;
                    }[];
                    warnings?: {
                        detail?: {
                            column?: number;
                            filename?: string;
                            line?: number;
                            suggestion?: string;
                            text?: string;
                        } | undefined;
                        text?: string;
                    }[];
                }): CompileResponse;
            };
            readonly responseStream: true;
            readonly options: {};
        };
    };
};

declare const BuildPackServiceName = "devvit.plugin.buildpack.BuildPack";

declare interface BuildResponse {
    bundle?: LinkedBundle | undefined;
    errors: CompileLog[];
    warnings: CompileLog[];
}

declare const BuildResponse: {
    $type: "devvit.plugin.builder.BuildResponse";
    encode(message: BuildResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BuildResponse;
    fromJSON(object: any): BuildResponse;
    toJSON(message: BuildResponse): unknown;
    create(base?: DeepPartial_24<BuildResponse>): BuildResponse;
    fromPartial(object: DeepPartial_24<BuildResponse>): BuildResponse;
};

declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_10 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_100 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_101 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_102 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_103 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_104 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_105 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_106 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_107 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_108 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_109 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_11 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_110 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_111 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_112 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_12 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_13 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_14 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_15 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_16 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_17 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_18 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_19 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_2 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_20 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_21 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_22 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_23 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_24 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_25 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_26 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_27 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_28 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_29 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_3 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_30 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_31 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_32 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_33 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_34 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_35 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_36 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_37 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_38 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_39 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_4 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_40 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_41 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_42 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_43 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_44 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_45 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_46 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_47 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_48 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_49 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_5 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_50 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_51 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_52 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_53 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_54 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_55 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_56 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_57 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_58 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_59 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_6 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_60 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_61 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_62 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_63 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_64 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_65 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_66 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_67 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_68 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_69 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_7 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_70 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_71 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_72 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_73 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_74 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_75 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_76 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_77 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_78 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_79 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_8 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_80 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_81 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_82 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_83 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_84 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_85 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_86 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_87 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_88 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_89 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_9 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_90 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_91 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_92 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_93 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_94 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_95 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_96 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_97 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_98 = Date | Function | Uint8Array | string | number | boolean | undefined;

declare type Builtin_99 = Date | Function | Uint8Array | string | number | boolean | undefined;

/** Requests */
declare interface BulkReadConversationsRequest {
    /** comma-delimited list of subreddit names (e.g. 'pics,worldnews' */
    entity: string;
    /**
     * one of (all, appeals, notifications, inbox, filtered, inprogress, mod, archived, default,
     * highlighted, join_requests, new)
     */
    state: string;
}

declare const BulkReadConversationsRequest: {
    $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsRequest";
    encode(message: BulkReadConversationsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BulkReadConversationsRequest;
    fromJSON(object: any): BulkReadConversationsRequest;
    toJSON(message: BulkReadConversationsRequest): unknown;
    create(base?: DeepPartial_71<BulkReadConversationsRequest>): BulkReadConversationsRequest;
    fromPartial(object: DeepPartial_71<BulkReadConversationsRequest>): BulkReadConversationsRequest;
};

/** Responses */
declare interface BulkReadConversationsResponse {
    conversationIds: string[];
}

declare const BulkReadConversationsResponse: {
    $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsResponse";
    encode(message: BulkReadConversationsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BulkReadConversationsResponse;
    fromJSON(object: any): BulkReadConversationsResponse;
    toJSON(message: BulkReadConversationsResponse): unknown;
    create(base?: DeepPartial_71<BulkReadConversationsResponse>): BulkReadConversationsResponse;
    fromPartial(object: DeepPartial_71<BulkReadConversationsResponse>): BulkReadConversationsResponse;
};

/** Actor program and configuration. */
declare interface Bundle {
    /** See LinkedBundle.code. */
    code: string;
    /**
     * This is the the detail on the bundle itself **and** its dependendencies.
     *
     * to-do: Can we can rename to "spec" or something like that. This is really
     *   confusing because if you want the Bundle's exported actor name (ie,
     *   `Devvit.init(name, ...)`), you have to ask for it form the dependencies
     *   which doesn't make sense.
     */
    dependencies?: DependencySpec | undefined;
    /**
     * Optional information about the environment the code was built in. Outdated
     * dependencies may indicate an invalid build.
     */
    buildInfo?: BuildInfo | undefined;
    /**
     * Contents of the ./assets directory, rooted at the ./assets directory.
     *
     * @deprecated
     */
    assets?: FileSystem | undefined;
    /**
     * This map contains the contents of the assets directory, rooted at the
     * assets directory. The keys are the relative paths of the files, and the
     * values are the devvit asset ids used to look up the asset during upload
     *  e.g. "images/en/banner.jpg": "30d509ee-208d-4b45-86b8-b48ef48cc524",
     */
    assetIds: {
        [key: string]: string;
    };
}

declare const Bundle: {
    $type: "devvit.plugin.buildpack.Bundle";
    encode(message: Bundle, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Bundle;
    fromJSON(object: any): Bundle;
    toJSON(message: Bundle): unknown;
    create(base?: DeepPartial_23<Bundle>): Bundle;
    fromPartial(object: DeepPartial_23<Bundle>): Bundle;
};

declare interface Bundle_AssetIdsEntry {
    key: string;
    value: string;
}

declare const Bundle_AssetIdsEntry: {
    $type: "devvit.plugin.buildpack.Bundle.AssetIdsEntry";
    encode(message: Bundle_AssetIdsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Bundle_AssetIdsEntry;
    fromJSON(object: any): Bundle_AssetIdsEntry;
    toJSON(message: Bundle_AssetIdsEntry): unknown;
    create(base?: DeepPartial_23<Bundle_AssetIdsEntry>): Bundle_AssetIdsEntry;
    fromPartial(object: DeepPartial_23<Bundle_AssetIdsEntry>): Bundle_AssetIdsEntry;
};

/** Fetch a bundle by its hostname */
declare interface BundleRequest {
    /** Must be legal name for filesystem. Eg, LinkedBundle.hostname. 'main.local' */
    hostname: string;
}

declare const BundleRequest: {
    $type: "devvit.service.BundleRequest";
    encode(message: BundleRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BundleRequest;
    fromJSON(object: any): BundleRequest;
    toJSON(message: BundleRequest): unknown;
    create(base?: DeepPartial_25<BundleRequest>): BundleRequest;
    fromPartial(object: DeepPartial_25<BundleRequest>): BundleRequest;
};

declare interface BundleService {
    /** Upload a bundle to the bundle repo */
    Upload(request: LinkedBundle, metadata?: Metadata): Promise<Empty>;
    /** Retrieve a bundle from the bundle repo */
    Fetch(request: BundleRequest, metadata?: Metadata): Promise<LinkedBundle>;
}

declare class BundleServiceClientImpl implements BundleService {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_2, opts?: {
        service?: string;
    });
    Upload(request: LinkedBundle, metadata?: Metadata): Promise<Empty>;
    Fetch(request: BundleRequest, metadata?: Metadata): Promise<LinkedBundle>;
}

declare type BundleServiceDefinition = typeof BundleServiceDefinition;

declare const BundleServiceDefinition: {
    readonly name: "BundleService";
    readonly fullName: "devvit.service.BundleService";
    readonly methods: {
        /** Upload a bundle to the bundle repo */
        readonly upload: {
            readonly name: "Upload";
            readonly requestType: {
                $type: "devvit.runtime.LinkedBundle";
                encode(message: LinkedBundle, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): LinkedBundle;
                fromJSON(object: any): LinkedBundle;
                toJSON(message: LinkedBundle): unknown;
                create(base?: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): LinkedBundle;
                fromPartial(object: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                }): LinkedBundle;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Retrieve a bundle from the bundle repo */
        readonly fetch: {
            readonly name: "Fetch";
            readonly requestType: {
                $type: "devvit.service.BundleRequest";
                encode(message: BundleRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): BundleRequest;
                fromJSON(object: any): BundleRequest;
                toJSON(message: BundleRequest): unknown;
                create(base?: DeepPartial_25<BundleRequest>): BundleRequest;
                fromPartial(object: DeepPartial_25<BundleRequest>): BundleRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.runtime.LinkedBundle";
                encode(message: LinkedBundle, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): LinkedBundle;
                fromJSON(object: any): LinkedBundle;
                toJSON(message: LinkedBundle): unknown;
                create(base?: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): LinkedBundle;
                fromPartial(object: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                }): LinkedBundle;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const BundleServiceServiceName = "devvit.service.BundleService";

export declare class ButtonWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get buttons(): WidgetButton[];
    get description(): string;
    get styles(): WidgetStyles;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<ButtonWidget, 'buttons' | 'description' | 'styles'>;
}

declare interface ButtonWidget_2 {
    id: string;
    kind: string;
    shortName: string;
    description: string;
    buttons: WidgetButton[];
    styles?: WidgetStyles | undefined;
}

declare const ButtonWidget_2: {
    $type: "devvit.plugin.redditapi.widgets.ButtonWidget";
    encode(message: ButtonWidget_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ButtonWidget_2;
    fromJSON(object: any): ButtonWidget_2;
    toJSON(message: ButtonWidget_2): unknown;
    create(base?: DeepPartial_4<ButtonWidget_2>): ButtonWidget_2;
    fromPartial(object: DeepPartial_4<ButtonWidget_2>): ButtonWidget_2;
};

/**
 * Wrapper message for `bytes`.
 *
 * The JSON representation for `BytesValue` is JSON string.
 */
declare interface BytesValue {
    /** The bytes value. */
    value: Uint8Array;
}

declare const BytesValue: {
    $type: "google.protobuf.BytesValue";
    encode(message: BytesValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BytesValue;
    fromJSON(object: any): BytesValue;
    toJSON(message: BytesValue): unknown;
    create(base?: DeepPartial_69<BytesValue>): BytesValue;
    fromPartial(object: DeepPartial_69<BytesValue>): BytesValue;
};

declare type CacheHelper = <T extends JSONValue>(fn: () => Promise<T>, options: CacheOptions) => Promise<T>;

declare type CacheOptions = {
    /**
     * Time to live in milliseconds.
     */
    ttl: number;
    /**
     * Key to use for caching.
     */
    key: string;
};

declare interface CacheUtils {
    PurgeAccessKey(request: AccessKeyPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
    PurgeInstallations(request: InstallationsPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
    PurgeInstallation(request: InstallationPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
    PurgeAppVersion(request: AppVersionPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
    PurgeApp(request: AppPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
}

declare class CacheUtilsClientImpl implements CacheUtils {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_61, opts?: {
        service?: string;
    });
    PurgeAccessKey(request: AccessKeyPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
    PurgeInstallations(request: InstallationsPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
    PurgeInstallation(request: InstallationPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
    PurgeAppVersion(request: AppVersionPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
    PurgeApp(request: AppPurgeRequest, metadata?: Metadata): Promise<PurgeResult>;
}

declare type CacheUtilsDefinition = typeof CacheUtilsDefinition;

declare const CacheUtilsDefinition: {
    readonly name: "CacheUtils";
    readonly fullName: "devvit.gateway.utils.v1alpha.CacheUtils";
    readonly methods: {
        readonly purgeAccessKey: {
            readonly name: "PurgeAccessKey";
            readonly requestType: {
                $type: "devvit.gateway.utils.v1alpha.AccessKeyPurgeRequest";
                encode(message: AccessKeyPurgeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): AccessKeyPurgeRequest;
                fromJSON(object: any): AccessKeyPurgeRequest;
                toJSON(message: AccessKeyPurgeRequest): unknown;
                create(base?: DeepPartial_26<AccessKeyPurgeRequest>): AccessKeyPurgeRequest;
                fromPartial(object: DeepPartial_26<AccessKeyPurgeRequest>): AccessKeyPurgeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gateway.utils.v1alpha.PurgeResult";
                encode(message: PurgeResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): PurgeResult;
                fromJSON(object: any): PurgeResult;
                toJSON(message: PurgeResult): unknown;
                create(base?: DeepPartial_26<PurgeResult>): PurgeResult;
                fromPartial(object: DeepPartial_26<PurgeResult>): PurgeResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly purgeInstallations: {
            readonly name: "PurgeInstallations";
            readonly requestType: {
                $type: "devvit.gateway.utils.v1alpha.InstallationsPurgeRequest";
                encode(message: InstallationsPurgeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): InstallationsPurgeRequest;
                fromJSON(object: any): InstallationsPurgeRequest;
                toJSON(message: InstallationsPurgeRequest): unknown;
                create(base?: DeepPartial_26<InstallationsPurgeRequest>): InstallationsPurgeRequest;
                fromPartial(object: DeepPartial_26<InstallationsPurgeRequest>): InstallationsPurgeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gateway.utils.v1alpha.PurgeResult";
                encode(message: PurgeResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): PurgeResult;
                fromJSON(object: any): PurgeResult;
                toJSON(message: PurgeResult): unknown;
                create(base?: DeepPartial_26<PurgeResult>): PurgeResult;
                fromPartial(object: DeepPartial_26<PurgeResult>): PurgeResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly purgeInstallation: {
            readonly name: "PurgeInstallation";
            readonly requestType: {
                $type: "devvit.gateway.utils.v1alpha.InstallationPurgeRequest";
                encode(message: InstallationPurgeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): InstallationPurgeRequest;
                fromJSON(object: any): InstallationPurgeRequest;
                toJSON(message: InstallationPurgeRequest): unknown;
                create(base?: DeepPartial_26<InstallationPurgeRequest>): InstallationPurgeRequest;
                fromPartial(object: DeepPartial_26<InstallationPurgeRequest>): InstallationPurgeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gateway.utils.v1alpha.PurgeResult";
                encode(message: PurgeResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): PurgeResult;
                fromJSON(object: any): PurgeResult;
                toJSON(message: PurgeResult): unknown;
                create(base?: DeepPartial_26<PurgeResult>): PurgeResult;
                fromPartial(object: DeepPartial_26<PurgeResult>): PurgeResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly purgeAppVersion: {
            readonly name: "PurgeAppVersion";
            readonly requestType: {
                $type: "devvit.gateway.utils.v1alpha.AppVersionPurgeRequest";
                encode(message: AppVersionPurgeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): AppVersionPurgeRequest;
                fromJSON(object: any): AppVersionPurgeRequest;
                toJSON(message: AppVersionPurgeRequest): unknown;
                create(base?: DeepPartial_26<AppVersionPurgeRequest>): AppVersionPurgeRequest;
                fromPartial(object: DeepPartial_26<AppVersionPurgeRequest>): AppVersionPurgeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gateway.utils.v1alpha.PurgeResult";
                encode(message: PurgeResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): PurgeResult;
                fromJSON(object: any): PurgeResult;
                toJSON(message: PurgeResult): unknown;
                create(base?: DeepPartial_26<PurgeResult>): PurgeResult;
                fromPartial(object: DeepPartial_26<PurgeResult>): PurgeResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly purgeApp: {
            readonly name: "PurgeApp";
            readonly requestType: {
                $type: "devvit.gateway.utils.v1alpha.AppPurgeRequest";
                encode(message: AppPurgeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): AppPurgeRequest;
                fromJSON(object: any): AppPurgeRequest;
                toJSON(message: AppPurgeRequest): unknown;
                create(base?: DeepPartial_26<AppPurgeRequest>): AppPurgeRequest;
                fromPartial(object: DeepPartial_26<AppPurgeRequest>): AppPurgeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gateway.utils.v1alpha.PurgeResult";
                encode(message: PurgeResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): PurgeResult;
                fromJSON(object: any): PurgeResult;
                toJSON(message: PurgeResult): unknown;
                create(base?: DeepPartial_26<PurgeResult>): PurgeResult;
                fromPartial(object: DeepPartial_26<PurgeResult>): PurgeResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const CacheUtilsServiceName = "devvit.gateway.utils.v1alpha.CacheUtils";

export declare class CalendarWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get googleCalendarId(): string;
    get configuration(): CalendarWidgetConfiguration;
    get styles(): WidgetStyles;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<CalendarWidget, 'googleCalendarId' | 'configuration' | 'styles'>;
}

declare interface CalendarWidget_2 {
    id: string;
    kind: string;
    configuration?: CalendarWidgetConfiguration | undefined;
    googleCalendarId: string;
    requiresSync: boolean;
    shortName: string;
    styles?: WidgetStyles | undefined;
}

declare const CalendarWidget_2: {
    $type: "devvit.plugin.redditapi.widgets.CalendarWidget";
    encode(message: CalendarWidget_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CalendarWidget_2;
    fromJSON(object: any): CalendarWidget_2;
    toJSON(message: CalendarWidget_2): unknown;
    create(base?: DeepPartial_4<CalendarWidget_2>): CalendarWidget_2;
    fromPartial(object: DeepPartial_4<CalendarWidget_2>): CalendarWidget_2;
};

declare interface CalendarWidgetConfiguration {
    numEvents: number;
    showDate: boolean;
    showDescription: boolean;
    showLocation: boolean;
    showTime: boolean;
    showTitle: boolean;
}

declare const CalendarWidgetConfiguration: {
    $type: "devvit.plugin.redditapi.widgets.CalendarWidgetConfiguration";
    encode(message: CalendarWidgetConfiguration, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CalendarWidgetConfiguration;
    fromJSON(object: any): CalendarWidgetConfiguration;
    toJSON(message: CalendarWidgetConfiguration): unknown;
    create(base?: DeepPartial_4<CalendarWidgetConfiguration>): CalendarWidgetConfiguration;
    fromPartial(object: DeepPartial_4<CalendarWidgetConfiguration>): CalendarWidgetConfiguration;
};

declare interface CancelActionRequest {
    /** Opaque ID returned from a previous call to Schedule() */
    id: string;
}

declare const CancelActionRequest: {
    $type: "devvit.plugin.scheduler.CancelActionRequest";
    encode(message: CancelActionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CancelActionRequest;
    fromJSON(object: any): CancelActionRequest;
    toJSON(message: CancelActionRequest): unknown;
    create(base?: DeepPartial_89<CancelActionRequest>): CancelActionRequest;
    fromPartial(object: DeepPartial_89<CancelActionRequest>): CancelActionRequest;
};

/**
 * Cancel a scheduled job
 * @param jobId The id of the job to cancel
 */
export declare type CancelJob = (jobId: string) => Promise<void>;

declare type ChannelOptions = {
    /** Name of the channel */
    name: string;
    /** Called every time a message is received on this channel */
    onMessage(data: Data): void | undefined;
    /** Optional hook to be informed when the channel has connected */
    onSubscribed?: (() => void | Promise<void>) | undefined;
    /** Optional hook to be informed when the channel has disconnected */
    onUnsubscribed?: (() => void | Promise<void>) | undefined;
};

declare enum ChannelStatus {
    Unknown = 0,
    Connecting = 1,
    Connected = 2,
    Disconnecting = 3,
    Disconnected = 4
}

declare interface ClearFlairTemplatesRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** one of (USER_FLAIR, LINK_FLAIR) */
    flairType: string;
}

declare const ClearFlairTemplatesRequest: {
    $type: "devvit.plugin.redditapi.flair.ClearFlairTemplatesRequest";
    encode(message: ClearFlairTemplatesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ClearFlairTemplatesRequest;
    fromJSON(object: any): ClearFlairTemplatesRequest;
    toJSON(message: ClearFlairTemplatesRequest): unknown;
    create(base?: DeepPartial_56<ClearFlairTemplatesRequest>): ClearFlairTemplatesRequest;
    fromPartial(object: DeepPartial_56<ClearFlairTemplatesRequest>): ClearFlairTemplatesRequest;
};

declare interface Clock {
    Now(request: Empty, metadata?: Metadata): Promise<Timestamp>;
}

declare class ClockClientImpl implements Clock {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_26, opts?: {
        service?: string;
    });
    Now(request: Empty, metadata?: Metadata): Promise<Timestamp>;
}

declare type ClockDefinition = typeof ClockDefinition;

declare const ClockDefinition: {
    readonly name: "Clock";
    readonly fullName: "devvit.plugin.clock.Clock";
    readonly methods: {
        readonly now: {
            readonly name: "Now";
            readonly requestType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Timestamp";
                encode(message: Timestamp, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Timestamp;
                fromJSON(object: any): Timestamp;
                toJSON(message: Timestamp): unknown;
                create(base?: {
                    seconds?: number;
                    nanos?: number;
                } | undefined): Timestamp;
                fromPartial(object: {
                    seconds?: number;
                    nanos?: number;
                }): Timestamp;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const ClockServiceName = "devvit.plugin.clock.Clock";

/**
 * @mixin
 */
declare type CodeBlockContainer<Context> = {
    /**
     * Append a Code Block element
     * @param opts {@link CodeBlockOptions}
     * @param cb scoped callback to add child elements to this Code Block
     */
    codeBlock(opts: CodeBlockOptions, cb: (codeBlock: CodeBlockContext) => void): Context;
};

/**
 * @borrows RawTextContainer
 */
declare interface CodeBlockContext extends RawTextContainer<CodeBlockContext> {
}

declare type CodeBlockOptions = {
    /**
     * Language of the content in this Code Block
     * @example { language: 'javascript' }
     */
    language?: string;
};

/** Determines how the collection items will be displayed in the ui. */
export declare enum CollectionDisplayLayout {
    /** PostCollection items will be displayed as a gallery. */
    Gallery = "GALLERY",
    /** PostCollection items will be displayed as a list. */
    Timeline = "TIMELINE"
}

/** requests */
declare interface CollectionRequest {
    /** The id of the collection to fetch. */
    collectionId?: string | undefined;
    /** The id of the collection to fetch. */
    includeLinks?: boolean | undefined;
}

declare const CollectionRequest: {
    $type: "devvit.plugin.redditapi.postcollections.CollectionRequest";
    encode(message: CollectionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CollectionRequest;
    fromJSON(object: any): CollectionRequest;
    toJSON(message: CollectionRequest): unknown;
    create(base?: DeepPartial_81<CollectionRequest>): CollectionRequest;
    fromPartial(object: DeepPartial_81<CollectionRequest>): CollectionRequest;
};

/** responses */
declare interface CollectionResponse {
    /** The id of the collection. */
    collectionId?: string | undefined;
    /** The subreddit id of subreddit that owns the collection. */
    subredditId?: string | undefined;
    /** The title of the collection. */
    title?: string | undefined;
    /** The description of the collection. */
    description?: string | undefined;
    /** The t2_ id of the user that created the collection. */
    authorId?: string | undefined;
    /** The username of the user that created the collection. */
    authorName?: string | undefined;
    /** A deep link to the collection. */
    permalink?: string | undefined;
    linkIds: string[];
    primaryLinkId?: string | undefined;
    /** One of: TIMELINE | GALLERY. This determines the layout of posts in the collection ui. */
    displayLayout?: string | undefined;
    createdAtUtc?: Date | undefined;
    lastUpdateUtc?: Date | undefined;
}

declare const CollectionResponse: {
    $type: "devvit.plugin.redditapi.postcollections.CollectionResponse";
    encode(message: CollectionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CollectionResponse;
    fromJSON(object: any): CollectionResponse;
    toJSON(message: CollectionResponse): unknown;
    create(base?: DeepPartial_81<CollectionResponse>): CollectionResponse;
    fromPartial(object: DeepPartial_81<CollectionResponse>): CollectionResponse;
};

declare interface CommandContext {
    user: string;
    subreddit: string;
    post: string;
    comment: string;
}

declare const CommandContext: {
    $type: "devvit.actor.bot.CommandContext";
    encode(message: CommandContext, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommandContext;
    fromJSON(object: any): CommandContext;
    toJSON(message: CommandContext): unknown;
    create(base?: DeepPartial_21<CommandContext>): CommandContext;
    fromPartial(object: DeepPartial_21<CommandContext>): CommandContext;
};

declare interface CommandDescription {
    name: string;
    command: string;
    description: string;
    usage: string;
}

declare const CommandDescription: {
    $type: "devvit.actor.bot.CommandDescription";
    encode(message: CommandDescription, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommandDescription;
    fromJSON(object: any): CommandDescription;
    toJSON(message: CommandDescription): unknown;
    create(base?: DeepPartial_21<CommandDescription>): CommandDescription;
    fromPartial(object: DeepPartial_21<CommandDescription>): CommandDescription;
};

declare interface CommandRequest {
    context?: CommandContext | undefined;
    command: string;
    args: string;
}

declare const CommandRequest: {
    $type: "devvit.actor.bot.CommandRequest";
    encode(message: CommandRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommandRequest;
    fromJSON(object: any): CommandRequest;
    toJSON(message: CommandRequest): unknown;
    create(base?: DeepPartial_21<CommandRequest>): CommandRequest;
    fromPartial(object: DeepPartial_21<CommandRequest>): CommandRequest;
};

declare interface CommandsList {
    commands: CommandDescription[];
}

declare const CommandsList: {
    $type: "devvit.actor.bot.CommandsList";
    encode(message: CommandsList, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommandsList;
    fromJSON(object: any): CommandsList;
    toJSON(message: CommandsList): unknown;
    create(base?: DeepPartial_21<CommandsList>): CommandsList;
    fromPartial(object: DeepPartial_21<CommandsList>): CommandsList;
};

export declare class Comment {
    #private;
    get id(): T1ID;
    get authorId(): T2ID | undefined;
    get authorName(): string;
    get subredditId(): T5ID;
    get subredditName(): string;
    get body(): string;
    get createdAt(): Date;
    get parentId(): T1ID | T3ID;
    get postId(): T3ID;
    get replies(): Listing<Comment>;
    get distinguishedBy(): string | undefined;
    get locked(): boolean;
    get stickied(): boolean;
    get removed(): boolean;
    get approved(): boolean;
    get spam(): boolean;
    get edited(): boolean;
    get numReports(): number;
    get collapsedBecauseCrowdControl(): boolean;
    get score(): number;
    get permalink(): string;
    get userReportReasons(): string[];
    get modReportReasons(): string[];
    get url(): string;
    toJSON(): Pick<Comment, 'id' | 'authorName' | 'subredditId' | 'subredditName' | 'body' | 'createdAt' | 'parentId' | 'postId' | 'replies' | 'approved' | 'locked' | 'removed' | 'stickied' | 'spam' | 'edited' | 'distinguishedBy' | 'numReports' | 'collapsedBecauseCrowdControl' | 'score' | 'permalink' | 'userReportReasons' | 'modReportReasons' | 'url'>;
    isLocked(): boolean;
    isApproved(): boolean;
    isRemoved(): boolean;
    isSpam(): boolean;
    isStickied(): boolean;
    isDistinguished(): boolean;
    isEdited(): boolean;
    delete(): Promise<void>;
    edit(options: EditCommentOptions): Promise<this>;
    approve(): Promise<void>;
    remove(isSpam?: boolean): Promise<void>;
    lock(): Promise<void>;
    unlock(): Promise<void>;
    reply(options: ReplyToCommentOptions): Promise<Comment>;
    getAuthor(): Promise<User>;
    distinguish(makeSticky?: boolean): Promise<void>;
    distinguishAsAdmin(makeSticky?: boolean): Promise<void>;
    undistinguish(): Promise<void>;
    /**
     * Add a mod note for why the comment was removed
     *
     * @param options.reasonId id of a Removal Reason - you can leave this as an empty string if you don't have one
     * @param options.modNote the reason for removal (maximum 100 characters) (optional)
     * @returns
     */
    addRemovalNote(options: {
        reasonId: string;
        modNote?: string;
    }): Promise<void>;
}

declare interface Comment_2 {
    allAwardings: Awarding[];
    approved?: boolean | undefined;
    approvedAtUtc?: number | undefined;
    approvedBy?: string | undefined;
    archived?: boolean | undefined;
    associatedAward?: string | undefined;
    author?: string | undefined;
    authorFlairBackgroundColor?: string | undefined;
    authorFlairCssClass?: string | undefined;
    authorFlairRichtext: AuthorFlairRichText[];
    authorFlairTemplateId?: string | undefined;
    authorFlairText?: string | undefined;
    authorFlairTextColor?: string | undefined;
    authorFlairType?: string | undefined;
    authorFullname?: string | undefined;
    authorIsBlocked?: boolean | undefined;
    authorPatreonFlair?: boolean | undefined;
    authorPremium?: boolean | undefined;
    awarders: string[];
    bannedAtUtc?: number | undefined;
    bannedBy?: string | undefined;
    body?: string | undefined;
    bodyHtml?: string | undefined;
    canGild?: boolean | undefined;
    canModPost?: boolean | undefined;
    collapsed?: boolean | undefined;
    collapsedBecauseCrowdControl?: boolean | undefined;
    collapsedReason?: string | undefined;
    collapsedReasonCode?: string | undefined;
    commentType?: string | undefined;
    controversiality?: number | undefined;
    created?: number | undefined;
    createdUtc?: number | undefined;
    depth?: number | undefined;
    distinguished?: string | undefined;
    downs?: number | undefined;
    edited?: boolean | undefined;
    gilded?: number | undefined;
    gildings?: Gildings | undefined;
    id?: string | undefined;
    ignoreReports?: boolean | undefined;
    isSubmitter?: boolean | undefined;
    likes?: boolean | undefined;
    linkId?: string | undefined;
    locked?: boolean | undefined;
    modNote?: string | undefined;
    modReasonBy?: string | undefined;
    modReasonTitle?: string | undefined;
    /** array of array of strings :-/ */
    modReports: Array<any>[];
    name?: string | undefined;
    noFollow?: boolean | undefined;
    numReports?: number | undefined;
    parentId?: string | undefined;
    permalink?: string | undefined;
    removalReason?: string | undefined;
    removed?: boolean | undefined;
    replies?: string | undefined;
    reportReasons: string[];
    rteMode?: string | undefined;
    saved?: boolean | undefined;
    score?: number | undefined;
    scoreHidden?: boolean | undefined;
    sendReplies?: boolean | undefined;
    spam?: boolean | undefined;
    stickied?: boolean | undefined;
    subreddit?: string | undefined;
    subredditId?: string | undefined;
    subredditNamePrefixed?: string | undefined;
    subredditType?: string | undefined;
    topAwardedType?: string | undefined;
    totalAwardsReceived?: number | undefined;
    treatmentTags: string[];
    unrepliableReason?: string | undefined;
    ups?: number | undefined;
    /** array of array of strings :-/ */
    userReports: Array<any>[];
    /** more type - for getting more comments */
    count?: number | undefined;
    /**
     * name: predefined at 50
     * id: predefined at 40
     * parent_id: predefined at 53
     * depth: predefined at 34
     */
    children: string[];
    /** needed for automod tap/compare */
    banInfo?: BanInfo | undefined;
    /** PRIVATE - DO NOT SET FOR PUBLIC USE */
    markedSpam?: boolean | undefined;
    verdict?: string | undefined;
}

declare const Comment_2: {
    $type: "devvit.reddit.Comment";
    encode(message: Comment_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Comment_2;
    fromJSON(object: any): Comment_2;
    toJSON(message: Comment_2): unknown;
    create(base?: DeepPartial_65<Comment_2>): Comment_2;
    fromPartial(object: DeepPartial_65<Comment_2>): Comment_2;
};

declare const COMMENT_LINK_ELEMENT = "c/";

declare interface CommentApprove {
    comment?: CommentV2 | undefined;
    post?: PostV2 | undefined;
    approvedAt?: Date | undefined;
    author?: UserV2 | undefined;
    source: EventSource_2;
    subreddit?: SubredditV2 | undefined;
}

declare const CommentApprove: {
    $type: "devvit.events.v1alpha.CommentApprove";
    encode(message: CommentApprove, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommentApprove;
    fromJSON(object: any): CommentApprove;
    toJSON(message: CommentApprove): unknown;
    create(base?: DeepPartial_74<CommentApprove>): CommentApprove;
    fromPartial(object: DeepPartial_74<CommentApprove>): CommentApprove;
};

declare interface CommentContributionSettings {
    allowedMediaTypes: string[];
}

declare const CommentContributionSettings: {
    $type: "devvit.reddit.CommentContributionSettings";
    encode(message: CommentContributionSettings, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommentContributionSettings;
    fromJSON(object: any): CommentContributionSettings;
    toJSON(message: CommentContributionSettings): unknown;
    create(base?: DeepPartial_5<CommentContributionSettings>): CommentContributionSettings;
    fromPartial(object: DeepPartial_5<CommentContributionSettings>): CommentContributionSettings;
};

/** The event name for when a comment is created, after safety delay */
export declare type CommentCreate = 'CommentCreate';

declare interface CommentCreate_2 {
    comment?: CommentV2 | undefined;
    author?: UserV2 | undefined;
    post?: PostV2 | undefined;
    subreddit?: SubredditV2 | undefined;
}

declare const CommentCreate_2: {
    $type: "devvit.events.v1alpha.CommentCreate";
    encode(message: CommentCreate_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommentCreate_2;
    fromJSON(object: any): CommentCreate_2;
    toJSON(message: CommentCreate_2): unknown;
    create(base?: DeepPartial_74<CommentCreate_2>): CommentCreate_2;
    fromPartial(object: DeepPartial_74<CommentCreate_2>): CommentCreate_2;
};

export declare type CommentCreateDefinition = {
    event: CommentCreate;
    onEvent: TriggerOnEventHandler<protos.CommentCreate>;
};

/** The event name for when a comment is deleted */
export declare type CommentDelete = 'CommentDelete';

declare interface CommentDelete_2 {
    commentId: string;
    postId: string;
    parentId: string;
    deletedAt?: Date | undefined;
    author?: UserV2 | undefined;
    createdAt?: Date | undefined;
    source: EventSource_2;
    reason: DeletionReason;
    subreddit?: SubredditV2 | undefined;
}

declare const CommentDelete_2: {
    $type: "devvit.events.v1alpha.CommentDelete";
    encode(message: CommentDelete_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommentDelete_2;
    fromJSON(object: any): CommentDelete_2;
    toJSON(message: CommentDelete_2): unknown;
    create(base?: DeepPartial_74<CommentDelete_2>): CommentDelete_2;
    fromPartial(object: DeepPartial_74<CommentDelete_2>): CommentDelete_2;
};

export declare type CommentDeleteDefinition = {
    event: CommentDelete;
    onEvent: TriggerOnEventHandler<protos.CommentDelete>;
};

declare type CommentLink = {
    e: typeof COMMENT_LINK_ELEMENT;
    t: string;
};

/**
 * @borrows RedditPermalinkOptions
 */
declare type CommentLinkOptions = RedditPermalinkOptions;

export declare type CommentMediaTypes = 'giphy' | 'static' | 'animated' | 'expression';

/** The event name for when a comment is reported */
export declare type CommentReport = 'CommentReport';

declare interface CommentReport_2 {
    comment?: CommentV2 | undefined;
    subreddit?: SubredditV2 | undefined;
    reason: string;
}

declare const CommentReport_2: {
    $type: "devvit.events.v1alpha.CommentReport";
    encode(message: CommentReport_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommentReport_2;
    fromJSON(object: any): CommentReport_2;
    toJSON(message: CommentReport_2): unknown;
    create(base?: DeepPartial_74<CommentReport_2>): CommentReport_2;
    fromPartial(object: DeepPartial_74<CommentReport_2>): CommentReport_2;
};

export declare type CommentReportDefinition = {
    event: CommentReport;
    onEvent: TriggerOnEventHandler<protos.CommentReport>;
};

/** Request Types */
declare interface CommentRequest {
    /**
     * Rich-text body of the comment. Serialized RTJSON string.
     * Note: If `richtext_json` is provided, `text` is ignored.
     * @example '{"document":[{"e":"par","c":[{"e":"text","t":"Hello, world!","f":[[2, 0, 13]]}]}]}'
     */
    richtextJson?: string | undefined;
    /**
     * Markdown body of the comment
     * @example '_Hello, world!_'
     */
    text: string;
    /**
     * Post or Comment thing ID
     * @example "t3_abc123"
     */
    thingId: string;
}

declare const CommentRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.CommentRequest";
    encode(message: CommentRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommentRequest;
    fromJSON(object: any): CommentRequest;
    toJSON(message: CommentRequest): unknown;
    create(base?: DeepPartial_64<CommentRequest>): CommentRequest;
    fromPartial(object: DeepPartial_64<CommentRequest>): CommentRequest;
};

export declare type CommentSort = 'confidence' | 'top' | 'new' | 'controversial' | 'old' | 'random' | 'qa' | 'live';

export declare type CommentSubmissionOptions = {
    text: string;
} | {
    richtext: object | RichTextBuilder;
};

/** The event name for when a comment is submitted */
export declare type CommentSubmit = 'CommentSubmit';

declare interface CommentSubmit_2 {
    comment?: CommentV2 | undefined;
    author?: UserV2 | undefined;
    post?: PostV2 | undefined;
    subreddit?: SubredditV2 | undefined;
}

declare const CommentSubmit_2: {
    $type: "devvit.events.v1alpha.CommentSubmit";
    encode(message: CommentSubmit_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommentSubmit_2;
    fromJSON(object: any): CommentSubmit_2;
    toJSON(message: CommentSubmit_2): unknown;
    create(base?: DeepPartial_74<CommentSubmit_2>): CommentSubmit_2;
    fromPartial(object: DeepPartial_74<CommentSubmit_2>): CommentSubmit_2;
};

export declare type CommentSubmitDefinition = {
    event: CommentSubmit;
    onEvent: TriggerOnEventHandler<protos.CommentSubmit>;
};

/** The event name for when a comment is updated */
export declare type CommentUpdate = 'CommentUpdate';

declare interface CommentUpdate_2 {
    comment?: CommentV2 | undefined;
    author?: UserV2 | undefined;
    post?: PostV2 | undefined;
    previousBody: string;
    subreddit?: SubredditV2 | undefined;
}

declare const CommentUpdate_2: {
    $type: "devvit.events.v1alpha.CommentUpdate";
    encode(message: CommentUpdate_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommentUpdate_2;
    fromJSON(object: any): CommentUpdate_2;
    toJSON(message: CommentUpdate_2): unknown;
    create(base?: DeepPartial_74<CommentUpdate_2>): CommentUpdate_2;
    fromPartial(object: DeepPartial_74<CommentUpdate_2>): CommentUpdate_2;
};

export declare type CommentUpdateDefinition = {
    event: CommentUpdate;
    onEvent: TriggerOnEventHandler<protos.CommentUpdate>;
};

declare interface CommentV2 {
    id: string;
    parentId: string;
    body: string;
    author: string;
    numReports: number;
    collapsedBecauseCrowdControl: boolean;
    spam: boolean;
    deleted: boolean;
    createdAt: number;
    upvotes: number;
    downvotes: number;
    languageCode: string;
    lastModifiedAt: number;
    gilded: boolean;
    score: number;
    permalink: string;
    hasMedia: boolean;
    postId: string;
    subredditId: string;
    elementTypes: string[];
}

declare const CommentV2: {
    $type: "devvit.reddit.v2alpha.CommentV2";
    encode(message: CommentV2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommentV2;
    fromJSON(object: any): CommentV2;
    toJSON(message: CommentV2): unknown;
    create(base?: DeepPartial_77<CommentV2>): CommentV2;
    fromPartial(object: DeepPartial_77<CommentV2>): CommentV2;
};

export declare type CommonSubmitPostOptions = {
    title: string;
    sendreplies?: boolean;
    nsfw?: boolean;
    spoiler?: boolean;
    flairId?: string;
    flairText?: string;
};

export declare class CommunityListWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get communities(): CommunityListWidget_CommunityData[];
    get styles(): WidgetStyles;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<CommunityListWidget, 'communities' | 'styles'>;
}

declare interface CommunityListWidget_2 {
    id: string;
    kind: string;
    shortName: string;
    data: CommunityListWidget_CommunityData[];
    styles?: WidgetStyles | undefined;
}

declare const CommunityListWidget_2: {
    $type: "devvit.plugin.redditapi.widgets.CommunityListWidget";
    encode(message: CommunityListWidget_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommunityListWidget_2;
    fromJSON(object: any): CommunityListWidget_2;
    toJSON(message: CommunityListWidget_2): unknown;
    create(base?: DeepPartial_4<CommunityListWidget_2>): CommunityListWidget_2;
    fromPartial(object: DeepPartial_4<CommunityListWidget_2>): CommunityListWidget_2;
};

declare interface CommunityListWidget_CommunityData {
    communityIcon: string;
    iconUrl: string;
    isNsfw: boolean;
    isSubscribed: boolean;
    name: string;
    prefixedName: string;
    primaryColor: string;
    subscribers: number;
    type: string;
}

declare const CommunityListWidget_CommunityData: {
    $type: "devvit.plugin.redditapi.widgets.CommunityListWidget.CommunityData";
    encode(message: CommunityListWidget_CommunityData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommunityListWidget_CommunityData;
    fromJSON(object: any): CommunityListWidget_CommunityData;
    toJSON(message: CommunityListWidget_CommunityData): unknown;
    create(base?: DeepPartial_4<CommunityListWidget_CommunityData>): CommunityListWidget_CommunityData;
    fromPartial(object: DeepPartial_4<CommunityListWidget_CommunityData>): CommunityListWidget_CommunityData;
};

declare interface CompileLog {
    detail?: CompileLogLineDetail | undefined;
    text: string;
}

declare const CompileLog: {
    $type: "devvit.plugin.buildpack.CompileLog";
    encode(message: CompileLog, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileLog;
    fromJSON(object: any): CompileLog;
    toJSON(message: CompileLog): unknown;
    create(base?: DeepPartial_23<CompileLog>): CompileLog;
    fromPartial(object: DeepPartial_23<CompileLog>): CompileLog;
};

declare interface CompileLogLineDetail {
    /** 0-based. */
    column: number;
    filename: string;
    /** 1-based. */
    line: number;
    suggestion: string;
    text: string;
}

declare const CompileLogLineDetail: {
    $type: "devvit.plugin.buildpack.CompileLogLineDetail";
    encode(message: CompileLogLineDetail, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileLogLineDetail;
    fromJSON(object: any): CompileLogLineDetail;
    toJSON(message: CompileLogLineDetail): unknown;
    create(base?: DeepPartial_23<CompileLogLineDetail>): CompileLogLineDetail;
    fromPartial(object: DeepPartial_23<CompileLogLineDetail>): CompileLogLineDetail;
};

declare interface CompileParams {
    /**
     * This is the stateless version, where the entire information needed to be
     * bundled is included with the request.  This **MUST** be supported for all
     * languages/implementations.
     */
    virtualFileSystem?: FileSystem | undefined;
    /**
     * Path to a directory with a file named BuildPack.DevvitModuleEntryPoint.
     *
     * Here we assume that we've transferred the repo to the build server using
     * rsync, git, or some other efficient protocol with e.g. deltas and
     * compression.
     *
     * This **MAY** be supported for various languages/implementations, and the
     * rsync-like protocol is left as an exercise for the build pack
     * implementor.
     */
    filename?: string | undefined;
    minify: Minify;
    info?: ActorSpec | undefined;
    includeAssets: boolean;
}

declare const CompileParams: {
    $type: "devvit.plugin.buildpack.CompileParams";
    encode(message: CompileParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileParams;
    fromJSON(object: any): CompileParams;
    toJSON(message: CompileParams): unknown;
    create(base?: DeepPartial_23<CompileParams>): CompileParams;
    fromPartial(object: DeepPartial_23<CompileParams>): CompileParams;
};

declare interface CompileResponse {
    /** This bundle may be present even when the build was erroneous. */
    bundle?: Bundle | undefined;
    errors: CompileLog[];
    warnings: CompileLog[];
}

declare const CompileResponse: {
    $type: "devvit.plugin.buildpack.CompileResponse";
    encode(message: CompileResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileResponse;
    fromJSON(object: any): CompileResponse;
    toJSON(message: CompileResponse): unknown;
    create(base?: DeepPartial_23<CompileResponse>): CompileResponse;
    fromPartial(object: DeepPartial_23<CompileResponse>): CompileResponse;
};

declare interface ComposeRequest {
    /** the name of an existing user */
    to: string;
    /** a string no longer than 100 characters */
    subject: string;
    /** raw markdown text */
    text: string;
    /** subreddit name */
    fromSr: string;
}

declare const ComposeRequest: {
    $type: "devvit.plugin.redditapi.privatemessages.ComposeRequest";
    encode(message: ComposeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ComposeRequest;
    fromJSON(object: any): ComposeRequest;
    toJSON(message: ComposeRequest): unknown;
    create(base?: DeepPartial_84<ComposeRequest>): ComposeRequest;
    fromPartial(object: DeepPartial_84<ComposeRequest>): ComposeRequest;
};

/**
 * Bundle configuration for code about to be built (eg, dependencies). All
 * Bundle config state that impacts building should be recorded in the
 * implementation. See Actor subclass constructors.
 *
 * This type is = kind of like a builder pattern where export() is the build
 * method. Devvit almost implements this class.
 */
declare type Config = {
    readonly assets: Readonly<AssetMap>;
    readonly providedDefinitions: Readonly<Definition>[];
    export(namespace: Readonly<Namespace>): DependencySpec;
    provides(definition: Readonly<Definition>): void;
    use<T>(definition: Readonly<Definition>, options?: Readonly<DeepPartial_15<PackageQuery>>): T;
    /**
     * Check if a previous call to `use` was made. This is useful for allowing polyfills
     * to ensure that they can provide functionality in terms of a plugin, or fallback to
     * default functionality if not
     */
    uses(definition: Readonly<Definition>): boolean;
};

/** Defines a configuration field with a specific type */
declare interface ConfigField {
    /** Determines what kind of user input to generate for this field */
    fieldType: ConfigFieldType;
    /** Unique identifier for the setting */
    key: string;
    /** Message to display to the user for this setting */
    prompt: string;
    /**
     * The value of the field.
     * When calling RenderForm provide the existing value of the field
     * When calling HandleFormResponse read this property to get the user's response
     */
    response: string;
}

declare const ConfigField: {
    $type: "devvit.actor.user_configurable.ConfigField";
    encode(message: ConfigField, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConfigField;
    fromJSON(object: any): ConfigField;
    toJSON(message: ConfigField): unknown;
    create(base?: DeepPartial_29<ConfigField>): ConfigField;
    fromPartial(object: DeepPartial_29<ConfigField>): ConfigField;
};

declare enum ConfigFieldType {
    /** STRING - Single-line string */
    STRING = 0,
    /** PARAGRAPH - Multi-line string */
    PARAGRAPH = 1,
    /** NUMBER - Number input (i.e.: spinner) */
    NUMBER = 2,
    /** BOOLEAN - Checkbox, switch */
    BOOLEAN = 3,
    /** IMAGE - Image upload - value is a URL for the uploaded image */
    IMAGE = 7,
    UNRECOGNIZED = -1
}

declare function configFieldTypeFromJSON(object: any): ConfigFieldType;

declare function configFieldTypeToJSON(object: ConfigFieldType): number;

declare interface ConfigForm {
    fields: ConfigField[];
}

declare const ConfigForm: {
    $type: "devvit.actor.user_configurable.ConfigForm";
    encode(message: ConfigForm, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConfigForm;
    fromJSON(object: any): ConfigForm;
    toJSON(message: ConfigForm): unknown;
    create(base?: DeepPartial_29<ConfigForm>): ConfigForm;
    fromPartial(object: DeepPartial_29<ConfigForm>): ConfigForm;
};

export declare type Configuration = {
    /** Allows your app to use the HTTP/Fetch API */
    http?: PluginSettings | boolean;
    /** Allows your app to use the reddit API */
    redditAPI?: PluginSettings | boolean;
    /** Allows your app to use the Key-Value Store */
    kvStore?: PluginSettings | boolean;
    /** Allows your app to use the Redis Plugin */
    redis?: PluginSettings | boolean;
    /** Allows media uploads from apps */
    media?: PluginSettings | boolean;
    /** Allows using ModLog API */
    modLog?: PluginSettings | boolean;
    /** Allows your app to use the Realtime Plugin */
    realtime?: PluginSettings | boolean;
};

/** The current app context of the event or render */
export declare type Context = ContextAPIClients & BaseContext;

/**
 * Context actions are clickable entry points from various parts of Reddit,
 * such as a Post or Comment, in order to trigger additional actions
 * (perform actions on behalf of the user, display additional UI, etc.)
 */
declare interface ContextAction {
    GetActions(request: Empty, metadata?: Metadata): Promise<ContextActionList>;
    OnAction(request: ContextActionRequest, metadata?: Metadata): Promise<ContextActionResponse>;
}

/** Which contexts an action should be applied to */
declare interface ContextActionAllowedContexts {
    post: boolean;
    comment: boolean;
    subreddit: boolean;
}

declare const ContextActionAllowedContexts: {
    $type: "devvit.actor.reddit.ContextActionAllowedContexts";
    encode(message: ContextActionAllowedContexts, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionAllowedContexts;
    fromJSON(object: any): ContextActionAllowedContexts;
    toJSON(message: ContextActionAllowedContexts): unknown;
    create(base?: DeepPartial_28<ContextActionAllowedContexts>): ContextActionAllowedContexts;
    fromPartial(object: DeepPartial_28<ContextActionAllowedContexts>): ContextActionAllowedContexts;
};

/** Restrict access to specific user groups */
declare interface ContextActionAllowedUsers {
    /** Moderator only */
    moderator: boolean;
    /** Member of the subreddit where the Actor is installed */
    member: boolean;
    /** Logged out users can perform this action */
    loggedOut: boolean;
}

declare const ContextActionAllowedUsers: {
    $type: "devvit.actor.reddit.ContextActionAllowedUsers";
    encode(message: ContextActionAllowedUsers, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionAllowedUsers;
    fromJSON(object: any): ContextActionAllowedUsers;
    toJSON(message: ContextActionAllowedUsers): unknown;
    create(base?: DeepPartial_28<ContextActionAllowedUsers>): ContextActionAllowedUsers;
    fromPartial(object: DeepPartial_28<ContextActionAllowedUsers>): ContextActionAllowedUsers;
};

declare class ContextActionClientImpl implements ContextAction {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_38, opts?: {
        service?: string;
    });
    GetActions(request: Empty, metadata?: Metadata): Promise<ContextActionList>;
    OnAction(request: ContextActionRequest, metadata?: Metadata): Promise<ContextActionResponse>;
}

/**
 * Context actions are clickable entry points from various parts of Reddit,
 * such as a Post or Comment, in order to trigger additional actions
 * (perform actions on behalf of the user, display additional UI, etc.)
 */
declare type ContextActionDefinition = typeof ContextActionDefinition;

declare const ContextActionDefinition: {
    readonly name: "ContextAction";
    readonly fullName: "devvit.actor.reddit.ContextAction";
    readonly methods: {
        readonly getActions: {
            readonly name: "GetActions";
            readonly requestType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                /** Describes a single action provided by an Actor */
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.reddit.ContextActionList";
                encode(message: ContextActionList, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionList;
                fromJSON(object: any): ContextActionList;
                toJSON(message: ContextActionList): unknown;
                create(base?: DeepPartial_28<ContextActionList>): ContextActionList;
                fromPartial(object: DeepPartial_28<ContextActionList>): ContextActionList;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly onAction: {
            readonly name: "OnAction";
            readonly requestType: {
                $type: "devvit.actor.reddit.ContextActionRequest";
                encode(message: ContextActionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionRequest;
                fromJSON(object: any): ContextActionRequest;
                toJSON(message: ContextActionRequest): unknown;
                create(base?: DeepPartial_28<ContextActionRequest>): ContextActionRequest;
                fromPartial(object: DeepPartial_28<ContextActionRequest>): ContextActionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.reddit.ContextActionResponse";
                encode(message: ContextActionResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionResponse;
                fromJSON(object: any): ContextActionResponse;
                toJSON(message: ContextActionResponse): unknown;
                create(base?: DeepPartial_28<ContextActionResponse>): ContextActionResponse;
                fromPartial(object: DeepPartial_28<ContextActionResponse>): ContextActionResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

/** Describes a single action provided by an Actor */
declare interface ContextActionDescription {
    /** Dev-specified ID for this action to determine which one was called in OnAction */
    actionId: string;
    /** User-facing name for this action (i.e.: text in the overflow menu) */
    name: string;
    /** Short, user-facing secondary text to describe what this action is going to do */
    description: string;
    /** Flags to determine in which contexts this action should be displayed */
    contexts?: ContextActionAllowedContexts | undefined;
    /** Flags to determine what kind of user can see this action */
    users?: ContextActionAllowedUsers | undefined;
    /** Optional field to request user input when the action is clicked */
    userInput?: ConfigForm | undefined;
    /** Filters to apply to actions in post context */
    postFilters?: ContextActionPostFilters | undefined;
}

declare const ContextActionDescription: {
    $type: "devvit.actor.reddit.ContextActionDescription";
    encode(message: ContextActionDescription, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionDescription;
    fromJSON(object: any): ContextActionDescription;
    toJSON(message: ContextActionDescription): unknown;
    create(base?: DeepPartial_28<ContextActionDescription>): ContextActionDescription;
    fromPartial(object: DeepPartial_28<ContextActionDescription>): ContextActionDescription;
};

declare interface ContextActionList {
    actions: ContextActionDescription[];
}

declare const ContextActionList: {
    $type: "devvit.actor.reddit.ContextActionList";
    encode(message: ContextActionList, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionList;
    fromJSON(object: any): ContextActionList;
    toJSON(message: ContextActionList): unknown;
    create(base?: DeepPartial_28<ContextActionList>): ContextActionList;
    fromPartial(object: DeepPartial_28<ContextActionList>): ContextActionList;
};

/** Filters for post actions */
declare interface ContextActionPostFilters {
    /** If true, only display action for posts created by the app itself, otherwise for all posts */
    currentApp?: boolean | undefined;
}

declare const ContextActionPostFilters: {
    $type: "devvit.actor.reddit.ContextActionPostFilters";
    encode(message: ContextActionPostFilters, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionPostFilters;
    fromJSON(object: any): ContextActionPostFilters;
    toJSON(message: ContextActionPostFilters): unknown;
    create(base?: DeepPartial_28<ContextActionPostFilters>): ContextActionPostFilters;
    fromPartial(object: DeepPartial_28<ContextActionPostFilters>): ContextActionPostFilters;
};

declare interface ContextActionRequest {
    /** The action ID defined in ContextActionDescription */
    actionId: string;
    /** Which context this request is coming from */
    context: ContextType;
    /** TODO: Replace with Post/Comment/Subreddit types when it's safe */
    post?: RedditObject | undefined;
    comment?: RedditObject | undefined;
    subreddit?: SubredditObject | undefined;
    /** If user_input is defined in ContextActionDescription, the result will be provided here */
    userInput?: ConfigForm | undefined;
}

declare const ContextActionRequest: {
    $type: "devvit.actor.reddit.ContextActionRequest";
    encode(message: ContextActionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionRequest;
    fromJSON(object: any): ContextActionRequest;
    toJSON(message: ContextActionRequest): unknown;
    create(base?: DeepPartial_28<ContextActionRequest>): ContextActionRequest;
    fromPartial(object: DeepPartial_28<ContextActionRequest>): ContextActionRequest;
};

declare interface ContextActionResponse {
    /**
     * Whether or not the action was successful.
     * @deprecated Use effects instead
     */
    success: boolean;
    /**
     * If set, display as a popup toast to the user
     * @deprecated Use effects instead
     */
    message: string;
    effects: Effect[];
}

declare const ContextActionResponse: {
    $type: "devvit.actor.reddit.ContextActionResponse";
    encode(message: ContextActionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ContextActionResponse;
    fromJSON(object: any): ContextActionResponse;
    toJSON(message: ContextActionResponse): unknown;
    create(base?: DeepPartial_28<ContextActionResponse>): ContextActionResponse;
    fromPartial(object: DeepPartial_28<ContextActionResponse>): ContextActionResponse;
};

declare const ContextActionServiceName = "devvit.actor.reddit.ContextAction";

export declare type ContextAPIClients = {
    /** A client for the ModLog API */
    modLog: ModLogClient;
    /** A client for the Key Value Store */
    kvStore: KVStore;
    /**
     * @experimental
     *
     * The cache helper will let you cache JSON-able objects in your devvit apps for a limited amount of time.
     *
     * Under the covers, It's just Redis, so you do need to enable the redis feature. This provides a pattern for e.g. fetching
     * remote calls without overwhelming someone's server.
     *
     * ```ts
     * Devvit.configure({
     *   redis: true, // Enable access to Redis
     * });
     *
     * /// ...
     *
     * let component = (context) => {
     *   let cached = context.cache(async () => {
     *     let rsp = await fetch("https://google.com")
     *     return rsp.body
     *   },
     *   {
     *     key: "some-fetch",
     *     ttl: 10_000 // millis
     *   }
     *   doSomethingWith(cached);
     *   return <text>yay</text>
     * }
     * ```
     */
    cache: CacheHelper;
    /** A client for the Redis API */
    redis: RedisClient;
    /** A client for the Reddit API */
    reddit: RedditAPIClient;
    /** A client for the Settings API */
    settings: SettingsClient;
    /** A client for the Scheduler API */
    scheduler: Scheduler;
    /** A client for media API */
    media: MediaPlugin;
    /** A client for resolving static assets to public URLs */
    assets: AssetsClient;
    /** A client for Realtime API */
    realtime: RealtimeClient;
    /**
     * @experimental
     *
     * Information about about a custom post's layout. Will be undefined
     * for non custom post surface areas such as menu items and task schedulers.
     */
    dimensions?: UIDimensions;
    /**
     * @experimental
     *
     * Additional information about client environment.
     * Will be undefined for non-ui contexts such as task schedulers or triggers.
     */
    uiEnvironment?: UIEnvironment;
    /** A client for the User Interface API */
    ui: UIClient;
    /**
     * A hook for managing a state between Block renders. This is only available
     * within a Block Component. Returns a tuple containing the current state and
     * a function to update it.
     *
     * ```ts
     * const [counter, setCounter] = useState(0);
     * setCounter(1); // counter = 1
     * setCounter((count) => count + 1) // counter = 2
     * ```
     */
    useState(initialState: boolean | (() => boolean | Promise<boolean>)): UseStateResult<boolean>;
    useState(initialState: number | (() => number | Promise<number>)): UseStateResult<number>;
    useState(initialState: string | (() => string | Promise<string>)): UseStateResult<string>;
    useState<S extends JSONValue | undefined | void>(initialState: S | (() => S | Promise<S>)): UseStateResult<S>;
    /**
     * A hook for managing a callback that runs on an interval between Block renders.
     * This is only available within a Block Component.
     */
    useInterval: UseIntervalHook;
    /**
     * A hook for managing a form between Block renders.
     * This is only available within a Block Component.
     */
    useForm: UseFormHook;
    /**
     * A hook hor managing a realtime pubsub channel between Block renders.
     * This is only available within a Block Component.
     */
    useChannel: UseChannelHook;
};

export declare type ContextDebugInfo = {
    effects?: EffectEmitter;
    metadata: Metadata;
} & {
    [key in AppDebug]?: string;
};

declare enum ContextType {
    POST = 0,
    COMMENT = 1,
    SUBREDDIT = 2,
    UNRECOGNIZED = -1
}

declare function contextTypeFromJSON(object: any): ContextType;

declare function contextTypeToJSON(object: ContextType): number;

export declare type ConversationData = {
    /** Conversation ID */
    id?: string;
    /** Suject of the conversation */
    subject?: string;
    /**
     * Subreddit owning the modmail conversation
     */
    subreddit?: {
        displayName?: string;
        id?: string;
    };
    /**
     * A ConversationType specifies whether a conversation is with a subreddit
     * itself, with another user, or with another subreddit entirely.
     * - `internal` - This is a conversation with another user outside of the subreddit. The participant ID is that user's ID.
     * - `sr_user` - This is a Mod Discussion, internal to the subreddit. There is no other participant.
     * - `sr_sr` - This is a conversation is with another subreddit. The participant will have a subreddit ID.
     */
    conversationType?: string;
    /** Is the conversation automatically generated e.g. from automod, u/reddit */
    isAuto?: boolean;
    /** Participant. Is absent for mod discussions */
    participant?: Participant;
    /** The last datetime a user made any interaction with the conversation */
    lastUserUpdate?: string;
    /** Is the conversation internal (i.e. mod only) */
    isInternal?: boolean;
    /**
     * The last datetime a mod from the owning subreddit made any interaction
     * with the conversation.
     *
     * (Note that if this is a subreddit to subreddit conversation, the mods of
     * the participant subreddit are irrelevant and do not affect this field.)
     */
    lastModUpdate?: string;
    /** The authors of each message in the modmail conversation. */
    authors: Participant[];
    /** The datetime of the last time the conversation was update. */
    lastUpdated?: string;
    /** State of the conversation */
    state?: ModMailConversationState;
    /** The datetime of the last unread message within this conversation for the current viewer. */
    lastUnread?: string;
    /** Is the conversation highlighted */
    isHighlighted?: boolean;
    /** Number of messages (not actions) in the conversation */
    numMessages?: number;
    /**
     * Conversation messages
     *
     * @example
     * ```ts
     * const arrayOfMessages = Object.values(conversation.messages);
     * const messageById = conversation.messages[messageId];
     * ```
     */
    messages: {
        [id: string]: MessageData;
    };
    /**
     * Conversation mod actions
     *
     * @example
     * ```ts
     * const arrayOfModActions = Object.values(conversation.modActions);
     * const modActionById = conversation.modActions[modActionId];
     * ```
     */
    modActions: {
        [id: string]: ModActionData;
    };
};

/** Shared Objects */
declare interface ConversationData_2 {
    /** Is the conversation automatically generated e.g. from automod, u/reddit */
    isAuto?: boolean | undefined;
    /** Participant. Is absent for mod discussions */
    participant?: Participant_2 | undefined;
    /** List of object ids (denormalized). E.g. [{id: 'qwer42', key: 'messages'}, {id: 'abcd33', key: 'modActions'}] */
    objIds: ConversationData_ObjId[];
    /** NOTE: is_repliable will always be true currently (at the time of writing this comment) */
    isRepliable?: boolean | undefined;
    /** The last datetime a user made any interaction with the conversation */
    lastUserUpdate?: string | undefined;
    /** Is the conversation internal (i.e. mod only) */
    isInternal?: boolean | undefined;
    /**
     * The last datetime a mod from the owning subreddit made any interaction with the conversation.
     * (Note that if this is a subreddit to subreddit conversation, the mods of
     * the participant subreddit are irrelevant and do not affect this field.)
     */
    lastModUpdate?: string | undefined;
    authors: Participant_2[];
    /** The last time the conversation was updated (includes actions) */
    lastUpdated?: string | undefined;
    /** Id of the first corresponding message in the legacy message system */
    legacyFirstMessageId?: string | undefined;
    state?: number | undefined;
    /**
     * Type of conversation:
     * - `internal` (mod discussion)
     * - `sr_user` (between a subreddit and user)
     * - `sr_sr` (between two subreddits)
     */
    conversationType?: string | undefined;
    /** The datetime of the last unread message within this conversation for the current viewer. */
    lastUnread?: string | undefined;
    /** The subreddit that owns the conversation. */
    owner?: ConversationData_Owner | undefined;
    /** Suject of the conversation */
    subject?: string | undefined;
    /** Conversation ID */
    id?: string | undefined;
    /** Is the conversation highlighted */
    isHighlighted?: boolean | undefined;
    /** Number of messages (not actions) in the conversation */
    numMessages?: number | undefined;
    /** from createconversationmessageresponse */
    modActions: {
        [key: string]: ModActionData_2;
    };
}

declare const ConversationData_2: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData";
    encode(message: ConversationData_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationData_2;
    fromJSON(object: any): ConversationData_2;
    toJSON(message: ConversationData_2): unknown;
    create(base?: DeepPartial_71<ConversationData_2>): ConversationData_2;
    fromPartial(object: DeepPartial_71<ConversationData_2>): ConversationData_2;
};

declare interface ConversationData_ModActionsEntry {
    key: string;
    value?: ModActionData_2 | undefined;
}

declare const ConversationData_ModActionsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ModActionsEntry";
    encode(message: ConversationData_ModActionsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationData_ModActionsEntry;
    fromJSON(object: any): ConversationData_ModActionsEntry;
    toJSON(message: ConversationData_ModActionsEntry): unknown;
    create(base?: DeepPartial_71<ConversationData_ModActionsEntry>): ConversationData_ModActionsEntry;
    fromPartial(object: DeepPartial_71<ConversationData_ModActionsEntry>): ConversationData_ModActionsEntry;
};

declare interface ConversationData_ObjId {
    /** Id of an object (e.g. message ID or modAction ID) */
    id?: string | undefined;
    /** Property name of the object collection (e.g. 'messages' or 'modActions') */
    key?: string | undefined;
}

declare const ConversationData_ObjId: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ObjId";
    encode(message: ConversationData_ObjId, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationData_ObjId;
    fromJSON(object: any): ConversationData_ObjId;
    toJSON(message: ConversationData_ObjId): unknown;
    create(base?: DeepPartial_71<ConversationData_ObjId>): ConversationData_ObjId;
    fromPartial(object: DeepPartial_71<ConversationData_ObjId>): ConversationData_ObjId;
};

declare interface ConversationData_Owner {
    /** Subreddit display name */
    displayName?: string | undefined;
    /** always 'subreddit' */
    type?: string | undefined;
    /** Subreddit id */
    id?: string | undefined;
}

declare const ConversationData_Owner: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData.Owner";
    encode(message: ConversationData_Owner, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationData_Owner;
    fromJSON(object: any): ConversationData_Owner;
    toJSON(message: ConversationData_Owner): unknown;
    create(base?: DeepPartial_71<ConversationData_Owner>): ConversationData_Owner;
    fromPartial(object: DeepPartial_71<ConversationData_Owner>): ConversationData_Owner;
};

export declare type ConversationResponse = {
    conversation: ConversationData;
};

/**
 * A Conversation State is a way in which conversations may be filtered within the UI.
 *
 * A conversation can be in more than one state.
 * For example, a conversation may be both 'highlighted' and 'inprogress'.
 */
export declare type ConversationStateFilter = 'all' | 'new' | 'inprogress' | 'archived' | 'appeals' | 'join_requests' | 'highlighted' | 'mod' | 'notifications' | 'inbox' | 'filtered' | 'default';

export declare type ConversationUserData = {
    /** User ID*/
    id?: string;
    /** Username */
    name?: string;
    /** Recent comments */
    recentComments: {
        [id: string]: {
            comment?: string;
            date?: string;
            permalink?: string;
            title?: string;
        };
    };
    /** Recent posts */
    recentPosts: {
        [id: string]: {
            date?: string;
            permalink?: string;
            title?: string;
        };
    };
    /** Recent conversations */
    recentConvos: {
        [id: string]: {
            date?: string;
            permalink?: string;
            id?: string;
            subject?: string;
        };
    };
    isSuspended?: boolean;
    isShadowBanned?: boolean;
    muteStatus?: {
        isMuted?: boolean;
        muteCount?: number;
        endDate?: string;
        reason?: string;
    };
    banStatus?: {
        isBanned?: boolean;
        isPermanent?: boolean;
        endDate?: string;
        reason?: string;
    };
    approveStatus?: {
        isApproved?: boolean;
    };
    /** When was created */
    created?: string;
};

declare interface ConversationUserData_2 {
    recentComments: {
        [key: string]: ConversationUserData_CommentData;
    };
    muteStatus?: ConversationUserData_MuteStatus | undefined;
    name?: string | undefined;
    created?: string | undefined;
    banStatus?: ConversationUserData_BanStatus | undefined;
    isSuspended?: boolean | undefined;
    approveStatus?: ConversationUserData_ApproveStatus | undefined;
    isShadowBanned?: boolean | undefined;
    recentPosts: {
        [key: string]: ConversationUserData_PostData;
    };
    recentConvos: {
        [key: string]: ConversationUserData_ConvoData;
    };
    id?: string | undefined;
}

declare const ConversationUserData_2: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData";
    encode(message: ConversationUserData_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_2;
    fromJSON(object: any): ConversationUserData_2;
    toJSON(message: ConversationUserData_2): unknown;
    create(base?: DeepPartial_71<ConversationUserData_2>): ConversationUserData_2;
    fromPartial(object: DeepPartial_71<ConversationUserData_2>): ConversationUserData_2;
};

declare interface ConversationUserData_ApproveStatus {
    isApproved?: boolean | undefined;
}

declare const ConversationUserData_ApproveStatus: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ApproveStatus";
    encode(message: ConversationUserData_ApproveStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_ApproveStatus;
    fromJSON(object: any): ConversationUserData_ApproveStatus;
    toJSON(message: ConversationUserData_ApproveStatus): unknown;
    create(base?: DeepPartial_71<ConversationUserData_ApproveStatus>): ConversationUserData_ApproveStatus;
    fromPartial(object: DeepPartial_71<ConversationUserData_ApproveStatus>): ConversationUserData_ApproveStatus;
};

declare interface ConversationUserData_BanStatus {
    isBanned?: boolean | undefined;
    isPermanent?: boolean | undefined;
    endDate?: string | undefined;
    reason?: string | undefined;
}

declare const ConversationUserData_BanStatus: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.BanStatus";
    encode(message: ConversationUserData_BanStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_BanStatus;
    fromJSON(object: any): ConversationUserData_BanStatus;
    toJSON(message: ConversationUserData_BanStatus): unknown;
    create(base?: DeepPartial_71<ConversationUserData_BanStatus>): ConversationUserData_BanStatus;
    fromPartial(object: DeepPartial_71<ConversationUserData_BanStatus>): ConversationUserData_BanStatus;
};

declare interface ConversationUserData_CommentData {
    comment?: string | undefined;
    date?: string | undefined;
    permalink?: string | undefined;
    title?: string | undefined;
}

declare const ConversationUserData_CommentData: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.CommentData";
    encode(message: ConversationUserData_CommentData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_CommentData;
    fromJSON(object: any): ConversationUserData_CommentData;
    toJSON(message: ConversationUserData_CommentData): unknown;
    create(base?: DeepPartial_71<ConversationUserData_CommentData>): ConversationUserData_CommentData;
    fromPartial(object: DeepPartial_71<ConversationUserData_CommentData>): ConversationUserData_CommentData;
};

declare interface ConversationUserData_ConvoData {
    date?: string | undefined;
    permalink?: string | undefined;
    id?: string | undefined;
    subject?: string | undefined;
}

declare const ConversationUserData_ConvoData: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ConvoData";
    encode(message: ConversationUserData_ConvoData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_ConvoData;
    fromJSON(object: any): ConversationUserData_ConvoData;
    toJSON(message: ConversationUserData_ConvoData): unknown;
    create(base?: DeepPartial_71<ConversationUserData_ConvoData>): ConversationUserData_ConvoData;
    fromPartial(object: DeepPartial_71<ConversationUserData_ConvoData>): ConversationUserData_ConvoData;
};

declare interface ConversationUserData_MuteStatus {
    muteCount?: number | undefined;
    isMuted?: boolean | undefined;
    endDate?: string | undefined;
    reason?: string | undefined;
}

declare const ConversationUserData_MuteStatus: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.MuteStatus";
    encode(message: ConversationUserData_MuteStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_MuteStatus;
    fromJSON(object: any): ConversationUserData_MuteStatus;
    toJSON(message: ConversationUserData_MuteStatus): unknown;
    create(base?: DeepPartial_71<ConversationUserData_MuteStatus>): ConversationUserData_MuteStatus;
    fromPartial(object: DeepPartial_71<ConversationUserData_MuteStatus>): ConversationUserData_MuteStatus;
};

declare interface ConversationUserData_PostData {
    date?: string | undefined;
    permalink?: string | undefined;
    title?: string | undefined;
}

declare const ConversationUserData_PostData: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.PostData";
    encode(message: ConversationUserData_PostData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_PostData;
    fromJSON(object: any): ConversationUserData_PostData;
    toJSON(message: ConversationUserData_PostData): unknown;
    create(base?: DeepPartial_71<ConversationUserData_PostData>): ConversationUserData_PostData;
    fromPartial(object: DeepPartial_71<ConversationUserData_PostData>): ConversationUserData_PostData;
};

declare interface ConversationUserData_RecentCommentsEntry {
    key: string;
    value?: ConversationUserData_CommentData | undefined;
}

declare const ConversationUserData_RecentCommentsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentCommentsEntry";
    encode(message: ConversationUserData_RecentCommentsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_RecentCommentsEntry;
    fromJSON(object: any): ConversationUserData_RecentCommentsEntry;
    toJSON(message: ConversationUserData_RecentCommentsEntry): unknown;
    create(base?: DeepPartial_71<ConversationUserData_RecentCommentsEntry>): ConversationUserData_RecentCommentsEntry;
    fromPartial(object: DeepPartial_71<ConversationUserData_RecentCommentsEntry>): ConversationUserData_RecentCommentsEntry;
};

declare interface ConversationUserData_RecentConvosEntry {
    key: string;
    value?: ConversationUserData_ConvoData | undefined;
}

declare const ConversationUserData_RecentConvosEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentConvosEntry";
    encode(message: ConversationUserData_RecentConvosEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_RecentConvosEntry;
    fromJSON(object: any): ConversationUserData_RecentConvosEntry;
    toJSON(message: ConversationUserData_RecentConvosEntry): unknown;
    create(base?: DeepPartial_71<ConversationUserData_RecentConvosEntry>): ConversationUserData_RecentConvosEntry;
    fromPartial(object: DeepPartial_71<ConversationUserData_RecentConvosEntry>): ConversationUserData_RecentConvosEntry;
};

declare interface ConversationUserData_RecentPostsEntry {
    key: string;
    value?: ConversationUserData_PostData | undefined;
}

declare const ConversationUserData_RecentPostsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentPostsEntry";
    encode(message: ConversationUserData_RecentPostsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConversationUserData_RecentPostsEntry;
    fromJSON(object: any): ConversationUserData_RecentPostsEntry;
    toJSON(message: ConversationUserData_RecentPostsEntry): unknown;
    create(base?: DeepPartial_71<ConversationUserData_RecentPostsEntry>): ConversationUserData_RecentPostsEntry;
    fromPartial(object: DeepPartial_71<ConversationUserData_RecentPostsEntry>): ConversationUserData_RecentPostsEntry;
};

export declare type CreateCollectionInput = {
    /** The title of the collection. */
    title?: string;
    /** The t5_ id of the subreddit in which this collection will be created. */
    subredditId?: string;
    /** The description of the collection. */
    description?: string;
    /** One of: TIMELINE | GALLERY. This determines the layout of posts in the collection UI. */
    displayLayout?: CollectionDisplayLayout;
};

declare interface CreateCollectionRequest {
    /** The title of the collection. */
    title?: string | undefined;
    /** The t5_ id of the subreddit in which this collection will be created. */
    srFullname?: string | undefined;
    /** The description of the collection. */
    description?: string | undefined;
    /** One of: TIMELINE | GALLERY. This determines the layout of posts in the collection ui. */
    displayLayout?: string | undefined;
}

declare const CreateCollectionRequest: {
    $type: "devvit.plugin.redditapi.postcollections.CreateCollectionRequest";
    encode(message: CreateCollectionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateCollectionRequest;
    fromJSON(object: any): CreateCollectionRequest;
    toJSON(message: CreateCollectionRequest): unknown;
    create(base?: DeepPartial_81<CreateCollectionRequest>): CreateCollectionRequest;
    fromPartial(object: DeepPartial_81<CreateCollectionRequest>): CreateCollectionRequest;
};

declare interface CreateConversationMessageRequest {
    /** markdown text */
    body: string;
    isAuthorHidden: boolean;
    isInternal: boolean;
    /** id36 of a modmail conversation id */
    conversationId: string;
}

declare const CreateConversationMessageRequest: {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageRequest";
    encode(message: CreateConversationMessageRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationMessageRequest;
    fromJSON(object: any): CreateConversationMessageRequest;
    toJSON(message: CreateConversationMessageRequest): unknown;
    create(base?: DeepPartial_71<CreateConversationMessageRequest>): CreateConversationMessageRequest;
    fromPartial(object: DeepPartial_71<CreateConversationMessageRequest>): CreateConversationMessageRequest;
};

declare interface CreateConversationMessageResponse {
    conversation?: ConversationData_2 | undefined;
    messages: {
        [key: string]: MessageData_2;
    };
    user?: ConversationUserData_2 | undefined;
}

declare const CreateConversationMessageResponse: {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse";
    encode(message: CreateConversationMessageResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationMessageResponse;
    fromJSON(object: any): CreateConversationMessageResponse;
    toJSON(message: CreateConversationMessageResponse): unknown;
    create(base?: DeepPartial_71<CreateConversationMessageResponse>): CreateConversationMessageResponse;
    fromPartial(object: DeepPartial_71<CreateConversationMessageResponse>): CreateConversationMessageResponse;
};

declare interface CreateConversationMessageResponse_MessagesEntry {
    key: string;
    value?: MessageData_2 | undefined;
}

declare const CreateConversationMessageResponse_MessagesEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse.MessagesEntry";
    encode(message: CreateConversationMessageResponse_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationMessageResponse_MessagesEntry;
    fromJSON(object: any): CreateConversationMessageResponse_MessagesEntry;
    toJSON(message: CreateConversationMessageResponse_MessagesEntry): unknown;
    create(base?: DeepPartial_71<CreateConversationMessageResponse_MessagesEntry>): CreateConversationMessageResponse_MessagesEntry;
    fromPartial(object: DeepPartial_71<CreateConversationMessageResponse_MessagesEntry>): CreateConversationMessageResponse_MessagesEntry;
};

declare interface CreateConversationRequest {
    /** raw markdown text */
    body: string;
    /** is author hidden? */
    isAuthorHidden: boolean;
    /** subreddit name */
    srName: string;
    /** subject of the conversation. max 100 characters. */
    subject: string;
    /** a user (e.g. u/username), a subreddit (e.g. r/subreddit) or null */
    to?: string | undefined;
}

declare const CreateConversationRequest: {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationRequest";
    encode(message: CreateConversationRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationRequest;
    fromJSON(object: any): CreateConversationRequest;
    toJSON(message: CreateConversationRequest): unknown;
    create(base?: DeepPartial_71<CreateConversationRequest>): CreateConversationRequest;
    fromPartial(object: DeepPartial_71<CreateConversationRequest>): CreateConversationRequest;
};

declare interface CreateConversationResponse {
    conversation?: ConversationData_2 | undefined;
    messages: {
        [key: string]: MessageData_2;
    };
    modActions: {
        [key: string]: ModActionData_2;
    };
    /** error case */
    fields: string[];
    reason?: string | undefined;
    message?: string | undefined;
    explanation?: string | undefined;
    user?: ConversationUserData_2 | undefined;
}

declare const CreateConversationResponse: {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse";
    encode(message: CreateConversationResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationResponse;
    fromJSON(object: any): CreateConversationResponse;
    toJSON(message: CreateConversationResponse): unknown;
    create(base?: DeepPartial_71<CreateConversationResponse>): CreateConversationResponse;
    fromPartial(object: DeepPartial_71<CreateConversationResponse>): CreateConversationResponse;
};

declare interface CreateConversationResponse_MessagesEntry {
    key: string;
    value?: MessageData_2 | undefined;
}

declare const CreateConversationResponse_MessagesEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.MessagesEntry";
    encode(message: CreateConversationResponse_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationResponse_MessagesEntry;
    fromJSON(object: any): CreateConversationResponse_MessagesEntry;
    toJSON(message: CreateConversationResponse_MessagesEntry): unknown;
    create(base?: DeepPartial_71<CreateConversationResponse_MessagesEntry>): CreateConversationResponse_MessagesEntry;
    fromPartial(object: DeepPartial_71<CreateConversationResponse_MessagesEntry>): CreateConversationResponse_MessagesEntry;
};

declare interface CreateConversationResponse_ModActionsEntry {
    key: string;
    value?: ModActionData_2 | undefined;
}

declare const CreateConversationResponse_ModActionsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.ModActionsEntry";
    encode(message: CreateConversationResponse_ModActionsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationResponse_ModActionsEntry;
    fromJSON(object: any): CreateConversationResponse_ModActionsEntry;
    toJSON(message: CreateConversationResponse_ModActionsEntry): unknown;
    create(base?: DeepPartial_71<CreateConversationResponse_ModActionsEntry>): CreateConversationResponse_ModActionsEntry;
    fromPartial(object: DeepPartial_71<CreateConversationResponse_ModActionsEntry>): CreateConversationResponse_ModActionsEntry;
};

export declare type CreateFlairTemplateOptions = {
    /** The name of the subreddit to create the flair template in. */
    subredditName: string;
    /** The flair template's allowable content. Either 'all', 'emoji', or 'text'. */
    allowableContent?: AllowableFlairContent;
    /** The background color of the flair. Either 'transparent' or a hex color code. e.g. #FFC0CB */
    backgroundColor?: string;
    maxEmojis?: number;
    /** Whether or not this flair template is only available to moderators. */
    modOnly?: boolean;
    /** The text to display in the flair. */
    text: string;
    /** Either 'dark' or 'light'. */
    textColor?: FlairTextColor;
    /** Whether or not users are allowed to edit this flair template before using it. */
    allowUserEdits?: boolean;
};

export declare type CreateModNoteOptions = Prettify<PostNotesRequest & {
    redditId: T1ID | T3ID;
    label: UserNoteLabel;
}>;

export declare type CreateRelationshipOptions = {
    subredditName: string;
    username: string;
    type: RelationshipType;
    banContext?: string;
    banMessage?: string;
    banReason?: string;
    duration?: number;
    note?: string;
    permissions?: ModeratorPermission[];
};

export declare type CreateWikiPageOptions = {
    /** The name of the subreddit to create the page in. */
    subredditName: string;
    /** The name of the page to create. */
    page: string;
    /** The content of the page. */
    content: string;
    /** The reason for creating the page. */
    reason?: string;
};

export declare type CrosspostOptions = CommonSubmitPostOptions & {
    subredditName: string;
    postId: string;
};

declare enum CrowdControlLevel {
    OFF = 0,
    LENIENT = 1,
    MEDIUM = 2,
    STRICT = 3,
    UNRECOGNIZED = -1
}

declare function crowdControlLevelFromJSON(object: any): CrowdControlLevel;

declare function crowdControlLevelToJSON(object: CrowdControlLevel): number;

declare interface Cursor {
    topic: string;
    offset: number;
    closeAtEnd: boolean;
}

declare const Cursor: {
    $type: "devvit.plugin.streambroker.Cursor";
    encode(message: Cursor, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Cursor;
    fromJSON(object: any): Cursor;
    toJSON(message: Cursor): unknown;
    create(base?: DeepPartial_91<Cursor>): Cursor;
    fromPartial(object: DeepPartial_91<Cursor>): Cursor;
};

declare interface CustomAction {
    /** Unique ID for this action */
    actionId: string;
    /** Text to display on the menu item */
    label: string;
    /** Short description for what the action will do */
    shortDescription: string;
    /** Which menus should get this action */
    menus?: CustomAction_Menus | undefined;
    /** Additional parameters to control where the action goes */
    options?: CustomAction_Options | undefined;
}

declare const CustomAction: {
    $type: "devvit.reddit.custom_actions.v2alpha.CustomAction";
    encode(message: CustomAction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CustomAction;
    fromJSON(object: any): CustomAction;
    toJSON(message: CustomAction): unknown;
    create(base?: DeepPartial_41<CustomAction>): CustomAction;
    fromPartial(object: DeepPartial_41<CustomAction>): CustomAction;
};

declare interface CustomAction_Menus {
    subreddit?: boolean | undefined;
    post?: boolean | undefined;
    comment?: boolean | undefined;
}

declare const CustomAction_Menus: {
    $type: "devvit.reddit.custom_actions.v2alpha.CustomAction.Menus";
    encode(message: CustomAction_Menus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CustomAction_Menus;
    fromJSON(object: any): CustomAction_Menus;
    toJSON(message: CustomAction_Menus): unknown;
    create(base?: DeepPartial_41<CustomAction_Menus>): CustomAction_Menus;
    fromPartial(object: DeepPartial_41<CustomAction_Menus>): CustomAction_Menus;
};

declare interface CustomAction_Options {
    /** If true, add to the mod tools menu and only allow a moderator to run the action */
    modTool?: boolean | undefined;
    /** Icon to show next to the label in the menu */
    icon?: string | undefined;
}

declare const CustomAction_Options: {
    $type: "devvit.reddit.custom_actions.v2alpha.CustomAction.Options";
    encode(message: CustomAction_Options, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CustomAction_Options;
    fromJSON(object: any): CustomAction_Options;
    toJSON(message: CustomAction_Options): unknown;
    create(base?: DeepPartial_41<CustomAction_Options>): CustomAction_Options;
    fromPartial(object: DeepPartial_41<CustomAction_Options>): CustomAction_Options;
};

declare interface CustomActions {
    GetActions(request: GetActionsRequest, metadata?: Metadata): Promise<GetActionsResponse>;
    OnAction(request: OnActionRequest, metadata?: Metadata): Promise<OnActionResponse>;
}

declare class CustomActionsClientImpl implements CustomActions {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_45, opts?: {
        service?: string;
    });
    GetActions(request: GetActionsRequest, metadata?: Metadata): Promise<GetActionsResponse>;
    OnAction(request: OnActionRequest, metadata?: Metadata): Promise<OnActionResponse>;
}

declare type CustomActionsDefinition = typeof CustomActionsDefinition;

declare const CustomActionsDefinition: {
    readonly name: "CustomActions";
    readonly fullName: "devvit.reddit.custom_actions.v2alpha.CustomActions";
    readonly methods: {
        readonly getActions: {
            readonly name: "GetActions";
            readonly requestType: {
                $type: "devvit.reddit.custom_actions.v2alpha.GetActionsRequest";
                encode(_: GetActionsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): GetActionsRequest;
                fromJSON(_: any): GetActionsRequest;
                toJSON(_: GetActionsRequest): unknown;
                create(base?: DeepPartial_41<GetActionsRequest>): GetActionsRequest;
                fromPartial(_: DeepPartial_41<GetActionsRequest>): GetActionsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.reddit.custom_actions.v2alpha.GetActionsResponse";
                encode(message: GetActionsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): GetActionsResponse;
                fromJSON(object: any): GetActionsResponse;
                toJSON(message: GetActionsResponse): unknown;
                create(base?: DeepPartial_41<GetActionsResponse>): GetActionsResponse;
                fromPartial(object: DeepPartial_41<GetActionsResponse>): GetActionsResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly onAction: {
            readonly name: "OnAction";
            readonly requestType: {
                $type: "devvit.reddit.custom_actions.v2alpha.OnActionRequest";
                encode(message: OnActionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): OnActionRequest;
                fromJSON(object: any): OnActionRequest;
                toJSON(message: OnActionRequest): unknown;
                create(base?: DeepPartial_41<OnActionRequest>): OnActionRequest;
                fromPartial(object: DeepPartial_41<OnActionRequest>): OnActionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.reddit.custom_actions.v2alpha.OnActionResponse";
                encode(message: OnActionResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): OnActionResponse;
                fromJSON(object: any): OnActionResponse;
                toJSON(message: OnActionResponse): unknown;
                create(base?: DeepPartial_41<OnActionResponse>): OnActionResponse;
                fromPartial(object: DeepPartial_41<OnActionResponse>): OnActionResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const CustomActionsServiceName = "devvit.reddit.custom_actions.v2alpha.CustomActions";

/**
 * Custom post type.  Most custom post types will also implement InstanceSettings,
 * which will allow them to be customized by the user in the post creation flow.
 *
 * Custom post types should also look up their instance and installation settings.
 */
declare interface CustomPost {
    /**
     * This is deprecated and should be fixed in time to maintain backwards compatability.
     * Please call RenderPostBody instead.
     *
     * @deprecated
     */
    RenderPost(request: RenderPostRequest, metadata?: Metadata): Promise<RenderPostResponse>;
    RenderPostContent(request: UIRequest, metadata?: Metadata): Promise<UIResponse>;
    RenderPostComposer(request: UIRequest, metadata?: Metadata): Promise<UIResponse>;
}

declare class CustomPostClientImpl implements CustomPost {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_44, opts?: {
        service?: string;
    });
    RenderPost(request: RenderPostRequest, metadata?: Metadata): Promise<RenderPostResponse>;
    RenderPostContent(request: UIRequest, metadata?: Metadata): Promise<UIResponse>;
    RenderPostComposer(request: UIRequest, metadata?: Metadata): Promise<UIResponse>;
}

/**
 * Custom post type.  Most custom post types will also implement InstanceSettings,
 * which will allow them to be customized by the user in the post creation flow.
 *
 * Custom post types should also look up their instance and installation settings.
 */
declare type CustomPostDefinition = typeof CustomPostDefinition;

declare const CustomPostDefinition: {
    readonly name: "CustomPost";
    readonly fullName: "devvit.reddit.custom_post.v1alpha.CustomPost";
    readonly methods: {
        /**
         * This is deprecated and should be fixed in time to maintain backwards compatability.
         * Please call RenderPostBody instead.
         *
         * @deprecated
         */
        readonly renderPost: {
            readonly name: "RenderPost";
            readonly requestType: {
                $type: "devvit.reddit.custom_post.v1alpha.RenderPostRequest";
                encode(message: RenderPostRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RenderPostRequest;
                fromJSON(object: any): RenderPostRequest;
                toJSON(message: RenderPostRequest): unknown;
                create(base?: DeepPartial_43<RenderPostRequest>): RenderPostRequest;
                fromPartial(object: DeepPartial_43<RenderPostRequest>): RenderPostRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.reddit.custom_post.v1alpha.RenderPostResponse";
                encode(message: RenderPostResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RenderPostResponse;
                fromJSON(object: any): RenderPostResponse;
                toJSON(message: RenderPostResponse): unknown;
                create(base?: DeepPartial_43<RenderPostResponse>): RenderPostResponse;
                fromPartial(object: DeepPartial_43<RenderPostResponse>): RenderPostResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly renderPostContent: {
            readonly name: "RenderPostContent";
            readonly requestType: {
                $type: "devvit.ui.block_kit.v1beta.UIRequest";
                encode(message: UIRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UIRequest;
                fromJSON(object: any): UIRequest;
                toJSON(message: UIRequest): unknown;
                create(base?: {
                    env?: {
                        locale?: string | undefined;
                        colorScheme?: string | undefined;
                        dimensions?: {
                            height?: number;
                            width?: number;
                            scale?: number;
                        } | undefined;
                        timezone?: string | undefined;
                    } | undefined;
                    props?: {
                        [x: string]: any;
                    } | undefined;
                    state?: {
                        [x: string]: any;
                    } | undefined;
                    events?: {
                        realtimeEvent?: {
                            event?: {
                                channel?: string;
                                data?: any;
                            } | undefined;
                            status?: RealtimeSubscriptionStatus_2 | undefined;
                        } | undefined;
                        formSubmitted?: {
                            results?: {
                                [x: string]: {
                                    fieldType?: FormFieldType_2;
                                    isSecret?: boolean | undefined;
                                    stringValue?: string | undefined;
                                    numberValue?: number | undefined;
                                    boolValue?: boolean | undefined;
                                    listValue?: {
                                        itemType?: FormFieldType_2;
                                        items?: any[];
                                    } | undefined;
                                    selectionValue?: {
                                        values?: string[];
                                    } | undefined;
                                    groupValue?: {} | undefined;
                                } | undefined;
                            };
                            formId?: string | undefined;
                        } | undefined;
                        toastAction?: {} | undefined;
                        userAction?: {
                            actionId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncRequest?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncResponse?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                            error?: {
                                message?: string;
                                details?: string;
                            } | undefined;
                        } | undefined;
                        timer?: {} | undefined;
                        blocking?: {} | undefined;
                        resize?: {} | undefined;
                        async?: boolean | undefined;
                        remoteOnly?: boolean | undefined;
                        hook?: string | undefined;
                        retry?: boolean | undefined;
                    }[];
                } | undefined): UIRequest;
                fromPartial(object: {
                    env?: {
                        locale?: string | undefined;
                        colorScheme?: string | undefined;
                        dimensions?: {
                            height?: number;
                            width?: number;
                            scale?: number;
                        } | undefined;
                        timezone?: string | undefined;
                    } | undefined;
                    props?: {
                        [x: string]: any;
                    } | undefined;
                    state?: {
                        [x: string]: any;
                    } | undefined;
                    events?: {
                        realtimeEvent?: {
                            event?: {
                                channel?: string;
                                data?: any;
                            } | undefined;
                            status?: RealtimeSubscriptionStatus_2 | undefined;
                        } | undefined;
                        formSubmitted?: {
                            results?: {
                                [x: string]: {
                                    fieldType?: FormFieldType_2;
                                    isSecret?: boolean | undefined;
                                    stringValue?: string | undefined;
                                    numberValue?: number | undefined;
                                    boolValue?: boolean | undefined;
                                    listValue?: {
                                        itemType?: FormFieldType_2;
                                        items?: any[];
                                    } | undefined;
                                    selectionValue?: {
                                        values?: string[];
                                    } | undefined;
                                    groupValue?: {} | undefined;
                                } | undefined;
                            };
                            formId?: string | undefined;
                        } | undefined;
                        toastAction?: {} | undefined;
                        userAction?: {
                            actionId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncRequest?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncResponse?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                            error?: {
                                message?: string;
                                details?: string;
                            } | undefined;
                        } | undefined;
                        timer?: {} | undefined;
                        blocking?: {} | undefined;
                        resize?: {} | undefined;
                        async?: boolean | undefined;
                        remoteOnly?: boolean | undefined;
                        hook?: string | undefined;
                        retry?: boolean | undefined;
                    }[];
                }): UIRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.ui.block_kit.v1beta.UIResponse";
                encode(message: UIResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UIResponse;
                fromJSON(object: any): UIResponse;
                toJSON(message: UIResponse): unknown;
                create(base?: {
                    state?: {
                        [x: string]: any;
                    } | undefined;
                    effects?: {
                        realtimeSubscriptions?: {
                            subscriptionIds?: string[];
                        } | undefined;
                        rerenderUi?: {
                            delaySeconds?: number | undefined;
                        } | undefined;
                        reloadPart?: {
                            subreddit?: {
                                subredditId?: string;
                            } | undefined;
                            post?: {
                                postId?: string;
                                body?: boolean | undefined;
                                comments?: boolean | undefined;
                            } | undefined;
                            comment?: {
                                postId?: string;
                                commentId?: string;
                                replies?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                        showForm?: {
                            form?: {
                                fields?: {
                                    fieldId?: string;
                                    fieldType?: FormFieldType_2;
                                    label?: string;
                                    helpText?: string | undefined;
                                    defaultValue?: {
                                        fieldType?: FormFieldType_2;
                                        isSecret?: boolean | undefined;
                                        stringValue?: string | undefined;
                                        numberValue?: number | undefined;
                                        boolValue?: boolean | undefined;
                                        listValue?: {
                                            itemType?: FormFieldType_2;
                                            items?: any[];
                                        } | undefined;
                                        selectionValue?: {
                                            values?: string[];
                                        } | undefined;
                                        groupValue?: {} | undefined;
                                    } | undefined;
                                    required?: boolean | undefined;
                                    disabled?: boolean | undefined;
                                    fieldConfig?: {
                                        stringConfig?: {
                                            minLength?: number | undefined;
                                            maxLength?: number | undefined;
                                            placeholder?: string | undefined;
                                        } | undefined;
                                        paragraphConfig?: {
                                            maxCharacters?: number | undefined;
                                            lineHeight?: number | undefined;
                                            placeholder?: string | undefined;
                                        } | undefined;
                                        numberConfig?: {
                                            step?: number | undefined;
                                            min?: number | undefined;
                                            max?: number | undefined;
                                        } | undefined;
                                        booleanConfig?: {} | undefined;
                                        listConfig?: {
                                            itemType?: FormFieldType_2;
                                            itemConfig?: any | undefined;
                                            minEntries?: number | undefined;
                                            maxEntries?: number | undefined;
                                            entryLabel?: string | undefined;
                                        } | undefined;
                                        selectionConfig?: {
                                            choices?: {
                                                label?: string;
                                                value?: string;
                                            }[];
                                            multiSelect?: boolean | undefined;
                                            minSelections?: number | undefined;
                                            maxSelections?: number | undefined;
                                            renderAsList?: boolean | undefined;
                                        } | undefined;
                                        groupConfig?: {
                                            fields?: any[];
                                        } | undefined;
                                    } | undefined;
                                    isSecret?: boolean | undefined;
                                }[];
                                title?: string | undefined;
                                shortDescription?: string | undefined;
                                acceptLabel?: string | undefined;
                                cancelLabel?: string | undefined;
                                id?: string | undefined;
                            } | undefined;
                        } | undefined;
                        showToast?: {
                            toast?: {
                                text?: string;
                                appearance?: ToastAppearance_2 | undefined;
                                leadingElement?: {
                                    icon?: string | undefined;
                                    emoji?: string | undefined;
                                    avatar?: string | undefined;
                                } | undefined;
                                trailingElement?: {
                                    label?: string | undefined;
                                    icon?: string | undefined;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        navigateToUrl?: {
                            url?: string;
                            target?: string | undefined;
                        } | undefined;
                        interval?: {
                            intervals?: {
                                [x: string]: {
                                    duration?: {
                                        seconds?: number;
                                        nanos?: number;
                                    } | undefined;
                                    async?: boolean | undefined;
                                } | undefined;
                            };
                        } | undefined;
                        type?: EffectType_2;
                    }[];
                    events?: {
                        realtimeEvent?: {
                            event?: {
                                channel?: string;
                                data?: any;
                            } | undefined;
                            status?: RealtimeSubscriptionStatus_2 | undefined;
                        } | undefined;
                        formSubmitted?: {
                            results?: {
                                [x: string]: {
                                    fieldType?: FormFieldType_2;
                                    isSecret?: boolean | undefined;
                                    stringValue?: string | undefined;
                                    numberValue?: number | undefined;
                                    boolValue?: boolean | undefined;
                                    listValue?: {
                                        itemType?: FormFieldType_2;
                                        items?: any[];
                                    } | undefined;
                                    selectionValue?: {
                                        values?: string[];
                                    } | undefined;
                                    groupValue?: {} | undefined;
                                } | undefined;
                            };
                            formId?: string | undefined;
                        } | undefined;
                        toastAction?: {} | undefined;
                        userAction?: {
                            actionId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncRequest?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncResponse?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                            error?: {
                                message?: string;
                                details?: string;
                            } | undefined;
                        } | undefined;
                        timer?: {} | undefined;
                        blocking?: {} | undefined;
                        resize?: {} | undefined;
                        async?: boolean | undefined;
                        remoteOnly?: boolean | undefined;
                        hook?: string | undefined;
                        retry?: boolean | undefined;
                    }[];
                    blocks?: {
                        type?: BlockType_2;
                        size?: {
                            grow?: boolean | undefined;
                            width?: number | undefined;
                            widthUnit?: BlockSizeUnit_2 | undefined;
                            height?: number | undefined;
                            heightUnit?: BlockSizeUnit_2 | undefined;
                        } | undefined;
                        sizes?: {
                            grow?: boolean | undefined;
                            width?: {
                                value?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                min?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                max?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                            } | undefined;
                            height?: {
                                value?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                min?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                max?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        config?: {
                            rootConfig?: {
                                children?: any[];
                                height?: number;
                            } | undefined;
                            stackConfig?: {
                                direction?: BlockStackDirection_2;
                                children?: any[];
                                reverse?: boolean | undefined;
                                alignment?: {
                                    vertical?: BlockVerticalAlignment_2 | undefined;
                                    horizontal?: BlockHorizontalAlignment_2 | undefined;
                                } | undefined;
                                padding?: BlockPadding_2 | undefined;
                                gap?: BlockGap_2 | undefined;
                                border?: {
                                    color?: string | undefined;
                                    width?: BlockBorderWidth_2 | undefined;
                                    colors?: {
                                        light?: string | undefined;
                                        dark?: string | undefined;
                                    } | undefined;
                                } | undefined;
                                cornerRadius?: BlockRadius_2 | undefined;
                                backgroundColor?: string | undefined;
                                backgroundColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            textConfig?: {
                                text?: string;
                                size?: BlockTextSize_2 | undefined;
                                weight?: BlockTextWeight_2 | undefined;
                                color?: string | undefined;
                                alignment?: {
                                    vertical?: BlockVerticalAlignment_2 | undefined;
                                    horizontal?: BlockHorizontalAlignment_2 | undefined;
                                } | undefined;
                                outline?: BlockTextOutline_2 | undefined;
                                style?: BlockTextStyle_2 | undefined;
                                selectable?: boolean | undefined;
                                colors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                                wrap?: boolean | undefined;
                                overflow?: BlockTextOverflow_2 | undefined;
                            } | undefined;
                            buttonConfig?: {
                                text?: string | undefined;
                                icon?: string | undefined;
                                buttonSize?: BlockButtonSize_2 | undefined;
                                buttonAppearance?: BlockButtonAppearance_2 | undefined;
                                textColor?: string | undefined;
                                backgroundColor?: string | undefined;
                                disabled?: boolean | undefined;
                                textColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                                backgroundColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            imageConfig?: {
                                url?: string;
                                width?: number;
                                height?: number;
                                description?: string | undefined;
                                resizeMode?: BlockImageResizeMode_2 | undefined;
                            } | undefined;
                            spacerConfig?: {
                                size?: BlockSpacerSize_2 | undefined;
                                shape?: BlockSpacerShape_2 | undefined;
                            } | undefined;
                            iconConfig?: {
                                icon?: string;
                                color?: string | undefined;
                                size?: BlockIconSize_2 | undefined;
                                colors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            avatarConfig?: {
                                thingId?: string;
                                facing?: BlockAvatarFacing_2 | undefined;
                                size?: BlockAvatarSize_2 | undefined;
                                background?: BlockAvatarBackground_2 | undefined;
                            } | undefined;
                            fullsnooConfig?: {
                                userId?: string;
                                facing?: BlockAvatarFacing_2 | undefined;
                                size?: BlockFullSnooSize_2 | undefined;
                            } | undefined;
                            animationConfig?: {
                                url?: string;
                                width?: number;
                                height?: number;
                                type?: BlockAnimationType_2;
                                loop?: boolean | undefined;
                                loopMode?: BlockAnimationLoopMode_2 | undefined;
                                autoplay?: boolean | undefined;
                                speed?: number | undefined;
                                direction?: BlockAnimationDirection_2 | undefined;
                            } | undefined;
                            webviewConfig?: {
                                url?: string;
                                state?: {
                                    [x: string]: any;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        actions?: {
                            type?: BlockActionType_2;
                            id?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        }[];
                        id?: string | undefined;
                        key?: string | undefined;
                    } | undefined;
                } | undefined): UIResponse;
                fromPartial(object: {
                    state?: {
                        [x: string]: any;
                    } | undefined;
                    effects?: {
                        realtimeSubscriptions?: {
                            subscriptionIds?: string[];
                        } | undefined;
                        rerenderUi?: {
                            delaySeconds?: number | undefined;
                        } | undefined;
                        reloadPart?: {
                            subreddit?: {
                                subredditId?: string;
                            } | undefined;
                            post?: {
                                postId?: string;
                                body?: boolean | undefined;
                                comments?: boolean | undefined;
                            } | undefined;
                            comment?: {
                                postId?: string;
                                commentId?: string;
                                replies?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                        showForm?: {
                            form?: {
                                fields?: {
                                    fieldId?: string;
                                    fieldType?: FormFieldType_2;
                                    label?: string;
                                    helpText?: string | undefined;
                                    defaultValue?: {
                                        fieldType?: FormFieldType_2;
                                        isSecret?: boolean | undefined;
                                        stringValue?: string | undefined;
                                        numberValue?: number | undefined;
                                        boolValue?: boolean | undefined;
                                        listValue?: {
                                            itemType?: FormFieldType_2;
                                            items?: any[];
                                        } | undefined;
                                        selectionValue?: {
                                            values?: string[];
                                        } | undefined;
                                        groupValue?: {} | undefined;
                                    } | undefined;
                                    required?: boolean | undefined;
                                    disabled?: boolean | undefined;
                                    fieldConfig?: {
                                        stringConfig?: {
                                            minLength?: number | undefined;
                                            maxLength?: number | undefined;
                                            placeholder?: string | undefined;
                                        } | undefined;
                                        paragraphConfig?: {
                                            maxCharacters?: number | undefined;
                                            lineHeight?: number | undefined;
                                            placeholder?: string | undefined;
                                        } | undefined;
                                        numberConfig?: {
                                            step?: number | undefined;
                                            min?: number | undefined;
                                            max?: number | undefined;
                                        } | undefined;
                                        booleanConfig?: {} | undefined;
                                        listConfig?: {
                                            itemType?: FormFieldType_2;
                                            itemConfig?: any | undefined;
                                            minEntries?: number | undefined;
                                            maxEntries?: number | undefined;
                                            entryLabel?: string | undefined;
                                        } | undefined;
                                        selectionConfig?: {
                                            choices?: {
                                                label?: string;
                                                value?: string;
                                            }[];
                                            multiSelect?: boolean | undefined;
                                            minSelections?: number | undefined;
                                            maxSelections?: number | undefined;
                                            renderAsList?: boolean | undefined;
                                        } | undefined;
                                        groupConfig?: {
                                            fields?: any[];
                                        } | undefined;
                                    } | undefined;
                                    isSecret?: boolean | undefined;
                                }[];
                                title?: string | undefined;
                                shortDescription?: string | undefined;
                                acceptLabel?: string | undefined;
                                cancelLabel?: string | undefined;
                                id?: string | undefined;
                            } | undefined;
                        } | undefined;
                        showToast?: {
                            toast?: {
                                text?: string;
                                appearance?: ToastAppearance_2 | undefined;
                                leadingElement?: {
                                    icon?: string | undefined;
                                    emoji?: string | undefined;
                                    avatar?: string | undefined;
                                } | undefined;
                                trailingElement?: {
                                    label?: string | undefined;
                                    icon?: string | undefined;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        navigateToUrl?: {
                            url?: string;
                            target?: string | undefined;
                        } | undefined;
                        interval?: {
                            intervals?: {
                                [x: string]: {
                                    duration?: {
                                        seconds?: number;
                                        nanos?: number;
                                    } | undefined;
                                    async?: boolean | undefined;
                                } | undefined;
                            };
                        } | undefined;
                        type?: EffectType_2;
                    }[];
                    events?: {
                        realtimeEvent?: {
                            event?: {
                                channel?: string;
                                data?: any;
                            } | undefined;
                            status?: RealtimeSubscriptionStatus_2 | undefined;
                        } | undefined;
                        formSubmitted?: {
                            results?: {
                                [x: string]: {
                                    fieldType?: FormFieldType_2;
                                    isSecret?: boolean | undefined;
                                    stringValue?: string | undefined;
                                    numberValue?: number | undefined;
                                    boolValue?: boolean | undefined;
                                    listValue?: {
                                        itemType?: FormFieldType_2;
                                        items?: any[];
                                    } | undefined;
                                    selectionValue?: {
                                        values?: string[];
                                    } | undefined;
                                    groupValue?: {} | undefined;
                                } | undefined;
                            };
                            formId?: string | undefined;
                        } | undefined;
                        toastAction?: {} | undefined;
                        userAction?: {
                            actionId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncRequest?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncResponse?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                            error?: {
                                message?: string;
                                details?: string;
                            } | undefined;
                        } | undefined;
                        timer?: {} | undefined;
                        blocking?: {} | undefined;
                        resize?: {} | undefined;
                        async?: boolean | undefined;
                        remoteOnly?: boolean | undefined;
                        hook?: string | undefined;
                        retry?: boolean | undefined;
                    }[];
                    blocks?: {
                        type?: BlockType_2;
                        size?: {
                            grow?: boolean | undefined;
                            width?: number | undefined;
                            widthUnit?: BlockSizeUnit_2 | undefined;
                            height?: number | undefined;
                            heightUnit?: BlockSizeUnit_2 | undefined;
                        } | undefined;
                        sizes?: {
                            grow?: boolean | undefined;
                            width?: {
                                value?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                min?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                max?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                            } | undefined;
                            height?: {
                                value?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                min?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                max?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        config?: {
                            rootConfig?: {
                                children?: any[];
                                height?: number;
                            } | undefined;
                            stackConfig?: {
                                direction?: BlockStackDirection_2;
                                children?: any[];
                                reverse?: boolean | undefined;
                                alignment?: {
                                    vertical?: BlockVerticalAlignment_2 | undefined;
                                    horizontal?: BlockHorizontalAlignment_2 | undefined;
                                } | undefined;
                                padding?: BlockPadding_2 | undefined;
                                gap?: BlockGap_2 | undefined;
                                border?: {
                                    color?: string | undefined;
                                    width?: BlockBorderWidth_2 | undefined;
                                    colors?: {
                                        light?: string | undefined;
                                        dark?: string | undefined;
                                    } | undefined;
                                } | undefined;
                                cornerRadius?: BlockRadius_2 | undefined;
                                backgroundColor?: string | undefined;
                                backgroundColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            textConfig?: {
                                text?: string;
                                size?: BlockTextSize_2 | undefined;
                                weight?: BlockTextWeight_2 | undefined;
                                color?: string | undefined;
                                alignment?: {
                                    vertical?: BlockVerticalAlignment_2 | undefined;
                                    horizontal?: BlockHorizontalAlignment_2 | undefined;
                                } | undefined;
                                outline?: BlockTextOutline_2 | undefined;
                                style?: BlockTextStyle_2 | undefined;
                                selectable?: boolean | undefined;
                                colors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                                wrap?: boolean | undefined;
                                overflow?: BlockTextOverflow_2 | undefined;
                            } | undefined;
                            buttonConfig?: {
                                text?: string | undefined;
                                icon?: string | undefined;
                                buttonSize?: BlockButtonSize_2 | undefined;
                                buttonAppearance?: BlockButtonAppearance_2 | undefined;
                                textColor?: string | undefined;
                                backgroundColor?: string | undefined;
                                disabled?: boolean | undefined;
                                textColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                                backgroundColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            imageConfig?: {
                                url?: string;
                                width?: number;
                                height?: number;
                                description?: string | undefined;
                                resizeMode?: BlockImageResizeMode_2 | undefined;
                            } | undefined;
                            spacerConfig?: {
                                size?: BlockSpacerSize_2 | undefined;
                                shape?: BlockSpacerShape_2 | undefined;
                            } | undefined;
                            iconConfig?: {
                                icon?: string;
                                color?: string | undefined;
                                size?: BlockIconSize_2 | undefined;
                                colors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            avatarConfig?: {
                                thingId?: string;
                                facing?: BlockAvatarFacing_2 | undefined;
                                size?: BlockAvatarSize_2 | undefined;
                                background?: BlockAvatarBackground_2 | undefined;
                            } | undefined;
                            fullsnooConfig?: {
                                userId?: string;
                                facing?: BlockAvatarFacing_2 | undefined;
                                size?: BlockFullSnooSize_2 | undefined;
                            } | undefined;
                            animationConfig?: {
                                url?: string;
                                width?: number;
                                height?: number;
                                type?: BlockAnimationType_2;
                                loop?: boolean | undefined;
                                loopMode?: BlockAnimationLoopMode_2 | undefined;
                                autoplay?: boolean | undefined;
                                speed?: number | undefined;
                                direction?: BlockAnimationDirection_2 | undefined;
                            } | undefined;
                            webviewConfig?: {
                                url?: string;
                                state?: {
                                    [x: string]: any;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        actions?: {
                            type?: BlockActionType_2;
                            id?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        }[];
                        id?: string | undefined;
                        key?: string | undefined;
                    } | undefined;
                }): UIResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly renderPostComposer: {
            readonly name: "RenderPostComposer";
            readonly requestType: {
                $type: "devvit.ui.block_kit.v1beta.UIRequest";
                encode(message: UIRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UIRequest;
                fromJSON(object: any): UIRequest;
                toJSON(message: UIRequest): unknown;
                create(base?: {
                    env?: {
                        locale?: string | undefined;
                        colorScheme?: string | undefined;
                        dimensions?: {
                            height?: number;
                            width?: number;
                            scale?: number;
                        } | undefined;
                        timezone?: string | undefined;
                    } | undefined;
                    props?: {
                        [x: string]: any;
                    } | undefined;
                    state?: {
                        [x: string]: any;
                    } | undefined;
                    events?: {
                        realtimeEvent?: {
                            event?: {
                                channel?: string;
                                data?: any;
                            } | undefined;
                            status?: RealtimeSubscriptionStatus_2 | undefined;
                        } | undefined;
                        formSubmitted?: {
                            results?: {
                                [x: string]: {
                                    fieldType?: FormFieldType_2;
                                    isSecret?: boolean | undefined;
                                    stringValue?: string | undefined;
                                    numberValue?: number | undefined;
                                    boolValue?: boolean | undefined;
                                    listValue?: {
                                        itemType?: FormFieldType_2;
                                        items?: any[];
                                    } | undefined;
                                    selectionValue?: {
                                        values?: string[];
                                    } | undefined;
                                    groupValue?: {} | undefined;
                                } | undefined;
                            };
                            formId?: string | undefined;
                        } | undefined;
                        toastAction?: {} | undefined;
                        userAction?: {
                            actionId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncRequest?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncResponse?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                            error?: {
                                message?: string;
                                details?: string;
                            } | undefined;
                        } | undefined;
                        timer?: {} | undefined;
                        blocking?: {} | undefined;
                        resize?: {} | undefined;
                        async?: boolean | undefined;
                        remoteOnly?: boolean | undefined;
                        hook?: string | undefined;
                        retry?: boolean | undefined;
                    }[];
                } | undefined): UIRequest;
                fromPartial(object: {
                    env?: {
                        locale?: string | undefined;
                        colorScheme?: string | undefined;
                        dimensions?: {
                            height?: number;
                            width?: number;
                            scale?: number;
                        } | undefined;
                        timezone?: string | undefined;
                    } | undefined;
                    props?: {
                        [x: string]: any;
                    } | undefined;
                    state?: {
                        [x: string]: any;
                    } | undefined;
                    events?: {
                        realtimeEvent?: {
                            event?: {
                                channel?: string;
                                data?: any;
                            } | undefined;
                            status?: RealtimeSubscriptionStatus_2 | undefined;
                        } | undefined;
                        formSubmitted?: {
                            results?: {
                                [x: string]: {
                                    fieldType?: FormFieldType_2;
                                    isSecret?: boolean | undefined;
                                    stringValue?: string | undefined;
                                    numberValue?: number | undefined;
                                    boolValue?: boolean | undefined;
                                    listValue?: {
                                        itemType?: FormFieldType_2;
                                        items?: any[];
                                    } | undefined;
                                    selectionValue?: {
                                        values?: string[];
                                    } | undefined;
                                    groupValue?: {} | undefined;
                                } | undefined;
                            };
                            formId?: string | undefined;
                        } | undefined;
                        toastAction?: {} | undefined;
                        userAction?: {
                            actionId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncRequest?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncResponse?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                            error?: {
                                message?: string;
                                details?: string;
                            } | undefined;
                        } | undefined;
                        timer?: {} | undefined;
                        blocking?: {} | undefined;
                        resize?: {} | undefined;
                        async?: boolean | undefined;
                        remoteOnly?: boolean | undefined;
                        hook?: string | undefined;
                        retry?: boolean | undefined;
                    }[];
                }): UIRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.ui.block_kit.v1beta.UIResponse";
                encode(message: UIResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UIResponse;
                fromJSON(object: any): UIResponse;
                toJSON(message: UIResponse): unknown;
                create(base?: {
                    state?: {
                        [x: string]: any;
                    } | undefined;
                    effects?: {
                        realtimeSubscriptions?: {
                            subscriptionIds?: string[];
                        } | undefined;
                        rerenderUi?: {
                            delaySeconds?: number | undefined;
                        } | undefined;
                        reloadPart?: {
                            subreddit?: {
                                subredditId?: string;
                            } | undefined;
                            post?: {
                                postId?: string;
                                body?: boolean | undefined;
                                comments?: boolean | undefined;
                            } | undefined;
                            comment?: {
                                postId?: string;
                                commentId?: string;
                                replies?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                        showForm?: {
                            form?: {
                                fields?: {
                                    fieldId?: string;
                                    fieldType?: FormFieldType_2;
                                    label?: string;
                                    helpText?: string | undefined;
                                    defaultValue?: {
                                        fieldType?: FormFieldType_2;
                                        isSecret?: boolean | undefined;
                                        stringValue?: string | undefined;
                                        numberValue?: number | undefined;
                                        boolValue?: boolean | undefined;
                                        listValue?: {
                                            itemType?: FormFieldType_2;
                                            items?: any[];
                                        } | undefined;
                                        selectionValue?: {
                                            values?: string[];
                                        } | undefined;
                                        groupValue?: {} | undefined;
                                    } | undefined;
                                    required?: boolean | undefined;
                                    disabled?: boolean | undefined;
                                    fieldConfig?: {
                                        stringConfig?: {
                                            minLength?: number | undefined;
                                            maxLength?: number | undefined;
                                            placeholder?: string | undefined;
                                        } | undefined;
                                        paragraphConfig?: {
                                            maxCharacters?: number | undefined;
                                            lineHeight?: number | undefined;
                                            placeholder?: string | undefined;
                                        } | undefined;
                                        numberConfig?: {
                                            step?: number | undefined;
                                            min?: number | undefined;
                                            max?: number | undefined;
                                        } | undefined;
                                        booleanConfig?: {} | undefined;
                                        listConfig?: {
                                            itemType?: FormFieldType_2;
                                            itemConfig?: any | undefined;
                                            minEntries?: number | undefined;
                                            maxEntries?: number | undefined;
                                            entryLabel?: string | undefined;
                                        } | undefined;
                                        selectionConfig?: {
                                            choices?: {
                                                label?: string;
                                                value?: string;
                                            }[];
                                            multiSelect?: boolean | undefined;
                                            minSelections?: number | undefined;
                                            maxSelections?: number | undefined;
                                            renderAsList?: boolean | undefined;
                                        } | undefined;
                                        groupConfig?: {
                                            fields?: any[];
                                        } | undefined;
                                    } | undefined;
                                    isSecret?: boolean | undefined;
                                }[];
                                title?: string | undefined;
                                shortDescription?: string | undefined;
                                acceptLabel?: string | undefined;
                                cancelLabel?: string | undefined;
                                id?: string | undefined;
                            } | undefined;
                        } | undefined;
                        showToast?: {
                            toast?: {
                                text?: string;
                                appearance?: ToastAppearance_2 | undefined;
                                leadingElement?: {
                                    icon?: string | undefined;
                                    emoji?: string | undefined;
                                    avatar?: string | undefined;
                                } | undefined;
                                trailingElement?: {
                                    label?: string | undefined;
                                    icon?: string | undefined;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        navigateToUrl?: {
                            url?: string;
                            target?: string | undefined;
                        } | undefined;
                        interval?: {
                            intervals?: {
                                [x: string]: {
                                    duration?: {
                                        seconds?: number;
                                        nanos?: number;
                                    } | undefined;
                                    async?: boolean | undefined;
                                } | undefined;
                            };
                        } | undefined;
                        type?: EffectType_2;
                    }[];
                    events?: {
                        realtimeEvent?: {
                            event?: {
                                channel?: string;
                                data?: any;
                            } | undefined;
                            status?: RealtimeSubscriptionStatus_2 | undefined;
                        } | undefined;
                        formSubmitted?: {
                            results?: {
                                [x: string]: {
                                    fieldType?: FormFieldType_2;
                                    isSecret?: boolean | undefined;
                                    stringValue?: string | undefined;
                                    numberValue?: number | undefined;
                                    boolValue?: boolean | undefined;
                                    listValue?: {
                                        itemType?: FormFieldType_2;
                                        items?: any[];
                                    } | undefined;
                                    selectionValue?: {
                                        values?: string[];
                                    } | undefined;
                                    groupValue?: {} | undefined;
                                } | undefined;
                            };
                            formId?: string | undefined;
                        } | undefined;
                        toastAction?: {} | undefined;
                        userAction?: {
                            actionId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncRequest?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncResponse?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                            error?: {
                                message?: string;
                                details?: string;
                            } | undefined;
                        } | undefined;
                        timer?: {} | undefined;
                        blocking?: {} | undefined;
                        resize?: {} | undefined;
                        async?: boolean | undefined;
                        remoteOnly?: boolean | undefined;
                        hook?: string | undefined;
                        retry?: boolean | undefined;
                    }[];
                    blocks?: {
                        type?: BlockType_2;
                        size?: {
                            grow?: boolean | undefined;
                            width?: number | undefined;
                            widthUnit?: BlockSizeUnit_2 | undefined;
                            height?: number | undefined;
                            heightUnit?: BlockSizeUnit_2 | undefined;
                        } | undefined;
                        sizes?: {
                            grow?: boolean | undefined;
                            width?: {
                                value?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                min?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                max?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                            } | undefined;
                            height?: {
                                value?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                min?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                max?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        config?: {
                            rootConfig?: {
                                children?: any[];
                                height?: number;
                            } | undefined;
                            stackConfig?: {
                                direction?: BlockStackDirection_2;
                                children?: any[];
                                reverse?: boolean | undefined;
                                alignment?: {
                                    vertical?: BlockVerticalAlignment_2 | undefined;
                                    horizontal?: BlockHorizontalAlignment_2 | undefined;
                                } | undefined;
                                padding?: BlockPadding_2 | undefined;
                                gap?: BlockGap_2 | undefined;
                                border?: {
                                    color?: string | undefined;
                                    width?: BlockBorderWidth_2 | undefined;
                                    colors?: {
                                        light?: string | undefined;
                                        dark?: string | undefined;
                                    } | undefined;
                                } | undefined;
                                cornerRadius?: BlockRadius_2 | undefined;
                                backgroundColor?: string | undefined;
                                backgroundColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            textConfig?: {
                                text?: string;
                                size?: BlockTextSize_2 | undefined;
                                weight?: BlockTextWeight_2 | undefined;
                                color?: string | undefined;
                                alignment?: {
                                    vertical?: BlockVerticalAlignment_2 | undefined;
                                    horizontal?: BlockHorizontalAlignment_2 | undefined;
                                } | undefined;
                                outline?: BlockTextOutline_2 | undefined;
                                style?: BlockTextStyle_2 | undefined;
                                selectable?: boolean | undefined;
                                colors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                                wrap?: boolean | undefined;
                                overflow?: BlockTextOverflow_2 | undefined;
                            } | undefined;
                            buttonConfig?: {
                                text?: string | undefined;
                                icon?: string | undefined;
                                buttonSize?: BlockButtonSize_2 | undefined;
                                buttonAppearance?: BlockButtonAppearance_2 | undefined;
                                textColor?: string | undefined;
                                backgroundColor?: string | undefined;
                                disabled?: boolean | undefined;
                                textColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                                backgroundColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            imageConfig?: {
                                url?: string;
                                width?: number;
                                height?: number;
                                description?: string | undefined;
                                resizeMode?: BlockImageResizeMode_2 | undefined;
                            } | undefined;
                            spacerConfig?: {
                                size?: BlockSpacerSize_2 | undefined;
                                shape?: BlockSpacerShape_2 | undefined;
                            } | undefined;
                            iconConfig?: {
                                icon?: string;
                                color?: string | undefined;
                                size?: BlockIconSize_2 | undefined;
                                colors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            avatarConfig?: {
                                thingId?: string;
                                facing?: BlockAvatarFacing_2 | undefined;
                                size?: BlockAvatarSize_2 | undefined;
                                background?: BlockAvatarBackground_2 | undefined;
                            } | undefined;
                            fullsnooConfig?: {
                                userId?: string;
                                facing?: BlockAvatarFacing_2 | undefined;
                                size?: BlockFullSnooSize_2 | undefined;
                            } | undefined;
                            animationConfig?: {
                                url?: string;
                                width?: number;
                                height?: number;
                                type?: BlockAnimationType_2;
                                loop?: boolean | undefined;
                                loopMode?: BlockAnimationLoopMode_2 | undefined;
                                autoplay?: boolean | undefined;
                                speed?: number | undefined;
                                direction?: BlockAnimationDirection_2 | undefined;
                            } | undefined;
                            webviewConfig?: {
                                url?: string;
                                state?: {
                                    [x: string]: any;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        actions?: {
                            type?: BlockActionType_2;
                            id?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        }[];
                        id?: string | undefined;
                        key?: string | undefined;
                    } | undefined;
                } | undefined): UIResponse;
                fromPartial(object: {
                    state?: {
                        [x: string]: any;
                    } | undefined;
                    effects?: {
                        realtimeSubscriptions?: {
                            subscriptionIds?: string[];
                        } | undefined;
                        rerenderUi?: {
                            delaySeconds?: number | undefined;
                        } | undefined;
                        reloadPart?: {
                            subreddit?: {
                                subredditId?: string;
                            } | undefined;
                            post?: {
                                postId?: string;
                                body?: boolean | undefined;
                                comments?: boolean | undefined;
                            } | undefined;
                            comment?: {
                                postId?: string;
                                commentId?: string;
                                replies?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                        showForm?: {
                            form?: {
                                fields?: {
                                    fieldId?: string;
                                    fieldType?: FormFieldType_2;
                                    label?: string;
                                    helpText?: string | undefined;
                                    defaultValue?: {
                                        fieldType?: FormFieldType_2;
                                        isSecret?: boolean | undefined;
                                        stringValue?: string | undefined;
                                        numberValue?: number | undefined;
                                        boolValue?: boolean | undefined;
                                        listValue?: {
                                            itemType?: FormFieldType_2;
                                            items?: any[];
                                        } | undefined;
                                        selectionValue?: {
                                            values?: string[];
                                        } | undefined;
                                        groupValue?: {} | undefined;
                                    } | undefined;
                                    required?: boolean | undefined;
                                    disabled?: boolean | undefined;
                                    fieldConfig?: {
                                        stringConfig?: {
                                            minLength?: number | undefined;
                                            maxLength?: number | undefined;
                                            placeholder?: string | undefined;
                                        } | undefined;
                                        paragraphConfig?: {
                                            maxCharacters?: number | undefined;
                                            lineHeight?: number | undefined;
                                            placeholder?: string | undefined;
                                        } | undefined;
                                        numberConfig?: {
                                            step?: number | undefined;
                                            min?: number | undefined;
                                            max?: number | undefined;
                                        } | undefined;
                                        booleanConfig?: {} | undefined;
                                        listConfig?: {
                                            itemType?: FormFieldType_2;
                                            itemConfig?: any | undefined;
                                            minEntries?: number | undefined;
                                            maxEntries?: number | undefined;
                                            entryLabel?: string | undefined;
                                        } | undefined;
                                        selectionConfig?: {
                                            choices?: {
                                                label?: string;
                                                value?: string;
                                            }[];
                                            multiSelect?: boolean | undefined;
                                            minSelections?: number | undefined;
                                            maxSelections?: number | undefined;
                                            renderAsList?: boolean | undefined;
                                        } | undefined;
                                        groupConfig?: {
                                            fields?: any[];
                                        } | undefined;
                                    } | undefined;
                                    isSecret?: boolean | undefined;
                                }[];
                                title?: string | undefined;
                                shortDescription?: string | undefined;
                                acceptLabel?: string | undefined;
                                cancelLabel?: string | undefined;
                                id?: string | undefined;
                            } | undefined;
                        } | undefined;
                        showToast?: {
                            toast?: {
                                text?: string;
                                appearance?: ToastAppearance_2 | undefined;
                                leadingElement?: {
                                    icon?: string | undefined;
                                    emoji?: string | undefined;
                                    avatar?: string | undefined;
                                } | undefined;
                                trailingElement?: {
                                    label?: string | undefined;
                                    icon?: string | undefined;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        navigateToUrl?: {
                            url?: string;
                            target?: string | undefined;
                        } | undefined;
                        interval?: {
                            intervals?: {
                                [x: string]: {
                                    duration?: {
                                        seconds?: number;
                                        nanos?: number;
                                    } | undefined;
                                    async?: boolean | undefined;
                                } | undefined;
                            };
                        } | undefined;
                        type?: EffectType_2;
                    }[];
                    events?: {
                        realtimeEvent?: {
                            event?: {
                                channel?: string;
                                data?: any;
                            } | undefined;
                            status?: RealtimeSubscriptionStatus_2 | undefined;
                        } | undefined;
                        formSubmitted?: {
                            results?: {
                                [x: string]: {
                                    fieldType?: FormFieldType_2;
                                    isSecret?: boolean | undefined;
                                    stringValue?: string | undefined;
                                    numberValue?: number | undefined;
                                    boolValue?: boolean | undefined;
                                    listValue?: {
                                        itemType?: FormFieldType_2;
                                        items?: any[];
                                    } | undefined;
                                    selectionValue?: {
                                        values?: string[];
                                    } | undefined;
                                    groupValue?: {} | undefined;
                                } | undefined;
                            };
                            formId?: string | undefined;
                        } | undefined;
                        toastAction?: {} | undefined;
                        userAction?: {
                            actionId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncRequest?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        } | undefined;
                        asyncResponse?: {
                            requestId?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                            error?: {
                                message?: string;
                                details?: string;
                            } | undefined;
                        } | undefined;
                        timer?: {} | undefined;
                        blocking?: {} | undefined;
                        resize?: {} | undefined;
                        async?: boolean | undefined;
                        remoteOnly?: boolean | undefined;
                        hook?: string | undefined;
                        retry?: boolean | undefined;
                    }[];
                    blocks?: {
                        type?: BlockType_2;
                        size?: {
                            grow?: boolean | undefined;
                            width?: number | undefined;
                            widthUnit?: BlockSizeUnit_2 | undefined;
                            height?: number | undefined;
                            heightUnit?: BlockSizeUnit_2 | undefined;
                        } | undefined;
                        sizes?: {
                            grow?: boolean | undefined;
                            width?: {
                                value?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                min?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                max?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                            } | undefined;
                            height?: {
                                value?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                min?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                                max?: {
                                    value?: number;
                                    unit?: BlockSizeUnit_2;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        config?: {
                            rootConfig?: {
                                children?: any[];
                                height?: number;
                            } | undefined;
                            stackConfig?: {
                                direction?: BlockStackDirection_2;
                                children?: any[];
                                reverse?: boolean | undefined;
                                alignment?: {
                                    vertical?: BlockVerticalAlignment_2 | undefined;
                                    horizontal?: BlockHorizontalAlignment_2 | undefined;
                                } | undefined;
                                padding?: BlockPadding_2 | undefined;
                                gap?: BlockGap_2 | undefined;
                                border?: {
                                    color?: string | undefined;
                                    width?: BlockBorderWidth_2 | undefined;
                                    colors?: {
                                        light?: string | undefined;
                                        dark?: string | undefined;
                                    } | undefined;
                                } | undefined;
                                cornerRadius?: BlockRadius_2 | undefined;
                                backgroundColor?: string | undefined;
                                backgroundColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            textConfig?: {
                                text?: string;
                                size?: BlockTextSize_2 | undefined;
                                weight?: BlockTextWeight_2 | undefined;
                                color?: string | undefined;
                                alignment?: {
                                    vertical?: BlockVerticalAlignment_2 | undefined;
                                    horizontal?: BlockHorizontalAlignment_2 | undefined;
                                } | undefined;
                                outline?: BlockTextOutline_2 | undefined;
                                style?: BlockTextStyle_2 | undefined;
                                selectable?: boolean | undefined;
                                colors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                                wrap?: boolean | undefined;
                                overflow?: BlockTextOverflow_2 | undefined;
                            } | undefined;
                            buttonConfig?: {
                                text?: string | undefined;
                                icon?: string | undefined;
                                buttonSize?: BlockButtonSize_2 | undefined;
                                buttonAppearance?: BlockButtonAppearance_2 | undefined;
                                textColor?: string | undefined;
                                backgroundColor?: string | undefined;
                                disabled?: boolean | undefined;
                                textColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                                backgroundColors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            imageConfig?: {
                                url?: string;
                                width?: number;
                                height?: number;
                                description?: string | undefined;
                                resizeMode?: BlockImageResizeMode_2 | undefined;
                            } | undefined;
                            spacerConfig?: {
                                size?: BlockSpacerSize_2 | undefined;
                                shape?: BlockSpacerShape_2 | undefined;
                            } | undefined;
                            iconConfig?: {
                                icon?: string;
                                color?: string | undefined;
                                size?: BlockIconSize_2 | undefined;
                                colors?: {
                                    light?: string | undefined;
                                    dark?: string | undefined;
                                } | undefined;
                            } | undefined;
                            avatarConfig?: {
                                thingId?: string;
                                facing?: BlockAvatarFacing_2 | undefined;
                                size?: BlockAvatarSize_2 | undefined;
                                background?: BlockAvatarBackground_2 | undefined;
                            } | undefined;
                            fullsnooConfig?: {
                                userId?: string;
                                facing?: BlockAvatarFacing_2 | undefined;
                                size?: BlockFullSnooSize_2 | undefined;
                            } | undefined;
                            animationConfig?: {
                                url?: string;
                                width?: number;
                                height?: number;
                                type?: BlockAnimationType_2;
                                loop?: boolean | undefined;
                                loopMode?: BlockAnimationLoopMode_2 | undefined;
                                autoplay?: boolean | undefined;
                                speed?: number | undefined;
                                direction?: BlockAnimationDirection_2 | undefined;
                            } | undefined;
                            webviewConfig?: {
                                url?: string;
                                state?: {
                                    [x: string]: any;
                                } | undefined;
                            } | undefined;
                        } | undefined;
                        actions?: {
                            type?: BlockActionType_2;
                            id?: string;
                            data?: {
                                [x: string]: any;
                            } | undefined;
                        }[];
                        id?: string | undefined;
                        key?: string | undefined;
                    } | undefined;
                }): UIResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const CustomPostServiceName = "devvit.reddit.custom_post.v1alpha.CustomPost";

declare interface CustomPostSnapshot {
    snapshotId: string;
    renderConfig: string;
}

declare const CustomPostSnapshot: {
    $type: "devvit.gql.CustomPostSnapshot";
    encode(message: CustomPostSnapshot, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CustomPostSnapshot;
    fromJSON(object: any): CustomPostSnapshot;
    toJSON(message: CustomPostSnapshot): unknown;
    create(base?: DeepPartial_51<CustomPostSnapshot>): CustomPostSnapshot;
    fromPartial(object: DeepPartial_51<CustomPostSnapshot>): CustomPostSnapshot;
};

declare interface CustomPostSnapshotRequest {
    snapshotId: string;
}

declare const CustomPostSnapshotRequest: {
    $type: "devvit.gateway.CustomPostSnapshotRequest";
    encode(message: CustomPostSnapshotRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CustomPostSnapshotRequest;
    fromJSON(object: any): CustomPostSnapshotRequest;
    toJSON(message: CustomPostSnapshotRequest): unknown;
    create(base?: DeepPartial_50<CustomPostSnapshotRequest>): CustomPostSnapshotRequest;
    fromPartial(object: DeepPartial_50<CustomPostSnapshotRequest>): CustomPostSnapshotRequest;
};

declare interface CustomPostSnapshotResolver {
    GetCustomPostSnapshot(request: CustomPostSnapshotRequest, metadata?: Metadata): Promise<CustomPostSnapshot>;
}

declare class CustomPostSnapshotResolverClientImpl implements CustomPostSnapshotResolver {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_6, opts?: {
        service?: string;
    });
    GetCustomPostSnapshot(request: CustomPostSnapshotRequest, metadata?: Metadata): Promise<CustomPostSnapshot>;
}

declare type CustomPostSnapshotResolverDefinition = typeof CustomPostSnapshotResolverDefinition;

declare const CustomPostSnapshotResolverDefinition: {
    readonly name: "CustomPostSnapshotResolver";
    readonly fullName: "devvit.gateway.CustomPostSnapshotResolver";
    readonly methods: {
        readonly getCustomPostSnapshot: {
            readonly name: "GetCustomPostSnapshot";
            readonly requestType: {
                $type: "devvit.gateway.CustomPostSnapshotRequest";
                encode(message: CustomPostSnapshotRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): CustomPostSnapshotRequest;
                fromJSON(object: any): CustomPostSnapshotRequest;
                toJSON(message: CustomPostSnapshotRequest): unknown;
                create(base?: DeepPartial_50<CustomPostSnapshotRequest>): CustomPostSnapshotRequest;
                fromPartial(object: DeepPartial_50<CustomPostSnapshotRequest>): CustomPostSnapshotRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gql.CustomPostSnapshot";
                encode(message: CustomPostSnapshot, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CustomPostSnapshot;
                fromJSON(object: any): CustomPostSnapshot;
                toJSON(message: CustomPostSnapshot): unknown;
                create(base?: {
                    snapshotId?: string;
                    renderConfig?: string;
                } | undefined): CustomPostSnapshot;
                fromPartial(object: {
                    snapshotId?: string;
                    renderConfig?: string;
                }): CustomPostSnapshot;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const CustomPostSnapshotResolverServiceName = "devvit.gateway.CustomPostSnapshotResolver";

export declare type CustomPostType = {
    /** The name of the custom post type */
    name: string;
    /** A description of the custom post type */
    description?: string;
    /** The fixed height of the post, defaults to 'regular' */
    height?: Devvit.Blocks.RootHeight;
    /** A function component that renders the custom post */
    render: Devvit.CustomPostComponent;
};

export declare class CustomWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get images(): WidgetImage[];
    get text(): string;
    get stylesheetUrl(): string;
    get height(): number;
    get css(): string;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<CustomWidget, 'images' | 'text' | 'stylesheetUrl' | 'height' | 'css'>;
}

declare interface CustomWidget_2 {
    id: string;
    kind: string;
    shortName: string;
    text: string;
    height: number;
    css: string;
    imageData: WidgetImage[];
    styles?: WidgetStyles | undefined;
}

declare const CustomWidget_2: {
    $type: "devvit.plugin.redditapi.widgets.CustomWidget";
    encode(message: CustomWidget_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CustomWidget_2;
    fromJSON(object: any): CustomWidget_2;
    toJSON(message: CustomWidget_2): unknown;
    create(base?: DeepPartial_4<CustomWidget_2>): CustomWidget_2;
    fromPartial(object: DeepPartial_4<CustomWidget_2>): CustomWidget_2;
};

export declare type Data = {
    [key: string]: any;
};

/** DataApiAuthTokenIssuer is the service that issues auth tokens for the data api */
declare interface DataApiAuthTokenIssuer {
    GenerateAuthToken(request: DataApiAuthTokenRequest, metadata?: Metadata): Promise<DataApiAuthTokenResponse>;
}

declare interface DataApiAuthTokenIssuerClient {
    GenerateAuthToken(request: DataApiAuthTokenRequest): Promise<DataApiAuthTokenResponse>;
}

declare class DataApiAuthTokenIssuerClientImpl implements DataApiAuthTokenIssuer {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_64, opts?: {
        service?: string;
    });
    GenerateAuthToken(request: DataApiAuthTokenRequest, metadata?: Metadata): Promise<DataApiAuthTokenResponse>;
}

declare class DataApiAuthTokenIssuerClientJSON implements DataApiAuthTokenIssuerClient {
    private readonly rpc;
    constructor(rpc: Rpc_63);
    GenerateAuthToken(request: DataApiAuthTokenRequest): Promise<DataApiAuthTokenResponse>;
}

declare class DataApiAuthTokenIssuerClientProtobuf implements DataApiAuthTokenIssuerClient {
    private readonly rpc;
    constructor(rpc: Rpc_63);
    GenerateAuthToken(request: DataApiAuthTokenRequest): Promise<DataApiAuthTokenResponse>;
}

/** DataApiAuthTokenIssuer is the service that issues auth tokens for the data api */
declare type DataApiAuthTokenIssuerDefinition = typeof DataApiAuthTokenIssuerDefinition;

declare const DataApiAuthTokenIssuerDefinition: {
    readonly name: "DataApiAuthTokenIssuer";
    readonly fullName: "devvit.data.api.v1alpha.DataApiAuthTokenIssuer";
    readonly methods: {
        readonly generateAuthToken: {
            readonly name: "GenerateAuthToken";
            readonly requestType: {
                $type: "devvit.data.api.v1alpha.DataApiAuthTokenRequest";
                encode(message: DataApiAuthTokenRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): DataApiAuthTokenRequest;
                fromJSON(object: any): DataApiAuthTokenRequest;
                toJSON(message: DataApiAuthTokenRequest): unknown;
                create(base?: DeepPartial_52<DataApiAuthTokenRequest>): DataApiAuthTokenRequest;
                fromPartial(object: DeepPartial_52<DataApiAuthTokenRequest>): DataApiAuthTokenRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.data.api.v1alpha.DataApiAuthTokenResponse";
                encode(message: DataApiAuthTokenResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): DataApiAuthTokenResponse;
                fromJSON(object: any): DataApiAuthTokenResponse;
                toJSON(message: DataApiAuthTokenResponse): unknown;
                create(base?: DeepPartial_52<DataApiAuthTokenResponse>): DataApiAuthTokenResponse;
                fromPartial(object: DeepPartial_52<DataApiAuthTokenResponse>): DataApiAuthTokenResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const DataApiAuthTokenIssuerServiceName = "devvit.data.api.v1alpha.DataApiAuthTokenIssuer";

declare interface DataApiAuthTokenRequest {
    customer: string;
    expiresIn?: Duration | undefined;
}

declare const DataApiAuthTokenRequest: {
    $type: "devvit.data.api.v1alpha.DataApiAuthTokenRequest";
    encode(message: DataApiAuthTokenRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DataApiAuthTokenRequest;
    fromJSON(object: any): DataApiAuthTokenRequest;
    toJSON(message: DataApiAuthTokenRequest): unknown;
    create(base?: DeepPartial_52<DataApiAuthTokenRequest>): DataApiAuthTokenRequest;
    fromPartial(object: DeepPartial_52<DataApiAuthTokenRequest>): DataApiAuthTokenRequest;
};

declare interface DataApiAuthTokenResponse {
    id: string;
    token: string;
    expiresAt?: Date | undefined;
}

declare const DataApiAuthTokenResponse: {
    $type: "devvit.data.api.v1alpha.DataApiAuthTokenResponse";
    encode(message: DataApiAuthTokenResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DataApiAuthTokenResponse;
    fromJSON(object: any): DataApiAuthTokenResponse;
    toJSON(message: DataApiAuthTokenResponse): unknown;
    create(base?: DeepPartial_52<DataApiAuthTokenResponse>): DataApiAuthTokenResponse;
    fromPartial(object: DeepPartial_52<DataApiAuthTokenResponse>): DataApiAuthTokenResponse;
};

declare interface DataIntaker {
    OnEvent(request: IntakeEvent, metadata?: Metadata): Promise<IntakeResponse>;
}

declare class DataIntakerClientImpl implements DataIntaker {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_62, opts?: {
        service?: string;
    });
    OnEvent(request: IntakeEvent, metadata?: Metadata): Promise<IntakeResponse>;
}

declare type DataIntakerDefinition = typeof DataIntakerDefinition;

declare const DataIntakerDefinition: {
    readonly name: "DataIntaker";
    readonly fullName: "devvit.data.api.v1alpha.DataIntaker";
    readonly methods: {
        readonly onEvent: {
            readonly name: "OnEvent";
            readonly requestType: {
                $type: "devvit.data.api.v1alpha.IntakeEvent";
                encode(message: IntakeEvent, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): IntakeEvent;
                fromJSON(object: any): IntakeEvent;
                toJSON(message: IntakeEvent): unknown;
                create(base?: DeepPartial_53<IntakeEvent>): IntakeEvent;
                fromPartial(object: DeepPartial_53<IntakeEvent>): IntakeEvent;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.data.api.v1alpha.IntakeResponse";
                encode(_: IntakeResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): IntakeResponse;
                fromJSON(_: any): IntakeResponse;
                toJSON(_: IntakeResponse): unknown;
                create(base?: DeepPartial_53<IntakeResponse>): IntakeResponse;
                fromPartial(_: DeepPartial_53<IntakeResponse>): IntakeResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const DataIntakerServiceName = "devvit.data.api.v1alpha.DataIntaker";

declare interface DataSubscription {
    id: string;
    tier: DataTier;
    events: FirehoseEvent[];
    subreddits: string[];
    subredditRatings: SubredditRating[];
    organizationId: string;
    name: string;
    description?: string | undefined;
}

declare const DataSubscription: {
    $type: "devvit.data.api.v1alpha.DataSubscription";
    encode(message: DataSubscription, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DataSubscription;
    fromJSON(object: any): DataSubscription;
    toJSON(message: DataSubscription): unknown;
    create(base?: DeepPartial_52<DataSubscription>): DataSubscription;
    fromPartial(object: DeepPartial_52<DataSubscription>): DataSubscription;
};

/**
 * Data Tier defines the level of data delivered to the client
 * FIRST_DATA_TIER is the least amount of data, THIRD_DATA_TIER is the most
 */
declare enum DataTier {
    UNKNOWN_DATA_TIER = 0,
    FIRST_DATA_TIER = 1,
    SECOND_DATA_TIER = 2,
    THIRD_DATA_TIER = 3,
    UNRECOGNIZED = -1
}

declare function dataTierFromJSON(object: any): DataTier;

declare function dataTierToJSON(object: DataTier): number;

declare interface DataToken {
    id: string;
    organizationId: string;
    createdAt?: Date | undefined;
    expiresAt?: Date | undefined;
    isRevoked: boolean;
}

declare const DataToken: {
    $type: "devvit.data.api.v1alpha.DataToken";
    encode(message: DataToken, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DataToken;
    fromJSON(object: any): DataToken;
    toJSON(message: DataToken): unknown;
    create(base?: DeepPartial_52<DataToken>): DataToken;
    fromPartial(object: DeepPartial_52<DataToken>): DataToken;
};

declare interface Debug {
    message?: any | undefined;
}

declare const Debug: {
    $type: "devvit.runtime.Debug";
    encode(message: Debug, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Debug;
    fromJSON(object: any): Debug;
    toJSON(message: Debug): unknown;
    create(base?: DeepPartial<Debug>): Debug;
    fromPartial(object: DeepPartial<Debug>): Debug;
};

declare type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;

declare type DeepPartial_10<T> = T extends Builtin_10 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_10<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_10<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_10<T[K]>;
} : Partial<T>;

declare type DeepPartial_100<T> = T extends Builtin_100 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_100<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_100<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_100<T[K]>;
} : Partial<T>;

declare type DeepPartial_101<T> = T extends Builtin_101 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_101<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_101<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_101<T[K]>;
} : Partial<T>;

declare type DeepPartial_102<T> = T extends Builtin_102 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_102<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_102<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_102<T[K]>;
} : Partial<T>;

declare type DeepPartial_103<T> = T extends Builtin_103 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_103<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_103<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_103<T[K]>;
} : Partial<T>;

declare type DeepPartial_104<T> = T extends Builtin_104 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_104<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_104<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_104<T[K]>;
} : Partial<T>;

declare type DeepPartial_105<T> = T extends Builtin_105 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_105<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_105<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_105<T[K]>;
} : Partial<T>;

declare type DeepPartial_106<T> = T extends Builtin_106 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_106<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_106<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_106<T[K]>;
} : Partial<T>;

declare type DeepPartial_107<T> = T extends Builtin_107 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_107<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_107<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_107<T[K]>;
} : Partial<T>;

declare type DeepPartial_108<T> = T extends Builtin_108 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_108<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_108<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_108<T[K]>;
} : Partial<T>;

declare type DeepPartial_109<T> = T extends Builtin_109 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_109<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_109<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_109<T[K]>;
} : Partial<T>;

declare type DeepPartial_11<T> = T extends Builtin_11 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_11<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_11<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_11<T[K]>;
} : Partial<T>;

declare type DeepPartial_110<T> = T extends Builtin_110 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_110<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_110<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_110<T[K]>;
} : Partial<T>;

declare type DeepPartial_111<T> = T extends Builtin_111 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_111<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_111<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_111<T[K]>;
} : Partial<T>;

declare type DeepPartial_112<T> = T extends Builtin_112 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_112<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_112<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_112<T[K]>;
} : Partial<T>;

declare type DeepPartial_12<T> = T extends Builtin_12 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_12<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_12<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_12<T[K]>;
} : Partial<T>;

declare type DeepPartial_13<T> = T extends Builtin_13 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_13<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_13<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_13<T[K]>;
} : Partial<T>;

declare type DeepPartial_14<T> = T extends Builtin_14 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_14<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_14<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_14<T[K]>;
} : Partial<T>;

declare type DeepPartial_15<T> = T extends Builtin_15 ? T : T extends Array<infer U> ? Array<DeepPartial_15<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_15<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_15<T[K]>;
} : Partial<T>;

declare type DeepPartial_16<T> = T extends Builtin_16 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_16<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_16<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_16<T[K]>;
} : Partial<T>;

declare type DeepPartial_17<T> = T extends Builtin_17 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_17<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_17<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_17<T[K]>;
} : Partial<T>;

declare type DeepPartial_18<T> = T extends Builtin_18 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_18<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_18<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_18<T[K]>;
} : Partial<T>;

declare type DeepPartial_19<T> = T extends Builtin_19 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_19<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_19<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_19<T[K]>;
} : Partial<T>;

declare type DeepPartial_2<T> = T extends Builtin_2 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_2<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_2<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_2<T[K]>;
} : Partial<T>;

declare type DeepPartial_20<T> = T extends Builtin_20 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_20<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_20<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_20<T[K]>;
} : Partial<T>;

declare type DeepPartial_21<T> = T extends Builtin_21 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_21<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_21<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_21<T[K]>;
} : Partial<T>;

declare type DeepPartial_22<T> = T extends Builtin_22 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_22<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_22<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_22<T[K]>;
} : Partial<T>;

declare type DeepPartial_23<T> = T extends Builtin_23 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_23<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_23<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_23<T[K]>;
} : Partial<T>;

declare type DeepPartial_24<T> = T extends Builtin_24 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_24<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_24<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_24<T[K]>;
} : Partial<T>;

declare type DeepPartial_25<T> = T extends Builtin_25 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_25<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_25<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_25<T[K]>;
} : Partial<T>;

declare type DeepPartial_26<T> = T extends Builtin_26 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_26<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_26<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_26<T[K]>;
} : Partial<T>;

declare type DeepPartial_27<T> = T extends Builtin_27 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_27<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_27<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_27<T[K]>;
} : Partial<T>;

declare type DeepPartial_28<T> = T extends Builtin_28 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_28<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_28<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_28<T[K]>;
} : Partial<T>;

declare type DeepPartial_29<T> = T extends Builtin_29 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_29<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_29<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_29<T[K]>;
} : Partial<T>;

declare type DeepPartial_3<T> = T extends Builtin_3 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_3<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_3<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_3<T[K]>;
} : Partial<T>;

declare type DeepPartial_30<T> = T extends Builtin_30 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_30<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_30<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_30<T[K]>;
} : Partial<T>;

declare type DeepPartial_31<T> = T extends Builtin_31 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_31<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_31<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_31<T[K]>;
} : Partial<T>;

declare type DeepPartial_32<T> = T extends Builtin_32 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_32<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_32<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_32<T[K]>;
} : Partial<T>;

declare type DeepPartial_33<T> = T extends Builtin_33 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_33<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_33<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_33<T[K]>;
} : Partial<T>;

declare type DeepPartial_34<T> = T extends Builtin_34 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_34<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_34<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_34<T[K]>;
} : Partial<T>;

declare type DeepPartial_35<T> = T extends Builtin_35 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_35<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_35<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_35<T[K]>;
} : Partial<T>;

declare type DeepPartial_36<T> = T extends Builtin_36 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_36<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_36<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_36<T[K]>;
} : Partial<T>;

declare type DeepPartial_37<T> = T extends Builtin_37 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_37<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_37<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_37<T[K]>;
} : Partial<T>;

declare type DeepPartial_38<T> = T extends Builtin_38 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_38<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_38<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_38<T[K]>;
} : Partial<T>;

declare type DeepPartial_39<T> = T extends Builtin_39 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_39<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_39<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_39<T[K]>;
} : Partial<T>;

declare type DeepPartial_4<T> = T extends Builtin_4 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_4<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_4<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_4<T[K]>;
} : Partial<T>;

declare type DeepPartial_40<T> = T extends Builtin_40 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_40<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_40<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_40<T[K]>;
} : Partial<T>;

declare type DeepPartial_41<T> = T extends Builtin_41 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_41<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_41<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_41<T[K]>;
} : Partial<T>;

declare type DeepPartial_42<T> = T extends Builtin_42 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_42<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_42<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_42<T[K]>;
} : Partial<T>;

declare type DeepPartial_43<T> = T extends Builtin_43 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_43<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_43<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_43<T[K]>;
} : Partial<T>;

declare type DeepPartial_44<T> = T extends Builtin_44 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_44<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_44<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_44<T[K]>;
} : Partial<T>;

declare type DeepPartial_45<T> = T extends Builtin_45 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_45<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_45<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_45<T[K]>;
} : Partial<T>;

declare type DeepPartial_46<T> = T extends Builtin_46 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_46<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_46<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_46<T[K]>;
} : Partial<T>;

declare type DeepPartial_47<T> = T extends Builtin_47 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_47<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_47<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_47<T[K]>;
} : Partial<T>;

declare type DeepPartial_48<T> = T extends Builtin_48 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_48<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_48<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_48<T[K]>;
} : Partial<T>;

declare type DeepPartial_49<T> = T extends Builtin_49 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_49<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_49<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_49<T[K]>;
} : Partial<T>;

declare type DeepPartial_5<T> = T extends Builtin_5 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_5<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_5<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_5<T[K]>;
} : Partial<T>;

declare type DeepPartial_50<T> = T extends Builtin_50 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_50<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_50<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_50<T[K]>;
} : Partial<T>;

declare type DeepPartial_51<T> = T extends Builtin_51 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_51<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_51<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_51<T[K]>;
} : Partial<T>;

declare type DeepPartial_52<T> = T extends Builtin_52 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_52<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_52<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_52<T[K]>;
} : Partial<T>;

declare type DeepPartial_53<T> = T extends Builtin_53 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_53<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_53<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_53<T[K]>;
} : Partial<T>;

declare type DeepPartial_54<T> = T extends Builtin_54 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_54<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_54<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_54<T[K]>;
} : Partial<T>;

declare type DeepPartial_55<T> = T extends Builtin_55 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_55<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_55<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_55<T[K]>;
} : Partial<T>;

declare type DeepPartial_56<T> = T extends Builtin_56 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_56<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_56<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_56<T[K]>;
} : Partial<T>;

declare type DeepPartial_57<T> = T extends Builtin_57 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_57<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_57<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_57<T[K]>;
} : Partial<T>;

declare type DeepPartial_58<T> = T extends Builtin_58 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_58<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_58<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_58<T[K]>;
} : Partial<T>;

declare type DeepPartial_59<T> = T extends Builtin_59 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_59<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_59<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_59<T[K]>;
} : Partial<T>;

declare type DeepPartial_6<T> = T extends Builtin_6 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_6<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_6<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_6<T[K]>;
} : Partial<T>;

declare type DeepPartial_60<T> = T extends Builtin_60 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_60<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_60<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_60<T[K]>;
} : Partial<T>;

declare type DeepPartial_61<T> = T extends Builtin_61 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_61<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_61<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_61<T[K]>;
} : Partial<T>;

declare type DeepPartial_62<T> = T extends Builtin_62 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_62<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_62<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_62<T[K]>;
} : Partial<T>;

declare type DeepPartial_63<T> = T extends Builtin_63 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_63<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_63<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_63<T[K]>;
} : Partial<T>;

declare type DeepPartial_64<T> = T extends Builtin_64 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_64<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_64<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_64<T[K]>;
} : Partial<T>;

declare type DeepPartial_65<T> = T extends Builtin_65 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_65<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_65<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_65<T[K]>;
} : Partial<T>;

declare type DeepPartial_66<T> = T extends Builtin_66 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_66<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_66<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_66<T[K]>;
} : Partial<T>;

declare type DeepPartial_67<T> = T extends Builtin_67 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_67<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_67<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_67<T[K]>;
} : Partial<T>;

declare type DeepPartial_68<T> = T extends Builtin_68 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_68<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_68<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_68<T[K]>;
} : Partial<T>;

declare type DeepPartial_69<T> = T extends Builtin_69 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_69<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_69<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_69<T[K]>;
} : Partial<T>;

declare type DeepPartial_7<T> = T extends Builtin_7 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_7<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_7<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_7<T[K]>;
} : Partial<T>;

declare type DeepPartial_70<T> = T extends Builtin_70 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_70<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_70<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_70<T[K]>;
} : Partial<T>;

declare type DeepPartial_71<T> = T extends Builtin_71 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_71<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_71<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_71<T[K]>;
} : Partial<T>;

declare type DeepPartial_72<T> = T extends Builtin_72 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_72<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_72<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_72<T[K]>;
} : Partial<T>;

declare type DeepPartial_73<T> = T extends Builtin_73 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_73<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_73<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_73<T[K]>;
} : Partial<T>;

declare type DeepPartial_74<T> = T extends Builtin_74 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_74<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_74<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_74<T[K]>;
} : Partial<T>;

declare type DeepPartial_75<T> = T extends Builtin_75 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_75<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_75<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_75<T[K]>;
} : Partial<T>;

declare type DeepPartial_76<T> = T extends Builtin_76 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_76<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_76<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_76<T[K]>;
} : Partial<T>;

declare type DeepPartial_77<T> = T extends Builtin_77 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_77<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_77<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_77<T[K]>;
} : Partial<T>;

declare type DeepPartial_78<T> = T extends Builtin_78 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_78<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_78<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_78<T[K]>;
} : Partial<T>;

declare type DeepPartial_79<T> = T extends Builtin_79 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_79<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_79<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_79<T[K]>;
} : Partial<T>;

declare type DeepPartial_8<T> = T extends Builtin_8 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_8<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_8<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_8<T[K]>;
} : Partial<T>;

declare type DeepPartial_80<T> = T extends Builtin_80 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_80<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_80<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_80<T[K]>;
} : Partial<T>;

declare type DeepPartial_81<T> = T extends Builtin_81 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_81<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_81<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_81<T[K]>;
} : Partial<T>;

declare type DeepPartial_82<T> = T extends Builtin_82 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_82<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_82<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_82<T[K]>;
} : Partial<T>;

declare type DeepPartial_83<T> = T extends Builtin_83 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_83<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_83<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_83<T[K]>;
} : Partial<T>;

declare type DeepPartial_84<T> = T extends Builtin_84 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_84<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_84<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_84<T[K]>;
} : Partial<T>;

declare type DeepPartial_85<T> = T extends Builtin_85 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_85<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_85<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_85<T[K]>;
} : Partial<T>;

declare type DeepPartial_86<T> = T extends Builtin_86 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_86<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_86<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_86<T[K]>;
} : Partial<T>;

declare type DeepPartial_87<T> = T extends Builtin_87 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_87<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_87<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_87<T[K]>;
} : Partial<T>;

declare type DeepPartial_88<T> = T extends Builtin_88 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_88<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_88<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_88<T[K]>;
} : Partial<T>;

declare type DeepPartial_89<T> = T extends Builtin_89 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_89<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_89<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_89<T[K]>;
} : Partial<T>;

declare type DeepPartial_9<T> = T extends Builtin_9 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_9<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_9<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_9<T[K]>;
} : Partial<T>;

declare type DeepPartial_90<T> = T extends Builtin_90 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_90<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_90<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_90<T[K]>;
} : Partial<T>;

declare type DeepPartial_91<T> = T extends Builtin_91 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_91<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_91<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_91<T[K]>;
} : Partial<T>;

declare type DeepPartial_92<T> = T extends Builtin_92 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_92<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_92<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_92<T[K]>;
} : Partial<T>;

declare type DeepPartial_93<T> = T extends Builtin_93 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_93<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_93<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_93<T[K]>;
} : Partial<T>;

declare type DeepPartial_94<T> = T extends Builtin_94 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_94<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_94<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_94<T[K]>;
} : Partial<T>;

declare type DeepPartial_95<T> = T extends Builtin_95 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_95<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_95<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_95<T[K]>;
} : Partial<T>;

declare type DeepPartial_96<T> = T extends Builtin_96 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_96<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_96<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_96<T[K]>;
} : Partial<T>;

declare type DeepPartial_97<T> = T extends Builtin_97 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_97<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_97<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_97<T[K]>;
} : Partial<T>;

declare type DeepPartial_98<T> = T extends Builtin_98 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_98<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_98<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_98<T[K]>;
} : Partial<T>;

declare type DeepPartial_99<T> = T extends Builtin_99 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial_99<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial_99<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial_99<T[K]>;
} : Partial<T>;

declare const Definition: {
    toSerializable(definition: Readonly<Definition> | Readonly<SerializableServiceDefinition>): Readonly<SerializableServiceDefinition>;
    /**
     * To maintain our backwards/forwards compatibility, this should always return the subset of the service
     * definition that exists in the type registry, and not e.g. throw errors if the type registry is missing.
     */
    fromSerializable(def: Readonly<SerializableServiceDefinition>): Definition;
};

declare type Definition = {
    /**
     * The period-delimited Protobuf package name + Protobuf service name. Eg,
     * "devvit.plugin.logger.Logger" which corresponds to the "Logger" service in
     * the "devvit.plugin.logger" package.
     */
    fullName: string;
    /**
     * The type of type provided. = Eg, "devvit.plugin.logger.Logger". This
     * name is unique per `Definition`. Eg, there is only one
     * "devvit.plugin.gl.GLRenderer", not one for WebGL v1 and one for v2. Two (or
     * more) implementations may exist however.
     *
     * The key is the method.name in **camelCase, not PascalCase**. Eg, "log" or
     * loadActor.
     */
    methods: {
        [methodName: string]: MethodDefinition;
    };
    /**
     * The Protobuf service name. This is the last period-delimited field of
     * `fullName`. Eg, "Logger".
     */
    name: string;
};

declare interface DeleteCollectionRequest {
    /** The id of the collection. */
    collectionId?: string | undefined;
}

declare const DeleteCollectionRequest: {
    $type: "devvit.plugin.redditapi.postcollections.DeleteCollectionRequest";
    encode(message: DeleteCollectionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteCollectionRequest;
    fromJSON(object: any): DeleteCollectionRequest;
    toJSON(message: DeleteCollectionRequest): unknown;
    create(base?: DeepPartial_81<DeleteCollectionRequest>): DeleteCollectionRequest;
    fromPartial(object: DeepPartial_81<DeleteCollectionRequest>): DeleteCollectionRequest;
};

declare interface DeleteFlairRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** a user by name */
    name: string;
}

declare const DeleteFlairRequest: {
    $type: "devvit.plugin.redditapi.flair.DeleteFlairRequest";
    encode(message: DeleteFlairRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteFlairRequest;
    fromJSON(object: any): DeleteFlairRequest;
    toJSON(message: DeleteFlairRequest): unknown;
    create(base?: DeepPartial_56<DeleteFlairRequest>): DeleteFlairRequest;
    fromPartial(object: DeepPartial_56<DeleteFlairRequest>): DeleteFlairRequest;
};

declare interface DeleteFlairTemplateRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    flairTemplateId: string;
}

declare const DeleteFlairTemplateRequest: {
    $type: "devvit.plugin.redditapi.flair.DeleteFlairTemplateRequest";
    encode(message: DeleteFlairTemplateRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteFlairTemplateRequest;
    fromJSON(object: any): DeleteFlairTemplateRequest;
    toJSON(message: DeleteFlairTemplateRequest): unknown;
    create(base?: DeepPartial_56<DeleteFlairTemplateRequest>): DeleteFlairTemplateRequest;
    fromPartial(object: DeepPartial_56<DeleteFlairTemplateRequest>): DeleteFlairTemplateRequest;
};

export declare type DeleteNotesOptions = Prettify<DeleteNotesRequest>;

/** Requests */
declare interface DeleteNotesRequest {
    /** subreddit name without the r/ */
    subreddit: string;
    /** a unique ID for the note to be deleted (should have a ModNote_ prefix) */
    noteId: string;
    /** account username */
    user: string;
}

declare const DeleteNotesRequest: {
    $type: "devvit.plugin.redditapi.modnote.DeleteNotesRequest";
    encode(message: DeleteNotesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteNotesRequest;
    fromJSON(object: any): DeleteNotesRequest;
    toJSON(message: DeleteNotesRequest): unknown;
    create(base?: DeepPartial_3<DeleteNotesRequest>): DeleteNotesRequest;
    fromPartial(object: DeepPartial_3<DeleteNotesRequest>): DeleteNotesRequest;
};

declare interface DeleteNotesResponse {
    deleted?: boolean | undefined;
}

declare const DeleteNotesResponse: {
    $type: "devvit.plugin.redditapi.modnote.DeleteNotesResponse";
    encode(message: DeleteNotesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteNotesResponse;
    fromJSON(object: any): DeleteNotesResponse;
    toJSON(message: DeleteNotesResponse): unknown;
    create(base?: DeepPartial_3<DeleteNotesResponse>): DeleteNotesResponse;
    fromPartial(object: DeepPartial_3<DeleteNotesResponse>): DeleteNotesResponse;
};

declare interface DeleteSrImgRequest {
    /** the name of the subreddit */
    subreddit: string;
    /** a valid subreddit image name */
    imgName: string;
}

declare const DeleteSrImgRequest: {
    $type: "devvit.plugin.redditapi.subreddits.DeleteSrImgRequest";
    encode(message: DeleteSrImgRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSrImgRequest;
    fromJSON(object: any): DeleteSrImgRequest;
    toJSON(message: DeleteSrImgRequest): unknown;
    create(base?: DeepPartial_11<DeleteSrImgRequest>): DeleteSrImgRequest;
    fromPartial(object: DeepPartial_11<DeleteSrImgRequest>): DeleteSrImgRequest;
};

declare interface DeleteWidgetRequest {
    id: string;
    subreddit: string;
}

declare const DeleteWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.DeleteWidgetRequest";
    encode(message: DeleteWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteWidgetRequest;
    fromJSON(object: any): DeleteWidgetRequest;
    toJSON(message: DeleteWidgetRequest): unknown;
    create(base?: DeepPartial_4<DeleteWidgetRequest>): DeleteWidgetRequest;
    fromPartial(object: DeepPartial_4<DeleteWidgetRequest>): DeleteWidgetRequest;
};

declare enum DeletionReason {
    UNSPECIFIED_DELETION_REASON = 0,
    SPAM = 1,
    LEGAL = 2,
    OTHER = 3,
    UNKNOWN = 4,
    UNRECOGNIZED = -1
}

declare function deletionReasonFromJSON(object: any): DeletionReason;

declare function deletionReasonToJSON(object: DeletionReason): number;

/**
 * Delivery locations for events from snooron-worker
 * Nested in a msg since proto doesn't like repeated enums
 */
declare interface DeliverTo {
    to: DeliveryLocation[];
}

declare const DeliverTo: {
    $type: "devvit.options.DeliverTo";
    encode(message: DeliverTo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeliverTo;
    fromJSON(object: any): DeliverTo;
    toJSON(message: DeliverTo): unknown;
    create(base?: DeepPartial_105<DeliverTo>): DeliverTo;
    fromPartial(object: DeepPartial_105<DeliverTo>): DeliverTo;
};

declare enum DeliveryLocation {
    UNKNOWN_DELIVERY_LOCATION = 0,
    GATEWAY = 1,
    FIREHOSE = 2,
    UNRECOGNIZED = -1
}

declare function deliveryLocationFromJSON(object: any): DeliveryLocation;

declare function deliveryLocationToJSON(object: DeliveryLocation): number;

/** Dependencies offered and required by a Bundle or plugin. See Config.export(). */
declare interface DependencySpec {
    actor?: ActorSpec | undefined;
    /**
     * Actor hostname. This may be a plugin or a user actor. Eg,
     * "fd23937c-2891-44ed-a66c-5277265cfd54.pixelary-game.main.devvit-gateway.reddit.com":
     *
     * | Prisma Installation.id               | devvit.yaml app name / slug | ActorSpec.name |                           |
     * | ------------------------------------ | --------------------------- | -------------- | ------------------------- |
     * | fd23937c-2891-44ed-a66c-5277265cfd54 | pixelary-game               | main           | devvit-gateway.reddit.com |
     *
     * Which corresponds to the V8 LinkedBundle at
     * https://devvit-gateway.reddit.com/bundles/fd23937c-2891-44ed-a66c-5277265cfd54/main/0.0.8-359.
     *
     * Multi-actor apps are deprecated so app name is usually what's most
     * important. Plugins are simpler. Eg, "http.plugins.local".
     */
    hostname: string;
    provides: PackageSpec[];
    uses: PackageQuery[];
}

declare const DependencySpec: {
    $type: "devvit.runtime.DependencySpec";
    encode(message: DependencySpec, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DependencySpec;
    fromJSON(object: any): DependencySpec;
    toJSON(message: DependencySpec): unknown;
    create(base?: DeepPartial_14<DependencySpec>): DependencySpec;
    fromPartial(object: DeepPartial_14<DependencySpec>): DependencySpec;
};

/** Describes a message type. */
declare interface DescriptorProto {
    name?: string | undefined;
    field: FieldDescriptorProto[];
    extension: FieldDescriptorProto[];
    nestedType: DescriptorProto[];
    enumType: EnumDescriptorProto[];
    extensionRange: DescriptorProto_ExtensionRange[];
    oneofDecl: OneofDescriptorProto[];
    options?: MessageOptions | undefined;
    reservedRange: DescriptorProto_ReservedRange[];
    /**
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     */
    reservedName: string[];
}

declare const DescriptorProto: {
    $type: "google.protobuf.DescriptorProto";
    encode(message: DescriptorProto, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DescriptorProto;
    fromJSON(object: any): DescriptorProto;
    toJSON(message: DescriptorProto): unknown;
    create(base?: DeepPartial_104<DescriptorProto>): DescriptorProto;
    fromPartial(object: DeepPartial_104<DescriptorProto>): DescriptorProto;
};

declare interface DescriptorProto_ExtensionRange {
    /** Inclusive. */
    start?: number | undefined;
    /** Exclusive. */
    end?: number | undefined;
    options?: ExtensionRangeOptions | undefined;
}

declare const DescriptorProto_ExtensionRange: {
    $type: "google.protobuf.DescriptorProto.ExtensionRange";
    encode(message: DescriptorProto_ExtensionRange, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DescriptorProto_ExtensionRange;
    fromJSON(object: any): DescriptorProto_ExtensionRange;
    toJSON(message: DescriptorProto_ExtensionRange): unknown;
    create(base?: DeepPartial_104<DescriptorProto_ExtensionRange>): DescriptorProto_ExtensionRange;
    fromPartial(object: DeepPartial_104<DescriptorProto_ExtensionRange>): DescriptorProto_ExtensionRange;
};

/**
 * Range of reserved tag numbers. Reserved tag numbers may not be used by
 * fields or extension ranges in the same message. Reserved ranges may
 * not overlap.
 */
declare interface DescriptorProto_ReservedRange {
    /** Inclusive. */
    start?: number | undefined;
    /** Exclusive. */
    end?: number | undefined;
}

declare const DescriptorProto_ReservedRange: {
    $type: "google.protobuf.DescriptorProto.ReservedRange";
    encode(message: DescriptorProto_ReservedRange, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DescriptorProto_ReservedRange;
    fromJSON(object: any): DescriptorProto_ReservedRange;
    toJSON(message: DescriptorProto_ReservedRange): unknown;
    create(base?: DeepPartial_104<DescriptorProto_ReservedRange>): DescriptorProto_ReservedRange;
    fromPartial(object: DeepPartial_104<DescriptorProto_ReservedRange>): DescriptorProto_ReservedRange;
};

export declare class Devvit extends Actor {
    #private;
    static debug: DevvitDebug;
    /**
     * To use certain APIs and features of Devvit, you must enable them using this function.
     *
     * @param config - The configuration object.
     * @param config.http - Enables the HTTP API.
     * @param config.redditAPI - Enables the Reddit API.
     * @param config.kvStore - Enables the Key Value Storage API.
     * @example
     * ```ts
     * Devvit.configure({
     *   http: true,
     *   redditAPI: true,
     *   kvStore: true,
     *   media: true
     * });
     * ```
     */
    static configure(config: Configuration): void;
    /**
     * Add a menu item to the Reddit UI.
     * @param menuItem - The menu item to add.
     * @param menuItem.label - The label of the menu item.
     * @example
     * ```ts
     * Devvit.addMenuItem({
     *   label: 'My Menu Item',
     *   location: 'subreddit',
     *   onPress: (event, context) => {
     *     const location = event.location;
     *     const targetId = event.targetId;
     *     context.ui.showToast(`You clicked on ${location} ${targetId}`);
     *   }
     * });
     * ```
     */
    static addMenuItem(menuItem: MenuItem): void;
    /**
     * Add a custom post type for your app.
     * @param customPostType - The custom post type to add.
     * @param customPostType.name - The name of the custom post type.
     * @param customPostType.description - An optional description.
     * @param customPostType.height - An optional parameter to set post height, defaults to 'regular'.
     * @param customPostType.render - A function or `Devvit.CustomPostComponent` that returns the UI for the custom post.
     * @example
     * ```ts
     * Devvit.addCustomPostType({
     *   name: 'Counter',
     *   description: 'A simple click counter post.',
     *   render: (context) => {
     *     const [counter, setCounter] = context.useState();
     *
     *     return (
     *       <vstack>
     *         <text>{counter}</text>
     *         <button onPress={() => setCounter(counter => counter + 1)}>Click me!</button>
     *       </vstack>
     *     );
     *   }
     * });
     * ```
     */
    static addCustomPostType(customPostType: CustomPostType): void;
    /**
     * Create a form that can be opened from menu items and custom posts.
     * @param form - The form or a function that returns the form.
     * @param onSubmit - The function to call when the form is submitted.
     * @returns A unique key for the form that can used with `ui.showForm`.
     */
    static createForm(form: Form | FormFunction, onSubmit: FormOnSubmitEventHandler): FormKey;
    /**
     * Add a scheduled job type for your app. This will allow you to schedule jobs using the `scheduler` API.
     * @param job - The scheduled job type to add.
     * @param job.name - The name of the scheduled job type.
     * @param job.onRun - The function to call when the scheduled job is run.
     * @example
     * ```ts
     * Devvit.addSchedulerJob({
     *   name: 'checkNewPosts',
     *   onRun: async (event, context) => {
     *     const newPosts = await context.reddit.getNewPosts({ limit: 5 }).all();
     *     for (const post of newPosts) {
     *       if (post.title.includes('bad word')) {
     *         await post.remove();
     *       }
     *     }
     *   }
     * });
     *
     * Devvit.addMenuItem({
     *   label: 'Check for new posts',
     *   location: 'location',
     *   onPress: (event, context) => {
     *     const { scheduler } = context;
     *     const = await scheduler.runJob({
     *       name: 'checkNewPosts',
     *       when: new Date(Date.now() + 5000) // in 5 seconds
     *     });
     *   }
     * });
     * ```
     */
    static addSchedulerJob(job: ScheduledJobType): void;
    /**
     * Add settings that can be configured to customize the behavior of your app. There are two levels of settings: App settings (scope: 'app') and
     * install settings (scope: 'installation' or unspecified scope). Install settings are meant to be configured by the user that installs your app.
     * This is a good place to add anything that a user might want to change to personalize the app (e.g. the default city to show the weather for or a
     * specific sport team that a subreddit follows). Note that these are good for subreddit level customization but not necessarily good for things
     * that might be different for two users in a subreddit (e.g. setting the default city to show the weather for is only useful at a sub level if
     * the sub is for a specific city or region). Install settings can be viewed and configured here: https://developers.reddit.com/r/subreddit-name/apps/app-name.
     * App settings can be accessed and consumed by all installations of the app. This is mainly useful for developer secrets/API keys that your
     * app needs to function. They can only be changed/viewed by you via the CLI (devvit settings set and devvit settings list). This ensures secrets
     * are persisted in an encrypted store and don't get committed in the source code. You should never paste your actual key into any fields passed into
     * Devvit.addSettings - this is merely where you state what your API key's name and description are. You will be able to set the actual value of the key via CLI.
     * Note: setting names must be unique across all settings.
     * @param fields - Fields for the app and installation settings.
     * @example
     * ```ts
     * Devvit.addSettings([
     *   {
     *     type: 'string',
     *     name: 'weather-api-key',
     *     label: 'My weather.com API key',
     *     scope: SettingScope.App,
     *     isSecret: true
     *   },
     *   {
     *     type: 'string',
     *     name: 'Default City',
     *     label: 'Default city to show the weather for by default',
     *     scope: SettingScope.Installation,
     *     onValidate: ({ value }) => {
     *       if (isValidCity(value)) {
     *         return 'You must ender a valid city: ${validCities.join(", ")}';
     *       }
     *     }
     *   },
     *   {
     *     type: 'number',
     *     name: 'Default Forecast Window (in days)',
     *     label: 'The number of days to show for forecast for by default',
     *     scope: SettingScope.Installation,
     *     onValidate: ({ value }) => {
     *       if (value < 10 || value < 1) {
     *         return 'Forecast window must be from 1 to 10 days';
     *       }
     *     }
     *   },
     * ]);
     * ```
     */
    static addSettings(fields: SettingsFormField[]): void;
    /**
     * Add a trigger handler that will be invoked when the given event
     * occurs in a subreddit where the app is installed.
     *
     * @param triggerDefinition - The trigger definition.
     * @param triggerDefinition.event - The event to listen for.
     * @param triggerDefinition.events - The events to listen for.
     * @param triggerDefinition.onEvent - The function to call when the event happens.
     * @example
     * ```ts
     * Devvit.addTrigger({
     *   event: 'PostSubmit',
     *   async onEvent(event, context) {
     *     console.log("a new post was created!")
     *   }
     * });
     *
     * Devvit.addTrigger({
     *   events: ['PostSubmit', 'PostReport'],
     *   async onEvent(event, context){
     *     if (event.type === 'PostSubmit') {
     *       console.log("a new post was created!")
     *     } else if (event.type === 'PostReport') {
     *       console.log("a post was reported!")
     *     }
     *   }
     * });
     * ```
     */
    static addTrigger<T extends keyof TriggerEventType>(definition: {
        event: T;
        onEvent: TriggerOnEventHandler<TriggerEventType[T]>;
    }): typeof Devvit;
    static addTrigger<Event extends TriggerEvent>(triggerDefinition: MultiTriggerDefinition<Event>): typeof Devvit;
}

export declare namespace Devvit {
    export type Fragment = JSX.Fragment;
    export type ElementChildren = JSX.Element | JSX.Children | undefined;
    export type StringChild = Fragment | string | number;
    export type StringChildren = StringChild | (StringChild | StringChild[])[] | undefined;
    export function createElement(type: Blocks.IntrinsicElementsType, props: {} | undefined, ...children: JSX.Children[]): BlockElement;
    /** The current app context of the event or render. */
    export type Context = ContextAPIClients & BaseContext;
    export type BlockComponentProps<P = {}> = P & {
        children?: JSX.Children;
    };
    export type BlockComponent<P = {}> = (props: BlockComponentProps<P>, context: Context) => JSX.Element;
    export type CustomPostComponent = (context: Context) => JSX.Element;
    export namespace Blocks {
        export interface IntrinsicElements {
            blocks: Devvit.Blocks.RootProps;
            hstack: Devvit.Blocks.StackProps;
            vstack: Devvit.Blocks.StackProps;
            zstack: Devvit.Blocks.StackProps;
            text: Devvit.Blocks.TextProps;
            button: Devvit.Blocks.ButtonProps;
            image: Devvit.Blocks.ImageProps;
            spacer: Devvit.Blocks.SpacerProps;
            icon: Devvit.Blocks.IconProps;
            avatar: Devvit.Blocks.AvatarProps;
            fullsnoo: Devvit.Blocks.FullSnooProps;
            animation: Devvit.Blocks.AnimationProps;
            webview: Devvit.Blocks.WebViewProps;
        }
        export type IntrinsicElementsType = keyof IntrinsicElements;
        export type SizePixels = `${number}px`;
        export type SizePercent = `${number}%`;
        export type SizeString = SizePixels | SizePercent | number;
        export type Alignment = `${VerticalAlignment}` | `${HorizontalAlignment}` | `${VerticalAlignment} ${HorizontalAlignment}` | `${HorizontalAlignment} ${VerticalAlignment}`;
        export type AnimationDirection = 'forward' | 'backward';
        export type AnimationLoop = 'repeat' | 'bounce';
        export type AnimationType = 'lottie';
        export type AvatarBackground = 'light' | 'dark';
        export type AvatarFacing = 'left' | 'right';
        export type AvatarSize = 'xxsmall' | 'xsmall' | 'small' | 'medium' | 'large' | 'xlarge' | 'xxlarge' | 'xxxlarge';
        export type ButtonAppearance = 'secondary' | 'primary' | 'plain' | 'bordered' | 'media' | 'destructive' | 'caution' | 'success';
        /**
         * Affects the button height.
         * small = 32px;
         * medium = 40px;
         * large = 48px;
         */
        export type ButtonSize = 'small' | 'medium' | 'large';
        export type ColorString = string;
        /**
         * thin = 1px;
         * thick = 2px;
         */
        export type ContainerBorderWidth = Thickness;
        /**
         * small = 8px;
         * medium = 16px;
         * large = 24px;
         */
        export type ContainerCornerRadius = 'none' | 'small' | 'medium' | 'large' | 'full';
        /**
         * small = 8px;
         * medium = 16px;
         * large = 32px;
         */
        export type ContainerGap = 'none' | 'small' | 'medium' | 'large';
        /**
         * xsmall = 4px;
         * small = 8px;
         * medium = 16px;
         * large = 32px;
         */
        export type ContainerPadding = 'none' | 'xsmall' | 'small' | 'medium' | 'large';
        export type FullSnooSize = 'xsmall' | 'small' | 'medium' | 'large' | 'xlarge' | 'xxlarge';
        export type HorizontalAlignment = 'start' | 'center' | 'end';
        /**
         * xsmall = 12px;
         * small = 16px;
         * medium = 20px;
         * large = 24px;
         */
        export type IconSize = 'xsmall' | 'small' | 'medium' | 'large';
        export type ImageResizeMode = 'none' | 'fit' | 'fill' | 'cover' | 'scale-down';
        /**
         * xsmall = 4px;
         * small = 8px;
         * medium = 16px;
         * large = 32px;
         */
        export type SpacerSize = 'xsmall' | 'small' | 'medium' | 'large';
        export type SpacerShape = 'invisible' | 'thin' | 'square';
        /**
         * thin = 1px;
         * thick = 2px;
         */
        export type TextOutline = Thickness;
        /**
         * xsmall = 10px;
         * small = 12px;
         * medium = 14px;
         * large = 16px;
         * xlarge = 18px;
         * xxlarge = 24px;
         */
        export type TextSize = 'xsmall' | 'small' | 'medium' | 'large' | 'xlarge' | 'xxlarge';
        export type TextStyle = 'body' | 'metadata' | 'heading';
        export type TextWeight = 'regular' | 'bold';
        export type TextOverflow = 'clip' | 'ellipsis';
        export type Thickness = 'none' | 'thin' | 'thick';
        export type VerticalAlignment = 'top' | 'middle' | 'bottom';
        export type RootHeight = 'regular' | 'tall';
        export type BaseProps = {
            width?: SizeString;
            height?: SizeString;
            minWidth?: SizeString;
            minHeight?: SizeString;
            maxWidth?: SizeString;
            maxHeight?: SizeString;
            grow?: boolean;
            /**
             * This optional field provides some efficiencies around re-ordering elements in a list.  Rather
             * Than re-rendering the entire list, the client can use the key to determine if the element has
             * changed.  In the example below, if a and b were swapped, the client would know to reuse the
             * existing elements from b, rather than re-creating an expensive tree of elements.
             *
             * Unlike id, key is local to the parent element.  This means that the same key can be used in different
             * parts of the tree without conflict.
             *
             *     <hstack>
             *         <text key="a">hi world</text>
             *         <hstack key="b">...deeply nested content...</hstack>
             *     </hstack>
             */
            key?: string;
            /**
             * This optional field provides a unique identifier for the element.  This is useful for ensuring
             * re-use of elements across renders.  See the `key` field for more information.  Unlike key, id
             * is global.  You cannot have two elements with the same id in the same tree.
             */
            id?: string;
        };
        export type OnPressEvent = {
            state?: Data;
        };
        export type OnMessageEvent = {
            type: string;
            data?: Data;
        };
        export type OnPressEventHandler = (event: OnPressEvent) => void | Promise<void>;
        export type OnWebViewEventHandler = (event: OnMessageEvent) => void | Promise<void>;
        export type Actionable = {
            onPress?: OnPressEventHandler | undefined;
        };
        export type WebViewActionable = {
            onMessage?: OnWebViewEventHandler | undefined;
        };
        export type ActionHandlers = keyof (Actionable & WebViewActionable);
        export type HasElementChildren = {
            children?: Devvit.ElementChildren;
        };
        export type HasStringChildren = {
            children?: Devvit.StringChildren;
        };
        export type RootProps = HasElementChildren & {
            height?: Devvit.Blocks.RootHeight | undefined;
        };
        export type StackProps = BaseProps & HasElementChildren & Actionable & {
            reverse?: boolean | undefined;
            alignment?: Alignment;
            padding?: ContainerPadding | undefined;
            gap?: ContainerGap | undefined;
            border?: ContainerBorderWidth | undefined;
            borderColor?: ColorString | undefined;
            lightBorderColor?: ColorString | undefined;
            darkBorderColor?: ColorString | undefined;
            cornerRadius?: ContainerCornerRadius | undefined;
            backgroundColor?: ColorString | undefined;
            lightBackgroundColor?: ColorString | undefined;
            darkBackgroundColor?: ColorString | undefined;
        };
        export type TextProps = BaseProps & HasStringChildren & Actionable & {
            size?: TextSize | undefined;
            weight?: TextWeight | undefined;
            color?: ColorString | undefined;
            lightColor?: ColorString | undefined;
            darkColor?: ColorString | undefined;
            alignment?: Alignment | undefined;
            outline?: TextOutline | undefined;
            style?: TextStyle | undefined;
            selectable?: boolean | undefined;
            wrap?: boolean | undefined;
            overflow?: TextOverflow | undefined;
        };
        export type ButtonProps = BaseProps & HasStringChildren & Actionable & {
            icon?: IconName | undefined;
            size?: ButtonSize | undefined;
            appearance?: ButtonAppearance | undefined;
            textColor?: ColorString | undefined;
            lightTextColor?: ColorString | undefined;
            darkTextColor?: ColorString | undefined;
            disabled?: boolean | undefined;
        };
        export type ImageProps = BaseProps & Actionable & {
            url: string;
            imageWidth: SizePixels | number;
            imageHeight: SizePixels | number;
            description?: string | undefined;
            resizeMode?: ImageResizeMode | undefined;
        };
        export type SpacerProps = BaseProps & {
            size?: SpacerSize | undefined;
            shape?: SpacerShape | undefined;
        };
        export type IconProps = BaseProps & HasStringChildren & Actionable & {
            name: IconName;
            color?: ColorString | undefined;
            lightColor?: ColorString | undefined;
            darkColor?: ColorString | undefined;
            size?: IconSize | undefined;
        };
        export type AvatarProps = BaseProps & Actionable & {
            thingId: string;
            facing?: AvatarFacing | undefined;
            size?: AvatarSize | undefined;
            background?: AvatarBackground | undefined;
        };
        export type FullSnooProps = BaseProps & Actionable & {
            userId: string;
            facing?: AvatarFacing | undefined;
            size?: FullSnooSize | undefined;
        };
        export type AnimationProps = BaseProps & Actionable & {
            url: string;
            imageWidth: SizePixels | number;
            imageHeight: SizePixels | number;
            type?: AnimationType | undefined;
            loop?: boolean | undefined;
            loopMode?: AnimationLoop | undefined;
            autoplay?: boolean | undefined;
            speed?: number | undefined;
            direction?: AnimationDirection | undefined;
        };
        export type WebViewProps = BaseProps & WebViewActionable & {
            url: string;
            state?: Data;
        };
    }
}

/**
 * Home for debug flags, settings, and other information. Any type removals
 * may cause type errors but not runtime errors.
 *
 * **Favor ContextDebugInfo since request-based state is preferred.**
 */
declare type DevvitDebug = {
    /**
     * Should debug block rendering in console.log according to the reified JSX/XML output. Example:
     *
     *     <hstack><text>hi world</text></hstack>
     *
     */
    emitSnapshots?: boolean | undefined;
    /**
     * Should console.log the state of the app after every event.
     *
     */
    emitState?: boolean | undefined;
};

declare interface DevvitProfiler {
    GetProfile(request: GetProfileRequest, metadata?: Metadata): Promise<GetProfileResponse>;
}

declare class DevvitProfilerClientImpl implements DevvitProfiler {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_32, opts?: {
        service?: string;
    });
    GetProfile(request: GetProfileRequest, metadata?: Metadata): Promise<GetProfileResponse>;
}

declare type DevvitProfilerDefinition = typeof DevvitProfilerDefinition;

declare const DevvitProfilerDefinition: {
    readonly name: "DevvitProfiler";
    readonly fullName: "devvit.debug.v1alpha.DevvitProfiler";
    readonly methods: {
        readonly getProfile: {
            readonly name: "GetProfile";
            readonly requestType: {
                $type: "devvit.debug.v1alpha.GetProfileRequest";
                encode(message: GetProfileRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): GetProfileRequest;
                fromJSON(object: any): GetProfileRequest;
                toJSON(message: GetProfileRequest): unknown;
                create(base?: DeepPartial_54<GetProfileRequest>): GetProfileRequest;
                fromPartial(object: DeepPartial_54<GetProfileRequest>): GetProfileRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.debug.v1alpha.GetProfileResponse";
                encode(message: GetProfileResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): GetProfileResponse;
                fromJSON(object: any): GetProfileResponse;
                toJSON(message: GetProfileResponse): unknown;
                create(base?: DeepPartial_54<GetProfileResponse>): GetProfileResponse;
                fromPartial(object: DeepPartial_54<GetProfileResponse>): GetProfileResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const DevvitProfilerServiceName = "devvit.debug.v1alpha.DevvitProfiler";

/**
 * The subreddit manifest. Nothing to do with gRPC-web or any other kind of
 * metadata.
 * base64-encoded in Subreddit.devPlatformMetadata
 * ([ex](https://gql.reddit.com/?queryGz=eJw1y7EKg0AMANBfKTfpct07dnOoCH5AiU2kES8JXizIcf9eF5e3vZL3aSNE9k5mfR49JGrk5BGyk31JlPFt%2BxTaEmNUuY1XKEi%2FYQWfdUsvckBwaBIn8sPODmYrf8BZ5b5kldDWWv89vSpI&operationName=)).
 */
declare interface DevvitSubredditMetadata {
    /** List of all installed apps for the loaded Subreddit */
    installedRemoteApps: LinkedBundle[];
    contextActions: SubredditContextActions[];
    errors: ErrorMessage[];
    installedAppsInfo: DevvitSubredditMetadata_AppInfo[];
}

declare const DevvitSubredditMetadata: {
    $type: "devvit.gql.DevvitSubredditMetadata";
    encode(message: DevvitSubredditMetadata, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DevvitSubredditMetadata;
    fromJSON(object: any): DevvitSubredditMetadata;
    toJSON(message: DevvitSubredditMetadata): unknown;
    create(base?: DeepPartial_94<DevvitSubredditMetadata>): DevvitSubredditMetadata;
    fromPartial(object: DeepPartial_94<DevvitSubredditMetadata>): DevvitSubredditMetadata;
};

declare interface DevvitSubredditMetadata_AppInfo {
    /** Unique identifier */
    slug: string;
    /** Display name */
    name: string;
}

declare const DevvitSubredditMetadata_AppInfo: {
    $type: "devvit.gql.DevvitSubredditMetadata.AppInfo";
    encode(message: DevvitSubredditMetadata_AppInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DevvitSubredditMetadata_AppInfo;
    fromJSON(object: any): DevvitSubredditMetadata_AppInfo;
    toJSON(message: DevvitSubredditMetadata_AppInfo): unknown;
    create(base?: DeepPartial_94<DevvitSubredditMetadata_AppInfo>): DevvitSubredditMetadata_AppInfo;
    fromPartial(object: DeepPartial_94<DevvitSubredditMetadata_AppInfo>): DevvitSubredditMetadata_AppInfo;
};

/**
 * Dimensions describe the layout characteristics of a custom post within Devvit.
 * They are used to allow Devvitors to create responsive experiences within their post. For
 * example, they can use this API to conditionally render an element on small viewports only.
 *
 * @deprecated Use devvit.ui.events.v1alpha.UIDimensions instead.
 *
 * @deprecated
 */
declare interface Dimensions {
    /** Unitless pixels describing the content box height for the custom post */
    height: number;
    /** Unitless pixels describing the content box width for the custom post */
    width: number;
    /** Describes the device pixel ratio for a device. */
    scale: number;
}

declare const Dimensions: {
    $type: "devvit.reddit.custom_post.v1alpha.Dimensions";
    encode(message: Dimensions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Dimensions;
    fromJSON(object: any): Dimensions;
    toJSON(message: Dimensions): unknown;
    create(base?: DeepPartial_43<Dimensions>): Dimensions;
    fromPartial(object: DeepPartial_43<Dimensions>): Dimensions;
};

export declare type Dispatch<A> = (value: A) => void;

declare interface DistinguishRequest {
    /** one of (yes, no, admin, special) */
    how: string;
    /** thing id (e.g t1_15bfi0) */
    id: string;
    /** stick the distinguished comment to the top of all comments threads */
    sticky: boolean;
}

declare const DistinguishRequest: {
    $type: "devvit.plugin.redditapi.moderation.DistinguishRequest";
    encode(message: DistinguishRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DistinguishRequest;
    fromJSON(object: any): DistinguishRequest;
    toJSON(message: DistinguishRequest): unknown;
    create(base?: DeepPartial_2<DistinguishRequest>): DistinguishRequest;
    fromPartial(object: DeepPartial_2<DistinguishRequest>): DistinguishRequest;
};

declare enum DistinguishType {
    NULL_VALUE = 0,
    ADMIN = 1,
    GOLD = 2,
    GOLD_AUTO = 3,
    YES = 4,
    SPECIAL = 5,
    UNRECOGNIZED = -1
}

declare function distinguishTypeFromJSON(object: any): DistinguishType;

declare function distinguishTypeToJSON(object: DistinguishType): number;

/**
 * Wrapper message for `double`.
 *
 * The JSON representation for `DoubleValue` is JSON number.
 */
declare interface DoubleValue {
    /** The double value. */
    value: number;
}

declare const DoubleValue: {
    $type: "google.protobuf.DoubleValue";
    encode(message: DoubleValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DoubleValue;
    fromJSON(object: any): DoubleValue;
    toJSON(message: DoubleValue): unknown;
    create(base?: DeepPartial_69<DoubleValue>): DoubleValue;
    fromPartial(object: DeepPartial_69<DoubleValue>): DoubleValue;
};

/**
 * A Duration represents a signed, fixed-length span of time represented
 * as a count of seconds and fractions of seconds at nanosecond
 * resolution. It is independent of any calendar and concepts like "day"
 * or "month". It is related to Timestamp in that the difference between
 * two Timestamp values is a Duration and it can be added or subtracted
 * from a Timestamp. Range is approximately +-10,000 years.
 *
 * # Examples
 *
 * Example 1: Compute Duration from two Timestamps in pseudo code.
 *
 *     Timestamp start = ...;
 *     Timestamp end = ...;
 *     Duration duration = ...;
 *
 *     duration.seconds = end.seconds - start.seconds;
 *     duration.nanos = end.nanos - start.nanos;
 *
 *     if (duration.seconds < 0 && duration.nanos > 0) {
 *       duration.seconds += 1;
 *       duration.nanos -= 1000000000;
 *     } else if (duration.seconds > 0 && duration.nanos < 0) {
 *       duration.seconds -= 1;
 *       duration.nanos += 1000000000;
 *     }
 *
 * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
 *
 *     Timestamp start = ...;
 *     Duration duration = ...;
 *     Timestamp end = ...;
 *
 *     end.seconds = start.seconds + duration.seconds;
 *     end.nanos = start.nanos + duration.nanos;
 *
 *     if (end.nanos < 0) {
 *       end.seconds -= 1;
 *       end.nanos += 1000000000;
 *     } else if (end.nanos >= 1000000000) {
 *       end.seconds += 1;
 *       end.nanos -= 1000000000;
 *     }
 *
 * Example 3: Compute Duration from datetime.timedelta in Python.
 *
 *     td = datetime.timedelta(days=3, minutes=10)
 *     duration = Duration()
 *     duration.FromTimedelta(td)
 *
 * # JSON Mapping
 *
 * In JSON format, the Duration type is encoded as a string rather than an
 * object, where the string ends in the suffix "s" (indicating seconds) and
 * is preceded by the number of seconds, with nanoseconds expressed as
 * fractional seconds. For example, 3 seconds with 0 nanoseconds should be
 * encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
 * be expressed in JSON format as "3.000000001s", and 3 seconds and 1
 * microsecond should be expressed in JSON format as "3.000001s".
 */
declare interface Duration {
    /**
     * Signed seconds of the span of time. Must be from -315,576,000,000
     * to +315,576,000,000 inclusive. Note: these bounds are computed from:
     * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
     */
    seconds: number;
    /**
     * Signed fractions of a second at nanosecond resolution of the span
     * of time. Durations less than one second are represented with a 0
     * `seconds` field and a positive or negative `nanos` field. For durations
     * of one second or more, a non-zero value for the `nanos` field must be
     * of the same sign as the `seconds` field. Must be from -999,999,999
     * to +999,999,999 inclusive.
     */
    nanos: number;
}

declare const Duration: {
    $type: "google.protobuf.Duration";
    encode(message: Duration, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Duration;
    fromJSON(object: any): Duration;
    toJSON(message: Duration): unknown;
    create(base?: DeepPartial_38<Duration>): Duration;
    fromPartial(object: DeepPartial_38<Duration>): Duration;
};

declare interface Echo {
    Echo(request: Str, metadata?: Metadata): Promise<Str>;
}

declare class EchoClientImpl implements Echo {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_9, opts?: {
        service?: string;
    });
    Echo(request: Str, metadata?: Metadata): Promise<Str>;
}

declare type EchoDefinition = typeof EchoDefinition;

declare const EchoDefinition: {
    readonly name: "Echo";
    readonly fullName: "devvit.runtime.actor.Echo";
    readonly methods: {
        readonly echo: {
            readonly name: "Echo";
            readonly requestType: {
                $type: "devvit.runtime.Str";
                encode(message: Str, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Str;
                fromJSON(object: any): Str;
                toJSON(message: Str): unknown;
                create(base?: {
                    value?: string;
                } | undefined): Str;
                fromPartial(object: {
                    value?: string;
                }): Str;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.runtime.Str";
                encode(message: Str, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Str;
                fromJSON(object: any): Str;
                toJSON(message: Str): unknown;
                create(base?: {
                    value?: string;
                } | undefined): Str;
                fromPartial(object: {
                    value?: string;
                }): Str;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const EchoServiceName = "devvit.runtime.actor.Echo";

export declare type EditCommentOptions = CommentSubmissionOptions;

export declare type EditFlairTemplateOptions = CreateFlairTemplateOptions & {
    id: string;
};

/** The full set of known editions. */
declare enum Edition {
    /** EDITION_UNKNOWN - A placeholder for an unknown edition value. */
    EDITION_UNKNOWN = 0,
    /**
     * EDITION_PROTO2 - Legacy syntax "editions".  These pre-date editions, but behave much like
     * distinct editions.  These can't be used to specify the edition of proto
     * files, but feature definitions must supply proto2/proto3 defaults for
     * backwards compatibility.
     */
    EDITION_PROTO2 = 998,
    EDITION_PROTO3 = 999,
    /**
     * EDITION_2023 - Editions that have been released.  The specific values are arbitrary and
     * should not be depended on, but they will always be time-ordered for easy
     * comparison.
     */
    EDITION_2023 = 1000,
    EDITION_2024 = 1001,
    /**
     * EDITION_1_TEST_ONLY - Placeholder editions for testing feature resolution.  These should not be
     * used or relyed on outside of tests.
     */
    EDITION_1_TEST_ONLY = 1,
    EDITION_2_TEST_ONLY = 2,
    EDITION_99997_TEST_ONLY = 99997,
    EDITION_99998_TEST_ONLY = 99998,
    EDITION_99999_TEST_ONLY = 99999,
    /**
     * EDITION_MAX - Placeholder for specifying unbounded edition support.  This should only
     * ever be used by plugins that can expect to never require any changes to
     * support a new edition.
     */
    EDITION_MAX = 2147483647,
    UNRECOGNIZED = -1
}

declare function editionFromJSON(object: any): Edition;

declare function editionToJSON(object: Edition): number;

declare interface EditWikiPageRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
    /** The name of the wiki page. */
    page: string;
    /** The new content of the wiki page. */
    content: string;
    /** The reason for the edit. */
    reason: string;
}

declare const EditWikiPageRequest: {
    $type: "devvit.plugin.redditapi.wiki.EditWikiPageRequest";
    encode(message: EditWikiPageRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EditWikiPageRequest;
    fromJSON(object: any): EditWikiPageRequest;
    toJSON(message: EditWikiPageRequest): unknown;
    create(base?: DeepPartial_9<EditWikiPageRequest>): EditWikiPageRequest;
    fromPartial(object: DeepPartial_9<EditWikiPageRequest>): EditWikiPageRequest;
};

declare interface Effect {
    realtimeSubscriptions?: RealtimeSubscriptionsEffect | undefined;
    rerenderUi?: RerenderEffect | undefined;
    reloadPart?: ReloadPartEffect | undefined;
    showForm?: ShowFormEffect | undefined;
    showToast?: ShowToastEffect | undefined;
    navigateToUrl?: NavigateToUrlEffect | undefined;
    interval?: SetIntervalsEffect | undefined;
    /** TODO: remove this field once all clients are updated.  Redundant with effect_type */
    type: EffectType;
}

declare const Effect: {
    $type: "devvit.ui.effects.v1alpha.Effect";
    encode(message: Effect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Effect;
    fromJSON(object: any): Effect;
    toJSON(message: Effect): unknown;
    create(base?: DeepPartial_40<Effect>): Effect;
    fromPartial(object: DeepPartial_40<Effect>): Effect;
};

declare interface EffectEmitter {
    emitEffect(dedupeKey: string, effect: Effect): void;
}

declare enum EffectType {
    /** EFFECT_REALTIME_SUB - Notify client to synchronize its realtime subscriptions */
    EFFECT_REALTIME_SUB = 0,
    /** EFFECT_RERENDER_UI - Trigger a re-render for apps that have visible UI */
    EFFECT_RERENDER_UI = 1,
    /** EFFECT_RELOAD_PART - Notify the client that parts of a subreddit, post, or comment should be reloaded */
    EFFECT_RELOAD_PART = 2,
    /** EFFECT_SHOW_FORM - Display a user input form */
    EFFECT_SHOW_FORM = 3,
    /** EFFECT_SHOW_TOAST - Display a transient toast message */
    EFFECT_SHOW_TOAST = 4,
    /** EFFECT_NAVIGATE_TO_URL - Notify the client to navigate to a URL */
    EFFECT_NAVIGATE_TO_URL = 5,
    /** EFFECT_SET_INTERVALS - This updates the list of active timers. */
    EFFECT_SET_INTERVALS = 7,
    UNRECOGNIZED = -1
}

declare function effectTypeFromJSON(object: any): EffectType;

declare function effectTypeToJSON(object: EffectType): number;

/**
 * @mixin
 */
declare type EmbedContainer<Context> = {
    /**
     * Append an embedded iframe
     * @param opts {@link EmbedOptions}
     */
    embed(opts: EmbedOptions): Context;
};

declare type EmbedOptions = {
    /** Destination URL when the embed is clicked */
    sourceUrl: string;
    /** URL to load in the embedded iframe */
    contentUrl: string;
    width: number;
    height: number;
};

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 * empty messages in your APIs. A typical example is to use it as the request
 * or the response type of an API method. For instance:
 *
 *     service Foo {
 *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *     }
 */
declare interface Empty {
}

declare const Empty: {
    $type: "google.protobuf.Empty";
    encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Empty;
    fromJSON(_: any): Empty;
    toJSON(_: Empty): unknown;
    create(base?: DeepPartial_20<Empty>): Empty;
    fromPartial(_: DeepPartial_20<Empty>): Empty;
};

/** Describes an enum type. */
declare interface EnumDescriptorProto {
    name?: string | undefined;
    value: EnumValueDescriptorProto[];
    options?: EnumOptions | undefined;
    /**
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     */
    reservedRange: EnumDescriptorProto_EnumReservedRange[];
    /**
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     */
    reservedName: string[];
}

declare const EnumDescriptorProto: {
    $type: "google.protobuf.EnumDescriptorProto";
    encode(message: EnumDescriptorProto, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EnumDescriptorProto;
    fromJSON(object: any): EnumDescriptorProto;
    toJSON(message: EnumDescriptorProto): unknown;
    create(base?: DeepPartial_104<EnumDescriptorProto>): EnumDescriptorProto;
    fromPartial(object: DeepPartial_104<EnumDescriptorProto>): EnumDescriptorProto;
};

/**
 * Range of reserved numeric values. Reserved values may not be used by
 * entries in the same enum. Reserved ranges may not overlap.
 *
 * Note that this is distinct from DescriptorProto.ReservedRange in that it
 * is inclusive such that it can appropriately represent the entire int32
 * domain.
 */
declare interface EnumDescriptorProto_EnumReservedRange {
    /** Inclusive. */
    start?: number | undefined;
    /** Inclusive. */
    end?: number | undefined;
}

declare const EnumDescriptorProto_EnumReservedRange: {
    $type: "google.protobuf.EnumDescriptorProto.EnumReservedRange";
    encode(message: EnumDescriptorProto_EnumReservedRange, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EnumDescriptorProto_EnumReservedRange;
    fromJSON(object: any): EnumDescriptorProto_EnumReservedRange;
    toJSON(message: EnumDescriptorProto_EnumReservedRange): unknown;
    create(base?: DeepPartial_104<EnumDescriptorProto_EnumReservedRange>): EnumDescriptorProto_EnumReservedRange;
    fromPartial(object: DeepPartial_104<EnumDescriptorProto_EnumReservedRange>): EnumDescriptorProto_EnumReservedRange;
};

declare interface EnumOptions {
    /**
     * Set this option to true to allow mapping different tag names to the same
     * value.
     */
    allowAlias?: boolean | undefined;
    /**
     * Is this enum deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating enums.
     */
    deprecated?: boolean | undefined;
    /**
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * TODO Remove this legacy behavior once downstream teams have
     * had time to migrate.
     *
     * @deprecated
     */
    deprecatedLegacyJsonFieldConflicts?: boolean | undefined;
    /** Any features defined in the specific edition. */
    features?: FeatureSet | undefined;
    /** The parser stores options it doesn't recognize here. See above. */
    uninterpretedOption: UninterpretedOption[];
}

declare const EnumOptions: {
    $type: "google.protobuf.EnumOptions";
    encode(message: EnumOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EnumOptions;
    fromJSON(object: any): EnumOptions;
    toJSON(message: EnumOptions): unknown;
    create(base?: DeepPartial_104<EnumOptions>): EnumOptions;
    fromPartial(object: DeepPartial_104<EnumOptions>): EnumOptions;
};

/** Describes a value within an enum. */
declare interface EnumValueDescriptorProto {
    name?: string | undefined;
    number?: number | undefined;
    options?: EnumValueOptions | undefined;
}

declare const EnumValueDescriptorProto: {
    $type: "google.protobuf.EnumValueDescriptorProto";
    encode(message: EnumValueDescriptorProto, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EnumValueDescriptorProto;
    fromJSON(object: any): EnumValueDescriptorProto;
    toJSON(message: EnumValueDescriptorProto): unknown;
    create(base?: DeepPartial_104<EnumValueDescriptorProto>): EnumValueDescriptorProto;
    fromPartial(object: DeepPartial_104<EnumValueDescriptorProto>): EnumValueDescriptorProto;
};

declare interface EnumValueOptions {
    /**
     * Is this enum value deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum value, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating enum values.
     */
    deprecated?: boolean | undefined;
    /** Any features defined in the specific edition. */
    features?: FeatureSet | undefined;
    /**
     * Indicate that fields annotated with this enum value should not be printed
     * out when using debug formats, e.g. when the field contains sensitive
     * credentials.
     */
    debugRedact?: boolean | undefined;
    /** The parser stores options it doesn't recognize here. See above. */
    uninterpretedOption: UninterpretedOption[];
}

declare const EnumValueOptions: {
    $type: "google.protobuf.EnumValueOptions";
    encode(message: EnumValueOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EnumValueOptions;
    fromJSON(object: any): EnumValueOptions;
    toJSON(message: EnumValueOptions): unknown;
    create(base?: DeepPartial_104<EnumValueOptions>): EnumValueOptions;
    fromPartial(object: DeepPartial_104<EnumValueOptions>): EnumValueOptions;
};

declare interface Envelope {
    /**
     * Should be unique per-envelope. May remain the same for
     * envelopes that are mutated and forwarded along because
     * they are considered logically the same envelope.
     * Populated when the Envelope first gets post()ed to a central dispatcher.
     * Only to be used for debugging and repeat dispatch suppression.
     */
    id: string;
    src: string;
    dst: string;
    /**
     * The method has this format:
     *
     *   /<Definition.fullName>/<MethodDefinition.name>
     *
     * See EnvelopeUtil.envelopeMethod().
     */
    method: string;
    streamId: string;
    traceId: string;
    /**
     * When success is true and message is present, message adheres to the method
     * request / response type. When success is false, message's type is unknown.
     * In TypeScript only, messages are usually of type UnknownMessage.
     */
    success: boolean;
    message?: any | undefined;
    request: boolean;
    complete: boolean;
    /**
     * Must be consistent per streamId.  Can be omitted from subsequent
     * messages.
     */
    metadata: {
        [key: string]: Strings;
    };
}

declare const Envelope: {
    $type: "devvit.runtime.Envelope";
    encode(message: Envelope, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Envelope;
    fromJSON(object: any): Envelope;
    toJSON(message: Envelope): unknown;
    create(base?: DeepPartial_55<Envelope>): Envelope;
    fromPartial(object: DeepPartial_55<Envelope>): Envelope;
};

declare interface Envelope_MetadataEntry {
    key: string;
    value?: Strings | undefined;
}

declare const Envelope_MetadataEntry: {
    $type: "devvit.runtime.Envelope.MetadataEntry";
    encode(message: Envelope_MetadataEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Envelope_MetadataEntry;
    fromJSON(object: any): Envelope_MetadataEntry;
    toJSON(message: Envelope_MetadataEntry): unknown;
    create(base?: DeepPartial_55<Envelope_MetadataEntry>): Envelope_MetadataEntry;
    fromPartial(object: DeepPartial_55<Envelope_MetadataEntry>): Envelope_MetadataEntry;
};

/** Generic interface for a service that receives Envelopes */
declare interface EnvelopeReceiverPort {
    Post(request: Envelope, metadata?: Metadata): Promise<Empty>;
}

declare class EnvelopeReceiverPortClientImpl implements EnvelopeReceiverPort {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    Post(request: Envelope, metadata?: Metadata): Promise<Empty>;
}

/** Generic interface for a service that receives Envelopes */
declare type EnvelopeReceiverPortDefinition = typeof EnvelopeReceiverPortDefinition;

declare const EnvelopeReceiverPortDefinition: {
    readonly name: "EnvelopeReceiverPort";
    readonly fullName: "devvit.service.EnvelopeReceiverPort";
    readonly methods: {
        readonly post: {
            readonly name: "Post";
            readonly requestType: {
                $type: "devvit.runtime.Envelope";
                encode(message: Envelope, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Envelope;
                fromJSON(object: any): Envelope;
                toJSON(message: Envelope): unknown;
                create(base?: {
                    id?: string;
                    src?: string;
                    dst?: string;
                    method?: string;
                    streamId?: string;
                    traceId?: string;
                    success?: boolean;
                    message?: any;
                    request?: boolean;
                    complete?: boolean;
                    metadata?: {
                        [x: string]: {
                            values?: string[];
                        } | undefined;
                    };
                } | undefined): Envelope;
                fromPartial(object: {
                    id?: string;
                    src?: string;
                    dst?: string;
                    method?: string;
                    streamId?: string;
                    traceId?: string;
                    success?: boolean;
                    message?: any;
                    request?: boolean;
                    complete?: boolean;
                    metadata?: {
                        [x: string]: {
                            values?: string[];
                        } | undefined;
                    };
                }): Envelope;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const EnvelopeReceiverPortServiceName = "devvit.service.EnvelopeReceiverPort";

declare interface ErrorMessage {
    message: string;
}

declare const ErrorMessage: {
    $type: "devvit.gql.ErrorMessage";
    encode(message: ErrorMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ErrorMessage;
    fromJSON(object: any): ErrorMessage;
    toJSON(message: ErrorMessage): unknown;
    create(base?: DeepPartial_94<ErrorMessage>): ErrorMessage;
    fromPartial(object: DeepPartial_94<ErrorMessage>): ErrorMessage;
};

declare enum EventSource_2 {
    UNKNOWN_EVENT_SOURCE = 0,
    USER = 1,
    ADMIN = 2,
    MODERATOR = 3,
    UNRECOGNIZED = -1
}

declare function eventSourceFromJSON(object: any): EventSource_2;

declare function eventSourceToJSON(object: EventSource_2): number;

declare interface EventSpec {
    source: string;
    action: string;
    noun: string;
}

declare const EventSpec: {
    $type: "devvit.options.EventSpec";
    encode(message: EventSpec, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSpec;
    fromJSON(object: any): EventSpec;
    toJSON(message: EventSpec): unknown;
    create(base?: DeepPartial_105<EventSpec>): EventSpec;
    fromPartial(object: DeepPartial_105<EventSpec>): EventSpec;
};

declare interface ExpireRequest {
    key: string;
    seconds: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const ExpireRequest: {
    $type: "devvit.plugin.redis.ExpireRequest";
    encode(message: ExpireRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExpireRequest;
    fromJSON(object: any): ExpireRequest;
    toJSON(message: ExpireRequest): unknown;
    create(base?: DeepPartial_86<ExpireRequest>): ExpireRequest;
    fromPartial(object: DeepPartial_86<ExpireRequest>): ExpireRequest;
};

declare interface ExtensionRangeOptions {
    /** The parser stores options it doesn't recognize here. See above. */
    uninterpretedOption: UninterpretedOption[];
    /**
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     */
    declaration: ExtensionRangeOptions_Declaration[];
    /** Any features defined in the specific edition. */
    features?: FeatureSet | undefined;
    /**
     * The verification state of the range.
     * TODO: flip the default to DECLARATION once all empty ranges
     * are marked as UNVERIFIED.
     */
    verification?: ExtensionRangeOptions_VerificationState | undefined;
}

declare const ExtensionRangeOptions: {
    $type: "google.protobuf.ExtensionRangeOptions";
    encode(message: ExtensionRangeOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExtensionRangeOptions;
    fromJSON(object: any): ExtensionRangeOptions;
    toJSON(message: ExtensionRangeOptions): unknown;
    create(base?: DeepPartial_104<ExtensionRangeOptions>): ExtensionRangeOptions;
    fromPartial(object: DeepPartial_104<ExtensionRangeOptions>): ExtensionRangeOptions;
};

declare interface ExtensionRangeOptions_Declaration {
    /** The extension number declared within the extension range. */
    number?: number | undefined;
    /**
     * The fully-qualified name of the extension field. There must be a leading
     * dot in front of the full name.
     */
    fullName?: string | undefined;
    /**
     * The fully-qualified type name of the extension field. Unlike
     * Metadata.type, Declaration.type must have a leading dot for messages
     * and enums.
     */
    type?: string | undefined;
    /**
     * If true, indicates that the number is reserved in the extension range,
     * and any extension field with the number will fail to compile. Set this
     * when a declared extension field is deleted.
     */
    reserved?: boolean | undefined;
    /**
     * If true, indicates that the extension must be defined as repeated.
     * Otherwise the extension must be defined as optional.
     */
    repeated?: boolean | undefined;
}

declare const ExtensionRangeOptions_Declaration: {
    $type: "google.protobuf.ExtensionRangeOptions.Declaration";
    encode(message: ExtensionRangeOptions_Declaration, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExtensionRangeOptions_Declaration;
    fromJSON(object: any): ExtensionRangeOptions_Declaration;
    toJSON(message: ExtensionRangeOptions_Declaration): unknown;
    create(base?: DeepPartial_104<ExtensionRangeOptions_Declaration>): ExtensionRangeOptions_Declaration;
    fromPartial(object: DeepPartial_104<ExtensionRangeOptions_Declaration>): ExtensionRangeOptions_Declaration;
};

/** The verification state of the extension range. */
declare enum ExtensionRangeOptions_VerificationState {
    /** DECLARATION - All the extensions of the range must be declared. */
    DECLARATION = 0,
    UNVERIFIED = 1,
    UNRECOGNIZED = -1
}

declare function extensionRangeOptions_VerificationStateFromJSON(object: any): ExtensionRangeOptions_VerificationState;

declare function extensionRangeOptions_VerificationStateToJSON(object: ExtensionRangeOptions_VerificationState): number;

/**
 * TODO Enums in C++ gencode (and potentially other languages) are
 * not well scoped.  This means that each of the feature enums below can clash
 * with each other.  The short names we've chosen maximize call-site
 * readability, but leave us very open to this scenario.  A future feature will
 * be designed and implemented to handle this, hopefully before we ever hit a
 * conflict here.
 */
declare interface FeatureSet {
    fieldPresence?: FeatureSet_FieldPresence | undefined;
    enumType?: FeatureSet_EnumType | undefined;
    repeatedFieldEncoding?: FeatureSet_RepeatedFieldEncoding | undefined;
    utf8Validation?: FeatureSet_Utf8Validation | undefined;
    messageEncoding?: FeatureSet_MessageEncoding | undefined;
    jsonFormat?: FeatureSet_JsonFormat | undefined;
}

declare const FeatureSet: {
    $type: "google.protobuf.FeatureSet";
    encode(message: FeatureSet, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FeatureSet;
    fromJSON(object: any): FeatureSet;
    toJSON(message: FeatureSet): unknown;
    create(base?: DeepPartial_104<FeatureSet>): FeatureSet;
    fromPartial(object: DeepPartial_104<FeatureSet>): FeatureSet;
};

declare enum FeatureSet_EnumType {
    ENUM_TYPE_UNKNOWN = 0,
    OPEN = 1,
    CLOSED = 2,
    UNRECOGNIZED = -1
}

declare function featureSet_EnumTypeFromJSON(object: any): FeatureSet_EnumType;

declare function featureSet_EnumTypeToJSON(object: FeatureSet_EnumType): number;

declare enum FeatureSet_FieldPresence {
    FIELD_PRESENCE_UNKNOWN = 0,
    EXPLICIT = 1,
    IMPLICIT = 2,
    LEGACY_REQUIRED = 3,
    UNRECOGNIZED = -1
}

declare function featureSet_FieldPresenceFromJSON(object: any): FeatureSet_FieldPresence;

declare function featureSet_FieldPresenceToJSON(object: FeatureSet_FieldPresence): number;

declare enum FeatureSet_JsonFormat {
    JSON_FORMAT_UNKNOWN = 0,
    ALLOW = 1,
    LEGACY_BEST_EFFORT = 2,
    UNRECOGNIZED = -1
}

declare function featureSet_JsonFormatFromJSON(object: any): FeatureSet_JsonFormat;

declare function featureSet_JsonFormatToJSON(object: FeatureSet_JsonFormat): number;

declare enum FeatureSet_MessageEncoding {
    MESSAGE_ENCODING_UNKNOWN = 0,
    LENGTH_PREFIXED = 1,
    DELIMITED = 2,
    UNRECOGNIZED = -1
}

declare function featureSet_MessageEncodingFromJSON(object: any): FeatureSet_MessageEncoding;

declare function featureSet_MessageEncodingToJSON(object: FeatureSet_MessageEncoding): number;

declare enum FeatureSet_RepeatedFieldEncoding {
    REPEATED_FIELD_ENCODING_UNKNOWN = 0,
    PACKED = 1,
    EXPANDED = 2,
    UNRECOGNIZED = -1
}

declare function featureSet_RepeatedFieldEncodingFromJSON(object: any): FeatureSet_RepeatedFieldEncoding;

declare function featureSet_RepeatedFieldEncodingToJSON(object: FeatureSet_RepeatedFieldEncoding): number;

declare enum FeatureSet_Utf8Validation {
    UTF8_VALIDATION_UNKNOWN = 0,
    VERIFY = 2,
    NONE = 3,
    UNRECOGNIZED = -1
}

declare function featureSet_Utf8ValidationFromJSON(object: any): FeatureSet_Utf8Validation;

declare function featureSet_Utf8ValidationToJSON(object: FeatureSet_Utf8Validation): number;

/**
 * A compiled specification for the defaults of a set of features.  These
 * messages are generated from FeatureSet extensions and can be used to seed
 * feature resolution. The resolution with this object becomes a simple search
 * for the closest matching edition, followed by proto merges.
 */
declare interface FeatureSetDefaults {
    defaults: FeatureSetDefaults_FeatureSetEditionDefault[];
    /**
     * The minimum supported edition (inclusive) when this was constructed.
     * Editions before this will not have defaults.
     */
    minimumEdition?: Edition | undefined;
    /**
     * The maximum known edition (inclusive) when this was constructed. Editions
     * after this will not have reliable defaults.
     */
    maximumEdition?: Edition | undefined;
}

declare const FeatureSetDefaults: {
    $type: "google.protobuf.FeatureSetDefaults";
    encode(message: FeatureSetDefaults, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FeatureSetDefaults;
    fromJSON(object: any): FeatureSetDefaults;
    toJSON(message: FeatureSetDefaults): unknown;
    create(base?: DeepPartial_104<FeatureSetDefaults>): FeatureSetDefaults;
    fromPartial(object: DeepPartial_104<FeatureSetDefaults>): FeatureSetDefaults;
};

/**
 * A map from every known edition with a unique set of defaults to its
 * defaults. Not all editions may be contained here.  For a given edition,
 * the defaults at the closest matching edition ordered at or before it should
 * be used.  This field must be in strict ascending order by edition.
 */
declare interface FeatureSetDefaults_FeatureSetEditionDefault {
    edition?: Edition | undefined;
    features?: FeatureSet | undefined;
}

declare const FeatureSetDefaults_FeatureSetEditionDefault: {
    $type: "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault";
    encode(message: FeatureSetDefaults_FeatureSetEditionDefault, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FeatureSetDefaults_FeatureSetEditionDefault;
    fromJSON(object: any): FeatureSetDefaults_FeatureSetEditionDefault;
    toJSON(message: FeatureSetDefaults_FeatureSetEditionDefault): unknown;
    create(base?: DeepPartial_104<FeatureSetDefaults_FeatureSetEditionDefault>): FeatureSetDefaults_FeatureSetEditionDefault;
    fromPartial(object: DeepPartial_104<FeatureSetDefaults_FeatureSetEditionDefault>): FeatureSetDefaults_FeatureSetEditionDefault;
};

declare interface FetchRequest {
    url: string;
    data?: RequestData | undefined;
}

declare const FetchRequest: {
    $type: "devvit.plugin.http.FetchRequest";
    encode(message: FetchRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FetchRequest;
    fromJSON(object: any): FetchRequest;
    toJSON(message: FetchRequest): unknown;
    create(base?: DeepPartial_58<FetchRequest>): FetchRequest;
    fromPartial(object: DeepPartial_58<FetchRequest>): FetchRequest;
};

declare interface FetchResponse {
    url: string;
    body: Uint8Array;
    status: number;
    headers: {
        [key: string]: string;
    };
}

declare const FetchResponse: {
    $type: "devvit.plugin.http.FetchResponse";
    encode(message: FetchResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FetchResponse;
    fromJSON(object: any): FetchResponse;
    toJSON(message: FetchResponse): unknown;
    create(base?: DeepPartial_58<FetchResponse>): FetchResponse;
    fromPartial(object: DeepPartial_58<FetchResponse>): FetchResponse;
};

declare interface FetchResponse_HeadersEntry {
    key: string;
    value: string;
}

declare const FetchResponse_HeadersEntry: {
    $type: "devvit.plugin.http.FetchResponse.HeadersEntry";
    encode(message: FetchResponse_HeadersEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FetchResponse_HeadersEntry;
    fromJSON(object: any): FetchResponse_HeadersEntry;
    toJSON(message: FetchResponse_HeadersEntry): unknown;
    create(base?: DeepPartial_58<FetchResponse_HeadersEntry>): FetchResponse_HeadersEntry;
    fromPartial(object: DeepPartial_58<FetchResponse_HeadersEntry>): FetchResponse_HeadersEntry;
};

/** Per-type configuration options */
declare interface FieldConfig {
    stringConfig?: FieldConfig_String | undefined;
    paragraphConfig?: FieldConfig_Paragraph | undefined;
    numberConfig?: FieldConfig_Number | undefined;
    booleanConfig?: FieldConfig_Boolean | undefined;
    listConfig?: FieldConfig_List | undefined;
    selectionConfig?: FieldConfig_Selection | undefined;
    groupConfig?: FieldConfig_Group | undefined;
}

declare const FieldConfig: {
    $type: "devvit.ui.form_builder.v1alpha.FieldConfig";
    encode(message: FieldConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldConfig;
    fromJSON(object: any): FieldConfig;
    toJSON(message: FieldConfig): unknown;
    create(base?: DeepPartial_10<FieldConfig>): FieldConfig;
    fromPartial(object: DeepPartial_10<FieldConfig>): FieldConfig;
};

declare interface FieldConfig_Boolean {
}

declare const FieldConfig_Boolean: {
    $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Boolean";
    encode(_: FieldConfig_Boolean, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldConfig_Boolean;
    fromJSON(_: any): FieldConfig_Boolean;
    toJSON(_: FieldConfig_Boolean): unknown;
    create(base?: DeepPartial_10<FieldConfig_Boolean>): FieldConfig_Boolean;
    fromPartial(_: DeepPartial_10<FieldConfig_Boolean>): FieldConfig_Boolean;
};

declare interface FieldConfig_Group {
    /** Fields included in this group */
    fields: FormField_2[];
}

declare const FieldConfig_Group: {
    $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Group";
    encode(message: FieldConfig_Group, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldConfig_Group;
    fromJSON(object: any): FieldConfig_Group;
    toJSON(message: FieldConfig_Group): unknown;
    create(base?: DeepPartial_10<FieldConfig_Group>): FieldConfig_Group;
    fromPartial(object: DeepPartial_10<FieldConfig_Group>): FieldConfig_Group;
};

declare interface FieldConfig_List {
    /** The data type of each item in the list; LIST/SELECTION/GROUP not allowed */
    itemType: FormFieldType;
    /** Additional configuration for items */
    itemConfig?: FieldConfig | undefined;
    /** Minimum number of entries allowed in the list */
    minEntries?: number | undefined;
    /** Maximum number of entries allowed in the list */
    maxEntries?: number | undefined;
    /** Label on the new entry input */
    entryLabel?: string | undefined;
}

declare const FieldConfig_List: {
    $type: "devvit.ui.form_builder.v1alpha.FieldConfig.List";
    encode(message: FieldConfig_List, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldConfig_List;
    fromJSON(object: any): FieldConfig_List;
    toJSON(message: FieldConfig_List): unknown;
    create(base?: DeepPartial_10<FieldConfig_List>): FieldConfig_List;
    fromPartial(object: DeepPartial_10<FieldConfig_List>): FieldConfig_List;
};

declare interface FieldConfig_Number {
    /** Sets the amount the field can increment/decrement [Default: 1] */
    step?: number | undefined;
    /** Minimum allowed value */
    min?: number | undefined;
    /** Maximum allowed value */
    max?: number | undefined;
}

declare const FieldConfig_Number: {
    $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Number";
    encode(message: FieldConfig_Number, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldConfig_Number;
    fromJSON(object: any): FieldConfig_Number;
    toJSON(message: FieldConfig_Number): unknown;
    create(base?: DeepPartial_10<FieldConfig_Number>): FieldConfig_Number;
    fromPartial(object: DeepPartial_10<FieldConfig_Number>): FieldConfig_Number;
};

declare interface FieldConfig_Paragraph {
    /** Maximum allowed characters */
    maxCharacters?: number | undefined;
    /** Height based on the number of lines to display in the text area */
    lineHeight?: number | undefined;
    /** Placeholder to use when rendering the input field */
    placeholder?: string | undefined;
}

declare const FieldConfig_Paragraph: {
    $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Paragraph";
    encode(message: FieldConfig_Paragraph, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldConfig_Paragraph;
    fromJSON(object: any): FieldConfig_Paragraph;
    toJSON(message: FieldConfig_Paragraph): unknown;
    create(base?: DeepPartial_10<FieldConfig_Paragraph>): FieldConfig_Paragraph;
    fromPartial(object: DeepPartial_10<FieldConfig_Paragraph>): FieldConfig_Paragraph;
};

declare interface FieldConfig_Selection {
    /** Ordered list of choices to display in this field */
    choices: FieldConfig_Selection_Item[];
    /** If true allow multiple selections */
    multiSelect?: boolean | undefined;
    /** If multi_select the minimum number of selections required */
    minSelections?: number | undefined;
    /** If multi_select the maximum number of selections allowed */
    maxSelections?: number | undefined;
    /** Render the selection as a list of radio buttons or checkboxes */
    renderAsList?: boolean | undefined;
}

declare const FieldConfig_Selection: {
    $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Selection";
    encode(message: FieldConfig_Selection, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldConfig_Selection;
    fromJSON(object: any): FieldConfig_Selection;
    toJSON(message: FieldConfig_Selection): unknown;
    create(base?: DeepPartial_10<FieldConfig_Selection>): FieldConfig_Selection;
    fromPartial(object: DeepPartial_10<FieldConfig_Selection>): FieldConfig_Selection;
};

declare interface FieldConfig_Selection_Item {
    /** User-facing label */
    label: string;
    /** Value to use when this option is selected */
    value: string;
}

declare const FieldConfig_Selection_Item: {
    $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Selection.Item";
    encode(message: FieldConfig_Selection_Item, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldConfig_Selection_Item;
    fromJSON(object: any): FieldConfig_Selection_Item;
    toJSON(message: FieldConfig_Selection_Item): unknown;
    create(base?: DeepPartial_10<FieldConfig_Selection_Item>): FieldConfig_Selection_Item;
    fromPartial(object: DeepPartial_10<FieldConfig_Selection_Item>): FieldConfig_Selection_Item;
};

declare interface FieldConfig_String {
    /** Minimum allowed length for the string */
    minLength?: number | undefined;
    /** Maximum allowed length for the string */
    maxLength?: number | undefined;
    /** Placeholder to use when rendering the input field */
    placeholder?: string | undefined;
}

declare const FieldConfig_String: {
    $type: "devvit.ui.form_builder.v1alpha.FieldConfig.String";
    encode(message: FieldConfig_String, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldConfig_String;
    fromJSON(object: any): FieldConfig_String;
    toJSON(message: FieldConfig_String): unknown;
    create(base?: DeepPartial_10<FieldConfig_String>): FieldConfig_String;
    fromPartial(object: DeepPartial_10<FieldConfig_String>): FieldConfig_String;
};

/** Describes a field within a message. */
declare interface FieldDescriptorProto {
    name?: string | undefined;
    number?: number | undefined;
    label?: FieldDescriptorProto_Label | undefined;
    /**
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     */
    type?: FieldDescriptorProto_Type | undefined;
    /**
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     */
    typeName?: string | undefined;
    /**
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     */
    extendee?: string | undefined;
    /**
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
     */
    defaultValue?: string | undefined;
    /**
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     */
    oneofIndex?: number | undefined;
    /**
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     */
    jsonName?: string | undefined;
    options?: FieldOptions | undefined;
    /**
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     *
     * When proto3_optional is true, this field must belong to a oneof to signal
     * to old proto3 clients that presence is tracked for this field. This oneof
     * is known as a "synthetic" oneof, and this field must be its sole member
     * (each proto3 optional field gets its own synthetic oneof). Synthetic oneofs
     * exist in the descriptor only, and do not generate any API. Synthetic oneofs
     * must be ordered after all "real" oneofs.
     *
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     *
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     */
    proto3Optional?: boolean | undefined;
}

declare const FieldDescriptorProto: {
    $type: "google.protobuf.FieldDescriptorProto";
    encode(message: FieldDescriptorProto, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldDescriptorProto;
    fromJSON(object: any): FieldDescriptorProto;
    toJSON(message: FieldDescriptorProto): unknown;
    create(base?: DeepPartial_104<FieldDescriptorProto>): FieldDescriptorProto;
    fromPartial(object: DeepPartial_104<FieldDescriptorProto>): FieldDescriptorProto;
};

declare enum FieldDescriptorProto_Label {
    /** LABEL_OPTIONAL - 0 is reserved for errors */
    LABEL_OPTIONAL = 1,
    LABEL_REPEATED = 3,
    /**
     * LABEL_REQUIRED - The required label is only allowed in google.protobuf.  In proto3 and Editions
     * it's explicitly prohibited.  In Editions, the `field_presence` feature
     * can be used to get this behavior.
     */
    LABEL_REQUIRED = 2,
    UNRECOGNIZED = -1
}

declare function fieldDescriptorProto_LabelFromJSON(object: any): FieldDescriptorProto_Label;

declare function fieldDescriptorProto_LabelToJSON(object: FieldDescriptorProto_Label): number;

declare enum FieldDescriptorProto_Type {
    /**
     * TYPE_DOUBLE - 0 is reserved for errors.
     * Order is weird for historical reasons.
     */
    TYPE_DOUBLE = 1,
    TYPE_FLOAT = 2,
    /**
     * TYPE_INT64 - Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
     * negative values are likely.
     */
    TYPE_INT64 = 3,
    TYPE_UINT64 = 4,
    /**
     * TYPE_INT32 - Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
     * negative values are likely.
     */
    TYPE_INT32 = 5,
    TYPE_FIXED64 = 6,
    TYPE_FIXED32 = 7,
    TYPE_BOOL = 8,
    TYPE_STRING = 9,
    /**
     * TYPE_GROUP - Tag-delimited aggregate.
     * Group type is deprecated and not supported after google.protobuf. However, Proto3
     * implementations should still be able to parse the group wire format and
     * treat group fields as unknown fields.  In Editions, the group wire format
     * can be enabled via the `message_encoding` feature.
     */
    TYPE_GROUP = 10,
    /** TYPE_MESSAGE - Length-delimited aggregate. */
    TYPE_MESSAGE = 11,
    /** TYPE_BYTES - New in version 2. */
    TYPE_BYTES = 12,
    TYPE_UINT32 = 13,
    TYPE_ENUM = 14,
    TYPE_SFIXED32 = 15,
    TYPE_SFIXED64 = 16,
    /** TYPE_SINT32 - Uses ZigZag encoding. */
    TYPE_SINT32 = 17,
    /** TYPE_SINT64 - Uses ZigZag encoding. */
    TYPE_SINT64 = 18,
    UNRECOGNIZED = -1
}

declare function fieldDescriptorProto_TypeFromJSON(object: any): FieldDescriptorProto_Type;

declare function fieldDescriptorProto_TypeToJSON(object: FieldDescriptorProto_Type): number;

declare interface FieldOptions {
    /**
     * The ctype option instructs the C++ code generator to use a different
     * representation of the field than it normally would.  See the specific
     * options below.  This option is only implemented to support use of
     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
     * type "bytes" in the open source release -- sorry, we'll try to include
     * other types in a future version!
     */
    ctype?: FieldOptions_CType | undefined;
    /**
     * The packed option can be enabled for repeated primitive fields to enable
     * a more efficient representation on the wire. Rather than repeatedly
     * writing the tag and type for each element, the entire array is encoded as
     * a single length-delimited blob. In proto3, only explicit setting it to
     * false will avoid using packed encoding.  This option is prohibited in
     * Editions, but the `repeated_field_encoding` feature can be used to control
     * the behavior.
     */
    packed?: boolean | undefined;
    /**
     * The jstype option determines the JavaScript type used for values of the
     * field.  The option is permitted only for 64 bit integral and fixed types
     * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
     * is represented as JavaScript string, which avoids loss of precision that
     * can happen when a large value is converted to a floating point JavaScript.
     * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
     * use the JavaScript "number" type.  The behavior of the default option
     * JS_NORMAL is implementation dependent.
     *
     * This option is an enum to permit additional types to be added, e.g.
     * goog.math.Integer.
     */
    jstype?: FieldOptions_JSType | undefined;
    /**
     * Should this field be parsed lazily?  Lazy applies only to message-type
     * fields.  It means that when the outer message is initially parsed, the
     * inner message's contents will not be parsed but instead stored in encoded
     * form.  The inner message will actually be parsed when it is first accessed.
     *
     * This is only a hint.  Implementations are free to choose whether to use
     * eager or lazy parsing regardless of the value of this option.  However,
     * setting this option true suggests that the protocol author believes that
     * using lazy parsing on this field is worth the additional bookkeeping
     * overhead typically needed to implement it.
     *
     * This option does not affect the public interface of any generated code;
     * all method signatures remain the same.  Furthermore, thread-safety of the
     * interface is not affected by this option; const methods remain safe to
     * call from multiple threads concurrently, while non-const methods continue
     * to require exclusive access.
     *
     * Note that lazy message fields are still eagerly verified to check
     * ill-formed wireformat or missing required fields. Calling IsInitialized()
     * on the outer message would fail if the inner message has missing required
     * fields. Failed verification would result in parsing failure (except when
     * uninitialized messages are acceptable).
     */
    lazy?: boolean | undefined;
    /**
     * unverified_lazy does no correctness checks on the byte stream. This should
     * only be used where lazy with verification is prohibitive for performance
     * reasons.
     */
    unverifiedLazy?: boolean | undefined;
    /**
     * Is this field deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for accessors, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating fields.
     */
    deprecated?: boolean | undefined;
    /** For Google-internal migration only. Do not use. */
    weak?: boolean | undefined;
    /**
     * Indicate that the field value should not be printed out when using debug
     * formats, e.g. when the field contains sensitive credentials.
     */
    debugRedact?: boolean | undefined;
    retention?: FieldOptions_OptionRetention | undefined;
    targets: FieldOptions_OptionTargetType[];
    editionDefaults: FieldOptions_EditionDefault[];
    /** Any features defined in the specific edition. */
    features?: FeatureSet | undefined;
    /** The parser stores options it doesn't recognize here. See above. */
    uninterpretedOption: UninterpretedOption[];
}

declare const FieldOptions: {
    $type: "google.protobuf.FieldOptions";
    encode(message: FieldOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldOptions;
    fromJSON(object: any): FieldOptions;
    toJSON(message: FieldOptions): unknown;
    create(base?: DeepPartial_104<FieldOptions>): FieldOptions;
    fromPartial(object: DeepPartial_104<FieldOptions>): FieldOptions;
};

declare enum FieldOptions_CType {
    /** STRING - Default mode. */
    STRING = 0,
    /**
     * CORD - The option [ctype=CORD] may be applied to a non-repeated field of type
     * "bytes". It indicates that in C++, the data should be stored in a Cord
     * instead of a string.  For very large strings, this may reduce memory
     * fragmentation. It may also allow better performance when parsing from a
     * Cord, or when parsing with aliasing enabled, as the parsed Cord may then
     * alias the original buffer.
     */
    CORD = 1,
    STRING_PIECE = 2,
    UNRECOGNIZED = -1
}

declare function fieldOptions_CTypeFromJSON(object: any): FieldOptions_CType;

declare function fieldOptions_CTypeToJSON(object: FieldOptions_CType): number;

declare interface FieldOptions_EditionDefault {
    edition?: Edition | undefined;
    /** Textproto value. */
    value?: string | undefined;
}

declare const FieldOptions_EditionDefault: {
    $type: "google.protobuf.FieldOptions.EditionDefault";
    encode(message: FieldOptions_EditionDefault, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldOptions_EditionDefault;
    fromJSON(object: any): FieldOptions_EditionDefault;
    toJSON(message: FieldOptions_EditionDefault): unknown;
    create(base?: DeepPartial_104<FieldOptions_EditionDefault>): FieldOptions_EditionDefault;
    fromPartial(object: DeepPartial_104<FieldOptions_EditionDefault>): FieldOptions_EditionDefault;
};

declare enum FieldOptions_JSType {
    /** JS_NORMAL - Use the default type. */
    JS_NORMAL = 0,
    /** JS_STRING - Use JavaScript strings. */
    JS_STRING = 1,
    /** JS_NUMBER - Use JavaScript numbers. */
    JS_NUMBER = 2,
    UNRECOGNIZED = -1
}

declare function fieldOptions_JSTypeFromJSON(object: any): FieldOptions_JSType;

declare function fieldOptions_JSTypeToJSON(object: FieldOptions_JSType): number;

/**
 * If set to RETENTION_SOURCE, the option will be omitted from the binary.
 * Note: as of January 2023, support for this is in progress and does not yet
 * have an effect (b/264593489).
 */
declare enum FieldOptions_OptionRetention {
    RETENTION_UNKNOWN = 0,
    RETENTION_RUNTIME = 1,
    RETENTION_SOURCE = 2,
    UNRECOGNIZED = -1
}

declare function fieldOptions_OptionRetentionFromJSON(object: any): FieldOptions_OptionRetention;

declare function fieldOptions_OptionRetentionToJSON(object: FieldOptions_OptionRetention): number;

/**
 * This indicates the types of entities that the field may apply to when used
 * as an option. If it is unset, then the field may be freely used as an
 * option on any kind of entity. Note: as of January 2023, support for this is
 * in progress and does not yet have an effect (b/264593489).
 */
declare enum FieldOptions_OptionTargetType {
    TARGET_TYPE_UNKNOWN = 0,
    TARGET_TYPE_FILE = 1,
    TARGET_TYPE_EXTENSION_RANGE = 2,
    TARGET_TYPE_MESSAGE = 3,
    TARGET_TYPE_FIELD = 4,
    TARGET_TYPE_ONEOF = 5,
    TARGET_TYPE_ENUM = 6,
    TARGET_TYPE_ENUM_ENTRY = 7,
    TARGET_TYPE_SERVICE = 8,
    TARGET_TYPE_METHOD = 9,
    UNRECOGNIZED = -1
}

declare function fieldOptions_OptionTargetTypeFromJSON(object: any): FieldOptions_OptionTargetType;

declare function fieldOptions_OptionTargetTypeToJSON(object: FieldOptions_OptionTargetType): number;

/** A file is a single file or directory in a filesystem. */
declare interface File_2 {
    /**
     * The name of the file, relative to the root of the filesystem.
     * Please don't start with a slash.
     */
    path: string;
    content: string;
    isDirectory: boolean;
    isBase64: boolean;
}

declare const File_2: {
    $type: "devvit.plugin.buildpack.File";
    encode(message: File_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): File_2;
    fromJSON(object: any): File_2;
    toJSON(message: File_2): unknown;
    create(base?: DeepPartial_22<File_2>): File_2;
    fromPartial(object: DeepPartial_22<File_2>): File_2;
};

/** Describes a complete .proto file. */
declare interface FileDescriptorProto {
    /** file name, relative to root of source tree */
    name?: string | undefined;
    /** e.g. "foo", "foo.bar", etc. */
    package?: string | undefined;
    /** Names of files imported by this file. */
    dependency: string[];
    /** Indexes of the public imported files in the dependency list above. */
    publicDependency: number[];
    /**
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     */
    weakDependency: number[];
    /** All top-level definitions in this file. */
    messageType: DescriptorProto[];
    enumType: EnumDescriptorProto[];
    service: ServiceDescriptorProto[];
    extension: FieldDescriptorProto[];
    options?: FileOptions | undefined;
    /**
     * This field contains optional information about the original source code.
     * You may safely remove this entire field without harming runtime
     * functionality of the descriptors -- the information is needed only by
     * development tools.
     */
    sourceCodeInfo?: SourceCodeInfo | undefined;
    /**
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     *
     * If `edition` is present, this value must be "editions".
     */
    syntax?: string | undefined;
    /** The edition of the proto file. */
    edition?: Edition | undefined;
}

declare const FileDescriptorProto: {
    $type: "google.protobuf.FileDescriptorProto";
    encode(message: FileDescriptorProto, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FileDescriptorProto;
    fromJSON(object: any): FileDescriptorProto;
    toJSON(message: FileDescriptorProto): unknown;
    create(base?: DeepPartial_104<FileDescriptorProto>): FileDescriptorProto;
    fromPartial(object: DeepPartial_104<FileDescriptorProto>): FileDescriptorProto;
};

/**
 * The protocol compiler can output a FileDescriptorSet containing the .proto
 * files it parses.
 */
declare interface FileDescriptorSet {
    file: FileDescriptorProto[];
}

declare const FileDescriptorSet: {
    $type: "google.protobuf.FileDescriptorSet";
    encode(message: FileDescriptorSet, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FileDescriptorSet;
    fromJSON(object: any): FileDescriptorSet;
    toJSON(message: FileDescriptorSet): unknown;
    create(base?: DeepPartial_104<FileDescriptorSet>): FileDescriptorSet;
    fromPartial(object: DeepPartial_104<FileDescriptorSet>): FileDescriptorSet;
};

declare interface FileOptions {
    /**
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     */
    javaPackage?: string | undefined;
    /**
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     */
    javaOuterClassname?: string | undefined;
    /**
     * If enabled, then the Java code generator will generate a separate .java
     * file for each top-level message, enum, and service defined in the .proto
     * file.  Thus, these types will *not* be nested inside the wrapper class
     * named by java_outer_classname.  However, the wrapper class will still be
     * generated to contain the file's getDescriptor() method as well as any
     * top-level extensions defined in the file.
     */
    javaMultipleFiles?: boolean | undefined;
    /**
     * This option does nothing.
     *
     * @deprecated
     */
    javaGenerateEqualsAndHash?: boolean | undefined;
    /**
     * If set true, then the Java2 code generator will generate code that
     * throws an exception whenever an attempt is made to assign a non-UTF-8
     * byte sequence to a string field.
     * Message reflection will do the same.
     * However, an extension field still accepts non-UTF-8 byte sequences.
     * This option has no effect on when used with the lite runtime.
     */
    javaStringCheckUtf8?: boolean | undefined;
    optimizeFor?: FileOptions_OptimizeMode | undefined;
    /**
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     */
    goPackage?: string | undefined;
    /**
     * Should generic services be generated in each language?  "Generic" services
     * are not specific to any particular RPC system.  They are generated by the
     * main code generators in each language (without additional plugins).
     * Generic services were the only kind of service generation supported by
     * early versions of google.protobuf.
     *
     * Generic services are now considered deprecated in favor of using plugins
     * that generate code specific to your particular RPC system.  Therefore,
     * these default to false.  Old code which depends on generic services should
     * explicitly set them to true.
     */
    ccGenericServices?: boolean | undefined;
    javaGenericServices?: boolean | undefined;
    pyGenericServices?: boolean | undefined;
    /**
     * Is this file deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for everything in the file, or it will be completely ignored; in the very
     * least, this is a formalization for deprecating files.
     */
    deprecated?: boolean | undefined;
    /**
     * Enables the use of arenas for the proto messages in this file. This applies
     * only to generated classes for C++.
     */
    ccEnableArenas?: boolean | undefined;
    /**
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     */
    objcClassPrefix?: string | undefined;
    /** Namespace for generated classes; defaults to the package. */
    csharpNamespace?: string | undefined;
    /**
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     */
    swiftPrefix?: string | undefined;
    /**
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     */
    phpClassPrefix?: string | undefined;
    /**
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     */
    phpNamespace?: string | undefined;
    /**
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     */
    phpMetadataNamespace?: string | undefined;
    /**
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     */
    rubyPackage?: string | undefined;
    /** Any features defined in the specific edition. */
    features?: FeatureSet | undefined;
    /**
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     */
    uninterpretedOption: UninterpretedOption[];
}

declare const FileOptions: {
    $type: "google.protobuf.FileOptions";
    encode(message: FileOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FileOptions;
    fromJSON(object: any): FileOptions;
    toJSON(message: FileOptions): unknown;
    create(base?: DeepPartial_104<FileOptions>): FileOptions;
    fromPartial(object: DeepPartial_104<FileOptions>): FileOptions;
};

/** Generated classes can be optimized for speed or code size. */
declare enum FileOptions_OptimizeMode {
    /** SPEED - Generate complete code for parsing, serialization, */
    SPEED = 1,
    /** CODE_SIZE - etc. */
    CODE_SIZE = 2,
    /** LITE_RUNTIME - Generate code using MessageLite and the lite runtime. */
    LITE_RUNTIME = 3,
    UNRECOGNIZED = -1
}

declare function fileOptions_OptimizeModeFromJSON(object: any): FileOptions_OptimizeMode;

declare function fileOptions_OptimizeModeToJSON(object: FileOptions_OptimizeMode): number;

/**
 * A filesystem is a collection of files and directories.
 * This often will be a git repository.
 */
declare interface FileSystem {
    files: File_2[];
}

declare const FileSystem: {
    $type: "devvit.plugin.buildpack.FileSystem";
    encode(message: FileSystem, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FileSystem;
    fromJSON(object: any): FileSystem;
    toJSON(message: FileSystem): unknown;
    create(base?: DeepPartial_22<FileSystem>): FileSystem;
    fromPartial(object: DeepPartial_22<FileSystem>): FileSystem;
};

/**
 * Event types for firehose
 * Also maps directly to the stream name in redis
 */
declare enum FirehoseEvent {
    UNKNOWN_FIREHOSE_EVENT = 0,
    POST_CREATE = 1,
    POST_EDIT = 2,
    POST_DELETE = 3,
    COMMENT_CREATE = 4,
    COMMENT_EDIT = 5,
    COMMENT_DELETE = 6,
    VOTE = 7,
    MOD_ACTION = 8,
    ACCOUNT_DELETE = 9,
    ERROR = 10,
    WARNING = 11,
    POST_APPROVE = 12,
    COMMENT_APPROVE = 13,
    UNRECOGNIZED = -1
}

declare function firehoseEventFromJSON(object: any): FirehoseEvent;

declare function firehoseEventToJSON(object: FirehoseEvent): number;

declare interface FirehoseFilterData {
    event: FirehoseEvent;
    subredditId: string;
    subredditRating: SubredditRating;
    post?: FirehoseFilterData_PostFilterData | undefined;
    comment?: FirehoseFilterData_CommentFilterData | undefined;
    subredditType: SubredditType_2;
}

declare const FirehoseFilterData: {
    $type: "devvit.data.api.v1alpha.FirehoseFilterData";
    encode(message: FirehoseFilterData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FirehoseFilterData;
    fromJSON(object: any): FirehoseFilterData;
    toJSON(message: FirehoseFilterData): unknown;
    create(base?: DeepPartial_112<FirehoseFilterData>): FirehoseFilterData;
    fromPartial(object: DeepPartial_112<FirehoseFilterData>): FirehoseFilterData;
};

/** The approval status for a post or comment */
declare enum FirehoseFilterData_ApprovalStatus {
    UNKNOWN_APPROVAL_STATUS = 0,
    MOD_APPROVED = 1,
    MOD_REMOVED = 2,
    MOD_SPAMMED = 3,
    ADMIN_APPROVED = 4,
    ADMIN_REMOVED = 5,
    ADMIN_SPAMMED = 6,
    AUTHOR_REMOVED = 7,
    AUTHOR_SPAMMED = 8,
    UNRECOGNIZED = -1
}

declare function firehoseFilterData_ApprovalStatusFromJSON(object: any): FirehoseFilterData_ApprovalStatus;

declare function firehoseFilterData_ApprovalStatusToJSON(object: FirehoseFilterData_ApprovalStatus): number;

declare interface FirehoseFilterData_CommentFilterData {
    adminTakedown: boolean;
    abuseScore: number;
    perspectiveScores: {
        [key: string]: number;
    };
    approvalStatus: FirehoseFilterData_ApprovalStatus;
    safetyXTag?: FirehoseFilterData_SafetyTag | undefined;
    safetyVTag?: FirehoseFilterData_SafetyTag | undefined;
    /** custom value set by our own services */
    sexuallyExplicit: boolean;
    mediaIds: string[];
}

declare const FirehoseFilterData_CommentFilterData: {
    $type: "devvit.data.api.v1alpha.FirehoseFilterData.CommentFilterData";
    encode(message: FirehoseFilterData_CommentFilterData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FirehoseFilterData_CommentFilterData;
    fromJSON(object: any): FirehoseFilterData_CommentFilterData;
    toJSON(message: FirehoseFilterData_CommentFilterData): unknown;
    create(base?: DeepPartial_112<FirehoseFilterData_CommentFilterData>): FirehoseFilterData_CommentFilterData;
    fromPartial(object: DeepPartial_112<FirehoseFilterData_CommentFilterData>): FirehoseFilterData_CommentFilterData;
};

declare interface FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry {
    key: string;
    value: number;
}

declare const FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry: {
    $type: "devvit.data.api.v1alpha.FirehoseFilterData.CommentFilterData.PerspectiveScoresEntry";
    encode(message: FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry;
    fromJSON(object: any): FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry;
    toJSON(message: FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry): unknown;
    create(base?: DeepPartial_112<FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry>): FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry;
    fromPartial(object: DeepPartial_112<FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry>): FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry;
};

declare interface FirehoseFilterData_PostFilterData {
    adminTakedown: boolean;
    perspectiveScoresTitle: {
        [key: string]: number;
    };
    perspectiveScoresBody: {
        [key: string]: number;
    };
    safetyXTag?: FirehoseFilterData_SafetyTag | undefined;
    safetyVTag?: FirehoseFilterData_SafetyTag | undefined;
    approvalStatus: FirehoseFilterData_ApprovalStatus;
    /** custom value set by our own services */
    sexuallyExplicit: boolean;
    mediaIds: string[];
    languageCode: string;
}

declare const FirehoseFilterData_PostFilterData: {
    $type: "devvit.data.api.v1alpha.FirehoseFilterData.PostFilterData";
    encode(message: FirehoseFilterData_PostFilterData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FirehoseFilterData_PostFilterData;
    fromJSON(object: any): FirehoseFilterData_PostFilterData;
    toJSON(message: FirehoseFilterData_PostFilterData): unknown;
    create(base?: DeepPartial_112<FirehoseFilterData_PostFilterData>): FirehoseFilterData_PostFilterData;
    fromPartial(object: DeepPartial_112<FirehoseFilterData_PostFilterData>): FirehoseFilterData_PostFilterData;
};

declare interface FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry {
    key: string;
    value: number;
}

declare const FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry: {
    $type: "devvit.data.api.v1alpha.FirehoseFilterData.PostFilterData.PerspectiveScoresBodyEntry";
    encode(message: FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry;
    fromJSON(object: any): FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry;
    toJSON(message: FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry): unknown;
    create(base?: DeepPartial_112<FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry>): FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry;
    fromPartial(object: DeepPartial_112<FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry>): FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry;
};

declare interface FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry {
    key: string;
    value: number;
}

declare const FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry: {
    $type: "devvit.data.api.v1alpha.FirehoseFilterData.PostFilterData.PerspectiveScoresTitleEntry";
    encode(message: FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry;
    fromJSON(object: any): FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry;
    toJSON(message: FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry): unknown;
    create(base?: DeepPartial_112<FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry>): FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry;
    fromPartial(object: DeepPartial_112<FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry>): FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry;
};

declare interface FirehoseFilterData_SafetyTag {
    versions: {
        [key: string]: number;
    };
    score: number;
}

declare const FirehoseFilterData_SafetyTag: {
    $type: "devvit.data.api.v1alpha.FirehoseFilterData.SafetyTag";
    encode(message: FirehoseFilterData_SafetyTag, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FirehoseFilterData_SafetyTag;
    fromJSON(object: any): FirehoseFilterData_SafetyTag;
    toJSON(message: FirehoseFilterData_SafetyTag): unknown;
    create(base?: DeepPartial_112<FirehoseFilterData_SafetyTag>): FirehoseFilterData_SafetyTag;
    fromPartial(object: DeepPartial_112<FirehoseFilterData_SafetyTag>): FirehoseFilterData_SafetyTag;
};

declare interface FirehoseFilterData_SafetyTag_VersionsEntry {
    key: string;
    value: number;
}

declare const FirehoseFilterData_SafetyTag_VersionsEntry: {
    $type: "devvit.data.api.v1alpha.FirehoseFilterData.SafetyTag.VersionsEntry";
    encode(message: FirehoseFilterData_SafetyTag_VersionsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FirehoseFilterData_SafetyTag_VersionsEntry;
    fromJSON(object: any): FirehoseFilterData_SafetyTag_VersionsEntry;
    toJSON(message: FirehoseFilterData_SafetyTag_VersionsEntry): unknown;
    create(base?: DeepPartial_112<FirehoseFilterData_SafetyTag_VersionsEntry>): FirehoseFilterData_SafetyTag_VersionsEntry;
    fromPartial(object: DeepPartial_112<FirehoseFilterData_SafetyTag_VersionsEntry>): FirehoseFilterData_SafetyTag_VersionsEntry;
};

export declare class Flair {
    #private;
}

/** FLAIR - https://www.reddit.com/dev/api#section_flair */
declare interface Flair_2 {
    /** https://www.reddit.com/dev/api#POST_api_clearflairtemplates */
    ClearFlairTemplates(request: ClearFlairTemplatesRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_deleteflair */
    DeleteFlair(request: DeleteFlairRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_deleteflairtemplate */
    DeleteFlairTemplate(request: DeleteFlairTemplateRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_flair */
    Flair(request: FlairRequest, metadata?: Metadata): Promise<JsonStatus>;
    /**
     * https://www.reddit.com/dev/api#PATCH_api_flair_template_order
     * Note: Endpoint expects body as raw array of flair id's
     */
    FlairTemplateOrder(request: FlairTemplateOrderRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_flairconfig */
    FlairConfig(request: FlairConfigRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_flaircsv */
    FlairCsv(request: FlairCsvRequest, metadata?: Metadata): Promise<FlairCsvResponse>;
    /** https://www.reddit.com/dev/api#GET_api_flairlist */
    FlairList(request: FlairListRequest, metadata?: Metadata): Promise<FlairListResponse>;
    /** https://www.reddit.com/dev/api#POST_api_flairselector */
    FlairSelector(request: FlairSelectorRequest, metadata?: Metadata): Promise<FlairSelectorResponse>;
    /**
     * https://www.reddit.com/dev/api#POST_api_flairtemplate_v2
     * Note: We ignore the "v1" implementation of this method
     * Beware: The JSON response to this endpoint is a FlairObject in camelCase, not snake_case
     * like the other responses.
     */
    FlairTemplate(request: FlairTemplateRequest, metadata?: Metadata): Promise<FlairObject>;
    /**
     * https://www.reddit.com/dev/api#GET_api_link_flair_v2
     * Note: We ignore the "v1" implementation of this method
     */
    LinkFlair(request: LinkFlairRequest, metadata?: Metadata): Promise<FlairArray>;
    /** https://www.reddit.com/dev/api#POST_api_selectflair */
    SelectFlair(request: SelectFlairRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_setflairenabled */
    SetFlairEnabled(request: SetFlairEnabledRequest, metadata?: Metadata): Promise<JsonStatus>;
    /**
     * https://www.reddit.com/dev/api#GET_api_user_flair_v2
     * Note: We ignore the "v1" implementation of this method
     */
    UserFlair(request: LinkFlairRequest, metadata?: Metadata): Promise<FlairArray>;
}

declare interface FlairArray {
    flair: FlairObject[];
}

declare const FlairArray: {
    $type: "devvit.plugin.redditapi.flair.FlairArray";
    encode(message: FlairArray, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairArray;
    fromJSON(object: any): FlairArray;
    toJSON(message: FlairArray): unknown;
    create(base?: DeepPartial_56<FlairArray>): FlairArray;
    fromPartial(object: DeepPartial_56<FlairArray>): FlairArray;
};

export declare type FlairBackgroundColor = `#${string}` | 'transparent';

declare class FlairClientImpl implements Flair_2 {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_60, opts?: {
        service?: string;
    });
    ClearFlairTemplates(request: ClearFlairTemplatesRequest, metadata?: Metadata): Promise<JsonStatus>;
    DeleteFlair(request: DeleteFlairRequest, metadata?: Metadata): Promise<JsonStatus>;
    DeleteFlairTemplate(request: DeleteFlairTemplateRequest, metadata?: Metadata): Promise<JsonStatus>;
    Flair(request: FlairRequest, metadata?: Metadata): Promise<JsonStatus>;
    FlairTemplateOrder(request: FlairTemplateOrderRequest, metadata?: Metadata): Promise<Empty>;
    FlairConfig(request: FlairConfigRequest, metadata?: Metadata): Promise<JsonStatus>;
    FlairCsv(request: FlairCsvRequest, metadata?: Metadata): Promise<FlairCsvResponse>;
    FlairList(request: FlairListRequest, metadata?: Metadata): Promise<FlairListResponse>;
    FlairSelector(request: FlairSelectorRequest, metadata?: Metadata): Promise<FlairSelectorResponse>;
    FlairTemplate(request: FlairTemplateRequest, metadata?: Metadata): Promise<FlairObject>;
    LinkFlair(request: LinkFlairRequest, metadata?: Metadata): Promise<FlairArray>;
    SelectFlair(request: SelectFlairRequest, metadata?: Metadata): Promise<JsonStatus>;
    SetFlairEnabled(request: SetFlairEnabledRequest, metadata?: Metadata): Promise<JsonStatus>;
    UserFlair(request: LinkFlairRequest, metadata?: Metadata): Promise<FlairArray>;
}

declare interface FlairConfigRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** is flair enabled? e.g. true/false */
    flairEnabled: boolean;
    /** position of flair e.g. one of (left, right) */
    flairPosition: string;
    /** a boolean value e.g. true/false */
    flairSelfAssignEnabled: boolean;
    /** position of link flair */
    linkFlairPosition: string;
    /** a boolean value e.g. true/false */
    linkFlairSelfAssignEnabled: boolean;
}

declare const FlairConfigRequest: {
    $type: "devvit.plugin.redditapi.flair.FlairConfigRequest";
    encode(message: FlairConfigRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairConfigRequest;
    fromJSON(object: any): FlairConfigRequest;
    toJSON(message: FlairConfigRequest): unknown;
    create(base?: DeepPartial_56<FlairConfigRequest>): FlairConfigRequest;
    fromPartial(object: DeepPartial_56<FlairConfigRequest>): FlairConfigRequest;
};

declare interface FlairCsvRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** flair information, separated by commas */
    flairCsv: string;
}

declare const FlairCsvRequest: {
    $type: "devvit.plugin.redditapi.flair.FlairCsvRequest";
    encode(message: FlairCsvRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairCsvRequest;
    fromJSON(object: any): FlairCsvRequest;
    toJSON(message: FlairCsvRequest): unknown;
    create(base?: DeepPartial_56<FlairCsvRequest>): FlairCsvRequest;
    fromPartial(object: DeepPartial_56<FlairCsvRequest>): FlairCsvRequest;
};

declare interface FlairCsvResponse {
    result: FlairCsvResult[];
}

declare const FlairCsvResponse: {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResponse";
    encode(message: FlairCsvResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairCsvResponse;
    fromJSON(object: any): FlairCsvResponse;
    toJSON(message: FlairCsvResponse): unknown;
    create(base?: DeepPartial_56<FlairCsvResponse>): FlairCsvResponse;
    fromPartial(object: DeepPartial_56<FlairCsvResponse>): FlairCsvResponse;
};

declare interface FlairCsvResult {
    status?: string | undefined;
    ok?: boolean | undefined;
    errors?: FlairCsvResultError | undefined;
    warnings?: FlairCsvResultWarning | undefined;
}

declare const FlairCsvResult: {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResult";
    encode(message: FlairCsvResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairCsvResult;
    fromJSON(object: any): FlairCsvResult;
    toJSON(message: FlairCsvResult): unknown;
    create(base?: DeepPartial_56<FlairCsvResult>): FlairCsvResult;
    fromPartial(object: DeepPartial_56<FlairCsvResult>): FlairCsvResult;
};

/**
 * options derived from this:
 * https://github.snooguts.net/reddit/reddit-public/blob/ec7d110c0be319e68502828a2662b86caca03a3c/r2/r2/controllers/api.py#L8531
 */
declare interface FlairCsvResultError {
    css?: string | undefined;
    row?: string | undefined;
    user?: string | undefined;
}

declare const FlairCsvResultError: {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResultError";
    encode(message: FlairCsvResultError, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairCsvResultError;
    fromJSON(object: any): FlairCsvResultError;
    toJSON(message: FlairCsvResultError): unknown;
    create(base?: DeepPartial_56<FlairCsvResultError>): FlairCsvResultError;
    fromPartial(object: DeepPartial_56<FlairCsvResultError>): FlairCsvResultError;
};

declare interface FlairCsvResultWarning {
    text?: string | undefined;
}

declare const FlairCsvResultWarning: {
    $type: "devvit.plugin.redditapi.flair.FlairCsvResultWarning";
    encode(message: FlairCsvResultWarning, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairCsvResultWarning;
    fromJSON(object: any): FlairCsvResultWarning;
    toJSON(message: FlairCsvResultWarning): unknown;
    create(base?: DeepPartial_56<FlairCsvResultWarning>): FlairCsvResultWarning;
    fromPartial(object: DeepPartial_56<FlairCsvResultWarning>): FlairCsvResultWarning;
};

/** FLAIR - https://www.reddit.com/dev/api#section_flair */
declare type FlairDefinition = typeof FlairDefinition;

declare const FlairDefinition: {
    readonly name: "Flair";
    readonly fullName: "devvit.plugin.redditapi.flair.Flair";
    readonly methods: {
        /** https://www.reddit.com/dev/api#POST_api_clearflairtemplates */
        readonly clearFlairTemplates: {
            readonly name: "ClearFlairTemplates";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.ClearFlairTemplatesRequest";
                encode(message: ClearFlairTemplatesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ClearFlairTemplatesRequest;
                fromJSON(object: any): ClearFlairTemplatesRequest;
                toJSON(message: ClearFlairTemplatesRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    flairType?: string;
                } | undefined): ClearFlairTemplatesRequest;
                fromPartial(object: {
                    subreddit?: string;
                    flairType?: string;
                }): ClearFlairTemplatesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_deleteflair */
        readonly deleteFlair: {
            readonly name: "DeleteFlair";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.DeleteFlairRequest";
                encode(message: DeleteFlairRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DeleteFlairRequest;
                fromJSON(object: any): DeleteFlairRequest;
                toJSON(message: DeleteFlairRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    name?: string;
                } | undefined): DeleteFlairRequest;
                fromPartial(object: {
                    subreddit?: string;
                    name?: string;
                }): DeleteFlairRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_deleteflairtemplate */
        readonly deleteFlairTemplate: {
            readonly name: "DeleteFlairTemplate";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.DeleteFlairTemplateRequest";
                encode(message: DeleteFlairTemplateRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DeleteFlairTemplateRequest;
                fromJSON(object: any): DeleteFlairTemplateRequest;
                toJSON(message: DeleteFlairTemplateRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    flairTemplateId?: string;
                } | undefined): DeleteFlairTemplateRequest;
                fromPartial(object: {
                    subreddit?: string;
                    flairTemplateId?: string;
                }): DeleteFlairTemplateRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_flair */
        readonly flair: {
            readonly name: "Flair";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.FlairRequest";
                encode(message: FlairRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairRequest;
                fromJSON(object: any): FlairRequest;
                toJSON(message: FlairRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    cssClass?: string | undefined;
                    link?: string | undefined;
                    name?: string | undefined;
                    text?: string | undefined;
                } | undefined): FlairRequest;
                fromPartial(object: {
                    subreddit?: string;
                    cssClass?: string | undefined;
                    link?: string | undefined;
                    name?: string | undefined;
                    text?: string | undefined;
                }): FlairRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * https://www.reddit.com/dev/api#PATCH_api_flair_template_order
         * Note: Endpoint expects body as raw array of flair id's
         */
        readonly flairTemplateOrder: {
            readonly name: "FlairTemplateOrder";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.FlairTemplateOrderRequest";
                encode(message: FlairTemplateOrderRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairTemplateOrderRequest;
                fromJSON(object: any): FlairTemplateOrderRequest;
                toJSON(message: FlairTemplateOrderRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    flairType?: string;
                    order?: string[];
                } | undefined): FlairTemplateOrderRequest;
                fromPartial(object: {
                    subreddit?: string;
                    flairType?: string;
                    order?: string[];
                }): FlairTemplateOrderRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api#POST_api_flairconfig */
        readonly flairConfig: {
            readonly name: "FlairConfig";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.FlairConfigRequest";
                encode(message: FlairConfigRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairConfigRequest;
                fromJSON(object: any): FlairConfigRequest;
                toJSON(message: FlairConfigRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    flairEnabled?: boolean;
                    flairPosition?: string;
                    flairSelfAssignEnabled?: boolean;
                    linkFlairPosition?: string;
                    linkFlairSelfAssignEnabled?: boolean;
                } | undefined): FlairConfigRequest;
                fromPartial(object: {
                    subreddit?: string;
                    flairEnabled?: boolean;
                    flairPosition?: string;
                    flairSelfAssignEnabled?: boolean;
                    linkFlairPosition?: string;
                    linkFlairSelfAssignEnabled?: boolean;
                }): FlairConfigRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_flaircsv */
        readonly flairCsv: {
            readonly name: "FlairCsv";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.FlairCsvRequest";
                encode(message: FlairCsvRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairCsvRequest;
                fromJSON(object: any): FlairCsvRequest;
                toJSON(message: FlairCsvRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    flairCsv?: string;
                } | undefined): FlairCsvRequest;
                fromPartial(object: {
                    subreddit?: string;
                    flairCsv?: string;
                }): FlairCsvRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.flair.FlairCsvResponse";
                encode(message: FlairCsvResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairCsvResponse;
                fromJSON(object: any): FlairCsvResponse;
                toJSON(message: FlairCsvResponse): unknown;
                create(base?: {
                    result?: {
                        status?: string | undefined;
                        ok?: boolean | undefined;
                        errors?: {
                            css?: string | undefined;
                            row?: string | undefined;
                            user?: string | undefined;
                        } | undefined;
                        warnings?: {
                            text?: string | undefined;
                        } | undefined;
                    }[];
                } | undefined): FlairCsvResponse;
                fromPartial(object: {
                    result?: {
                        status?: string | undefined;
                        ok?: boolean | undefined;
                        errors?: {
                            css?: string | undefined;
                            row?: string | undefined;
                            user?: string | undefined;
                        } | undefined;
                        warnings?: {
                            text?: string | undefined;
                        } | undefined;
                    }[];
                }): FlairCsvResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_flairlist */
        readonly flairList: {
            readonly name: "FlairList";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.FlairListRequest";
                encode(message: FlairListRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairListRequest;
                fromJSON(object: any): FlairListRequest;
                toJSON(message: FlairListRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    name?: string | undefined;
                    show?: string | undefined;
                } | undefined): FlairListRequest;
                fromPartial(object: {
                    subreddit?: string;
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    name?: string | undefined;
                    show?: string | undefined;
                }): FlairListRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.flair.FlairListResponse";
                encode(message: FlairListResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairListResponse;
                fromJSON(object: any): FlairListResponse;
                toJSON(message: FlairListResponse): unknown;
                create(base?: {
                    users?: {
                        flairCssClass?: string | undefined;
                        user?: string | undefined;
                        flairText?: string | undefined;
                    }[];
                    next?: string | undefined;
                    prev?: string | undefined;
                } | undefined): FlairListResponse;
                fromPartial(object: {
                    users?: {
                        flairCssClass?: string | undefined;
                        user?: string | undefined;
                        flairText?: string | undefined;
                    }[];
                    next?: string | undefined;
                    prev?: string | undefined;
                }): FlairListResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_flairselector */
        readonly flairSelector: {
            readonly name: "FlairSelector";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.FlairSelectorRequest";
                encode(message: FlairSelectorRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairSelectorRequest;
                fromJSON(object: any): FlairSelectorRequest;
                toJSON(message: FlairSelectorRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    isNewlink?: boolean;
                    link?: string | undefined;
                    name?: string;
                } | undefined): FlairSelectorRequest;
                fromPartial(object: {
                    subreddit?: string;
                    isNewlink?: boolean;
                    link?: string | undefined;
                    name?: string;
                }): FlairSelectorRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.flair.FlairSelectorResponse";
                encode(message: FlairSelectorResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairSelectorResponse;
                fromJSON(object: any): FlairSelectorResponse;
                toJSON(message: FlairSelectorResponse): unknown;
                create(base?: {
                    current?: {
                        flairCssClass?: string | undefined;
                        flairTemplateId?: string | undefined;
                        flairText?: string | undefined;
                        flairTextEditable?: boolean | undefined;
                        flairPosition?: string | undefined;
                    } | undefined;
                    choices?: {
                        flairCssClass?: string | undefined;
                        flairTemplateId?: string | undefined;
                        flairText?: string | undefined;
                        flairTextEditable?: boolean | undefined;
                        flairPosition?: string | undefined;
                    }[];
                } | undefined): FlairSelectorResponse;
                fromPartial(object: {
                    current?: {
                        flairCssClass?: string | undefined;
                        flairTemplateId?: string | undefined;
                        flairText?: string | undefined;
                        flairTextEditable?: boolean | undefined;
                        flairPosition?: string | undefined;
                    } | undefined;
                    choices?: {
                        flairCssClass?: string | undefined;
                        flairTemplateId?: string | undefined;
                        flairText?: string | undefined;
                        flairTextEditable?: boolean | undefined;
                        flairPosition?: string | undefined;
                    }[];
                }): FlairSelectorResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * https://www.reddit.com/dev/api#POST_api_flairtemplate_v2
         * Note: We ignore the "v1" implementation of this method
         * Beware: The JSON response to this endpoint is a FlairObject in camelCase, not snake_case
         * like the other responses.
         */
        readonly flairTemplate: {
            readonly name: "FlairTemplate";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.FlairTemplateRequest";
                encode(message: FlairTemplateRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairTemplateRequest;
                fromJSON(object: any): FlairTemplateRequest;
                toJSON(message: FlairTemplateRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    allowableContent?: string;
                    backgroundColor?: string;
                    cssClass?: string;
                    flairTemplateId?: string;
                    flairType?: string;
                    maxEmojis?: number;
                    modOnly?: boolean;
                    overrideCss?: boolean;
                    text?: string;
                    textColor?: string;
                    textEditable?: boolean;
                } | undefined): FlairTemplateRequest;
                fromPartial(object: {
                    subreddit?: string;
                    allowableContent?: string;
                    backgroundColor?: string;
                    cssClass?: string;
                    flairTemplateId?: string;
                    flairType?: string;
                    maxEmojis?: number;
                    modOnly?: boolean;
                    overrideCss?: boolean;
                    text?: string;
                    textColor?: string;
                    textEditable?: boolean;
                }): FlairTemplateRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.flair.FlairObject";
                encode(message: FlairObject, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairObject;
                fromJSON(object: any): FlairObject;
                toJSON(message: FlairObject): unknown;
                create(base?: {
                    allowableContent?: string | undefined;
                    text?: string | undefined;
                    textColor?: string | undefined;
                    modOnly?: boolean;
                    backgroundColor?: string | undefined;
                    id?: string | undefined;
                    cssClass?: string | undefined;
                    maxEmojis?: number;
                    richtext?: string[];
                    textEditable?: boolean;
                    overrideCss?: boolean;
                    type?: string | undefined;
                    flairType?: string | undefined;
                } | undefined): FlairObject;
                fromPartial(object: {
                    allowableContent?: string | undefined;
                    text?: string | undefined;
                    textColor?: string | undefined;
                    modOnly?: boolean;
                    backgroundColor?: string | undefined;
                    id?: string | undefined;
                    cssClass?: string | undefined;
                    maxEmojis?: number;
                    richtext?: string[];
                    textEditable?: boolean;
                    overrideCss?: boolean;
                    type?: string | undefined;
                    flairType?: string | undefined;
                }): FlairObject;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * https://www.reddit.com/dev/api#GET_api_link_flair_v2
         * Note: We ignore the "v1" implementation of this method
         */
        readonly linkFlair: {
            readonly name: "LinkFlair";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.LinkFlairRequest";
                encode(message: LinkFlairRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): LinkFlairRequest;
                fromJSON(object: any): LinkFlairRequest;
                toJSON(message: LinkFlairRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): LinkFlairRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): LinkFlairRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.flair.FlairArray";
                encode(message: FlairArray, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairArray;
                fromJSON(object: any): FlairArray;
                toJSON(message: FlairArray): unknown;
                create(base?: {
                    flair?: {
                        allowableContent?: string | undefined;
                        text?: string | undefined;
                        textColor?: string | undefined;
                        modOnly?: boolean;
                        backgroundColor?: string | undefined;
                        id?: string | undefined;
                        cssClass?: string | undefined;
                        maxEmojis?: number;
                        richtext?: string[];
                        textEditable?: boolean;
                        overrideCss?: boolean;
                        type?: string | undefined;
                        flairType?: string | undefined;
                    }[];
                } | undefined): FlairArray;
                fromPartial(object: {
                    flair?: {
                        allowableContent?: string | undefined;
                        text?: string | undefined;
                        textColor?: string | undefined;
                        modOnly?: boolean;
                        backgroundColor?: string | undefined;
                        id?: string | undefined;
                        cssClass?: string | undefined;
                        maxEmojis?: number;
                        richtext?: string[];
                        textEditable?: boolean;
                        overrideCss?: boolean;
                        type?: string | undefined;
                        flairType?: string | undefined;
                    }[];
                }): FlairArray;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api#POST_api_selectflair */
        readonly selectFlair: {
            readonly name: "SelectFlair";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.SelectFlairRequest";
                encode(message: SelectFlairRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SelectFlairRequest;
                fromJSON(object: any): SelectFlairRequest;
                toJSON(message: SelectFlairRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    backgroundColor?: string;
                    cssClass?: string;
                    flairTemplateId?: string;
                    link?: string;
                    name?: string;
                    returnRtjson?: string;
                    text?: string;
                    textColor?: string;
                } | undefined): SelectFlairRequest;
                fromPartial(object: {
                    subreddit?: string;
                    backgroundColor?: string;
                    cssClass?: string;
                    flairTemplateId?: string;
                    link?: string;
                    name?: string;
                    returnRtjson?: string;
                    text?: string;
                    textColor?: string;
                }): SelectFlairRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_setflairenabled */
        readonly setFlairEnabled: {
            readonly name: "SetFlairEnabled";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.SetFlairEnabledRequest";
                encode(message: SetFlairEnabledRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SetFlairEnabledRequest;
                fromJSON(object: any): SetFlairEnabledRequest;
                toJSON(message: SetFlairEnabledRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    flairEnabled?: boolean;
                } | undefined): SetFlairEnabledRequest;
                fromPartial(object: {
                    subreddit?: string;
                    flairEnabled?: boolean;
                }): SetFlairEnabledRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * https://www.reddit.com/dev/api#GET_api_user_flair_v2
         * Note: We ignore the "v1" implementation of this method
         */
        readonly userFlair: {
            readonly name: "UserFlair";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.LinkFlairRequest";
                encode(message: LinkFlairRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): LinkFlairRequest;
                fromJSON(object: any): LinkFlairRequest;
                toJSON(message: LinkFlairRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): LinkFlairRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): LinkFlairRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.flair.FlairArray";
                encode(message: FlairArray, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FlairArray;
                fromJSON(object: any): FlairArray;
                toJSON(message: FlairArray): unknown;
                create(base?: {
                    flair?: {
                        allowableContent?: string | undefined;
                        text?: string | undefined;
                        textColor?: string | undefined;
                        modOnly?: boolean;
                        backgroundColor?: string | undefined;
                        id?: string | undefined;
                        cssClass?: string | undefined;
                        maxEmojis?: number;
                        richtext?: string[];
                        textEditable?: boolean;
                        overrideCss?: boolean;
                        type?: string | undefined;
                        flairType?: string | undefined;
                    }[];
                } | undefined): FlairArray;
                fromPartial(object: {
                    flair?: {
                        allowableContent?: string | undefined;
                        text?: string | undefined;
                        textColor?: string | undefined;
                        modOnly?: boolean;
                        backgroundColor?: string | undefined;
                        id?: string | undefined;
                        cssClass?: string | undefined;
                        maxEmojis?: number;
                        richtext?: string[];
                        textEditable?: boolean;
                        overrideCss?: boolean;
                        type?: string | undefined;
                        flairType?: string | undefined;
                    }[];
                }): FlairArray;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare interface FlairListRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** thing id e.g. t3_15bfi0 */
    after?: string | undefined;
    /** thing id e.g. t3_15bfi0 */
    before?: string | undefined;
    /** a positive integer (default: 0) */
    count?: number | undefined;
    /** the maximum number of items desired (default: 25, maximum: 1000) */
    limit?: number | undefined;
    /** a user by name */
    name?: string | undefined;
    /** (optional) the string "all" */
    show?: string | undefined;
}

declare const FlairListRequest: {
    $type: "devvit.plugin.redditapi.flair.FlairListRequest";
    encode(message: FlairListRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairListRequest;
    fromJSON(object: any): FlairListRequest;
    toJSON(message: FlairListRequest): unknown;
    create(base?: DeepPartial_56<FlairListRequest>): FlairListRequest;
    fromPartial(object: DeepPartial_56<FlairListRequest>): FlairListRequest;
};

declare interface FlairListResponse {
    users: UserFlair_2[];
    next?: string | undefined;
    prev?: string | undefined;
}

declare const FlairListResponse: {
    $type: "devvit.plugin.redditapi.flair.FlairListResponse";
    encode(message: FlairListResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairListResponse;
    fromJSON(object: any): FlairListResponse;
    toJSON(message: FlairListResponse): unknown;
    create(base?: DeepPartial_56<FlairListResponse>): FlairListResponse;
    fromPartial(object: DeepPartial_56<FlairListResponse>): FlairListResponse;
};

declare interface FlairObject {
    allowableContent?: string | undefined;
    text?: string | undefined;
    textColor?: string | undefined;
    modOnly: boolean;
    backgroundColor?: string | undefined;
    id?: string | undefined;
    cssClass?: string | undefined;
    maxEmojis: number;
    richtext: string[];
    textEditable: boolean;
    overrideCss: boolean;
    type?: string | undefined;
    flairType?: string | undefined;
}

declare const FlairObject: {
    $type: "devvit.plugin.redditapi.flair.FlairObject";
    encode(message: FlairObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairObject;
    fromJSON(object: any): FlairObject;
    toJSON(message: FlairObject): unknown;
    create(base?: DeepPartial_56<FlairObject>): FlairObject;
    fromPartial(object: DeepPartial_56<FlairObject>): FlairObject;
};

declare interface FlairRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** a valid subreddit image name */
    cssClass?: string | undefined;
    /** the thing id of a link e.g. t3_15bfi0 */
    link?: string | undefined;
    /** a user by name */
    name?: string | undefined;
    /** a string no longer than 64 characters */
    text?: string | undefined;
}

declare const FlairRequest: {
    $type: "devvit.plugin.redditapi.flair.FlairRequest";
    encode(message: FlairRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairRequest;
    fromJSON(object: any): FlairRequest;
    toJSON(message: FlairRequest): unknown;
    create(base?: DeepPartial_56<FlairRequest>): FlairRequest;
    fromPartial(object: DeepPartial_56<FlairRequest>): FlairRequest;
};

declare interface FlairSelectorRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** is it a new link e.g. true/false */
    isNewlink: boolean;
    /** the thing id of a link e.g. t3_15bfi0 */
    link?: string | undefined;
    /** a user by name */
    name: string;
}

declare const FlairSelectorRequest: {
    $type: "devvit.plugin.redditapi.flair.FlairSelectorRequest";
    encode(message: FlairSelectorRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairSelectorRequest;
    fromJSON(object: any): FlairSelectorRequest;
    toJSON(message: FlairSelectorRequest): unknown;
    create(base?: DeepPartial_56<FlairSelectorRequest>): FlairSelectorRequest;
    fromPartial(object: DeepPartial_56<FlairSelectorRequest>): FlairSelectorRequest;
};

declare interface FlairSelectorResponse {
    current?: FlairSelectorResponseOption | undefined;
    choices: FlairSelectorResponseOption[];
}

declare const FlairSelectorResponse: {
    $type: "devvit.plugin.redditapi.flair.FlairSelectorResponse";
    encode(message: FlairSelectorResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairSelectorResponse;
    fromJSON(object: any): FlairSelectorResponse;
    toJSON(message: FlairSelectorResponse): unknown;
    create(base?: DeepPartial_56<FlairSelectorResponse>): FlairSelectorResponse;
    fromPartial(object: DeepPartial_56<FlairSelectorResponse>): FlairSelectorResponse;
};

declare interface FlairSelectorResponseOption {
    flairCssClass?: string | undefined;
    flairTemplateId?: string | undefined;
    flairText?: string | undefined;
    flairTextEditable?: boolean | undefined;
    flairPosition?: string | undefined;
}

declare const FlairSelectorResponseOption: {
    $type: "devvit.plugin.redditapi.flair.FlairSelectorResponseOption";
    encode(message: FlairSelectorResponseOption, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairSelectorResponseOption;
    fromJSON(object: any): FlairSelectorResponseOption;
    toJSON(message: FlairSelectorResponseOption): unknown;
    create(base?: DeepPartial_56<FlairSelectorResponseOption>): FlairSelectorResponseOption;
    fromPartial(object: DeepPartial_56<FlairSelectorResponseOption>): FlairSelectorResponseOption;
};

declare const FlairServiceName = "devvit.plugin.redditapi.flair.Flair";

export declare type FlairSettings = {
    enabled: boolean;
    usersCanAssign: boolean;
};

export declare class FlairTemplate {
    #private;
    /** The flair template's ID */
    get id(): string;
    /** The flair template's text */
    get text(): string;
    /** The flair template's text color. Either 'dark' or 'light'. */
    get textColor(): FlairTextColor;
    /** The flair template's background color. Either 'transparent' or a hex color code. e.g. #FFC0CB */
    get backgroundColor(): FlairBackgroundColor;
    /** The flair template's allowable content. Either 'all', 'emoji', or 'text'. */
    get allowableContent(): AllowableFlairContent;
    /** Is the flair template only available to moderators? */
    get modOnly(): boolean;
    /** The flair template's maximum number of emojis. */
    get maxEmojis(): number;
    /** Does the flair template allow users to edit their flair? */
    get allowUserEdits(): boolean;
    /** Delete this flair template */
    delete(): Promise<void>;
    /** Edit this flair template */
    edit(options: Partial<Omit<EditFlairTemplateOptions, 'id' | 'subredditName'>>): Promise<FlairTemplate>;
}

declare interface FlairTemplateOrderRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** one of (USER_FLAIR, LINK_FLAIR) */
    flairType: string;
    order: string[];
}

declare const FlairTemplateOrderRequest: {
    $type: "devvit.plugin.redditapi.flair.FlairTemplateOrderRequest";
    encode(message: FlairTemplateOrderRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairTemplateOrderRequest;
    fromJSON(object: any): FlairTemplateOrderRequest;
    toJSON(message: FlairTemplateOrderRequest): unknown;
    create(base?: DeepPartial_56<FlairTemplateOrderRequest>): FlairTemplateOrderRequest;
    fromPartial(object: DeepPartial_56<FlairTemplateOrderRequest>): FlairTemplateOrderRequest;
};

declare interface FlairTemplateRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** one of (all, emoji, text) */
    allowableContent: string;
    /** a 6-digit rgb hex color, e.g. #AABBCC */
    backgroundColor: string;
    /** a valid subreddit image name */
    cssClass: string;
    /** no-op */
    flairTemplateId: string;
    /** one of (USER_FLAIR, LINK_FLAIR) */
    flairType: string;
    /** an integer between 1 and 10 (default: 10) */
    maxEmojis: number;
    /** a boolean value */
    modOnly: boolean;
    /** no-op */
    overrideCss: boolean;
    /** a string no longer than 64 characters */
    text: string;
    /** one of (light, dark) */
    textColor: string;
    /** is this text editable? e.g. true/false */
    textEditable: boolean;
}

declare const FlairTemplateRequest: {
    $type: "devvit.plugin.redditapi.flair.FlairTemplateRequest";
    encode(message: FlairTemplateRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FlairTemplateRequest;
    fromJSON(object: any): FlairTemplateRequest;
    toJSON(message: FlairTemplateRequest): unknown;
    create(base?: DeepPartial_56<FlairTemplateRequest>): FlairTemplateRequest;
    fromPartial(object: DeepPartial_56<FlairTemplateRequest>): FlairTemplateRequest;
};

export declare type FlairTextColor = 'light' | 'dark';

export declare enum FlairType {
    User = "USER_FLAIR",
    Post = "LINK_FLAIR"
}

/**
 * Wrapper message for `float`.
 *
 * The JSON representation for `FloatValue` is JSON number.
 */
declare interface FloatValue {
    /** The float value. */
    value: number;
}

declare const FloatValue: {
    $type: "google.protobuf.FloatValue";
    encode(message: FloatValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FloatValue;
    fromJSON(object: any): FloatValue;
    toJSON(message: FloatValue): unknown;
    create(base?: DeepPartial_69<FloatValue>): FloatValue;
    fromPartial(object: DeepPartial_69<FloatValue>): FloatValue;
};

declare interface FollowCollectionRequest {
    /** The id of the collection. */
    collectionId?: string | undefined;
    /** One of: true | false. Indicating whether the collection should be followed or unfollowed. */
    follow?: boolean | undefined;
}

declare const FollowCollectionRequest: {
    $type: "devvit.plugin.redditapi.postcollections.FollowCollectionRequest";
    encode(message: FollowCollectionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FollowCollectionRequest;
    fromJSON(object: any): FollowCollectionRequest;
    toJSON(message: FollowCollectionRequest): unknown;
    create(base?: DeepPartial_81<FollowCollectionRequest>): FollowCollectionRequest;
    fromPartial(object: DeepPartial_81<FollowCollectionRequest>): FollowCollectionRequest;
};

declare interface FollowPostRequest {
    /** `true` to follow; `false` to unfollow */
    follow: boolean;
    /**
     * Post thing ID
     * @example "t3_abc123"
     */
    fullname: string;
}

declare const FollowPostRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.FollowPostRequest";
    encode(message: FollowPostRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FollowPostRequest;
    fromJSON(object: any): FollowPostRequest;
    toJSON(message: FollowPostRequest): unknown;
    create(base?: DeepPartial_64<FollowPostRequest>): FollowPostRequest;
    fromPartial(object: DeepPartial_64<FollowPostRequest>): FollowPostRequest;
};

export declare type Form = {
    /** The fields that will be displayed in the form */
    fields: FormField[];
    /** An optional title for the form */
    title?: string;
    /** An optional description for the form */
    description?: string;
    /** An optional label for the submit button */
    acceptLabel?: string;
    /** An optional label for the cancel button */
    cancelLabel?: string;
};

declare interface Form_2 {
    fields: FormField_2[];
    /** Title to display on the form */
    title?: string | undefined;
    /** Short description explaining the purpose of the form */
    shortDescription?: string | undefined;
    /** Alternate text to display on the "OK" button */
    acceptLabel?: string | undefined;
    /** Alternate text to display on the "Cancel" button */
    cancelLabel?: string | undefined;
    /** Unique ID for this form, to help differentiate results if managing more than one form at a time */
    id?: string | undefined;
}

declare const Form_2: {
    $type: "devvit.ui.form_builder.v1alpha.Form";
    encode(message: Form_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Form_2;
    fromJSON(object: any): Form_2;
    toJSON(message: Form_2): unknown;
    create(base?: DeepPartial_18<Form_2>): Form_2;
    fromPartial(object: DeepPartial_18<Form_2>): Form_2;
};

declare type FormatRange = [
FormattingSpecification,
number,
number
];

declare type FormattingSpecification = number;

export declare type FormDefinition = {
    /** A form or a function that returns a form */
    form: Form | FormFunction;
    /** A callback that will be invoked when the form is submitted */
    onSubmit: FormOnSubmitEventHandler;
};

export declare type FormField = StringField | ImageField | ParagraphField | NumberField | BooleanField | SelectField | FormFieldGroup;

/** The base type */
declare interface FormField_2 {
    /** Unique ID within the actor or app */
    fieldId: string;
    /** Field type */
    fieldType: FormFieldType;
    /** Text to display above the input field */
    label: string;
    /** Additional description to help the user */
    helpText?: string | undefined;
    /** Default/initial value */
    defaultValue?: FormFieldValue | undefined;
    /** Whether or not this field is required to submit the form */
    required?: boolean | undefined;
    /** If true, disable the input */
    disabled?: boolean | undefined;
    /** Additional field configuration */
    fieldConfig?: FieldConfig | undefined;
    /** If true, this field is some sort of API key or password */
    isSecret?: boolean | undefined;
}

declare const FormField_2: {
    $type: "devvit.ui.form_builder.v1alpha.FormField";
    encode(message: FormField_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FormField_2;
    fromJSON(object: any): FormField_2;
    toJSON(message: FormField_2): unknown;
    create(base?: DeepPartial_10<FormField_2>): FormField_2;
    fromPartial(object: DeepPartial_10<FormField_2>): FormField_2;
};

/** A grouping of fields */
export declare type FormFieldGroup = {
    type: 'group';
    /** The label of the group that will be displayed to the user */
    label: string;
    /** The fields that will be displayed in the group */
    fields: FormField[];
    /** An optional help text that will be displayed below the group */
    helpText?: string | undefined;
};

declare enum FormFieldType {
    /** STRING - Single-line string */
    STRING = 0,
    /** PARAGRAPH - Multi-line string */
    PARAGRAPH = 1,
    /** NUMBER - Number input */
    NUMBER = 2,
    /** BOOLEAN - Checkbox, switch */
    BOOLEAN = 3,
    /** LIST - Collect multiple entries of a single type */
    LIST = 4,
    /** SELECTION - Provide a list of options for the user to choose from */
    SELECTION = 5,
    /** GROUP - Create a labeled subsection of the form with nested fields */
    GROUP = 6,
    /** IMAGE - Image upload - value is a URL for the uploaded image */
    IMAGE = 7,
    UNRECOGNIZED = -1
}

declare function formFieldTypeFromJSON(object: any): FormFieldType;

declare function formFieldTypeToJSON(object: FormFieldType): number;

declare interface FormFieldValue {
    /** The type as configured in the corresponding FormField */
    fieldType: FormFieldType;
    /** If true this value comes from a FormField that was defined as a secret */
    isSecret?: boolean | undefined;
    /** For: STRING, PARAGRAPH, IMAGE (the URL) */
    stringValue?: string | undefined;
    /** For: NUMBER */
    numberValue?: number | undefined;
    /** For: BOOLEAN */
    boolValue?: boolean | undefined;
    /** For: LIST */
    listValue?: FormFieldValue_ListValue | undefined;
    /** For: SELECTION */
    selectionValue?: FormFieldValue_SelectionValue | undefined;
    /** For: GROUP */
    groupValue?: FormFieldValue_GroupValue | undefined;
}

declare const FormFieldValue: {
    $type: "devvit.ui.form_builder.v1alpha.FormFieldValue";
    encode(message: FormFieldValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FormFieldValue;
    fromJSON(object: any): FormFieldValue;
    toJSON(message: FormFieldValue): unknown;
    create(base?: DeepPartial_17<FormFieldValue>): FormFieldValue;
    fromPartial(object: DeepPartial_17<FormFieldValue>): FormFieldValue;
};

/** Group does not have a value */
declare interface FormFieldValue_GroupValue {
}

declare const FormFieldValue_GroupValue: {
    $type: "devvit.ui.form_builder.v1alpha.FormFieldValue.GroupValue";
    encode(_: FormFieldValue_GroupValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FormFieldValue_GroupValue;
    fromJSON(_: any): FormFieldValue_GroupValue;
    toJSON(_: FormFieldValue_GroupValue): unknown;
    create(base?: DeepPartial_17<FormFieldValue_GroupValue>): FormFieldValue_GroupValue;
    fromPartial(_: DeepPartial_17<FormFieldValue_GroupValue>): FormFieldValue_GroupValue;
};

declare interface FormFieldValue_ListValue {
    /** The type as configured in the corresponding FieldConfig */
    itemType: FormFieldType;
    items: FormFieldValue[];
}

declare const FormFieldValue_ListValue: {
    $type: "devvit.ui.form_builder.v1alpha.FormFieldValue.ListValue";
    encode(message: FormFieldValue_ListValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FormFieldValue_ListValue;
    fromJSON(object: any): FormFieldValue_ListValue;
    toJSON(message: FormFieldValue_ListValue): unknown;
    create(base?: DeepPartial_17<FormFieldValue_ListValue>): FormFieldValue_ListValue;
    fromPartial(object: DeepPartial_17<FormFieldValue_ListValue>): FormFieldValue_ListValue;
};

declare interface FormFieldValue_SelectionValue {
    /** One or more values from the choices defined in the Selection config. */
    values: string[];
}

declare const FormFieldValue_SelectionValue: {
    $type: "devvit.ui.form_builder.v1alpha.FormFieldValue.SelectionValue";
    encode(message: FormFieldValue_SelectionValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FormFieldValue_SelectionValue;
    fromJSON(object: any): FormFieldValue_SelectionValue;
    toJSON(message: FormFieldValue_SelectionValue): unknown;
    create(base?: DeepPartial_17<FormFieldValue_SelectionValue>): FormFieldValue_SelectionValue;
    fromPartial(object: DeepPartial_17<FormFieldValue_SelectionValue>): FormFieldValue_SelectionValue;
};

/**
 * A function that returns a form. You can use this to dynamically generate a form.
 * @example
 * ```ts
 * const formKey = Devvit.createForm((data) => ({
 *   fields: data.fields,
 *   title: data.title,
 * }), callback);
 *
 * ...
 *
 * ui.showForm(formKey, {
 *  fields: [{ type: 'string', name: 'title', label: 'Title' }]
 *  title: 'My dynamic form'
 * });
 * ```
 * */
export declare type FormFunction = (data: Data) => Form;

/** A unique key generated by `Devvit.createForm` or the `useForm` hook. */
export declare type FormKey = `form.${number}` | `form.hook.${string}.${number}`;

export declare type FormOnSubmitEvent = {
    /** The form values that were submitted */
    values: FormValues;
};

export declare type FormOnSubmitEventHandler = (
/** The event object containing the results of the form submission */
event: FormOnSubmitEvent, 
/** The current app context of the form submission event */
context: Devvit.Context) => void | Promise<void>;

declare interface FormResponse {
    success: boolean;
    messages: string[];
}

declare const FormResponse: {
    $type: "devvit.actor.user_configurable.FormResponse";
    encode(message: FormResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FormResponse;
    fromJSON(object: any): FormResponse;
    toJSON(message: FormResponse): unknown;
    create(base?: DeepPartial_29<FormResponse>): FormResponse;
    fromPartial(object: DeepPartial_29<FormResponse>): FormResponse;
};

/** Form results */
declare interface FormSubmittedEvent {
    results: {
        [key: string]: FormFieldValue;
    };
    formId?: string | undefined;
}

declare const FormSubmittedEvent: {
    $type: "devvit.ui.effects.v1alpha.FormSubmittedEvent";
    encode(message: FormSubmittedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FormSubmittedEvent;
    fromJSON(object: any): FormSubmittedEvent;
    toJSON(message: FormSubmittedEvent): unknown;
    create(base?: DeepPartial_34<FormSubmittedEvent>): FormSubmittedEvent;
    fromPartial(object: DeepPartial_34<FormSubmittedEvent>): FormSubmittedEvent;
};

declare interface FormSubmittedEvent_ResultsEntry {
    key: string;
    value?: FormFieldValue | undefined;
}

declare const FormSubmittedEvent_ResultsEntry: {
    $type: "devvit.ui.effects.v1alpha.FormSubmittedEvent.ResultsEntry";
    encode(message: FormSubmittedEvent_ResultsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FormSubmittedEvent_ResultsEntry;
    fromJSON(object: any): FormSubmittedEvent_ResultsEntry;
    toJSON(message: FormSubmittedEvent_ResultsEntry): unknown;
    create(base?: DeepPartial_34<FormSubmittedEvent_ResultsEntry>): FormSubmittedEvent_ResultsEntry;
    fromPartial(object: DeepPartial_34<FormSubmittedEvent_ResultsEntry>): FormSubmittedEvent_ResultsEntry;
};

export declare type FormValues = Data;

declare interface FriendRequest {
    /** thing id e.g. 't3_15bfi0' */
    banContext?: string | undefined;
    /** raw markdown text */
    banMessage?: string | undefined;
    /** a string no longer than 100 characters */
    banReason?: string | undefined;
    /** an integer between 1 and 999 */
    duration?: number | undefined;
    /** the name of an existing user */
    name: string;
    /** a string no longer than 300 characters */
    note?: string | undefined;
    permissions?: string | undefined;
    /** one of (friend, moderator, moderator_invite, contributor, banned, muted, wikibanned, wikicontributor) */
    type: string;
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit?: string | undefined;
}

declare const FriendRequest: {
    $type: "devvit.plugin.redditapi.users.FriendRequest";
    encode(message: FriendRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FriendRequest;
    fromJSON(object: any): FriendRequest;
    toJSON(message: FriendRequest): unknown;
    create(base?: DeepPartial_100<FriendRequest>): FriendRequest;
    fromPartial(object: DeepPartial_100<FriendRequest>): FriendRequest;
};

declare interface FullSubredditObject {
    userFlairBackgroundColor?: string | undefined;
    submitTextHtml?: string | undefined;
    restrictPosting?: boolean | undefined;
    userIsBanned?: boolean | undefined;
    freeFormReports?: boolean | undefined;
    wikiEnabled?: boolean | undefined;
    userIsMuted?: boolean | undefined;
    userCanFlairInSr?: boolean | undefined;
    displayName?: string | undefined;
    headerImg?: string | undefined;
    title?: string | undefined;
    allowGalleries?: boolean | undefined;
    iconSize: number[];
    primaryColor?: string | undefined;
    activeUserCount?: number | undefined;
    iconImg?: string | undefined;
    displayNamePrefixed?: string | undefined;
    accountsActive?: number | undefined;
    publicTraffic?: boolean | undefined;
    subscribers?: number | undefined;
    userFlairRichtext: string[];
    videostreamLinksCount?: number | undefined;
    name?: string | undefined;
    quarantine?: boolean | undefined;
    hideAds?: boolean | undefined;
    emojisEnabled?: boolean | undefined;
    advertiserCategory?: string | undefined;
    publicDescription?: string | undefined;
    commentScoreHideMins?: number | undefined;
    allowPredictions?: boolean | undefined;
    userHasFavorited?: boolean | undefined;
    userFlairTemplateId?: string | undefined;
    communityIcon?: string | undefined;
    bannerBackgroundImage?: string | undefined;
    originalContentTagEnabled?: boolean | undefined;
    communityReviewed?: boolean | undefined;
    submitText?: string | undefined;
    descriptionHtml?: string | undefined;
    spoilersEnabled?: boolean | undefined;
    commentContributionSettings?: CommentContributionSettings | undefined;
    allowTalks?: boolean | undefined;
    headerSize: number[];
    userFlairPosition?: string | undefined;
    allOriginalContent?: boolean | undefined;
    hasMenuWidget?: boolean | undefined;
    isEnrolledInNewModmail?: boolean | undefined;
    keyColor?: string | undefined;
    canAssignUserFlair?: boolean | undefined;
    created?: number | undefined;
    wls?: number | undefined;
    showMediaPreview?: boolean | undefined;
    submissionType?: string | undefined;
    userIsSubscriber?: boolean | undefined;
    allowedMediaInComments: string[];
    allowVideogifs?: boolean | undefined;
    shouldArchivePosts?: boolean | undefined;
    userFlairType?: string | undefined;
    allowPolls?: boolean | undefined;
    collapseDeletedComments?: boolean | undefined;
    emojisCustomSize: number[];
    publicDescriptionHtml?: string | undefined;
    allowVideos?: boolean | undefined;
    isCrosspostableSubreddit?: boolean | undefined;
    notificationLevel?: string | undefined;
    shouldShowMediaInCommentsSetting?: boolean | undefined;
    canAssignLinkFlair?: boolean | undefined;
    accountsActiveIsFuzzed?: boolean | undefined;
    allowPredictionContributors?: boolean | undefined;
    submitTextLabel?: string | undefined;
    linkFlairPosition?: string | undefined;
    userSrFlairEnabled?: boolean | undefined;
    userFlairEnabledInSr?: boolean | undefined;
    allowChatPostCreation?: boolean | undefined;
    allowDiscovery?: boolean | undefined;
    acceptFollowers?: boolean | undefined;
    userSrThemeEnabled?: boolean | undefined;
    linkFlairEnabled?: boolean | undefined;
    disableContributorRequests?: boolean | undefined;
    subredditType?: string | undefined;
    suggestedCommentSort?: string | undefined;
    bannerImg?: string | undefined;
    userFlairText?: string | undefined;
    contentCategory?: string | undefined;
    bannerBackgroundColor?: string | undefined;
    showMedia?: boolean | undefined;
    id?: string | undefined;
    userIsModerator?: boolean | undefined;
    over18?: boolean | undefined;
    headerTitle?: string | undefined;
    description?: string | undefined;
    isChatPostFeatureEnabled?: boolean | undefined;
    submitLinkLabel?: string | undefined;
    userFlairTextColor?: string | undefined;
    restrictCommenting?: boolean | undefined;
    userFlairCssClass?: string | undefined;
    allowImages?: boolean | undefined;
    lang?: string | undefined;
    whitelistStatus?: string | undefined;
    url?: string | undefined;
    createdUtc?: number | undefined;
    bannerSize: number[];
    mobileBannerImage?: string | undefined;
    userIsContributor?: boolean | undefined;
    allowPredictionsTournament?: boolean | undefined;
}

declare const FullSubredditObject: {
    $type: "devvit.plugin.redditapi.subreddits.FullSubredditObject";
    encode(message: FullSubredditObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FullSubredditObject;
    fromJSON(object: any): FullSubredditObject;
    toJSON(message: FullSubredditObject): unknown;
    create(base?: DeepPartial_11<FullSubredditObject>): FullSubredditObject;
    fromPartial(object: DeepPartial_11<FullSubredditObject>): FullSubredditObject;
};

/** Responses */
declare interface GeneralFriendResponse {
    date?: number | undefined;
    relId?: string | undefined;
    name?: string | undefined;
    id?: string | undefined;
    /** error case */
    fields: string[];
    explanation?: string | undefined;
    message?: string | undefined;
    reason?: string | undefined;
}

declare const GeneralFriendResponse: {
    $type: "devvit.plugin.redditapi.users.GeneralFriendResponse";
    encode(message: GeneralFriendResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GeneralFriendResponse;
    fromJSON(object: any): GeneralFriendResponse;
    toJSON(message: GeneralFriendResponse): unknown;
    create(base?: DeepPartial_100<GeneralFriendResponse>): GeneralFriendResponse;
    fromPartial(object: DeepPartial_100<GeneralFriendResponse>): GeneralFriendResponse;
};

/**
 * Describes the relationship between generated code and its original source
 * file. A GeneratedCodeInfo message is associated with only one generated
 * source file, but may contain references to different source .proto files.
 */
declare interface GeneratedCodeInfo {
    /**
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     */
    annotation: GeneratedCodeInfo_Annotation[];
}

declare const GeneratedCodeInfo: {
    $type: "google.protobuf.GeneratedCodeInfo";
    encode(message: GeneratedCodeInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GeneratedCodeInfo;
    fromJSON(object: any): GeneratedCodeInfo;
    toJSON(message: GeneratedCodeInfo): unknown;
    create(base?: DeepPartial_104<GeneratedCodeInfo>): GeneratedCodeInfo;
    fromPartial(object: DeepPartial_104<GeneratedCodeInfo>): GeneratedCodeInfo;
};

declare interface GeneratedCodeInfo_Annotation {
    /**
     * Identifies the element in the original source .proto file. This field
     * is formatted the same as SourceCodeInfo.Location.path.
     */
    path: number[];
    /** Identifies the filesystem path to the original source .proto. */
    sourceFile?: string | undefined;
    /**
     * Identifies the starting offset in bytes in the generated code
     * that relates to the identified object.
     */
    begin?: number | undefined;
    /**
     * Identifies the ending offset in bytes in the generated code that
     * relates to the identified object. The end offset should be one past
     * the last relevant byte (so the length of the text = end - begin).
     */
    end?: number | undefined;
    semantic?: GeneratedCodeInfo_Annotation_Semantic | undefined;
}

declare const GeneratedCodeInfo_Annotation: {
    $type: "google.protobuf.GeneratedCodeInfo.Annotation";
    encode(message: GeneratedCodeInfo_Annotation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GeneratedCodeInfo_Annotation;
    fromJSON(object: any): GeneratedCodeInfo_Annotation;
    toJSON(message: GeneratedCodeInfo_Annotation): unknown;
    create(base?: DeepPartial_104<GeneratedCodeInfo_Annotation>): GeneratedCodeInfo_Annotation;
    fromPartial(object: DeepPartial_104<GeneratedCodeInfo_Annotation>): GeneratedCodeInfo_Annotation;
};

/**
 * Represents the identified object's effect on the element in the original
 * .proto file.
 */
declare enum GeneratedCodeInfo_Annotation_Semantic {
    /** NONE - There is no effect or the effect is indescribable. */
    NONE = 0,
    /** SET - The element is set or otherwise mutated. */
    SET = 1,
    /** ALIAS - An alias to the element is returned. */
    ALIAS = 2,
    UNRECOGNIZED = -1
}

declare function generatedCodeInfo_Annotation_SemanticFromJSON(object: any): GeneratedCodeInfo_Annotation_Semantic;

declare function generatedCodeInfo_Annotation_SemanticToJSON(object: GeneratedCodeInfo_Annotation_Semantic): number;

declare interface GenericPrivateMessagesRequest {
    /** fullname of a thing */
    id: string;
}

declare const GenericPrivateMessagesRequest: {
    $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest";
    encode(message: GenericPrivateMessagesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GenericPrivateMessagesRequest;
    fromJSON(object: any): GenericPrivateMessagesRequest;
    toJSON(message: GenericPrivateMessagesRequest): unknown;
    create(base?: DeepPartial_84<GenericPrivateMessagesRequest>): GenericPrivateMessagesRequest;
    fromPartial(object: DeepPartial_84<GenericPrivateMessagesRequest>): GenericPrivateMessagesRequest;
};

/** Requests */
declare interface GenericUsersRequest {
    /** thing id e.g. 't3_15bfi0' */
    id?: string | undefined;
    /** a valid, existing reddit username */
    username: string;
}

declare const GenericUsersRequest: {
    $type: "devvit.plugin.redditapi.users.GenericUsersRequest";
    encode(message: GenericUsersRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GenericUsersRequest;
    fromJSON(object: any): GenericUsersRequest;
    toJSON(message: GenericUsersRequest): unknown;
    create(base?: DeepPartial_100<GenericUsersRequest>): GenericUsersRequest;
    fromPartial(object: DeepPartial_100<GenericUsersRequest>): GenericUsersRequest;
};

declare interface GetActionResponse {
    id: string;
    request?: ScheduledActionRequest | undefined;
}

declare const GetActionResponse: {
    $type: "devvit.plugin.scheduler.GetActionResponse";
    encode(message: GetActionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetActionResponse;
    fromJSON(object: any): GetActionResponse;
    toJSON(message: GetActionResponse): unknown;
    create(base?: DeepPartial_89<GetActionResponse>): GetActionResponse;
    fromPartial(object: DeepPartial_89<GetActionResponse>): GetActionResponse;
};

declare interface GetActionsRequest {
}

declare const GetActionsRequest: {
    $type: "devvit.reddit.custom_actions.v2alpha.GetActionsRequest";
    encode(_: GetActionsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetActionsRequest;
    fromJSON(_: any): GetActionsRequest;
    toJSON(_: GetActionsRequest): unknown;
    create(base?: DeepPartial_41<GetActionsRequest>): GetActionsRequest;
    fromPartial(_: DeepPartial_41<GetActionsRequest>): GetActionsRequest;
};

declare interface GetActionsResponse {
    /** List of actions provided by this actor */
    actions: CustomAction[];
}

declare const GetActionsResponse: {
    $type: "devvit.reddit.custom_actions.v2alpha.GetActionsResponse";
    encode(message: GetActionsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetActionsResponse;
    fromJSON(object: any): GetActionsResponse;
    toJSON(message: GetActionsResponse): unknown;
    create(base?: DeepPartial_41<GetActionsResponse>): GetActionsResponse;
    fromPartial(object: DeepPartial_41<GetActionsResponse>): GetActionsResponse;
};

declare interface GetAssetURLRequest {
    /** The path to the asset relative to the /assets directory of the project */
    path: string;
}

declare const GetAssetURLRequest: {
    $type: "devvit.plugin.assetresolver.GetAssetURLRequest";
    encode(message: GetAssetURLRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetURLRequest;
    fromJSON(object: any): GetAssetURLRequest;
    toJSON(message: GetAssetURLRequest): unknown;
    create(base?: DeepPartial_19<GetAssetURLRequest>): GetAssetURLRequest;
    fromPartial(object: DeepPartial_19<GetAssetURLRequest>): GetAssetURLRequest;
};

declare interface GetAssetURLResponse {
    /**
     * The full public URL to the asset (including the protocol); empty string if not found.
     * Example: https://i.redd.it/asdf.png
     */
    url: string;
    /**
     * Whether or not the asset is in the linked bundle. If false, the value in url should
     * be ignored. (It should also be the empty string.)
     */
    found: boolean;
}

declare const GetAssetURLResponse: {
    $type: "devvit.plugin.assetresolver.GetAssetURLResponse";
    encode(message: GetAssetURLResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetURLResponse;
    fromJSON(object: any): GetAssetURLResponse;
    toJSON(message: GetAssetURLResponse): unknown;
    create(base?: DeepPartial_19<GetAssetURLResponse>): GetAssetURLResponse;
    fromPartial(object: DeepPartial_19<GetAssetURLResponse>): GetAssetURLResponse;
};

declare interface GetBestRequest {
    /**
     * Post thing ID
     * Return Posts in the listing up to this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    after?: string | undefined;
    /**
     * Post thing ID
     * Return Posts in the listing starting after this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    before?: string | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`.
     */
    count?: number | undefined;
    /** The maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    /** Adding the string "all" will show all results regardless of user preferences */
    show?: string | undefined;
}

declare const GetBestRequest: {
    $type: "devvit.plugin.redditapi.listings.GetBestRequest";
    encode(message: GetBestRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetBestRequest;
    fromJSON(object: any): GetBestRequest;
    toJSON(message: GetBestRequest): unknown;
    create(base?: DeepPartial_66<GetBestRequest>): GetBestRequest;
    fromPartial(object: DeepPartial_66<GetBestRequest>): GetBestRequest;
};

declare interface GetByIdRequest {
    /**
     * Comma-separated list of Post thing IDs
     * @example "t3_abc123,t3_def456"
     */
    postIds: string;
}

declare const GetByIdRequest: {
    $type: "devvit.plugin.redditapi.listings.GetByIdRequest";
    encode(message: GetByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetByIdRequest;
    fromJSON(object: any): GetByIdRequest;
    toJSON(message: GetByIdRequest): unknown;
    create(base?: DeepPartial_66<GetByIdRequest>): GetByIdRequest;
    fromPartial(object: DeepPartial_66<GetByIdRequest>): GetByIdRequest;
};

export declare type GetCommentsByUserOptions = {
    username: string;
    sort?: 'hot' | 'new' | 'top' | 'controversial';
    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
    pageSize?: number;
    limit?: number;
    after?: string;
    before?: string;
};

export declare type GetCommentsOptions = {
    postId: string;
    commentId?: string | undefined;
    depth?: number;
    pageSize?: number;
    limit?: number;
    sort?: CommentSort;
};

declare interface GetCommentsRequest {
    /**
     * Post thing ID without t3_ prefix
     * @example "abc123" // for: t3_abc123
     */
    article: string;
    /**
     * Comment thing ID without t1_ prefix
     * Note: If provided this will be the only sub-tree in the listing
     * @example "def456" // for: t1_def456
     */
    comment?: string | undefined;
    /**
     * If `comment` is provided and is not a top-level comment include
     * up to this amount of parent comments. Range: 0-8
     */
    context?: number | undefined;
    /** Maximum depth of any comment tree in the listing */
    depth?: number | undefined;
    /**
     * Maximum comments to include in each sub-tree
     * Note: This limit is applied to each level of the comment tree
     */
    limit?: number | undefined;
    /** One of: "confidence", "top", "new", "controversial", "old", "random", "qa", "live" */
    sort?: string | undefined;
    /** If `false` the comment tree is flattened instead of nesting sub-trees in `replies` */
    threaded?: boolean | undefined;
    /**
     * Limit the total number of comments returned to this amount. Range: 0-50
     * Note: While `limit` sets the maximum comments per sub-tree, `truncate`
     *       counts each comment and its descendents toward the maximum
     */
    truncate?: number | undefined;
}

declare const GetCommentsRequest: {
    $type: "devvit.plugin.redditapi.listings.GetCommentsRequest";
    encode(message: GetCommentsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetCommentsRequest;
    fromJSON(object: any): GetCommentsRequest;
    toJSON(message: GetCommentsRequest): unknown;
    create(base?: DeepPartial_66<GetCommentsRequest>): GetCommentsRequest;
    fromPartial(object: DeepPartial_66<GetCommentsRequest>): GetCommentsRequest;
};

declare interface GetConversationRequest {
    /** id36 of a modmail conversation id */
    conversationId: string;
    /** mark read? */
    markRead: boolean;
}

declare const GetConversationRequest: {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationRequest";
    encode(message: GetConversationRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationRequest;
    fromJSON(object: any): GetConversationRequest;
    toJSON(message: GetConversationRequest): unknown;
    create(base?: DeepPartial_71<GetConversationRequest>): GetConversationRequest;
    fromPartial(object: DeepPartial_71<GetConversationRequest>): GetConversationRequest;
};

export declare type GetConversationResponse = {
    conversation?: ConversationData;
    /** If the conversation is with another subreddit, what subreddit we are communicating with. */
    participantSubreddit?: ParticipantSubreddit;
} & WithUserData;

declare interface GetConversationResponse_2 {
    conversation?: ConversationData_2 | undefined;
    messages: {
        [key: string]: MessageData_2;
    };
    modActions: {
        [key: string]: ModActionData_2;
    };
    participantSubreddit?: Any | undefined;
    user?: ConversationUserData_2 | undefined;
}

declare const GetConversationResponse_2: {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse";
    encode(message: GetConversationResponse_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationResponse_2;
    fromJSON(object: any): GetConversationResponse_2;
    toJSON(message: GetConversationResponse_2): unknown;
    create(base?: DeepPartial_71<GetConversationResponse_2>): GetConversationResponse_2;
    fromPartial(object: DeepPartial_71<GetConversationResponse_2>): GetConversationResponse_2;
};

declare interface GetConversationResponse_MessagesEntry {
    key: string;
    value?: MessageData_2 | undefined;
}

declare const GetConversationResponse_MessagesEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.MessagesEntry";
    encode(message: GetConversationResponse_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationResponse_MessagesEntry;
    fromJSON(object: any): GetConversationResponse_MessagesEntry;
    toJSON(message: GetConversationResponse_MessagesEntry): unknown;
    create(base?: DeepPartial_71<GetConversationResponse_MessagesEntry>): GetConversationResponse_MessagesEntry;
    fromPartial(object: DeepPartial_71<GetConversationResponse_MessagesEntry>): GetConversationResponse_MessagesEntry;
};

declare interface GetConversationResponse_ModActionsEntry {
    key: string;
    value?: ModActionData_2 | undefined;
}

declare const GetConversationResponse_ModActionsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.ModActionsEntry";
    encode(message: GetConversationResponse_ModActionsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationResponse_ModActionsEntry;
    fromJSON(object: any): GetConversationResponse_ModActionsEntry;
    toJSON(message: GetConversationResponse_ModActionsEntry): unknown;
    create(base?: DeepPartial_71<GetConversationResponse_ModActionsEntry>): GetConversationResponse_ModActionsEntry;
    fromPartial(object: DeepPartial_71<GetConversationResponse_ModActionsEntry>): GetConversationResponse_ModActionsEntry;
};

export declare type GetConversationsRequest = {
    /** modmail conversation id */
    after?: string;
    /** array of subreddit names */
    subreddits?: string[];
    /** an integer between 1 and 100 (default: 25) */
    limit?: number;
    /**
     * Sort by:
     * - `recent` - Order by whenever anyone last updated the conversation, mod or participant
     * - `mod` - Order by the last time a mod updated the conversation
     * - `user` - Order by the last time a participant user updated the conversation
     * - `unread` - Order by the most recent unread message in the conversation for this mod
     */
    sort?: 'recent' | 'mod' | 'user' | 'unread';
    /**
     * Filter by conversation state
     *
     * A conversation can be in more than one state.
     * For example, a conversation may be both 'highlighted' and 'inprogress'.
     */
    state?: ConversationStateFilter;
};

declare interface GetConversationsRequest_2 {
    /** id36 of a modmail */
    after?: string | undefined;
    /** comma-delimited list of subreddit names */
    entity?: string | undefined;
    /** an integer between 1 and 100 (default: 25) */
    limit?: number | undefined;
    /** one of (recent, mod, user, unread) */
    sort?: string | undefined;
    /**
     * one of (all, appeals, notifications, inbox, filtered, inprogress, mod, archived, default,
     * highlighted, join_requests, new)
     */
    state?: string | undefined;
}

declare const GetConversationsRequest_2: {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsRequest";
    encode(message: GetConversationsRequest_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationsRequest_2;
    fromJSON(object: any): GetConversationsRequest_2;
    toJSON(message: GetConversationsRequest_2): unknown;
    create(base?: DeepPartial_71<GetConversationsRequest_2>): GetConversationsRequest_2;
    fromPartial(object: DeepPartial_71<GetConversationsRequest_2>): GetConversationsRequest_2;
};

export declare type GetConversationsResponse = {
    /**
     * Conversations key-value map
     */
    conversations: {
        [id: string]: ConversationData;
    };
    viewerId?: string;
};

declare interface GetConversationsResponse_2 {
    conversations: {
        [key: string]: ConversationData_2;
    };
    messages: {
        [key: string]: MessageData_2;
    };
    viewerId?: string | undefined;
    conversationIds: string[];
}

declare const GetConversationsResponse_2: {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse";
    encode(message: GetConversationsResponse_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationsResponse_2;
    fromJSON(object: any): GetConversationsResponse_2;
    toJSON(message: GetConversationsResponse_2): unknown;
    create(base?: DeepPartial_71<GetConversationsResponse_2>): GetConversationsResponse_2;
    fromPartial(object: DeepPartial_71<GetConversationsResponse_2>): GetConversationsResponse_2;
};

declare interface GetConversationsResponse_ConversationsEntry {
    key: string;
    value?: ConversationData_2 | undefined;
}

declare const GetConversationsResponse_ConversationsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.ConversationsEntry";
    encode(message: GetConversationsResponse_ConversationsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationsResponse_ConversationsEntry;
    fromJSON(object: any): GetConversationsResponse_ConversationsEntry;
    toJSON(message: GetConversationsResponse_ConversationsEntry): unknown;
    create(base?: DeepPartial_71<GetConversationsResponse_ConversationsEntry>): GetConversationsResponse_ConversationsEntry;
    fromPartial(object: DeepPartial_71<GetConversationsResponse_ConversationsEntry>): GetConversationsResponse_ConversationsEntry;
};

declare interface GetConversationsResponse_MessagesEntry {
    key: string;
    value?: MessageData_2 | undefined;
}

declare const GetConversationsResponse_MessagesEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.MessagesEntry";
    encode(message: GetConversationsResponse_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationsResponse_MessagesEntry;
    fromJSON(object: any): GetConversationsResponse_MessagesEntry;
    toJSON(message: GetConversationsResponse_MessagesEntry): unknown;
    create(base?: DeepPartial_71<GetConversationsResponse_MessagesEntry>): GetConversationsResponse_MessagesEntry;
    fromPartial(object: DeepPartial_71<GetConversationsResponse_MessagesEntry>): GetConversationsResponse_MessagesEntry;
};

declare interface GetDuplicatesRequest {
    /**
     * Post thing ID without t3_ prefix
     * @example "abc123" // for: t3_abc123
     */
    article: string;
    /**
     * Post thing ID
     * Return Posts in the listing starting after this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    before?: string | undefined;
    /**
     * Post thing ID
     * Return Posts in the listing up to this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    after?: string | undefined;
    /** Maximum number of items to include in the response */
    limit?: number | undefined;
    /** One of: "num_comments", "new" */
    sort?: string | undefined;
    /**
     * Limit search to the given subreddit name
     * @example "AskReddit"
     */
    sr?: string | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`.
     */
    count?: number | undefined;
    /** Only return duplicates that are crossposting this post */
    crosspostsOnly?: boolean | undefined;
    /** Adding the string "all" will show all results regardless of user preferences */
    show?: string | undefined;
}

declare const GetDuplicatesRequest: {
    $type: "devvit.plugin.redditapi.listings.GetDuplicatesRequest";
    encode(message: GetDuplicatesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetDuplicatesRequest;
    fromJSON(object: any): GetDuplicatesRequest;
    toJSON(message: GetDuplicatesRequest): unknown;
    create(base?: DeepPartial_66<GetDuplicatesRequest>): GetDuplicatesRequest;
    fromPartial(object: DeepPartial_66<GetDuplicatesRequest>): GetDuplicatesRequest;
};

declare interface GetFieldsRequest {
    /** If true, the form is editing existing settings */
    editing: boolean;
}

declare const GetFieldsRequest: {
    $type: "devvit.actor.settings.v1alpha.GetFieldsRequest";
    encode(message: GetFieldsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetFieldsRequest;
    fromJSON(object: any): GetFieldsRequest;
    toJSON(message: GetFieldsRequest): unknown;
    create(base?: DeepPartial_16<GetFieldsRequest>): GetFieldsRequest;
    fromPartial(object: DeepPartial_16<GetFieldsRequest>): GetFieldsRequest;
};

declare interface GetFieldsResponse {
    fields?: Form_2 | undefined;
}

declare const GetFieldsResponse: {
    $type: "devvit.actor.settings.v1alpha.GetFieldsResponse";
    encode(message: GetFieldsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetFieldsResponse;
    fromJSON(object: any): GetFieldsResponse;
    toJSON(message: GetFieldsResponse): unknown;
    create(base?: DeepPartial_16<GetFieldsResponse>): GetFieldsResponse;
    fromPartial(object: DeepPartial_16<GetFieldsResponse>): GetFieldsResponse;
};

export declare type GetHotPostsOptions = GetPostsOptions & {
    location?: 'GLOBAL' | 'US' | 'AR' | 'AU' | 'BG' | 'CA' | 'CL' | 'CO' | 'HR' | 'CZ' | 'FI' | 'FR' | 'DE' | 'GR' | 'HU' | 'IS' | 'IN' | 'IE' | 'IT' | 'JP' | 'MY' | 'MX' | 'NZ' | 'PH' | 'PL' | 'PT' | 'PR' | 'RO' | 'RS' | 'SG' | 'ES' | 'SE' | 'TW' | 'TH' | 'TR' | 'GB' | 'US_WA' | 'US_DE' | 'US_DC' | 'US_WI' | 'US_WV' | 'US_HI' | 'US_FL' | 'US_WY' | 'US_NH' | 'US_NJ' | 'US_NM' | 'US_TX' | 'US_LA' | 'US_NC' | 'US_ND' | 'US_NE' | 'US_TN' | 'US_NY' | 'US_PA' | 'US_CA' | 'US_NV' | 'US_VA' | 'US_CO' | 'US_AK' | 'US_AL' | 'US_AR' | 'US_VT' | 'US_IL' | 'US_GA' | 'US_IN' | 'US_IA' | 'US_OK' | 'US_AZ' | 'US_ID' | 'US_CT' | 'US_ME' | 'US_MD' | 'US_MA' | 'US_OH' | 'US_UT' | 'US_MO' | 'US_MN' | 'US_MI' | 'US_RI' | 'US_KS' | 'US_MT' | 'US_MS' | 'US_SC' | 'US_KY' | 'US_OR' | 'US_SD';
};

declare interface GetHotRequest {
    /**
     * Fetch posts from this subreddit.
     * Note: If omitted Home is used
     * @example "AskReddit"
     */
    subreddit?: string | undefined;
    /**
     * Post thing ID
     * Return Posts in the listing starting after this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    before?: string | undefined;
    /**
     * Post thing ID
     * Return Posts in the listing up to this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    after?: string | undefined;
    /** The maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`.
     */
    count?: number | undefined;
    /** Adding the string "all" will show all results regardless of user preferences */
    show?: string | undefined;
    /**
     * If provided filter the results by geographic location
     * One of: GLOBAL, US, AR, AU, BG, CA, CL, CO, HR, CZ, FI, FR,
     *         DE, GR, HU, IS, IN, IE, IT, JP, MY, MX, NZ, PH, PL,
     *         PT, PR, RO, RS, SG, ES, SE, TW, TH, TR, GB,
     *         US_WA, US_DE, US_DC, US_WI, US_WV, US_HI, US_FL, US_WY,
     *         US_NH, US_NJ, US_NM, US_TX, US_LA, US_NC, US_ND, US_NE,
     *         US_TN, US_NY, US_PA, US_CA, US_NV, US_VA, US_CO, US_AK,
     *         US_AL, US_AR, US_VT, US_IL, US_GA, US_IN, US_IA, US_OK,
     *         US_AZ, US_ID, US_CT, US_ME, US_MD, US_MA, US_OH, US_UT,
     *         US_MO, US_MN, US_MI, US_RI, US_KS, US_MT, US_MS, US_SC,
     *         US_KY, US_OR, US_SD
     */
    g?: string | undefined;
}

declare const GetHotRequest: {
    $type: "devvit.plugin.redditapi.listings.GetHotRequest";
    encode(message: GetHotRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetHotRequest;
    fromJSON(object: any): GetHotRequest;
    toJSON(message: GetHotRequest): unknown;
    create(base?: DeepPartial_66<GetHotRequest>): GetHotRequest;
    fromPartial(object: DeepPartial_66<GetHotRequest>): GetHotRequest;
};

export declare function getModerationLog(options: GetModerationLogOptions, metadata: Metadata | undefined): Listing<ModAction>;

export declare type GetModerationLogOptions = ListingFetchOptions & {
    /** Subreddit name */
    subredditName: string;
    /** (optional) A moderator filter. Accepts an array of usernames */
    moderatorUsernames?: string[];
    /** Type of the Moderator action */
    type?: ModActionType;
};

declare type GetModerationLogOptions_2 = Omit<GetModerationLogOptions, 'subredditName'>;

export declare type GetModNotesOptions = Prettify<Pick<GetNotesRequest, 'subreddit' | 'user'> & {
    filter?: ModNoteType;
} & Pick<ListingFetchOptions, 'limit' | 'before'>>;

declare interface GetMultipleAssetURLsRequest {
    /**
     * The paths to the assets relative to the /assets directory of the project
     * could be a mix of file paths, and glob patterns
     */
    paths: string[];
}

declare const GetMultipleAssetURLsRequest: {
    $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsRequest";
    encode(message: GetMultipleAssetURLsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetMultipleAssetURLsRequest;
    fromJSON(object: any): GetMultipleAssetURLsRequest;
    toJSON(message: GetMultipleAssetURLsRequest): unknown;
    create(base?: DeepPartial_19<GetMultipleAssetURLsRequest>): GetMultipleAssetURLsRequest;
    fromPartial(object: DeepPartial_19<GetMultipleAssetURLsRequest>): GetMultipleAssetURLsRequest;
};

declare interface GetMultipleAssetURLsResponse {
    /**
     * A map indexed by the paths to the assets relative to the /assets directory of the project
     * whose values are the full public URLs to the assets (including the protocol)
     */
    urls: {
        [key: string]: GetMultipleAssetURLsResponse_GlobResult;
    };
}

declare const GetMultipleAssetURLsResponse: {
    $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsResponse";
    encode(message: GetMultipleAssetURLsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetMultipleAssetURLsResponse;
    fromJSON(object: any): GetMultipleAssetURLsResponse;
    toJSON(message: GetMultipleAssetURLsResponse): unknown;
    create(base?: DeepPartial_19<GetMultipleAssetURLsResponse>): GetMultipleAssetURLsResponse;
    fromPartial(object: DeepPartial_19<GetMultipleAssetURLsResponse>): GetMultipleAssetURLsResponse;
};

declare interface GetMultipleAssetURLsResponse_GlobResult {
    /**
     * Whether or not the asset is in the linked bundle. If false, the paths value below should
     * be ignored. (It should also be an empty array.)
     */
    found: boolean;
    /**
     * The full public URL to the asset (including the protocol); empty string if not found.
     * For studio compatability reasons, this is an array.
     * Example: ["https://i.redd.it/asdf.png"]
     */
    paths: string[];
}

declare const GetMultipleAssetURLsResponse_GlobResult: {
    $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsResponse.GlobResult";
    encode(message: GetMultipleAssetURLsResponse_GlobResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetMultipleAssetURLsResponse_GlobResult;
    fromJSON(object: any): GetMultipleAssetURLsResponse_GlobResult;
    toJSON(message: GetMultipleAssetURLsResponse_GlobResult): unknown;
    create(base?: DeepPartial_19<GetMultipleAssetURLsResponse_GlobResult>): GetMultipleAssetURLsResponse_GlobResult;
    fromPartial(object: DeepPartial_19<GetMultipleAssetURLsResponse_GlobResult>): GetMultipleAssetURLsResponse_GlobResult;
};

declare interface GetMultipleAssetURLsResponse_UrlsEntry {
    key: string;
    value?: GetMultipleAssetURLsResponse_GlobResult | undefined;
}

declare const GetMultipleAssetURLsResponse_UrlsEntry: {
    $type: "devvit.plugin.assetresolver.GetMultipleAssetURLsResponse.UrlsEntry";
    encode(message: GetMultipleAssetURLsResponse_UrlsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetMultipleAssetURLsResponse_UrlsEntry;
    fromJSON(object: any): GetMultipleAssetURLsResponse_UrlsEntry;
    toJSON(message: GetMultipleAssetURLsResponse_UrlsEntry): unknown;
    create(base?: DeepPartial_19<GetMultipleAssetURLsResponse_UrlsEntry>): GetMultipleAssetURLsResponse_UrlsEntry;
    fromPartial(object: DeepPartial_19<GetMultipleAssetURLsResponse_UrlsEntry>): GetMultipleAssetURLsResponse_UrlsEntry;
};

declare interface GetNewRequest {
    /**
     * Fetch posts from this subreddit.
     * Note: If omitted Home is used
     * @example "AskReddit"
     */
    subreddit?: string | undefined;
    /**
     * Post thing ID
     * Return Posts in the listing starting after this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    before?: string | undefined;
    /**
     * Post thing ID
     * Return Posts in the listing up to this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    after?: string | undefined;
    /** The maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`.
     */
    count?: number | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`.
     */
    show?: string | undefined;
}

declare const GetNewRequest: {
    $type: "devvit.plugin.redditapi.listings.GetNewRequest";
    encode(message: GetNewRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetNewRequest;
    fromJSON(object: any): GetNewRequest;
    toJSON(message: GetNewRequest): unknown;
    create(base?: DeepPartial_66<GetNewRequest>): GetNewRequest;
    fromPartial(object: DeepPartial_66<GetNewRequest>): GetNewRequest;
};

declare interface GetNotesRequest {
    /** subreddit name without the r/ */
    subreddit: string;
    /** (optional) an encoded string used for pagination with mod notes */
    before?: string | undefined;
    /**
     * (optional) one of (NOTE, APPROVAL, REMOVAL, BAN, MUTE, INVITE, SPAM, CONTENT_CHANGE,
     * MOD_ACTION, ALL), to be used for querying specific types of mod notes (default: all)
     */
    filter?: string | undefined;
    /** (optional) the number of mod notes to return in the response payload (default: 25, max: 100) */
    limit?: number | undefined;
    /** account username */
    user: string;
}

declare const GetNotesRequest: {
    $type: "devvit.plugin.redditapi.modnote.GetNotesRequest";
    encode(message: GetNotesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetNotesRequest;
    fromJSON(object: any): GetNotesRequest;
    toJSON(message: GetNotesRequest): unknown;
    create(base?: DeepPartial_3<GetNotesRequest>): GetNotesRequest;
    fromPartial(object: DeepPartial_3<GetNotesRequest>): GetNotesRequest;
};

export declare type GetPageRevisionsOptions = {
    /** The name of the subreddit the page is in. */
    subredditName: string;
    /** The name of the page to get revisions for. */
    page: string;
    /** The number of revisions to get per request. */
    pageSize?: number;
    /** The maximum number of revisions to get. */
    limit?: number;
    /** The ID of the revision to start at. */
    after?: string;
};

export declare type GetPostsByUserOptions = {
    username: string;
    sort?: 'hot' | 'new' | 'top' | 'controversial';
    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
    pageSize?: number;
    limit?: number;
    after?: string;
    before?: string;
};

export declare type GetPostsOptions = ListingFetchOptions & {
    subredditName?: string;
};

export declare type GetPostsOptionsWithTimeframe = GetPostsOptions & {
    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
};

export declare type GetPrivateMessagesOptions = Prettify<{
    type?: 'inbox' | 'unread' | 'sent';
} & ListingFetchOptions>;

declare interface GetProfileRequest {
    profileId: string;
}

declare const GetProfileRequest: {
    $type: "devvit.debug.v1alpha.GetProfileRequest";
    encode(message: GetProfileRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetProfileRequest;
    fromJSON(object: any): GetProfileRequest;
    toJSON(message: GetProfileRequest): unknown;
    create(base?: DeepPartial_54<GetProfileRequest>): GetProfileRequest;
    fromPartial(object: DeepPartial_54<GetProfileRequest>): GetProfileRequest;
};

declare interface GetProfileResponse {
    profileId: string;
    profile: Uint8Array;
}

declare const GetProfileResponse: {
    $type: "devvit.debug.v1alpha.GetProfileResponse";
    encode(message: GetProfileResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetProfileResponse;
    fromJSON(object: any): GetProfileResponse;
    toJSON(message: GetProfileResponse): unknown;
    create(base?: DeepPartial_54<GetProfileResponse>): GetProfileResponse;
    fromPartial(object: DeepPartial_54<GetProfileResponse>): GetProfileResponse;
};

declare interface GetRisingRequest {
    /**
     * Fetch posts from this subreddit.
     * Note: If omitted Home is used
     * @example "AskReddit"
     */
    subreddit?: string | undefined;
    /**
     * Post thing ID
     * Return Posts in the listing up to this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    after?: string | undefined;
    /**
     * Post thing ID
     * Return Posts in the listing starting after this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    before?: string | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`.
     */
    count?: number | undefined;
    /** The maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`.
     */
    show?: string | undefined;
}

declare const GetRisingRequest: {
    $type: "devvit.plugin.redditapi.listings.GetRisingRequest";
    encode(message: GetRisingRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetRisingRequest;
    fromJSON(object: any): GetRisingRequest;
    toJSON(message: GetRisingRequest): unknown;
    create(base?: DeepPartial_66<GetRisingRequest>): GetRisingRequest;
    fromPartial(object: DeepPartial_66<GetRisingRequest>): GetRisingRequest;
};

export declare type GetSortedPostsOptions = GetPostsOptionsWithTimeframe & {
    sort: 'top' | 'controversial';
};

declare interface GetSortRequest {
    /**
     * Fetch posts from this subreddit.
     * Note: If omitted Home is used
     * @example "AskReddit"
     */
    subreddit?: string | undefined;
    /**
     * Sort method
     * One of: "top", "controversial"
     */
    sort: string;
    /**
     * Post thing ID
     * Return Posts in the listing up to this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    after?: string | undefined;
    /**
     * Post thing ID
     * Return Posts in the listing starting after this Post (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     * @example "t3_abc123"
     */
    before?: string | undefined;
    /** One of: "num_comments", "new" */
    limit?: number | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`, defaults to 0
     */
    count?: number | undefined;
    /** Adding the string "all" will show all results regardless of user preferences */
    show?: string | undefined;
    /**
     * Show results within the given timeframe (default: "day")
     * One of: "hour", "day", "week", "month", "year", "all"
     */
    t?: string | undefined;
}

declare const GetSortRequest: {
    $type: "devvit.plugin.redditapi.listings.GetSortRequest";
    encode(message: GetSortRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetSortRequest;
    fromJSON(object: any): GetSortRequest;
    toJSON(message: GetSortRequest): unknown;
    create(base?: DeepPartial_66<GetSortRequest>): GetSortRequest;
    fromPartial(object: DeepPartial_66<GetSortRequest>): GetSortRequest;
};

export declare type GetSubredditUsersByTypeOptions = ListingFetchOptions & {
    subredditName: string;
    type: 'banned' | 'muted' | 'wikibanned' | 'contributors' | 'wikicontributors' | 'moderators';
    username?: string;
};

declare type GetSubredditUsersOptions = Omit<GetSubredditUsersByTypeOptions, 'type'>;

export declare type GetUserFlairBySubredditOptions = UserFlairPageOptions & {
    /** The subreddit associated with the flair being retrieved. */
    subreddit: string;
    /** The username associated with the flair being retrieved. */
    name?: string;
};

export declare type GetUserFlairBySubredditResponse = {
    /** The list of user flair */
    users: UserFlair[];
    /** The user id of the last user flair in this slice. Its presence indicates
     * that there are more items that can be fetched. Pass this into the "after" parameter
     * in the next call to get the next slice of data  */
    next?: string;
    /** The user id of the first user flair in this slice. Its presence indicates
     * that there are items before this item that can be fetched. Pass this into the "before" parameter
     * in the next call to get the previous slice of data  */
    prev?: string;
};

export declare type GetUserFlairOptions = UserFlairPageOptions & {
    /** If provide the method will return the flairs for the provided users, if not provided
     * it will return a list of all users assigned flairs in the subreddit */
    usernames?: string[];
};

export declare type GetUserOverviewOptions = {
    username: string;
    sort?: 'hot' | 'new' | 'top' | 'controversial';
    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
    pageSize?: number;
    limit?: number;
    after?: string;
    before?: string;
};

declare type GetUsersOptions = Omit<GetSubredditUsersByTypeOptions, 'subredditName' | 'type'>;

export declare function getVaultByAddress(address: string, metadata: Metadata | undefined): Promise<Vault>;

export declare function getVaultByUserId(userId: T2ID, metadata: Metadata | undefined): Promise<Vault>;

declare interface GetWidgetImageUploadLeaseRequest {
    subreddit: string;
    filepath: string;
    mimetype: string;
}

declare const GetWidgetImageUploadLeaseRequest: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseRequest";
    encode(message: GetWidgetImageUploadLeaseRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetImageUploadLeaseRequest;
    fromJSON(object: any): GetWidgetImageUploadLeaseRequest;
    toJSON(message: GetWidgetImageUploadLeaseRequest): unknown;
    create(base?: DeepPartial_4<GetWidgetImageUploadLeaseRequest>): GetWidgetImageUploadLeaseRequest;
    fromPartial(object: DeepPartial_4<GetWidgetImageUploadLeaseRequest>): GetWidgetImageUploadLeaseRequest;
};

declare interface GetWidgetImageUploadLeaseResponse {
    s3UploadLease?: GetWidgetImageUploadLeaseResponse_S3UploadLease | undefined;
    websocketUrl: string;
}

declare const GetWidgetImageUploadLeaseResponse: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse";
    encode(message: GetWidgetImageUploadLeaseResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetImageUploadLeaseResponse;
    fromJSON(object: any): GetWidgetImageUploadLeaseResponse;
    toJSON(message: GetWidgetImageUploadLeaseResponse): unknown;
    create(base?: DeepPartial_4<GetWidgetImageUploadLeaseResponse>): GetWidgetImageUploadLeaseResponse;
    fromPartial(object: DeepPartial_4<GetWidgetImageUploadLeaseResponse>): GetWidgetImageUploadLeaseResponse;
};

declare interface GetWidgetImageUploadLeaseResponse_S3UploadLease {
    action: string;
    fields: GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair[];
}

declare const GetWidgetImageUploadLeaseResponse_S3UploadLease: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease";
    encode(message: GetWidgetImageUploadLeaseResponse_S3UploadLease, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetImageUploadLeaseResponse_S3UploadLease;
    fromJSON(object: any): GetWidgetImageUploadLeaseResponse_S3UploadLease;
    toJSON(message: GetWidgetImageUploadLeaseResponse_S3UploadLease): unknown;
    create(base?: DeepPartial_4<GetWidgetImageUploadLeaseResponse_S3UploadLease>): GetWidgetImageUploadLeaseResponse_S3UploadLease;
    fromPartial(object: DeepPartial_4<GetWidgetImageUploadLeaseResponse_S3UploadLease>): GetWidgetImageUploadLeaseResponse_S3UploadLease;
};

declare interface GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair {
    name: string;
    value: string;
}

declare const GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease.NameValuePair";
    encode(message: GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair;
    fromJSON(object: any): GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair;
    toJSON(message: GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair): unknown;
    create(base?: DeepPartial_4<GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair>): GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair;
    fromPartial(object: DeepPartial_4<GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair>): GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair;
};

declare interface GetWidgetsRequest {
    subreddit: string;
    progressiveImages?: boolean | undefined;
}

declare const GetWidgetsRequest: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsRequest";
    encode(message: GetWidgetsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsRequest;
    fromJSON(object: any): GetWidgetsRequest;
    toJSON(message: GetWidgetsRequest): unknown;
    create(base?: DeepPartial_4<GetWidgetsRequest>): GetWidgetsRequest;
    fromPartial(object: DeepPartial_4<GetWidgetsRequest>): GetWidgetsRequest;
};

declare interface GetWidgetsResponse {
    layout?: GetWidgetsResponse_Layout | undefined;
    items: {
        [key: string]: GetWidgetsResponse_WidgetItem;
    };
}

declare const GetWidgetsResponse: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse";
    encode(message: GetWidgetsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsResponse;
    fromJSON(object: any): GetWidgetsResponse;
    toJSON(message: GetWidgetsResponse): unknown;
    create(base?: DeepPartial_4<GetWidgetsResponse>): GetWidgetsResponse;
    fromPartial(object: DeepPartial_4<GetWidgetsResponse>): GetWidgetsResponse;
};

declare interface GetWidgetsResponse_ItemsEntry {
    key: string;
    value?: GetWidgetsResponse_WidgetItem | undefined;
}

declare const GetWidgetsResponse_ItemsEntry: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.ItemsEntry";
    encode(message: GetWidgetsResponse_ItemsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsResponse_ItemsEntry;
    fromJSON(object: any): GetWidgetsResponse_ItemsEntry;
    toJSON(message: GetWidgetsResponse_ItemsEntry): unknown;
    create(base?: DeepPartial_4<GetWidgetsResponse_ItemsEntry>): GetWidgetsResponse_ItemsEntry;
    fromPartial(object: DeepPartial_4<GetWidgetsResponse_ItemsEntry>): GetWidgetsResponse_ItemsEntry;
};

declare interface GetWidgetsResponse_Layout {
    idCardWidget: string;
    topbar?: GetWidgetsResponse_WidgetOrdering | undefined;
    sidebar?: GetWidgetsResponse_WidgetOrdering | undefined;
    moderatorWidget: string;
}

declare const GetWidgetsResponse_Layout: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.Layout";
    encode(message: GetWidgetsResponse_Layout, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsResponse_Layout;
    fromJSON(object: any): GetWidgetsResponse_Layout;
    toJSON(message: GetWidgetsResponse_Layout): unknown;
    create(base?: DeepPartial_4<GetWidgetsResponse_Layout>): GetWidgetsResponse_Layout;
    fromPartial(object: DeepPartial_4<GetWidgetsResponse_Layout>): GetWidgetsResponse_Layout;
};

declare interface GetWidgetsResponse_WidgetItem {
    id: string;
    kind: string;
    styles?: WidgetStyles | undefined;
    shortName: string;
    description?: string | undefined;
    data: GetWidgetsResponse_WidgetItem_Data[];
    buttons: WidgetButton[];
    subscribersCount?: number | undefined;
    currentlyViewingText?: string | undefined;
    currentlyViewingCount?: number | undefined;
    subscribersText?: string | undefined;
    showWiki?: boolean | undefined;
    templates: {
        [key: string]: GetWidgetsResponse_WidgetItem_PostFlairTemplate;
    };
    display?: string | undefined;
    order: string[];
    mods: GetWidgetsResponse_WidgetItem_Moderator[];
    totalMods?: number | undefined;
    googleCalendarId?: string | undefined;
    requiresSync?: boolean | undefined;
    configuration?: CalendarWidgetConfiguration | undefined;
    text?: string | undefined;
    css?: string | undefined;
    stylesheetUrl?: string | undefined;
    height?: number | undefined;
    imageData: WidgetImage[];
}

declare const GetWidgetsResponse_WidgetItem: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem";
    encode(message: GetWidgetsResponse_WidgetItem, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsResponse_WidgetItem;
    fromJSON(object: any): GetWidgetsResponse_WidgetItem;
    toJSON(message: GetWidgetsResponse_WidgetItem): unknown;
    create(base?: DeepPartial_4<GetWidgetsResponse_WidgetItem>): GetWidgetsResponse_WidgetItem;
    fromPartial(object: DeepPartial_4<GetWidgetsResponse_WidgetItem>): GetWidgetsResponse_WidgetItem;
};

declare interface GetWidgetsResponse_WidgetItem_Data {
    url?: string | undefined;
    linkUrl?: string | undefined;
    height?: number | undefined;
    width?: number | undefined;
    iconUrl?: string | undefined;
    name?: string | undefined;
    prefixedName?: string | undefined;
    isSubscribed?: boolean | undefined;
    type?: string | undefined;
    subscribers?: number | undefined;
    communityIcon?: string | undefined;
    isNsfw?: boolean | undefined;
    text?: string | undefined;
    children: MenuWidgetItem[];
}

declare const GetWidgetsResponse_WidgetItem_Data: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Data";
    encode(message: GetWidgetsResponse_WidgetItem_Data, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsResponse_WidgetItem_Data;
    fromJSON(object: any): GetWidgetsResponse_WidgetItem_Data;
    toJSON(message: GetWidgetsResponse_WidgetItem_Data): unknown;
    create(base?: DeepPartial_4<GetWidgetsResponse_WidgetItem_Data>): GetWidgetsResponse_WidgetItem_Data;
    fromPartial(object: DeepPartial_4<GetWidgetsResponse_WidgetItem_Data>): GetWidgetsResponse_WidgetItem_Data;
};

declare interface GetWidgetsResponse_WidgetItem_Moderator {
    name: string;
    authorFlairType: string;
    authorFlairTextColor: string;
    authorFlairBackgroundColor: string;
    authorFalirText: string;
    authorFlairRichtext: AuthorFlairRichText[];
}

declare const GetWidgetsResponse_WidgetItem_Moderator: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Moderator";
    encode(message: GetWidgetsResponse_WidgetItem_Moderator, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsResponse_WidgetItem_Moderator;
    fromJSON(object: any): GetWidgetsResponse_WidgetItem_Moderator;
    toJSON(message: GetWidgetsResponse_WidgetItem_Moderator): unknown;
    create(base?: DeepPartial_4<GetWidgetsResponse_WidgetItem_Moderator>): GetWidgetsResponse_WidgetItem_Moderator;
    fromPartial(object: DeepPartial_4<GetWidgetsResponse_WidgetItem_Moderator>): GetWidgetsResponse_WidgetItem_Moderator;
};

declare interface GetWidgetsResponse_WidgetItem_PostFlairTemplate {
    text: string;
    richtext: AuthorFlairRichText[];
    backgroundColor: string;
    templateId: string;
    textColor: string;
    type: string;
}

declare const GetWidgetsResponse_WidgetItem_PostFlairTemplate: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.PostFlairTemplate";
    encode(message: GetWidgetsResponse_WidgetItem_PostFlairTemplate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsResponse_WidgetItem_PostFlairTemplate;
    fromJSON(object: any): GetWidgetsResponse_WidgetItem_PostFlairTemplate;
    toJSON(message: GetWidgetsResponse_WidgetItem_PostFlairTemplate): unknown;
    create(base?: DeepPartial_4<GetWidgetsResponse_WidgetItem_PostFlairTemplate>): GetWidgetsResponse_WidgetItem_PostFlairTemplate;
    fromPartial(object: DeepPartial_4<GetWidgetsResponse_WidgetItem_PostFlairTemplate>): GetWidgetsResponse_WidgetItem_PostFlairTemplate;
};

declare interface GetWidgetsResponse_WidgetItem_TemplatesEntry {
    key: string;
    value?: GetWidgetsResponse_WidgetItem_PostFlairTemplate | undefined;
}

declare const GetWidgetsResponse_WidgetItem_TemplatesEntry: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.TemplatesEntry";
    encode(message: GetWidgetsResponse_WidgetItem_TemplatesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsResponse_WidgetItem_TemplatesEntry;
    fromJSON(object: any): GetWidgetsResponse_WidgetItem_TemplatesEntry;
    toJSON(message: GetWidgetsResponse_WidgetItem_TemplatesEntry): unknown;
    create(base?: DeepPartial_4<GetWidgetsResponse_WidgetItem_TemplatesEntry>): GetWidgetsResponse_WidgetItem_TemplatesEntry;
    fromPartial(object: DeepPartial_4<GetWidgetsResponse_WidgetItem_TemplatesEntry>): GetWidgetsResponse_WidgetItem_TemplatesEntry;
};

declare interface GetWidgetsResponse_WidgetOrdering {
    order: string[];
}

declare const GetWidgetsResponse_WidgetOrdering: {
    $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetOrdering";
    encode(message: GetWidgetsResponse_WidgetOrdering, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWidgetsResponse_WidgetOrdering;
    fromJSON(object: any): GetWidgetsResponse_WidgetOrdering;
    toJSON(message: GetWidgetsResponse_WidgetOrdering): unknown;
    create(base?: DeepPartial_4<GetWidgetsResponse_WidgetOrdering>): GetWidgetsResponse_WidgetOrdering;
    fromPartial(object: DeepPartial_4<GetWidgetsResponse_WidgetOrdering>): GetWidgetsResponse_WidgetOrdering;
};

declare interface GetWikiPageRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
    /** The name of the wiki page. */
    page: string;
}

declare const GetWikiPageRequest: {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPageRequest";
    encode(message: GetWikiPageRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWikiPageRequest;
    fromJSON(object: any): GetWikiPageRequest;
    toJSON(message: GetWikiPageRequest): unknown;
    create(base?: DeepPartial_9<GetWikiPageRequest>): GetWikiPageRequest;
    fromPartial(object: DeepPartial_9<GetWikiPageRequest>): GetWikiPageRequest;
};

declare interface GetWikiPageResponse {
    /** String value: "wikipage" */
    kind: string;
    /** The data of the wiki page. */
    data?: WikiPage_2 | undefined;
}

declare const GetWikiPageResponse: {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPageResponse";
    encode(message: GetWikiPageResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWikiPageResponse;
    fromJSON(object: any): GetWikiPageResponse;
    toJSON(message: GetWikiPageResponse): unknown;
    create(base?: DeepPartial_9<GetWikiPageResponse>): GetWikiPageResponse;
    fromPartial(object: DeepPartial_9<GetWikiPageResponse>): GetWikiPageResponse;
};

declare interface GetWikiPageRevisionsRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
    /** The name of the wiki page. */
    page: string;
    /**
     * Revision ID
     * Return Revisions in the listing up to this Revision (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     */
    after?: string | undefined;
    /**
     * Revision ID
     * Return Revisions in the listing starting after this Revision (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     */
    before?: string | undefined;
    /** The maximum number of revisions to return. */
    limit?: number | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`.
     */
    count?: number | undefined;
    /** (optional) Show all results regardless of user preferences */
    show?: boolean | undefined;
    /** (optional) expand subreddits */
    srDetail?: boolean | undefined;
}

declare const GetWikiPageRevisionsRequest: {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPageRevisionsRequest";
    encode(message: GetWikiPageRevisionsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWikiPageRevisionsRequest;
    fromJSON(object: any): GetWikiPageRevisionsRequest;
    toJSON(message: GetWikiPageRevisionsRequest): unknown;
    create(base?: DeepPartial_9<GetWikiPageRevisionsRequest>): GetWikiPageRevisionsRequest;
    fromPartial(object: DeepPartial_9<GetWikiPageRevisionsRequest>): GetWikiPageRevisionsRequest;
};

declare interface GetWikiPageSettingsRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
    /** The name of the wiki page. */
    page: string;
}

declare const GetWikiPageSettingsRequest: {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPageSettingsRequest";
    encode(message: GetWikiPageSettingsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWikiPageSettingsRequest;
    fromJSON(object: any): GetWikiPageSettingsRequest;
    toJSON(message: GetWikiPageSettingsRequest): unknown;
    create(base?: DeepPartial_9<GetWikiPageSettingsRequest>): GetWikiPageSettingsRequest;
    fromPartial(object: DeepPartial_9<GetWikiPageSettingsRequest>): GetWikiPageSettingsRequest;
};

declare interface GetWikiPagesRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
}

declare const GetWikiPagesRequest: {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPagesRequest";
    encode(message: GetWikiPagesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWikiPagesRequest;
    fromJSON(object: any): GetWikiPagesRequest;
    toJSON(message: GetWikiPagesRequest): unknown;
    create(base?: DeepPartial_9<GetWikiPagesRequest>): GetWikiPagesRequest;
    fromPartial(object: DeepPartial_9<GetWikiPagesRequest>): GetWikiPagesRequest;
};

declare interface GetWikiPagesResponse {
    /** String value: "wikipagelisting" */
    kind: string;
    /** A list of wiki page names. */
    data: string[];
}

declare const GetWikiPagesResponse: {
    $type: "devvit.plugin.redditapi.wiki.GetWikiPagesResponse";
    encode(message: GetWikiPagesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWikiPagesResponse;
    fromJSON(object: any): GetWikiPagesResponse;
    toJSON(message: GetWikiPagesResponse): unknown;
    create(base?: DeepPartial_9<GetWikiPagesResponse>): GetWikiPagesResponse;
    fromPartial(object: DeepPartial_9<GetWikiPagesResponse>): GetWikiPagesResponse;
};

declare interface GetWikiRevisionsRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
    /**
     * Revision ID
     * Return Revisions in the listing up to this Revision (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     */
    after?: string | undefined;
    /**
     * Revision ID
     * Return Revisions in the listing starting after this Revision (non-inclusive)
     * Note: Do not use `before` and `after` in the same request
     */
    before?: string | undefined;
    /** The maximum number of revisions to return. */
    limit?: number | undefined;
    /**
     * The number of items seen so far.
     * Use when fetching subsequent pages with `before` or `after`.
     */
    count?: number | undefined;
    /** (optional) Show all results regardless of user preferences */
    show?: boolean | undefined;
    /** (optional) expand subreddits */
    srDetail?: boolean | undefined;
}

declare const GetWikiRevisionsRequest: {
    $type: "devvit.plugin.redditapi.wiki.GetWikiRevisionsRequest";
    encode(message: GetWikiRevisionsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetWikiRevisionsRequest;
    fromJSON(object: any): GetWikiRevisionsRequest;
    toJSON(message: GetWikiRevisionsRequest): unknown;
    create(base?: DeepPartial_9<GetWikiRevisionsRequest>): GetWikiRevisionsRequest;
    fromPartial(object: DeepPartial_9<GetWikiRevisionsRequest>): GetWikiRevisionsRequest;
};

declare interface Gildings {
    gid1?: number | undefined;
    gid2?: number | undefined;
    gid3?: number | undefined;
}

declare const Gildings: {
    $type: "devvit.reddit.Gildings";
    encode(message: Gildings, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Gildings;
    fromJSON(object: any): Gildings;
    toJSON(message: Gildings): unknown;
    create(base?: DeepPartial_5<Gildings>): Gildings;
    fromPartial(object: DeepPartial_5<Gildings>): Gildings;
};

declare interface GraphQL {
    /** Sending a GraphQL query request using a custom query string */
    Query(request: QueryRequest, metadata?: Metadata): Promise<QueryResponse>;
    /**
     * Sending a GraphQL persisted query request
     *
     * A persisted query is a query string that's cached on the server side,
     * along with its unique identifier (always its SHA-256 hash)
     */
    PersistedQuery(request: PersistedQueryRequest, metadata?: Metadata): Promise<QueryResponse>;
}

declare class GraphQLClientImpl implements GraphQL {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_59, opts?: {
        service?: string;
    });
    Query(request: QueryRequest, metadata?: Metadata): Promise<QueryResponse>;
    PersistedQuery(request: PersistedQueryRequest, metadata?: Metadata): Promise<QueryResponse>;
}

declare type GraphQLDefinition = typeof GraphQLDefinition;

declare const GraphQLDefinition: {
    readonly name: "GraphQL";
    readonly fullName: "devvit.plugin.redditapi.graphql.GraphQL";
    readonly methods: {
        /** Sending a GraphQL query request using a custom query string */
        readonly query: {
            readonly name: "Query";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.graphql.QueryRequest";
                encode(message: QueryRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryRequest;
                fromJSON(object: any): QueryRequest;
                toJSON(message: QueryRequest): unknown;
                create(base?: {
                    query?: string;
                    variables?: {
                        [x: string]: any;
                    } | undefined;
                } | undefined): QueryRequest;
                fromPartial(object: {
                    query?: string;
                    variables?: {
                        [x: string]: any;
                    } | undefined;
                }): QueryRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.graphql.QueryResponse";
                encode(message: QueryResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryResponse;
                fromJSON(object: any): QueryResponse;
                toJSON(message: QueryResponse): unknown;
                create(base?: {
                    data?: {
                        [x: string]: any;
                    } | undefined;
                } | undefined): QueryResponse;
                fromPartial(object: {
                    data?: {
                        [x: string]: any;
                    } | undefined;
                }): QueryResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /**
         * Sending a GraphQL persisted query request
         *
         * A persisted query is a query string that's cached on the server side,
         * along with its unique identifier (always its SHA-256 hash)
         */
        readonly persistedQuery: {
            readonly name: "PersistedQuery";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.graphql.PersistedQueryRequest";
                encode(message: PersistedQueryRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PersistedQueryRequest;
                fromJSON(object: any): PersistedQueryRequest;
                toJSON(message: PersistedQueryRequest): unknown;
                create(base?: {
                    id?: string;
                    variables?: {
                        [x: string]: any;
                    } | undefined;
                    operationName?: string;
                } | undefined): PersistedQueryRequest;
                fromPartial(object: {
                    id?: string;
                    variables?: {
                        [x: string]: any;
                    } | undefined;
                    operationName?: string;
                }): PersistedQueryRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.graphql.QueryResponse";
                encode(message: QueryResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryResponse;
                fromJSON(object: any): QueryResponse;
                toJSON(message: QueryResponse): unknown;
                create(base?: {
                    data?: {
                        [x: string]: any;
                    } | undefined;
                } | undefined): QueryResponse;
                fromPartial(object: {
                    data?: {
                        [x: string]: any;
                    } | undefined;
                }): QueryResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const GraphQLServiceName = "devvit.plugin.redditapi.graphql.GraphQL";

/** This needs to rectified with StepResult at some point */
declare interface HandlerResult {
}

declare const HandlerResult: {
    $type: "devvit.actor.automation.v1alpha.HandlerResult";
    encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
    fromJSON(_: any): HandlerResult;
    toJSON(_: HandlerResult): unknown;
    create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
    fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
};

/** @deprecated */
declare interface HandleUIEventRequest {
    state?: {
        [key: string]: any;
    } | undefined;
    event?: UIEvent | undefined;
}

declare const HandleUIEventRequest: {
    $type: "devvit.ui.events.v1alpha.HandleUIEventRequest";
    encode(message: HandleUIEventRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HandleUIEventRequest;
    fromJSON(object: any): HandleUIEventRequest;
    toJSON(message: HandleUIEventRequest): unknown;
    create(base?: DeepPartial_99<HandleUIEventRequest>): HandleUIEventRequest;
    fromPartial(object: DeepPartial_99<HandleUIEventRequest>): HandleUIEventRequest;
};

/** @deprecated */
declare interface HandleUIEventResponse {
    state?: {
        [key: string]: any;
    } | undefined;
    effects: Effect[];
}

declare const HandleUIEventResponse: {
    $type: "devvit.ui.events.v1alpha.HandleUIEventResponse";
    encode(message: HandleUIEventResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HandleUIEventResponse;
    fromJSON(object: any): HandleUIEventResponse;
    toJSON(message: HandleUIEventResponse): unknown;
    create(base?: DeepPartial_99<HandleUIEventResponse>): HandleUIEventResponse;
    fromPartial(object: DeepPartial_99<HandleUIEventResponse>): HandleUIEventResponse;
};

declare interface HDelRequest {
    key: string;
    fields: string[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const HDelRequest: {
    $type: "devvit.plugin.redis.HDelRequest";
    encode(message: HDelRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HDelRequest;
    fromJSON(object: any): HDelRequest;
    toJSON(message: HDelRequest): unknown;
    create(base?: DeepPartial_86<HDelRequest>): HDelRequest;
    fromPartial(object: DeepPartial_86<HDelRequest>): HDelRequest;
};

/**
 * @mixin
 */
declare type HeadingContainer<Context> = {
    /**
     * Append a Heading
     * @param opts {@link HeadingOptions}
     * @param cb scoped callback to add child elements to this Heading
     */
    heading(opts: HeadingOptions, cb: (heading: HeadingContext) => void): Context;
};

/**
 * @borrows RawTextContainer
 * @borrows LinkContainer
 */
declare interface HeadingContext extends RawTextContainer<HeadingContext>, LinkContainer<HeadingContext> {
}

declare type HeadingLevel = 1 | 2 | 3 | 4 | 5 | 6;

declare type HeadingOptions = {
    /**
     * The depth for this heading (such as <h1>, <h2>, <h3>)
     * @see {@link HeadingLevel}
     */
    level: HeadingLevel;
};

declare interface Health {
    Check(request: Empty, metadata?: Metadata): Promise<HealthStatus>;
}

declare class HealthClientImpl implements Health {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_43, opts?: {
        service?: string;
    });
    Check(request: Empty, metadata?: Metadata): Promise<HealthStatus>;
}

declare type HealthDefinition = typeof HealthDefinition;

declare const HealthDefinition: {
    readonly name: "Health";
    readonly fullName: "devvit.runtime.actor.v1alpha.Health";
    readonly methods: {
        readonly check: {
            readonly name: "Check";
            readonly requestType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.runtime.actor.v1alpha.HealthStatus";
                encode(message: HealthStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HealthStatus;
                fromJSON(object: any): HealthStatus;
                toJSON(message: HealthStatus): unknown;
                create(base?: DeepPartial_111<HealthStatus>): HealthStatus;
                fromPartial(object: DeepPartial_111<HealthStatus>): HealthStatus;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const HealthServiceName = "devvit.runtime.actor.v1alpha.Health";

declare interface HealthStatus {
    start?: Date | undefined;
    end?: Date | undefined;
}

declare const HealthStatus: {
    $type: "devvit.runtime.actor.v1alpha.HealthStatus";
    encode(message: HealthStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HealthStatus;
    fromJSON(object: any): HealthStatus;
    toJSON(message: HealthStatus): unknown;
    create(base?: DeepPartial_111<HealthStatus>): HealthStatus;
    fromPartial(object: DeepPartial_111<HealthStatus>): HealthStatus;
};

/**
 * hello is a ping service, with various conditions applied to how it succeeds
 * and fails
 */
declare interface Hello {
    Ping(request: PingMessage, metadata?: Metadata): Promise<PingMessage>;
}

declare class HelloClientImpl implements Hello {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_40, opts?: {
        service?: string;
    });
    Ping(request: PingMessage, metadata?: Metadata): Promise<PingMessage>;
}

/**
 * hello is a ping service, with various conditions applied to how it succeeds
 * and fails
 */
declare type HelloDefinition = typeof HelloDefinition;

declare const HelloDefinition: {
    readonly name: "Hello";
    readonly fullName: "devvit.actor.hello.Hello";
    readonly methods: {
        readonly ping: {
            readonly name: "Ping";
            readonly requestType: {
                $type: "devvit.actor.hello.PingMessage";
                encode(message: PingMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): PingMessage;
                fromJSON(object: any): PingMessage;
                toJSON(message: PingMessage): unknown;
                create(base?: DeepPartial_59<PingMessage>): PingMessage;
                fromPartial(object: DeepPartial_59<PingMessage>): PingMessage;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.hello.PingMessage";
                encode(message: PingMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): PingMessage;
                fromJSON(object: any): PingMessage;
                toJSON(message: PingMessage): unknown;
                create(base?: DeepPartial_59<PingMessage>): PingMessage;
                fromPartial(object: DeepPartial_59<PingMessage>): PingMessage;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const HelloServiceName = "devvit.actor.hello.Hello";

declare interface HGetRequest {
    key: string;
    field: string;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const HGetRequest: {
    $type: "devvit.plugin.redis.HGetRequest";
    encode(message: HGetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HGetRequest;
    fromJSON(object: any): HGetRequest;
    toJSON(message: HGetRequest): unknown;
    create(base?: DeepPartial_86<HGetRequest>): HGetRequest;
    fromPartial(object: DeepPartial_86<HGetRequest>): HGetRequest;
};

declare interface HideWikiPageRevisionRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
    /** The name of the wiki page. */
    page: string;
    /** The revision ID to hide. */
    revision: string;
}

declare const HideWikiPageRevisionRequest: {
    $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionRequest";
    encode(message: HideWikiPageRevisionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HideWikiPageRevisionRequest;
    fromJSON(object: any): HideWikiPageRevisionRequest;
    toJSON(message: HideWikiPageRevisionRequest): unknown;
    create(base?: DeepPartial_9<HideWikiPageRevisionRequest>): HideWikiPageRevisionRequest;
    fromPartial(object: DeepPartial_9<HideWikiPageRevisionRequest>): HideWikiPageRevisionRequest;
};

declare interface HideWikiPageRevisionResponse {
    /** Whether the revision was hidden. */
    status: boolean;
}

declare const HideWikiPageRevisionResponse: {
    $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionResponse";
    encode(message: HideWikiPageRevisionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HideWikiPageRevisionResponse;
    fromJSON(object: any): HideWikiPageRevisionResponse;
    toJSON(message: HideWikiPageRevisionResponse): unknown;
    create(base?: DeepPartial_9<HideWikiPageRevisionResponse>): HideWikiPageRevisionResponse;
    fromPartial(object: DeepPartial_9<HideWikiPageRevisionResponse>): HideWikiPageRevisionResponse;
};

declare interface HighlightConversationResponse {
    /** @deprecated use `conversation` */
    conversations?: ConversationData_2 | undefined;
    messages: {
        [key: string]: MessageData_2;
    };
    modActions: {
        [key: string]: ModActionData_2;
    };
    conversation?: ConversationData_2 | undefined;
}

declare const HighlightConversationResponse: {
    $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse";
    encode(message: HighlightConversationResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HighlightConversationResponse;
    fromJSON(object: any): HighlightConversationResponse;
    toJSON(message: HighlightConversationResponse): unknown;
    create(base?: DeepPartial_71<HighlightConversationResponse>): HighlightConversationResponse;
    fromPartial(object: DeepPartial_71<HighlightConversationResponse>): HighlightConversationResponse;
};

declare interface HighlightConversationResponse_MessagesEntry {
    key: string;
    value?: MessageData_2 | undefined;
}

declare const HighlightConversationResponse_MessagesEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.MessagesEntry";
    encode(message: HighlightConversationResponse_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HighlightConversationResponse_MessagesEntry;
    fromJSON(object: any): HighlightConversationResponse_MessagesEntry;
    toJSON(message: HighlightConversationResponse_MessagesEntry): unknown;
    create(base?: DeepPartial_71<HighlightConversationResponse_MessagesEntry>): HighlightConversationResponse_MessagesEntry;
    fromPartial(object: DeepPartial_71<HighlightConversationResponse_MessagesEntry>): HighlightConversationResponse_MessagesEntry;
};

declare interface HighlightConversationResponse_ModActionsEntry {
    key: string;
    value?: ModActionData_2 | undefined;
}

declare const HighlightConversationResponse_ModActionsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.ModActionsEntry";
    encode(message: HighlightConversationResponse_ModActionsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HighlightConversationResponse_ModActionsEntry;
    fromJSON(object: any): HighlightConversationResponse_ModActionsEntry;
    toJSON(message: HighlightConversationResponse_ModActionsEntry): unknown;
    create(base?: DeepPartial_71<HighlightConversationResponse_ModActionsEntry>): HighlightConversationResponse_ModActionsEntry;
    fromPartial(object: DeepPartial_71<HighlightConversationResponse_ModActionsEntry>): HighlightConversationResponse_ModActionsEntry;
};

declare interface HIncrByRequest {
    key: string;
    field: string;
    value: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const HIncrByRequest: {
    $type: "devvit.plugin.redis.HIncrByRequest";
    encode(message: HIncrByRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HIncrByRequest;
    fromJSON(object: any): HIncrByRequest;
    toJSON(message: HIncrByRequest): unknown;
    create(base?: DeepPartial_86<HIncrByRequest>): HIncrByRequest;
    fromPartial(object: DeepPartial_86<HIncrByRequest>): HIncrByRequest;
};

/**
 * @mixin
 */
declare type HorizontalRuleContainer<Context> = {
    /**
     * Append a Horizontal Rule
     */
    horizontalRule(): Context;
};

declare interface HScanRequest {
    key: string;
    cursor: number;
    pattern?: string | undefined;
    count?: number | undefined;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const HScanRequest: {
    $type: "devvit.plugin.redis.HScanRequest";
    encode(message: HScanRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HScanRequest;
    fromJSON(object: any): HScanRequest;
    toJSON(message: HScanRequest): unknown;
    create(base?: DeepPartial_86<HScanRequest>): HScanRequest;
    fromPartial(object: DeepPartial_86<HScanRequest>): HScanRequest;
};

declare interface HScanResponse {
    cursor: number;
    fieldValues: RedisFieldValue[];
}

declare const HScanResponse: {
    $type: "devvit.plugin.redis.HScanResponse";
    encode(message: HScanResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HScanResponse;
    fromJSON(object: any): HScanResponse;
    toJSON(message: HScanResponse): unknown;
    create(base?: DeepPartial_86<HScanResponse>): HScanResponse;
    fromPartial(object: DeepPartial_86<HScanResponse>): HScanResponse;
};

declare interface HSetRequest {
    key: string;
    fv: RedisFieldValue[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const HSetRequest: {
    $type: "devvit.plugin.redis.HSetRequest";
    encode(message: HSetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HSetRequest;
    fromJSON(object: any): HSetRequest;
    toJSON(message: HSetRequest): unknown;
    create(base?: DeepPartial_86<HSetRequest>): HSetRequest;
    fromPartial(object: DeepPartial_86<HSetRequest>): HSetRequest;
};

declare interface HTTP {
    Fetch(request: FetchRequest, metadata?: Metadata): Promise<FetchResponse>;
}

declare class HTTPClientImpl implements HTTP {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_25, opts?: {
        service?: string;
    });
    Fetch(request: FetchRequest, metadata?: Metadata): Promise<FetchResponse>;
}

declare type HTTPDefinition = typeof HTTPDefinition;

declare const HTTPDefinition: {
    readonly name: "HTTP";
    readonly fullName: "devvit.plugin.http.HTTP";
    readonly methods: {
        readonly fetch: {
            readonly name: "Fetch";
            readonly requestType: {
                $type: "devvit.plugin.http.FetchRequest";
                encode(message: FetchRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): FetchRequest;
                fromJSON(object: any): FetchRequest;
                toJSON(message: FetchRequest): unknown;
                create(base?: DeepPartial_58<FetchRequest>): FetchRequest;
                fromPartial(object: DeepPartial_58<FetchRequest>): FetchRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.http.FetchResponse";
                encode(message: FetchResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): FetchResponse;
                fromJSON(object: any): FetchResponse;
                toJSON(message: FetchResponse): unknown;
                create(base?: DeepPartial_58<FetchResponse>): FetchResponse;
                fromPartial(object: DeepPartial_58<FetchResponse>): FetchResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const HTTPServiceName = "devvit.plugin.http.HTTP";

export declare type IconName = `${AllIconName}` | `${AllIconName}-outline` | `${AllIconName}-fill`;

declare type Image = {
    e: typeof IMAGE_ELEMENT;
    id: MediaAssetId;
    c?: string;
    o?: ObfuscationReason;
};

declare const IMAGE_ELEMENT = "img";

/**
 * @mixin
 */
declare type ImageContainer<Context> = {
    /**
     * Append an Image
     * @param opts {@link ImageOptions}
     */
    image(opts: ImageOptions): Context;
    /**
     * Append an Animated Image
     * @param opts {@link ImageOptions}
     */
    animatedImage(opts: ImageOptions): Context;
};

/**
 * Allows a user to upload an image as part of submitting the form. The string value that's
 * given back is the URL of the image.
 * @experimental
 */
export declare type ImageField = Omit<BaseField<string>, 'defaultValue'> & {
    type: 'image';
};

/**
 * @borrows MediaOptions
 */
declare type ImageOptions = MediaOptions;

export declare class ImageWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get images(): WidgetImage[];
    toJSON(): ReturnType<Widget['toJSON']> & Pick<ImageWidget, 'images'>;
}

declare interface ImageWidget_2 {
    id: string;
    kind: string;
    data: WidgetImage[];
    shortName: string;
    styles?: WidgetStyles | undefined;
    subreddit?: string | undefined;
}

declare const ImageWidget_2: {
    $type: "devvit.plugin.redditapi.widgets.ImageWidget";
    encode(message: ImageWidget_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ImageWidget_2;
    fromJSON(object: any): ImageWidget_2;
    toJSON(message: ImageWidget_2): unknown;
    create(base?: DeepPartial_4<ImageWidget_2>): ImageWidget_2;
    fromPartial(object: DeepPartial_4<ImageWidget_2>): ImageWidget_2;
};

declare interface IncrByRequest {
    key: string;
    value: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const IncrByRequest: {
    $type: "devvit.plugin.redis.IncrByRequest";
    encode(message: IncrByRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): IncrByRequest;
    fromJSON(object: any): IncrByRequest;
    toJSON(message: IncrByRequest): unknown;
    create(base?: DeepPartial_86<IncrByRequest>): IncrByRequest;
    fromPartial(object: DeepPartial_86<IncrByRequest>): IncrByRequest;
};

declare interface InfoRequest {
    /**
     * List of zero or more Subreddit names to fetch
     * @example ["AskReddit", "jokes"]
     */
    subreddits: string[];
    /**
     * List of zero or more thing IDs to fetch
     * Note: Must be a Comment (t1), Post (t3), or Subreddit (t5) ID
     * @example ["t1_abc123", "t3_abc123", "t5_abc123"]
     */
    thingIds: string[];
    /**
     * Any Link Posts that refer to this URL
     * Note: Providing `url` overrides `subreddits` and `thing_ids`
     * @example "https://www.reddit.com/"
     */
    url?: string | undefined;
}

declare const InfoRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.InfoRequest";
    encode(message: InfoRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InfoRequest;
    fromJSON(object: any): InfoRequest;
    toJSON(message: InfoRequest): unknown;
    create(base?: DeepPartial_64<InfoRequest>): InfoRequest;
    fromPartial(object: DeepPartial_64<InfoRequest>): InfoRequest;
};

declare interface Inspector {
    ListActors(request: InspectorQuery, metadata?: Metadata): Promise<InspectorDescriptions>;
    ActorChanges(request: Empty, metadata?: Metadata): Observable<InspectorUpdate>;
}

declare class InspectorClientImpl implements Inspector {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_24, opts?: {
        service?: string;
    });
    ListActors(request: InspectorQuery, metadata?: Metadata): Promise<InspectorDescriptions>;
    ActorChanges(request: Empty, metadata?: Metadata): Observable<InspectorUpdate>;
}

declare type InspectorDefinition = typeof InspectorDefinition;

declare const InspectorDefinition: {
    readonly name: "Inspector";
    readonly fullName: "devvit.plugin.inspector.Inspector";
    readonly methods: {
        readonly listActors: {
            readonly name: "ListActors";
            readonly requestType: {
                $type: "devvit.plugin.inspector.InspectorQuery";
                encode(message: InspectorQuery, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): InspectorQuery;
                fromJSON(object: any): InspectorQuery;
                toJSON(message: InspectorQuery): unknown;
                create(base?: DeepPartial_60<InspectorQuery>): InspectorQuery;
                fromPartial(object: DeepPartial_60<InspectorQuery>): InspectorQuery;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.inspector.InspectorDescriptions";
                encode(message: InspectorDescriptions, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): InspectorDescriptions;
                fromJSON(object: any): InspectorDescriptions;
                toJSON(message: InspectorDescriptions): unknown;
                create(base?: DeepPartial_60<InspectorDescriptions>): InspectorDescriptions;
                fromPartial(object: DeepPartial_60<InspectorDescriptions>): InspectorDescriptions;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly actorChanges: {
            readonly name: "ActorChanges";
            readonly requestType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.inspector.InspectorUpdate";
                encode(message: InspectorUpdate, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): InspectorUpdate;
                fromJSON(object: any): InspectorUpdate;
                toJSON(message: InspectorUpdate): unknown;
                create(base?: DeepPartial_60<InspectorUpdate>): InspectorUpdate;
                fromPartial(object: DeepPartial_60<InspectorUpdate>): InspectorUpdate;
            };
            readonly responseStream: true;
            readonly options: {};
        };
    };
};

declare interface InspectorDescription {
    provides: SerializableServiceDefinition[];
    hostname: string;
}

declare const InspectorDescription: {
    $type: "devvit.plugin.inspector.InspectorDescription";
    encode(message: InspectorDescription, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InspectorDescription;
    fromJSON(object: any): InspectorDescription;
    toJSON(message: InspectorDescription): unknown;
    create(base?: DeepPartial_60<InspectorDescription>): InspectorDescription;
    fromPartial(object: DeepPartial_60<InspectorDescription>): InspectorDescription;
};

declare interface InspectorDescriptions {
    descriptions: InspectorDescription[];
}

declare const InspectorDescriptions: {
    $type: "devvit.plugin.inspector.InspectorDescriptions";
    encode(message: InspectorDescriptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InspectorDescriptions;
    fromJSON(object: any): InspectorDescriptions;
    toJSON(message: InspectorDescriptions): unknown;
    create(base?: DeepPartial_60<InspectorDescriptions>): InspectorDescriptions;
    fromPartial(object: DeepPartial_60<InspectorDescriptions>): InspectorDescriptions;
};

declare interface InspectorQuery {
    type: string;
    hostname: string;
}

declare const InspectorQuery: {
    $type: "devvit.plugin.inspector.InspectorQuery";
    encode(message: InspectorQuery, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InspectorQuery;
    fromJSON(object: any): InspectorQuery;
    toJSON(message: InspectorQuery): unknown;
    create(base?: DeepPartial_60<InspectorQuery>): InspectorQuery;
    fromPartial(object: DeepPartial_60<InspectorQuery>): InspectorQuery;
};

declare const InspectorServiceName = "devvit.plugin.inspector.Inspector";

declare interface InspectorUpdate {
    description?: InspectorDescription | undefined;
    type: InspectorUpdateType;
}

declare const InspectorUpdate: {
    $type: "devvit.plugin.inspector.InspectorUpdate";
    encode(message: InspectorUpdate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InspectorUpdate;
    fromJSON(object: any): InspectorUpdate;
    toJSON(message: InspectorUpdate): unknown;
    create(base?: DeepPartial_60<InspectorUpdate>): InspectorUpdate;
    fromPartial(object: DeepPartial_60<InspectorUpdate>): InspectorUpdate;
};

declare enum InspectorUpdateType {
    ADDED = 0,
    REMOVED = 1,
    CHANGED = 2,
    /** SUBSCRIBED - The client is now a registered subscriber and will receive updates. */
    SUBSCRIBED = 3,
    UNRECOGNIZED = -1
}

declare function inspectorUpdateTypeFromJSON(object: any): InspectorUpdateType;

declare function inspectorUpdateTypeToJSON(object: InspectorUpdateType): number;

/** Contains the details of an installation. For field documentation, refer to the Prisma schema. */
declare interface InstallationInfo {
    id: string;
    /** string installed_by = 2; // Removed; see DX-2225 */
    upgradeStrategy: UpgradeStrategy;
    upgradeStrategyConfig?: {
        [key: string]: any;
    } | undefined;
    runAs?: string | undefined;
    type: InstallationType;
    location?: InstallationLocationInfo | undefined;
    isEnabled: boolean;
}

declare const InstallationInfo: {
    $type: "devvit.dev_portal.installation.InstallationInfo";
    encode(message: InstallationInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InstallationInfo;
    fromJSON(object: any): InstallationInfo;
    toJSON(message: InstallationInfo): unknown;
    create(base?: DeepPartial_98<InstallationInfo>): InstallationInfo;
    fromPartial(object: DeepPartial_98<InstallationInfo>): InstallationInfo;
};

declare interface InstallationLocationInfo {
    /** Thing ID; eg, `"t5_2qh0u"` for r/pics. */
    id: string;
    /** Thing name; eg, `"pics"` for r/pics. */
    name: string;
    /** Thing type; eg, `5`, the second character in `t5_2qh0u` for r/pics. */
    type: ThingType;
    icon?: string | undefined;
    isNsfw: boolean;
    /** True if subreddit is private and the user isn't a member, or is not visible to viewer for any other reason. */
    isUnavailable: boolean;
}

declare const InstallationLocationInfo: {
    $type: "devvit.dev_portal.installation.InstallationLocationInfo";
    encode(message: InstallationLocationInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InstallationLocationInfo;
    fromJSON(object: any): InstallationLocationInfo;
    toJSON(message: InstallationLocationInfo): unknown;
    create(base?: DeepPartial_98<InstallationLocationInfo>): InstallationLocationInfo;
    fromPartial(object: DeepPartial_98<InstallationLocationInfo>): InstallationLocationInfo;
};

declare interface InstallationPurgeRequest {
    installationId: string;
}

declare const InstallationPurgeRequest: {
    $type: "devvit.gateway.utils.v1alpha.InstallationPurgeRequest";
    encode(message: InstallationPurgeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InstallationPurgeRequest;
    fromJSON(object: any): InstallationPurgeRequest;
    toJSON(message: InstallationPurgeRequest): unknown;
    create(base?: DeepPartial_26<InstallationPurgeRequest>): InstallationPurgeRequest;
    fromPartial(object: DeepPartial_26<InstallationPurgeRequest>): InstallationPurgeRequest;
};

/**
 * Define settings configured by the user when your app is installed.
 * Installation-level settings are available to every instance of your app within a single
 * installation context.  For example, if creating a custom post app, every post will have access
 * to these settings.
 * Load the saved values with the Settings plugin.
 */
declare interface InstallationSettings {
    /** Requested by the platform when rendering the configure form upon installing this app */
    GetSettingsFields(request: GetFieldsRequest, metadata?: Metadata): Promise<GetFieldsResponse>;
    /** Called by the installation form before saving settings to allow for more advanced field validation */
    ValidateForm(request: ValidateFormRequest, metadata?: Metadata): Promise<ValidateFormResponse>;
}

declare class InstallationSettingsClientImpl implements InstallationSettings {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_66, opts?: {
        service?: string;
    });
    GetSettingsFields(request: GetFieldsRequest, metadata?: Metadata): Promise<GetFieldsResponse>;
    ValidateForm(request: ValidateFormRequest, metadata?: Metadata): Promise<ValidateFormResponse>;
}

/**
 * Define settings configured by the user when your app is installed.
 * Installation-level settings are available to every instance of your app within a single
 * installation context.  For example, if creating a custom post app, every post will have access
 * to these settings.
 * Load the saved values with the Settings plugin.
 */
declare type InstallationSettingsDefinition = typeof InstallationSettingsDefinition;

declare const InstallationSettingsDefinition: {
    readonly name: "InstallationSettings";
    readonly fullName: "devvit.actor.settings.v1alpha.InstallationSettings";
    readonly methods: {
        /** Requested by the platform when rendering the configure form upon installing this app */
        readonly getSettingsFields: {
            readonly name: "GetSettingsFields";
            readonly requestType: {
                $type: "devvit.actor.settings.v1alpha.GetFieldsRequest";
                encode(message: GetFieldsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetFieldsRequest;
                fromJSON(object: any): GetFieldsRequest;
                toJSON(message: GetFieldsRequest): unknown;
                create(base?: {
                    editing?: boolean;
                } | undefined): GetFieldsRequest;
                fromPartial(object: {
                    editing?: boolean;
                }): GetFieldsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.settings.v1alpha.GetFieldsResponse";
                encode(message: GetFieldsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetFieldsResponse;
                fromJSON(object: any): GetFieldsResponse;
                toJSON(message: GetFieldsResponse): unknown;
                create(base?: {
                    fields?: {
                        fields?: {
                            fieldId?: string;
                            fieldType?: FormFieldType_2;
                            label?: string;
                            helpText?: string | undefined;
                            defaultValue?: {
                                fieldType?: FormFieldType_2;
                                isSecret?: boolean | undefined;
                                stringValue?: string | undefined;
                                numberValue?: number | undefined;
                                boolValue?: boolean | undefined;
                                listValue?: {
                                    itemType?: FormFieldType_2;
                                    items?: any[];
                                } | undefined;
                                selectionValue?: {
                                    values?: string[];
                                } | undefined;
                                groupValue?: {} | undefined;
                            } | undefined;
                            required?: boolean | undefined;
                            disabled?: boolean | undefined;
                            fieldConfig?: {
                                stringConfig?: {
                                    minLength?: number | undefined;
                                    maxLength?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                paragraphConfig?: {
                                    maxCharacters?: number | undefined;
                                    lineHeight?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                numberConfig?: {
                                    step?: number | undefined;
                                    min?: number | undefined;
                                    max?: number | undefined;
                                } | undefined;
                                booleanConfig?: {} | undefined;
                                listConfig?: {
                                    itemType?: FormFieldType_2;
                                    itemConfig?: any | undefined;
                                    minEntries?: number | undefined;
                                    maxEntries?: number | undefined;
                                    entryLabel?: string | undefined;
                                } | undefined;
                                selectionConfig?: {
                                    choices?: {
                                        label?: string;
                                        value?: string;
                                    }[];
                                    multiSelect?: boolean | undefined;
                                    minSelections?: number | undefined;
                                    maxSelections?: number | undefined;
                                    renderAsList?: boolean | undefined;
                                } | undefined;
                                groupConfig?: {
                                    fields?: any[];
                                } | undefined;
                            } | undefined;
                            isSecret?: boolean | undefined;
                        }[];
                        title?: string | undefined;
                        shortDescription?: string | undefined;
                        acceptLabel?: string | undefined;
                        cancelLabel?: string | undefined;
                        id?: string | undefined;
                    } | undefined;
                } | undefined): GetFieldsResponse;
                fromPartial(object: {
                    fields?: {
                        fields?: {
                            fieldId?: string;
                            fieldType?: FormFieldType_2;
                            label?: string;
                            helpText?: string | undefined;
                            defaultValue?: {
                                fieldType?: FormFieldType_2;
                                isSecret?: boolean | undefined;
                                stringValue?: string | undefined;
                                numberValue?: number | undefined;
                                boolValue?: boolean | undefined;
                                listValue?: {
                                    itemType?: FormFieldType_2;
                                    items?: any[];
                                } | undefined;
                                selectionValue?: {
                                    values?: string[];
                                } | undefined;
                                groupValue?: {} | undefined;
                            } | undefined;
                            required?: boolean | undefined;
                            disabled?: boolean | undefined;
                            fieldConfig?: {
                                stringConfig?: {
                                    minLength?: number | undefined;
                                    maxLength?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                paragraphConfig?: {
                                    maxCharacters?: number | undefined;
                                    lineHeight?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                numberConfig?: {
                                    step?: number | undefined;
                                    min?: number | undefined;
                                    max?: number | undefined;
                                } | undefined;
                                booleanConfig?: {} | undefined;
                                listConfig?: {
                                    itemType?: FormFieldType_2;
                                    itemConfig?: any | undefined;
                                    minEntries?: number | undefined;
                                    maxEntries?: number | undefined;
                                    entryLabel?: string | undefined;
                                } | undefined;
                                selectionConfig?: {
                                    choices?: {
                                        label?: string;
                                        value?: string;
                                    }[];
                                    multiSelect?: boolean | undefined;
                                    minSelections?: number | undefined;
                                    maxSelections?: number | undefined;
                                    renderAsList?: boolean | undefined;
                                } | undefined;
                                groupConfig?: {
                                    fields?: any[];
                                } | undefined;
                            } | undefined;
                            isSecret?: boolean | undefined;
                        }[];
                        title?: string | undefined;
                        shortDescription?: string | undefined;
                        acceptLabel?: string | undefined;
                        cancelLabel?: string | undefined;
                        id?: string | undefined;
                    } | undefined;
                }): GetFieldsResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Called by the installation form before saving settings to allow for more advanced field validation */
        readonly validateForm: {
            readonly name: "ValidateForm";
            readonly requestType: {
                $type: "devvit.actor.settings.v1alpha.ValidateFormRequest";
                encode(message: ValidateFormRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ValidateFormRequest;
                fromJSON(object: any): ValidateFormRequest;
                toJSON(message: ValidateFormRequest): unknown;
                create(base?: {
                    editing?: boolean;
                    fieldValues?: {
                        [x: string]: {
                            fieldType?: FormFieldType_2;
                            isSecret?: boolean | undefined;
                            stringValue?: string | undefined;
                            numberValue?: number | undefined;
                            boolValue?: boolean | undefined;
                            listValue?: {
                                itemType?: FormFieldType_2;
                                items?: any[];
                            } | undefined;
                            selectionValue?: {
                                values?: string[];
                            } | undefined;
                            groupValue?: {} | undefined;
                        } | undefined;
                    };
                } | undefined): ValidateFormRequest;
                fromPartial(object: {
                    editing?: boolean;
                    fieldValues?: {
                        [x: string]: {
                            fieldType?: FormFieldType_2;
                            isSecret?: boolean | undefined;
                            stringValue?: string | undefined;
                            numberValue?: number | undefined;
                            boolValue?: boolean | undefined;
                            listValue?: {
                                itemType?: FormFieldType_2;
                                items?: any[];
                            } | undefined;
                            selectionValue?: {
                                values?: string[];
                            } | undefined;
                            groupValue?: {} | undefined;
                        } | undefined;
                    };
                }): ValidateFormRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.settings.v1alpha.ValidateFormResponse";
                encode(message: ValidateFormResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ValidateFormResponse;
                fromJSON(object: any): ValidateFormResponse;
                toJSON(message: ValidateFormResponse): unknown;
                create(base?: {
                    success?: boolean;
                    errors?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): ValidateFormResponse;
                fromPartial(object: {
                    success?: boolean;
                    errors?: {
                        [x: string]: string | undefined;
                    };
                }): ValidateFormResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const InstallationSettingsServiceName = "devvit.actor.settings.v1alpha.InstallationSettings";

declare interface InstallationsPurgeRequest {
    /** t5 subreddit id */
    subreddit: string;
}

declare const InstallationsPurgeRequest: {
    $type: "devvit.gateway.utils.v1alpha.InstallationsPurgeRequest";
    encode(message: InstallationsPurgeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InstallationsPurgeRequest;
    fromJSON(object: any): InstallationsPurgeRequest;
    toJSON(message: InstallationsPurgeRequest): unknown;
    create(base?: DeepPartial_26<InstallationsPurgeRequest>): InstallationsPurgeRequest;
    fromPartial(object: DeepPartial_26<InstallationsPurgeRequest>): InstallationsPurgeRequest;
};

declare enum InstallationType {
    USER = 0,
    SUBREDDIT = 1,
    SUBREDDIT_GLOBAL = 2,
    UNRECOGNIZED = -1
}

/**
 * Define settings scoped to a single instance of your app.
 * Useful for multi-instanced apps such as custom posts, where each post is configured by the user
 * when they create the post.  These values will _not_ be shared between instances.
 * Load the saved values with the Settings plugin.
 */
declare interface InstanceSettings {
    /** Requested by the platform when rendering the form to configure this actor */
    GetSettingsFields(request: GetFieldsRequest, metadata?: Metadata): Promise<GetFieldsResponse>;
    /** Called by the platform to allow more advanced verification of fields */
    ValidateForm(request: ValidateFormRequest, metadata?: Metadata): Promise<ValidateFormResponse>;
}

declare class InstanceSettingsClientImpl implements InstanceSettings {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_65, opts?: {
        service?: string;
    });
    GetSettingsFields(request: GetFieldsRequest, metadata?: Metadata): Promise<GetFieldsResponse>;
    ValidateForm(request: ValidateFormRequest, metadata?: Metadata): Promise<ValidateFormResponse>;
}

/**
 * Define settings scoped to a single instance of your app.
 * Useful for multi-instanced apps such as custom posts, where each post is configured by the user
 * when they create the post.  These values will _not_ be shared between instances.
 * Load the saved values with the Settings plugin.
 */
declare type InstanceSettingsDefinition = typeof InstanceSettingsDefinition;

declare const InstanceSettingsDefinition: {
    readonly name: "InstanceSettings";
    readonly fullName: "devvit.actor.settings.v1alpha.InstanceSettings";
    readonly methods: {
        /** Requested by the platform when rendering the form to configure this actor */
        readonly getSettingsFields: {
            readonly name: "GetSettingsFields";
            readonly requestType: {
                $type: "devvit.actor.settings.v1alpha.GetFieldsRequest";
                encode(message: GetFieldsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetFieldsRequest;
                fromJSON(object: any): GetFieldsRequest;
                toJSON(message: GetFieldsRequest): unknown;
                create(base?: {
                    editing?: boolean;
                } | undefined): GetFieldsRequest;
                fromPartial(object: {
                    editing?: boolean;
                }): GetFieldsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.settings.v1alpha.GetFieldsResponse";
                encode(message: GetFieldsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetFieldsResponse;
                fromJSON(object: any): GetFieldsResponse;
                toJSON(message: GetFieldsResponse): unknown;
                create(base?: {
                    fields?: {
                        fields?: {
                            fieldId?: string;
                            fieldType?: FormFieldType_2;
                            label?: string;
                            helpText?: string | undefined;
                            defaultValue?: {
                                fieldType?: FormFieldType_2;
                                isSecret?: boolean | undefined;
                                stringValue?: string | undefined;
                                numberValue?: number | undefined;
                                boolValue?: boolean | undefined;
                                listValue?: {
                                    itemType?: FormFieldType_2;
                                    items?: any[];
                                } | undefined;
                                selectionValue?: {
                                    values?: string[];
                                } | undefined;
                                groupValue?: {} | undefined;
                            } | undefined;
                            required?: boolean | undefined;
                            disabled?: boolean | undefined;
                            fieldConfig?: {
                                stringConfig?: {
                                    minLength?: number | undefined;
                                    maxLength?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                paragraphConfig?: {
                                    maxCharacters?: number | undefined;
                                    lineHeight?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                numberConfig?: {
                                    step?: number | undefined;
                                    min?: number | undefined;
                                    max?: number | undefined;
                                } | undefined;
                                booleanConfig?: {} | undefined;
                                listConfig?: {
                                    itemType?: FormFieldType_2;
                                    itemConfig?: any | undefined;
                                    minEntries?: number | undefined;
                                    maxEntries?: number | undefined;
                                    entryLabel?: string | undefined;
                                } | undefined;
                                selectionConfig?: {
                                    choices?: {
                                        label?: string;
                                        value?: string;
                                    }[];
                                    multiSelect?: boolean | undefined;
                                    minSelections?: number | undefined;
                                    maxSelections?: number | undefined;
                                    renderAsList?: boolean | undefined;
                                } | undefined;
                                groupConfig?: {
                                    fields?: any[];
                                } | undefined;
                            } | undefined;
                            isSecret?: boolean | undefined;
                        }[];
                        title?: string | undefined;
                        shortDescription?: string | undefined;
                        acceptLabel?: string | undefined;
                        cancelLabel?: string | undefined;
                        id?: string | undefined;
                    } | undefined;
                } | undefined): GetFieldsResponse;
                fromPartial(object: {
                    fields?: {
                        fields?: {
                            fieldId?: string;
                            fieldType?: FormFieldType_2;
                            label?: string;
                            helpText?: string | undefined;
                            defaultValue?: {
                                fieldType?: FormFieldType_2;
                                isSecret?: boolean | undefined;
                                stringValue?: string | undefined;
                                numberValue?: number | undefined;
                                boolValue?: boolean | undefined;
                                listValue?: {
                                    itemType?: FormFieldType_2;
                                    items?: any[];
                                } | undefined;
                                selectionValue?: {
                                    values?: string[];
                                } | undefined;
                                groupValue?: {} | undefined;
                            } | undefined;
                            required?: boolean | undefined;
                            disabled?: boolean | undefined;
                            fieldConfig?: {
                                stringConfig?: {
                                    minLength?: number | undefined;
                                    maxLength?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                paragraphConfig?: {
                                    maxCharacters?: number | undefined;
                                    lineHeight?: number | undefined;
                                    placeholder?: string | undefined;
                                } | undefined;
                                numberConfig?: {
                                    step?: number | undefined;
                                    min?: number | undefined;
                                    max?: number | undefined;
                                } | undefined;
                                booleanConfig?: {} | undefined;
                                listConfig?: {
                                    itemType?: FormFieldType_2;
                                    itemConfig?: any | undefined;
                                    minEntries?: number | undefined;
                                    maxEntries?: number | undefined;
                                    entryLabel?: string | undefined;
                                } | undefined;
                                selectionConfig?: {
                                    choices?: {
                                        label?: string;
                                        value?: string;
                                    }[];
                                    multiSelect?: boolean | undefined;
                                    minSelections?: number | undefined;
                                    maxSelections?: number | undefined;
                                    renderAsList?: boolean | undefined;
                                } | undefined;
                                groupConfig?: {
                                    fields?: any[];
                                } | undefined;
                            } | undefined;
                            isSecret?: boolean | undefined;
                        }[];
                        title?: string | undefined;
                        shortDescription?: string | undefined;
                        acceptLabel?: string | undefined;
                        cancelLabel?: string | undefined;
                        id?: string | undefined;
                    } | undefined;
                }): GetFieldsResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Called by the platform to allow more advanced verification of fields */
        readonly validateForm: {
            readonly name: "ValidateForm";
            readonly requestType: {
                $type: "devvit.actor.settings.v1alpha.ValidateFormRequest";
                encode(message: ValidateFormRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ValidateFormRequest;
                fromJSON(object: any): ValidateFormRequest;
                toJSON(message: ValidateFormRequest): unknown;
                create(base?: {
                    editing?: boolean;
                    fieldValues?: {
                        [x: string]: {
                            fieldType?: FormFieldType_2;
                            isSecret?: boolean | undefined;
                            stringValue?: string | undefined;
                            numberValue?: number | undefined;
                            boolValue?: boolean | undefined;
                            listValue?: {
                                itemType?: FormFieldType_2;
                                items?: any[];
                            } | undefined;
                            selectionValue?: {
                                values?: string[];
                            } | undefined;
                            groupValue?: {} | undefined;
                        } | undefined;
                    };
                } | undefined): ValidateFormRequest;
                fromPartial(object: {
                    editing?: boolean;
                    fieldValues?: {
                        [x: string]: {
                            fieldType?: FormFieldType_2;
                            isSecret?: boolean | undefined;
                            stringValue?: string | undefined;
                            numberValue?: number | undefined;
                            boolValue?: boolean | undefined;
                            listValue?: {
                                itemType?: FormFieldType_2;
                                items?: any[];
                            } | undefined;
                            selectionValue?: {
                                values?: string[];
                            } | undefined;
                            groupValue?: {} | undefined;
                        } | undefined;
                    };
                }): ValidateFormRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.settings.v1alpha.ValidateFormResponse";
                encode(message: ValidateFormResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ValidateFormResponse;
                fromJSON(object: any): ValidateFormResponse;
                toJSON(message: ValidateFormResponse): unknown;
                create(base?: {
                    success?: boolean;
                    errors?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): ValidateFormResponse;
                fromPartial(object: {
                    success?: boolean;
                    errors?: {
                        [x: string]: string | undefined;
                    };
                }): ValidateFormResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const InstanceSettingsServiceName = "devvit.actor.settings.v1alpha.InstanceSettings";

/**
 * Wrapper message for `int32`.
 *
 * The JSON representation for `Int32Value` is JSON number.
 */
declare interface Int32Value {
    /** The int32 value. */
    value: number;
}

declare const Int32Value: {
    $type: "google.protobuf.Int32Value";
    encode(message: Int32Value, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Int32Value;
    fromJSON(object: any): Int32Value;
    toJSON(message: Int32Value): unknown;
    create(base?: DeepPartial_69<Int32Value>): Int32Value;
    fromPartial(object: DeepPartial_69<Int32Value>): Int32Value;
};

/**
 * Wrapper message for `int64`.
 *
 * The JSON representation for `Int64Value` is JSON string.
 */
declare interface Int64Value {
    /** The int64 value. */
    value: number;
}

declare const Int64Value: {
    $type: "google.protobuf.Int64Value";
    encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Int64Value;
    fromJSON(object: any): Int64Value;
    toJSON(message: Int64Value): unknown;
    create(base?: DeepPartial_69<Int64Value>): Int64Value;
    fromPartial(object: DeepPartial_69<Int64Value>): Int64Value;
};

declare interface IntakeEvent {
    topic: string;
    id: string;
    event?: Any | undefined;
}

declare const IntakeEvent: {
    $type: "devvit.data.api.v1alpha.IntakeEvent";
    encode(message: IntakeEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): IntakeEvent;
    fromJSON(object: any): IntakeEvent;
    toJSON(message: IntakeEvent): unknown;
    create(base?: DeepPartial_53<IntakeEvent>): IntakeEvent;
    fromPartial(object: DeepPartial_53<IntakeEvent>): IntakeEvent;
};

declare interface IntakeResponse {
}

declare const IntakeResponse: {
    $type: "devvit.data.api.v1alpha.IntakeResponse";
    encode(_: IntakeResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): IntakeResponse;
    fromJSON(_: any): IntakeResponse;
    toJSON(_: IntakeResponse): unknown;
    create(base?: DeepPartial_53<IntakeResponse>): IntakeResponse;
    fromPartial(_: DeepPartial_53<IntakeResponse>): IntakeResponse;
};

export declare type InternalSetPostFlairOptions = SetFlairOptions & {
    postId: T3ID;
};

declare interface IntervalDetails {
    duration?: Duration | undefined;
    /** Distinguishes between synchronous and asynchronous events. */
    async?: boolean | undefined;
}

declare const IntervalDetails: {
    $type: "devvit.ui.effects.v1alpha.IntervalDetails";
    encode(message: IntervalDetails, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): IntervalDetails;
    fromJSON(object: any): IntervalDetails;
    toJSON(message: IntervalDetails): unknown;
    create(base?: DeepPartial_39<IntervalDetails>): IntervalDetails;
    fromPartial(object: DeepPartial_39<IntervalDetails>): IntervalDetails;
};

declare type InviteModeratorOptions = {
    /** The name of the subreddit to invite the user to moderate */
    subredditName: string;
    /** The name of the user to invite as a moderator */
    username: string;
    /** The permissions to grant the user */
    permissions?: ModeratorPermission[];
};

export declare type JSONArray = JSONValue[];

export declare type JSONObject = {
    [key: string]: JSONValue;
};

export declare type JSONPrimitive = boolean | null | number | string;

declare interface JsonRedditObjects {
    json?: JsonRedditObjects_JsonType | undefined;
}

declare const JsonRedditObjects: {
    $type: "devvit.plugin.redditapi.common.JsonRedditObjects";
    encode(message: JsonRedditObjects, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonRedditObjects;
    fromJSON(object: any): JsonRedditObjects;
    toJSON(message: JsonRedditObjects): unknown;
    create(base?: DeepPartial_8<JsonRedditObjects>): JsonRedditObjects;
    fromPartial(object: DeepPartial_8<JsonRedditObjects>): JsonRedditObjects;
};

declare interface JsonRedditObjects_JsonType {
    errors: Any[];
    data?: JsonRedditObjects_JsonType_JsonData | undefined;
}

declare const JsonRedditObjects_JsonType: {
    $type: "devvit.plugin.redditapi.common.JsonRedditObjects.JsonType";
    encode(message: JsonRedditObjects_JsonType, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonRedditObjects_JsonType;
    fromJSON(object: any): JsonRedditObjects_JsonType;
    toJSON(message: JsonRedditObjects_JsonType): unknown;
    create(base?: DeepPartial_8<JsonRedditObjects_JsonType>): JsonRedditObjects_JsonType;
    fromPartial(object: DeepPartial_8<JsonRedditObjects_JsonType>): JsonRedditObjects_JsonType;
};

declare interface JsonRedditObjects_JsonType_JsonData {
    things: WrappedRedditObject[];
}

declare const JsonRedditObjects_JsonType_JsonData: {
    $type: "devvit.plugin.redditapi.common.JsonRedditObjects.JsonType.JsonData";
    encode(message: JsonRedditObjects_JsonType_JsonData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonRedditObjects_JsonType_JsonData;
    fromJSON(object: any): JsonRedditObjects_JsonType_JsonData;
    toJSON(message: JsonRedditObjects_JsonType_JsonData): unknown;
    create(base?: DeepPartial_8<JsonRedditObjects_JsonType_JsonData>): JsonRedditObjects_JsonType_JsonData;
    fromPartial(object: DeepPartial_8<JsonRedditObjects_JsonType_JsonData>): JsonRedditObjects_JsonType_JsonData;
};

declare interface JsonStatus {
    json?: JsonStatus_JsonErrorType | undefined;
}

declare const JsonStatus: {
    $type: "devvit.plugin.redditapi.common.JsonStatus";
    encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonStatus;
    fromJSON(object: any): JsonStatus;
    toJSON(message: JsonStatus): unknown;
    create(base?: DeepPartial_8<JsonStatus>): JsonStatus;
    fromPartial(object: DeepPartial_8<JsonStatus>): JsonStatus;
};

declare interface JsonStatus_JsonErrorType {
    errors: string[];
}

declare const JsonStatus_JsonErrorType: {
    $type: "devvit.plugin.redditapi.common.JsonStatus.JsonErrorType";
    encode(message: JsonStatus_JsonErrorType, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonStatus_JsonErrorType;
    fromJSON(object: any): JsonStatus_JsonErrorType;
    toJSON(message: JsonStatus_JsonErrorType): unknown;
    create(base?: DeepPartial_8<JsonStatus_JsonErrorType>): JsonStatus_JsonErrorType;
    fromPartial(object: DeepPartial_8<JsonStatus_JsonErrorType>): JsonStatus_JsonErrorType;
};

/**
 * Any JSON type. Ie, a string, number, boolean, null, an array of these JSON
 * types, or an object with JSON type values, recursively.
 *
 * This type is often used to type-check attempts to serialize and deserialize
 * classes, functions, and other _JavaScript_-only types that cannot be
 * represented losslessly in plain JSON.
 *
 * @see https://github.com/microsoft/TypeScript/issues/1897
 * @see https://www.json.org
 */
export declare type JSONValue = JSONPrimitive | JSONArray | JSONObject;

/** Response Types */
declare interface JsonWrappedComment {
    json?: JsonWrappedComment_Json | undefined;
}

declare const JsonWrappedComment: {
    $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment";
    encode(message: JsonWrappedComment, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonWrappedComment;
    fromJSON(object: any): JsonWrappedComment;
    toJSON(message: JsonWrappedComment): unknown;
    create(base?: DeepPartial_64<JsonWrappedComment>): JsonWrappedComment;
    fromPartial(object: DeepPartial_64<JsonWrappedComment>): JsonWrappedComment;
};

declare interface JsonWrappedComment_Json {
    errors: string[];
    data?: JsonWrappedComment_JsonData | undefined;
}

declare const JsonWrappedComment_Json: {
    $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.Json";
    encode(message: JsonWrappedComment_Json, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonWrappedComment_Json;
    fromJSON(object: any): JsonWrappedComment_Json;
    toJSON(message: JsonWrappedComment_Json): unknown;
    create(base?: DeepPartial_64<JsonWrappedComment_Json>): JsonWrappedComment_Json;
    fromPartial(object: DeepPartial_64<JsonWrappedComment_Json>): JsonWrappedComment_Json;
};

declare interface JsonWrappedComment_JsonData {
    things: JsonWrappedComment_WrappedComment[];
}

declare const JsonWrappedComment_JsonData: {
    $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.JsonData";
    encode(message: JsonWrappedComment_JsonData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonWrappedComment_JsonData;
    fromJSON(object: any): JsonWrappedComment_JsonData;
    toJSON(message: JsonWrappedComment_JsonData): unknown;
    create(base?: DeepPartial_64<JsonWrappedComment_JsonData>): JsonWrappedComment_JsonData;
    fromPartial(object: DeepPartial_64<JsonWrappedComment_JsonData>): JsonWrappedComment_JsonData;
};

declare interface JsonWrappedComment_WrappedComment {
    kind: string;
    data?: Comment_2 | undefined;
}

declare const JsonWrappedComment_WrappedComment: {
    $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.WrappedComment";
    encode(message: JsonWrappedComment_WrappedComment, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonWrappedComment_WrappedComment;
    fromJSON(object: any): JsonWrappedComment_WrappedComment;
    toJSON(message: JsonWrappedComment_WrappedComment): unknown;
    create(base?: DeepPartial_64<JsonWrappedComment_WrappedComment>): JsonWrappedComment_WrappedComment;
    fromPartial(object: DeepPartial_64<JsonWrappedComment_WrappedComment>): JsonWrappedComment_WrappedComment;
};

declare interface KeepAliveMessage {
    timestamp?: Date | undefined;
}

declare const KeepAliveMessage: {
    $type: "devvit.remote_logger.KeepAliveMessage";
    encode(message: KeepAliveMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): KeepAliveMessage;
    fromJSON(object: any): KeepAliveMessage;
    toJSON(message: KeepAliveMessage): unknown;
    create(base?: DeepPartial_87<KeepAliveMessage>): KeepAliveMessage;
    fromPartial(object: DeepPartial_87<KeepAliveMessage>): KeepAliveMessage;
};

declare interface KeyRangeRequest {
    key: string;
    start: number;
    end: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const KeyRangeRequest: {
    $type: "devvit.plugin.redis.KeyRangeRequest";
    encode(message: KeyRangeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): KeyRangeRequest;
    fromJSON(object: any): KeyRangeRequest;
    toJSON(message: KeyRangeRequest): unknown;
    create(base?: DeepPartial_86<KeyRangeRequest>): KeyRangeRequest;
    fromPartial(object: DeepPartial_86<KeyRangeRequest>): KeyRangeRequest;
};

declare interface KeyRequest {
    key: string;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const KeyRequest: {
    $type: "devvit.plugin.redis.KeyRequest";
    encode(message: KeyRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): KeyRequest;
    fromJSON(object: any): KeyRequest;
    toJSON(message: KeyRequest): unknown;
    create(base?: DeepPartial_86<KeyRequest>): KeyRequest;
    fromPartial(object: DeepPartial_86<KeyRequest>): KeyRequest;
};

declare interface KeySet {
    keys: string[];
}

declare const KeySet: {
    $type: "devvit.plugin.kvstore.KeySet";
    encode(message: KeySet, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): KeySet;
    fromJSON(object: any): KeySet;
    toJSON(message: KeySet): unknown;
    create(base?: DeepPartial_61<KeySet>): KeySet;
    fromPartial(object: DeepPartial_61<KeySet>): KeySet;
};

declare interface KeysRequest {
    keys: string[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const KeysRequest: {
    $type: "devvit.plugin.redis.KeysRequest";
    encode(message: KeysRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): KeysRequest;
    fromJSON(object: any): KeysRequest;
    toJSON(message: KeysRequest): unknown;
    create(base?: DeepPartial_86<KeysRequest>): KeysRequest;
    fromPartial(object: DeepPartial_86<KeysRequest>): KeysRequest;
};

declare interface KeysResponse {
    keys: string[];
}

declare const KeysResponse: {
    $type: "devvit.plugin.redis.KeysResponse";
    encode(message: KeysResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): KeysResponse;
    fromJSON(object: any): KeysResponse;
    toJSON(message: KeysResponse): unknown;
    create(base?: DeepPartial_86<KeysResponse>): KeysResponse;
    fromPartial(object: DeepPartial_86<KeysResponse>): KeysResponse;
};

declare interface KeyValuesRequest {
    kv: RedisKeyValue[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const KeyValuesRequest: {
    $type: "devvit.plugin.redis.KeyValuesRequest";
    encode(message: KeyValuesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): KeyValuesRequest;
    fromJSON(object: any): KeyValuesRequest;
    toJSON(message: KeyValuesRequest): unknown;
    create(base?: DeepPartial_86<KeyValuesRequest>): KeyValuesRequest;
    fromPartial(object: DeepPartial_86<KeyValuesRequest>): KeyValuesRequest;
};

export declare type KVStore = {
    /**
     * Retrieves a value from the store at the given key
     */
    get<T extends JSONValue = JSONValue>(key: string): Promise<T | undefined>;
    /**
     * Assigns a value to a key in the store
     */
    put(key: string, value: JSONValue): Promise<void>;
    /**
     * Deletes a key from the store if present
     */
    delete(key: string): Promise<void>;
    /**
     * Returns a list of keys in the store
     */
    list(): Promise<string[]>;
};

declare interface KVStore_2 {
    Put(request: MessageSet, metadata?: Metadata): Promise<Empty>;
    Get(request: KeySet, metadata?: Metadata): Promise<MessageSet>;
    Del(request: KeySet, metadata?: Metadata): Promise<Empty>;
    List(request: ListFilter, metadata?: Metadata): Promise<KeySet>;
}

declare class KVStoreClientImpl implements KVStore_2 {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_23, opts?: {
        service?: string;
    });
    Put(request: MessageSet, metadata?: Metadata): Promise<Empty>;
    Get(request: KeySet, metadata?: Metadata): Promise<MessageSet>;
    Del(request: KeySet, metadata?: Metadata): Promise<Empty>;
    List(request: ListFilter, metadata?: Metadata): Promise<KeySet>;
}

declare type KVStoreDefinition = typeof KVStoreDefinition;

declare const KVStoreDefinition: {
    readonly name: "KVStore";
    readonly fullName: "devvit.plugin.kvstore.KVStore";
    readonly methods: {
        readonly put: {
            readonly name: "Put";
            readonly requestType: {
                $type: "devvit.plugin.kvstore.MessageSet";
                encode(message: MessageSet, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): MessageSet;
                fromJSON(object: any): MessageSet;
                toJSON(message: MessageSet): unknown;
                create(base?: DeepPartial_61<MessageSet>): MessageSet;
                fromPartial(object: DeepPartial_61<MessageSet>): MessageSet;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly get: {
            readonly name: "Get";
            readonly requestType: {
                $type: "devvit.plugin.kvstore.KeySet";
                encode(message: KeySet, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeySet;
                fromJSON(object: any): KeySet;
                toJSON(message: KeySet): unknown;
                create(base?: DeepPartial_61<KeySet>): KeySet;
                fromPartial(object: DeepPartial_61<KeySet>): KeySet;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.kvstore.MessageSet";
                encode(message: MessageSet, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): MessageSet;
                fromJSON(object: any): MessageSet;
                toJSON(message: MessageSet): unknown;
                create(base?: DeepPartial_61<MessageSet>): MessageSet;
                fromPartial(object: DeepPartial_61<MessageSet>): MessageSet;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly del: {
            readonly name: "Del";
            readonly requestType: {
                $type: "devvit.plugin.kvstore.KeySet";
                encode(message: KeySet, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeySet;
                fromJSON(object: any): KeySet;
                toJSON(message: KeySet): unknown;
                create(base?: DeepPartial_61<KeySet>): KeySet;
                fromPartial(object: DeepPartial_61<KeySet>): KeySet;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly list: {
            readonly name: "List";
            readonly requestType: {
                $type: "devvit.plugin.kvstore.ListFilter";
                encode(message: ListFilter, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ListFilter;
                fromJSON(object: any): ListFilter;
                toJSON(message: ListFilter): unknown;
                create(base?: DeepPartial_61<ListFilter>): ListFilter;
                fromPartial(object: DeepPartial_61<ListFilter>): ListFilter;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.kvstore.KeySet";
                encode(message: KeySet, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeySet;
                fromJSON(object: any): KeySet;
                toJSON(message: KeySet): unknown;
                create(base?: DeepPartial_61<KeySet>): KeySet;
                fromPartial(object: DeepPartial_61<KeySet>): KeySet;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const KVStoreServiceName = "devvit.plugin.kvstore.KVStore";

declare type LineBreak = {
    e: typeof LINEBREAK_ELEMENT;
};

declare const LINEBREAK_ELEMENT = "br";

/**
 * @mixin
 */
declare type LineBreakContainer<Context> = {
    /**
     * Append a Line Break
     */
    linebreak(): Context;
};

declare type Link = {
    e: typeof LINK_ELEMENT;
    t: string;
    u: UrlString;
    f?: FormatRange[];
    a?: string;
};

declare const LINK_ELEMENT = "link";

/**
 * @mixin
 */
declare type LinkContainer<Context> = RedditLinkContainer<Context> & {
    /**
     * Append a Link
     * @param opts {@link LinkOptions}
     */
    link(opts: LinkOptions): Context;
};

/**
 * A fully built actor (either a user app or plugin). This resolved Bundle is
 * ready for execution by the runtime.
 */
declare interface LinkedBundle {
    actor?: ActorSpec | undefined;
    /**
     * Compiled bundle or plugin code. A hostname and empty code implies that the
     * runtime should resolve this as a remote actor accessible over the network;
     * this is empty for "skinny bundles" (AKA Gateway bundles).
     */
    code: string;
    /**
     * Actor hostname. This may be a plugin or a user. See DependencySpec.hostname
     * which Community Portal copies here.
     */
    hostname: string;
    provides: SerializableServiceDefinition[];
    /**
     * True dependencies. This is empty for skinny bundles which describe the
     * input / output API only. They have no code and cannot be executed so their
     * dependencies are not needed.
     */
    uses: LinkedBundle[];
    /**
     * Optional information about the environment the code was built in. Outdated
     * dependencies may indicate an invalid build.
     */
    buildInfo?: BuildInfo | undefined;
    /**
     * Where did the uploaded ./assets folder land?  This is a URL to the FileSystem
     * as JSON that contains the assets.
     *
     * @deprecated
     */
    assetsUrl?: string | undefined;
    /**
     * This map is used to resolve relative asset paths to URLs. The key
     * is the path to the asset, and the value is the URL to the asset.
     * e.g. "images/example.png": "https://i.redd.it/example.png",
     */
    assets: {
        [key: string]: string;
    };
}

declare const LinkedBundle: {
    $type: "devvit.runtime.LinkedBundle";
    encode(message: LinkedBundle, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LinkedBundle;
    fromJSON(object: any): LinkedBundle;
    toJSON(message: LinkedBundle): unknown;
    create(base?: DeepPartial_14<LinkedBundle>): LinkedBundle;
    fromPartial(object: DeepPartial_14<LinkedBundle>): LinkedBundle;
};

declare interface LinkedBundle_AssetsEntry {
    key: string;
    value: string;
}

declare const LinkedBundle_AssetsEntry: {
    $type: "devvit.runtime.LinkedBundle.AssetsEntry";
    encode(message: LinkedBundle_AssetsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LinkedBundle_AssetsEntry;
    fromJSON(object: any): LinkedBundle_AssetsEntry;
    toJSON(message: LinkedBundle_AssetsEntry): unknown;
    create(base?: DeepPartial_14<LinkedBundle_AssetsEntry>): LinkedBundle_AssetsEntry;
    fromPartial(object: DeepPartial_14<LinkedBundle_AssetsEntry>): LinkedBundle_AssetsEntry;
};

/** See also LinkedBundle. */
declare enum LinkedBundleTargetPlatform {
    /** BROWSER - A LinkedBundle for browser runtimes. */
    BROWSER = 0,
    /** V8 - A LinkedBundle for V8 runtimes. */
    V8 = 1,
    /**
     * SKINNY - An API definition that cannot be executed. This is a LinkedBundle with no
     * code and no dependencies.
     */
    SKINNY = 2,
    UNRECOGNIZED = -1
}

declare function linkedBundleTargetPlatformFromJSON(object: any): LinkedBundleTargetPlatform;

declare function linkedBundleTargetPlatformToJSON(object: LinkedBundleTargetPlatform): number;

/**
 * Linker makes a BundledApp out of a bundle.  Technically, it could probably
 * make a BundledApp out of a VersionedBundle#uuid, but that would require some
 * refactoring.
 *
 * A Linker implementation will typically coordinate with a Resolver to find all
 * of the other bundles to include.
 */
declare interface Linker {
    Link(request: Bundle, metadata?: Metadata): Promise<LinkerResponse>;
}

declare class LinkerClientImpl implements Linker {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_22, opts?: {
        service?: string;
    });
    Link(request: Bundle, metadata?: Metadata): Promise<LinkerResponse>;
}

/**
 * Linker makes a BundledApp out of a bundle.  Technically, it could probably
 * make a BundledApp out of a VersionedBundle#uuid, but that would require some
 * refactoring.
 *
 * A Linker implementation will typically coordinate with a Resolver to find all
 * of the other bundles to include.
 */
declare type LinkerDefinition = typeof LinkerDefinition;

declare const LinkerDefinition: {
    readonly name: "Linker";
    readonly fullName: "devvit.plugin.linker.Linker";
    readonly methods: {
        readonly link: {
            readonly name: "Link";
            readonly requestType: {
                $type: "devvit.plugin.buildpack.Bundle";
                encode(message: Bundle, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Bundle;
                fromJSON(object: any): Bundle;
                toJSON(message: Bundle): unknown;
                create(base?: {
                    code?: string;
                    dependencies?: {
                        actor?: {
                            name?: string;
                            owner?: string;
                            version?: string;
                        } | undefined;
                        hostname?: string;
                        provides?: {
                            actor?: {
                                name?: string;
                                owner?: string;
                                version?: string;
                            } | undefined;
                            definition?: {
                                fullName?: string;
                                methods?: {
                                    fullName?: string;
                                    name?: string;
                                    requestStream?: boolean;
                                    responseStream?: boolean;
                                    requestType?: string;
                                    responseType?: string;
                                }[];
                                name?: string;
                                version?: string;
                            } | undefined;
                            locations?: {
                                allow?: string[];
                                deny?: string[];
                            } | undefined;
                            partitionsBy?: string[];
                        }[];
                        uses?: {
                            name?: string | undefined;
                            owner?: string | undefined;
                            typeName?: string;
                            versions?: string | undefined;
                        }[];
                    } | undefined;
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assets?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    assetIds?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): Bundle;
                fromPartial(object: {
                    code?: string;
                    dependencies?: {
                        actor?: {
                            name?: string;
                            owner?: string;
                            version?: string;
                        } | undefined;
                        hostname?: string;
                        provides?: {
                            actor?: {
                                name?: string;
                                owner?: string;
                                version?: string;
                            } | undefined;
                            definition?: {
                                fullName?: string;
                                methods?: {
                                    fullName?: string;
                                    name?: string;
                                    requestStream?: boolean;
                                    responseStream?: boolean;
                                    requestType?: string;
                                    responseType?: string;
                                }[];
                                name?: string;
                                version?: string;
                            } | undefined;
                            locations?: {
                                allow?: string[];
                                deny?: string[];
                            } | undefined;
                            partitionsBy?: string[];
                        }[];
                        uses?: {
                            name?: string | undefined;
                            owner?: string | undefined;
                            typeName?: string;
                            versions?: string | undefined;
                        }[];
                    } | undefined;
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assets?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    assetIds?: {
                        [x: string]: string | undefined;
                    };
                }): Bundle;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.linker.LinkerResponse";
                encode(message: LinkerResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): LinkerResponse;
                fromJSON(object: any): LinkerResponse;
                toJSON(message: LinkerResponse): unknown;
                create(base?: DeepPartial_63<LinkerResponse>): LinkerResponse;
                fromPartial(object: DeepPartial_63<LinkerResponse>): LinkerResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare interface LinkerResponse {
    bundle?: LinkedBundle | undefined;
    errors: ResolutionError[];
}

declare const LinkerResponse: {
    $type: "devvit.plugin.linker.LinkerResponse";
    encode(message: LinkerResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LinkerResponse;
    fromJSON(object: any): LinkerResponse;
    toJSON(message: LinkerResponse): unknown;
    create(base?: DeepPartial_63<LinkerResponse>): LinkerResponse;
    fromPartial(object: DeepPartial_63<LinkerResponse>): LinkerResponse;
};

declare const LinkerServiceName = "devvit.plugin.linker.Linker";

export declare type LinkFlair = {
    /**
     * One of: "text", "richtext"
     */
    type?: string;
    /**
     * Flair template ID to use when rendering this flair
     */
    templateId?: string;
    /**
     * Plain text representation of the flair
     */
    text?: string;
    /**
     * RichText object representation of the flair
     */
    richtext: {
        /**
         * Enum of element types.  e.g. emoji or text
         */
        elementType?: string;
        /**
         * Text to show up in the flair, e.g. "Need Advice"
         */
        text?: string;
        /**
         * Emoji references, e.g. ":rainbow:"
         */
        emojiRef?: string;
        /**
         * url string, e.g. "https://reddit.com/"
         */
        url?: string;
    }[];
    /**
     * Custom CSS classes from the subreddit's stylesheet to apply to the flair if rendered as HTML
     */
    cssClass?: string;
    /**
     * One of: "light", "dark"
     */
    textColor?: string;
    /**
     * Flair background color as a hex color string (# prefixed)
     * @example "#FF4500"
     */
    backgroundColor?: string;
};

declare interface LinkFlairRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
}

declare const LinkFlairRequest: {
    $type: "devvit.plugin.redditapi.flair.LinkFlairRequest";
    encode(message: LinkFlairRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LinkFlairRequest;
    fromJSON(object: any): LinkFlairRequest;
    toJSON(message: LinkFlairRequest): unknown;
    create(base?: DeepPartial_56<LinkFlairRequest>): LinkFlairRequest;
    fromPartial(object: DeepPartial_56<LinkFlairRequest>): LinkFlairRequest;
};

declare interface LinkFlairV2 {
    text: string;
    cssClass: string;
    backgroundColor: string;
    templateId: string;
    textColor: string;
}

declare const LinkFlairV2: {
    $type: "devvit.reddit.v2alpha.LinkFlairV2";
    encode(message: LinkFlairV2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LinkFlairV2;
    fromJSON(object: any): LinkFlairV2;
    toJSON(message: LinkFlairV2): unknown;
    create(base?: DeepPartial_72<LinkFlairV2>): LinkFlairV2;
    fromPartial(object: DeepPartial_72<LinkFlairV2>): LinkFlairV2;
};

/**
 * @borrows TextOptions
 */
declare type LinkOptions = TextOptions & {
    /** Destination URL */
    url: string;
    /** Tooltip text shown when the link is focused */
    tooltip?: string;
};

/**
 * LINKS & COMMENTS - https://www.reddit.com/dev/api#section_links_and_comments
 * Note: all endpoints require oauth
 */
declare interface LinksAndComments {
    /**
     * Submit a new Comment
     * Note: `thing_id` refers to the Post or Comment this comment is replying to
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_comment}
     */
    Comment(request: CommentRequest, metadata?: Metadata): Promise<JsonWrappedComment>;
    /**
     * Delete a Post or Comment
     * Note: `id` must be a single thing ID for a Post or Comment
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_del}
     */
    Del(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Edit the body text of a Comment or Post
     * Note: `thing_id` refers to the Post or Comment being edited
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
     */
    EditUserText(request: CommentRequest, metadata?: Metadata): Promise<JsonWrappedComment>;
    /**
     * Follow or unfollow a Post
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_follow_post}
     */
    FollowPost(request: FollowPostRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Hide one or more Posts for the user
     * Note: `id` must be one or more comma-separated Post thing IDs
     *
     * @see {@link Unhide}
     * @see {@link https://www.reddit.com/dev/api#POST_api_hide}
     */
    Hide(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Get one or more things by ID, Subreddit name, or Link Post URL
     *
     * @see {@link https://www.reddit.com/dev/api#GET_api_info}
     */
    Info(request: InfoRequest, metadata?: Metadata): Promise<Listing_2>;
    /**
     * Disable comments for a Post or Comment
     * Note: `id` must be a single thing ID for a Post or Comment
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_lock}
     */
    Lock(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Marks a Post as Not-Safe-For-Work
     *
     * @see {@link UnmarkNSFW}
     * @see {@link https://www.reddit.com/dev/api#POST_api_marknsfw}
     */
    MarkNSFW(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Get more comments from a truncated Comment tree
     *
     * A comment tree has been truncated if it ends with an entry of kind "more"
     * instead of "t1".  Use this API to fetch the additional comments listed in
     * the "children" array of the "more" entry.
     *
     * @see {@link https://www.reddit.com/dev/api#GET_api_morechildren}
     */
    MoreChildren(request: MoreChildrenRequest, metadata?: Metadata): Promise<JsonWrappedComment>;
    /**
     * Report a Post, Comment, or Private Message
     *
     * If reporting a Post or Comment the report is sent to the moderators of the subreddit for review.
     * If reporting a Private Message the report is sent to Reddit for review.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_report}
     */
    Report(request: ReportRequest, metadata?: Metadata): Promise<JsonStatus>;
    /**
     * Report an award to Reddit for review
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_report_award}
     */
    ReportAward(request: ReportAwardRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Save a Post or Comment to the user's Saved list
     *
     * @see {@link Unsave}
     * @see {@link https://www.reddit.com/dev/api#POST_api_save}
     */
    Save(request: SaveRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Enable or disable reply notifications for a Post or Comment
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_sendreplies}
     */
    SendReplies(request: SendRepliesRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Toggle Contest Mode for a Post's comments
     *
     * Contest Mode randomizes the sort order and hides the vote score for comments
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_set_contest_mode}
     */
    SetContestMode(request: SetContestModeRequest, metadata?: Metadata): Promise<JsonStatus>;
    /**
     * Set the "sticky" or "pinned" status of a Post
     *
     * If the post was created by the current user they can pin the post
     * to the top of their user profile.  Otherwise they must be a moderator
     * of the subreddit to stick it to the top of the subreddit it was posted in.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_set_subreddit_sticky}
     */
    SetSubredditSticky(request: SetSubredditStickyRequest, metadata?: Metadata): Promise<JsonStatus>;
    /**
     * Set the default sort order for comments in the given Post
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_set_suggested_sort}
     */
    SetSuggestedSort(request: SetSuggestedSortRequest, metadata?: Metadata): Promise<JsonStatus>;
    /**
     * Sets the spoiler tag on a given Post to hide its contents by default
     * Note: `id` must be a single thing ID for a Post
     *
     * @see {@link Unspoiler}
     * @see {@link https://www.reddit.com/dev/api#POST_api_spoiler}
     */
    Spoiler(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Create a new Post
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_submit}
     *
     * Note: not specifying ApiClientConfig to avoid automatic generation.
     * Submit has extra logic that needs to be manually implemented.
     */
    Submit(request: SubmitRequest, metadata?: Metadata): Promise<SubmitResponse>;
    /**
     * Unhide one or more Posts for the user
     * Note: `id` must be one or more comma-separated Post thing IDs
     *
     * @see {@link Hide}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unhide}
     */
    Unhide(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Enable comments for a Post or Comment
     * Note: `id` must be a single thing ID for a Post or Comment
     *
     * @see {@link Lock}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unlock}
     */
    Unlock(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Clears the Not-Safe-For-Work status from a Post
     *
     * @see {@link MarkNSFW}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unmarknsfw}
     */
    UnmarkNSFW(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Remove a Post or Comment from the user's Saved list
     *
     * @see {@link Save}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unsave}
     */
    Unsave(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Clears the spoiler tag on a given Post
     *
     * @see {@link Spoiler}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unspoiler}
     */
    Unspoiler(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Vote or clear a vote on a Post or Comment
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_vote}
     */
    Vote(request: VoteRequest, metadata?: Metadata): Promise<Empty>;
}

declare class LinksAndCommentsClientImpl implements LinksAndComments {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_58, opts?: {
        service?: string;
    });
    Comment(request: CommentRequest, metadata?: Metadata): Promise<JsonWrappedComment>;
    Del(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    EditUserText(request: CommentRequest, metadata?: Metadata): Promise<JsonWrappedComment>;
    FollowPost(request: FollowPostRequest, metadata?: Metadata): Promise<Empty>;
    Hide(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    Info(request: InfoRequest, metadata?: Metadata): Promise<Listing_2>;
    Lock(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    MarkNSFW(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    MoreChildren(request: MoreChildrenRequest, metadata?: Metadata): Promise<JsonWrappedComment>;
    Report(request: ReportRequest, metadata?: Metadata): Promise<JsonStatus>;
    ReportAward(request: ReportAwardRequest, metadata?: Metadata): Promise<Empty>;
    Save(request: SaveRequest, metadata?: Metadata): Promise<Empty>;
    SendReplies(request: SendRepliesRequest, metadata?: Metadata): Promise<Empty>;
    SetContestMode(request: SetContestModeRequest, metadata?: Metadata): Promise<JsonStatus>;
    SetSubredditSticky(request: SetSubredditStickyRequest, metadata?: Metadata): Promise<JsonStatus>;
    SetSuggestedSort(request: SetSuggestedSortRequest, metadata?: Metadata): Promise<JsonStatus>;
    Spoiler(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    Submit(request: SubmitRequest, metadata?: Metadata): Promise<SubmitResponse>;
    Unhide(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    Unlock(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    UnmarkNSFW(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    Unsave(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    Unspoiler(request: BasicIdRequest, metadata?: Metadata): Promise<Empty>;
    Vote(request: VoteRequest, metadata?: Metadata): Promise<Empty>;
}

/**
 * LINKS & COMMENTS - https://www.reddit.com/dev/api#section_links_and_comments
 * Note: all endpoints require oauth
 */
declare type LinksAndCommentsDefinition = typeof LinksAndCommentsDefinition;

declare const LinksAndCommentsDefinition: {
    readonly name: "LinksAndComments";
    readonly fullName: "devvit.plugin.redditapi.linksandcomments.LinksAndComments";
    readonly methods: {
        /**
         * Submit a new Comment
         * Note: `thing_id` refers to the Post or Comment this comment is replying to
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_comment}
         */
        readonly comment: {
            readonly name: "Comment";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.CommentRequest";
                encode(message: CommentRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CommentRequest;
                fromJSON(object: any): CommentRequest;
                toJSON(message: CommentRequest): unknown;
                create(base?: {
                    richtextJson?: string | undefined;
                    text?: string;
                    thingId?: string;
                } | undefined): CommentRequest;
                fromPartial(object: {
                    richtextJson?: string | undefined;
                    text?: string;
                    thingId?: string;
                }): CommentRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment";
                encode(message: JsonWrappedComment, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonWrappedComment;
                fromJSON(object: any): JsonWrappedComment;
                toJSON(message: JsonWrappedComment): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                        data?: {
                            things?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        awardSubType?: string | undefined;
                                        awardType?: string | undefined;
                                        awardingsRequiredToGrantBenefits?: number | undefined;
                                        coinPrice?: number | undefined;
                                        coinReward?: number | undefined;
                                        count?: number | undefined;
                                        daysOfDripExtension?: number | undefined;
                                        daysOfPremium?: number | undefined;
                                        description?: string | undefined;
                                        endDate?: string | undefined;
                                        giverCoinReward?: number | undefined;
                                        iconFormat?: string | undefined;
                                        iconHeight?: number | undefined;
                                        iconUrl?: string | undefined;
                                        iconWidth?: number | undefined;
                                        id?: string | undefined;
                                        isEnabled?: boolean | undefined;
                                        isNew?: boolean | undefined;
                                        name?: string | undefined;
                                        pennyDonate?: number | undefined;
                                        pennyPrice?: number | undefined;
                                        resizedIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        resizedStaticIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        startDate?: string | undefined;
                                        staticIconHeight?: number | undefined;
                                        staticIconUrl?: string | undefined;
                                        staticIconWidth?: number | undefined;
                                        stickyDurationSeconds?: number | undefined;
                                        subredditCoinReward?: number | undefined;
                                        subredditId?: string | undefined;
                                        tiersByRequiredAwardings?: string | undefined;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    depth?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        gid1?: number | undefined;
                                        gid2?: number | undefined;
                                        gid3?: number | undefined;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    modReports?: any[][];
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: string[];
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: string[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    userReports?: any[][];
                                    count?: number | undefined;
                                    children?: string[];
                                    banInfo?: {
                                        auto?: boolean | undefined;
                                        bannedAt?: number | undefined;
                                        banner?: string | undefined;
                                        moderatorBanned?: boolean | undefined;
                                        note?: string | undefined;
                                        unbanner?: string | undefined;
                                        unbannedAt?: number | undefined;
                                        resetUsed?: boolean | undefined;
                                        reasonId?: string | undefined;
                                        reasonTitle?: string | undefined;
                                        reasonMessage?: string | undefined;
                                        reasonBy?: string | undefined;
                                        modNote?: string | undefined;
                                        banAllTriggered?: boolean | undefined;
                                        subredditMessage?: string | undefined;
                                        removeAction?: BanInfo_BanInfoAction_2;
                                    } | undefined;
                                    markedSpam?: boolean | undefined;
                                    verdict?: string | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    } | undefined;
                } | undefined): JsonWrappedComment;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                        data?: {
                            things?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        awardSubType?: string | undefined;
                                        awardType?: string | undefined;
                                        awardingsRequiredToGrantBenefits?: number | undefined;
                                        coinPrice?: number | undefined;
                                        coinReward?: number | undefined;
                                        count?: number | undefined;
                                        daysOfDripExtension?: number | undefined;
                                        daysOfPremium?: number | undefined;
                                        description?: string | undefined;
                                        endDate?: string | undefined;
                                        giverCoinReward?: number | undefined;
                                        iconFormat?: string | undefined;
                                        iconHeight?: number | undefined;
                                        iconUrl?: string | undefined;
                                        iconWidth?: number | undefined;
                                        id?: string | undefined;
                                        isEnabled?: boolean | undefined;
                                        isNew?: boolean | undefined;
                                        name?: string | undefined;
                                        pennyDonate?: number | undefined;
                                        pennyPrice?: number | undefined;
                                        resizedIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        resizedStaticIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        startDate?: string | undefined;
                                        staticIconHeight?: number | undefined;
                                        staticIconUrl?: string | undefined;
                                        staticIconWidth?: number | undefined;
                                        stickyDurationSeconds?: number | undefined;
                                        subredditCoinReward?: number | undefined;
                                        subredditId?: string | undefined;
                                        tiersByRequiredAwardings?: string | undefined;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    depth?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        gid1?: number | undefined;
                                        gid2?: number | undefined;
                                        gid3?: number | undefined;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    modReports?: any[][];
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: string[];
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: string[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    userReports?: any[][];
                                    count?: number | undefined;
                                    children?: string[];
                                    banInfo?: {
                                        auto?: boolean | undefined;
                                        bannedAt?: number | undefined;
                                        banner?: string | undefined;
                                        moderatorBanned?: boolean | undefined;
                                        note?: string | undefined;
                                        unbanner?: string | undefined;
                                        unbannedAt?: number | undefined;
                                        resetUsed?: boolean | undefined;
                                        reasonId?: string | undefined;
                                        reasonTitle?: string | undefined;
                                        reasonMessage?: string | undefined;
                                        reasonBy?: string | undefined;
                                        modNote?: string | undefined;
                                        banAllTriggered?: boolean | undefined;
                                        subredditMessage?: string | undefined;
                                        removeAction?: BanInfo_BanInfoAction_2;
                                    } | undefined;
                                    markedSpam?: boolean | undefined;
                                    verdict?: string | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    } | undefined;
                }): JsonWrappedComment;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /**
         * Delete a Post or Comment
         * Note: `id` must be a single thing ID for a Post or Comment
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_del}
         */
        readonly del: {
            readonly name: "Del";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Edit the body text of a Comment or Post
         * Note: `thing_id` refers to the Post or Comment being edited
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
         */
        readonly editUserText: {
            readonly name: "EditUserText";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.CommentRequest";
                encode(message: CommentRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CommentRequest;
                fromJSON(object: any): CommentRequest;
                toJSON(message: CommentRequest): unknown;
                create(base?: {
                    richtextJson?: string | undefined;
                    text?: string;
                    thingId?: string;
                } | undefined): CommentRequest;
                fromPartial(object: {
                    richtextJson?: string | undefined;
                    text?: string;
                    thingId?: string;
                }): CommentRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment";
                encode(message: JsonWrappedComment, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonWrappedComment;
                fromJSON(object: any): JsonWrappedComment;
                toJSON(message: JsonWrappedComment): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                        data?: {
                            things?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        awardSubType?: string | undefined;
                                        awardType?: string | undefined;
                                        awardingsRequiredToGrantBenefits?: number | undefined;
                                        coinPrice?: number | undefined;
                                        coinReward?: number | undefined;
                                        count?: number | undefined;
                                        daysOfDripExtension?: number | undefined;
                                        daysOfPremium?: number | undefined;
                                        description?: string | undefined;
                                        endDate?: string | undefined;
                                        giverCoinReward?: number | undefined;
                                        iconFormat?: string | undefined;
                                        iconHeight?: number | undefined;
                                        iconUrl?: string | undefined;
                                        iconWidth?: number | undefined;
                                        id?: string | undefined;
                                        isEnabled?: boolean | undefined;
                                        isNew?: boolean | undefined;
                                        name?: string | undefined;
                                        pennyDonate?: number | undefined;
                                        pennyPrice?: number | undefined;
                                        resizedIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        resizedStaticIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        startDate?: string | undefined;
                                        staticIconHeight?: number | undefined;
                                        staticIconUrl?: string | undefined;
                                        staticIconWidth?: number | undefined;
                                        stickyDurationSeconds?: number | undefined;
                                        subredditCoinReward?: number | undefined;
                                        subredditId?: string | undefined;
                                        tiersByRequiredAwardings?: string | undefined;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    depth?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        gid1?: number | undefined;
                                        gid2?: number | undefined;
                                        gid3?: number | undefined;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    modReports?: any[][];
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: string[];
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: string[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    userReports?: any[][];
                                    count?: number | undefined;
                                    children?: string[];
                                    banInfo?: {
                                        auto?: boolean | undefined;
                                        bannedAt?: number | undefined;
                                        banner?: string | undefined;
                                        moderatorBanned?: boolean | undefined;
                                        note?: string | undefined;
                                        unbanner?: string | undefined;
                                        unbannedAt?: number | undefined;
                                        resetUsed?: boolean | undefined;
                                        reasonId?: string | undefined;
                                        reasonTitle?: string | undefined;
                                        reasonMessage?: string | undefined;
                                        reasonBy?: string | undefined;
                                        modNote?: string | undefined;
                                        banAllTriggered?: boolean | undefined;
                                        subredditMessage?: string | undefined;
                                        removeAction?: BanInfo_BanInfoAction_2;
                                    } | undefined;
                                    markedSpam?: boolean | undefined;
                                    verdict?: string | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    } | undefined;
                } | undefined): JsonWrappedComment;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                        data?: {
                            things?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        awardSubType?: string | undefined;
                                        awardType?: string | undefined;
                                        awardingsRequiredToGrantBenefits?: number | undefined;
                                        coinPrice?: number | undefined;
                                        coinReward?: number | undefined;
                                        count?: number | undefined;
                                        daysOfDripExtension?: number | undefined;
                                        daysOfPremium?: number | undefined;
                                        description?: string | undefined;
                                        endDate?: string | undefined;
                                        giverCoinReward?: number | undefined;
                                        iconFormat?: string | undefined;
                                        iconHeight?: number | undefined;
                                        iconUrl?: string | undefined;
                                        iconWidth?: number | undefined;
                                        id?: string | undefined;
                                        isEnabled?: boolean | undefined;
                                        isNew?: boolean | undefined;
                                        name?: string | undefined;
                                        pennyDonate?: number | undefined;
                                        pennyPrice?: number | undefined;
                                        resizedIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        resizedStaticIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        startDate?: string | undefined;
                                        staticIconHeight?: number | undefined;
                                        staticIconUrl?: string | undefined;
                                        staticIconWidth?: number | undefined;
                                        stickyDurationSeconds?: number | undefined;
                                        subredditCoinReward?: number | undefined;
                                        subredditId?: string | undefined;
                                        tiersByRequiredAwardings?: string | undefined;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    depth?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        gid1?: number | undefined;
                                        gid2?: number | undefined;
                                        gid3?: number | undefined;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    modReports?: any[][];
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: string[];
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: string[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    userReports?: any[][];
                                    count?: number | undefined;
                                    children?: string[];
                                    banInfo?: {
                                        auto?: boolean | undefined;
                                        bannedAt?: number | undefined;
                                        banner?: string | undefined;
                                        moderatorBanned?: boolean | undefined;
                                        note?: string | undefined;
                                        unbanner?: string | undefined;
                                        unbannedAt?: number | undefined;
                                        resetUsed?: boolean | undefined;
                                        reasonId?: string | undefined;
                                        reasonTitle?: string | undefined;
                                        reasonMessage?: string | undefined;
                                        reasonBy?: string | undefined;
                                        modNote?: string | undefined;
                                        banAllTriggered?: boolean | undefined;
                                        subredditMessage?: string | undefined;
                                        removeAction?: BanInfo_BanInfoAction_2;
                                    } | undefined;
                                    markedSpam?: boolean | undefined;
                                    verdict?: string | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    } | undefined;
                }): JsonWrappedComment;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Follow or unfollow a Post
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_follow_post}
         */
        readonly followPost: {
            readonly name: "FollowPost";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.FollowPostRequest";
                encode(message: FollowPostRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FollowPostRequest;
                fromJSON(object: any): FollowPostRequest;
                toJSON(message: FollowPostRequest): unknown;
                create(base?: {
                    follow?: boolean;
                    fullname?: string;
                } | undefined): FollowPostRequest;
                fromPartial(object: {
                    follow?: boolean;
                    fullname?: string;
                }): FollowPostRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Hide one or more Posts for the user
         * Note: `id` must be one or more comma-separated Post thing IDs
         *
         * @see {@link Unhide}
         * @see {@link https://www.reddit.com/dev/api#POST_api_hide}
         */
        readonly hide: {
            readonly name: "Hide";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Get one or more things by ID, Subreddit name, or Link Post URL
         *
         * @see {@link https://www.reddit.com/dev/api#GET_api_info}
         */
        readonly info: {
            readonly name: "Info";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.InfoRequest";
                encode(message: InfoRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): InfoRequest;
                fromJSON(object: any): InfoRequest;
                toJSON(message: InfoRequest): unknown;
                create(base?: {
                    subreddits?: string[];
                    thingIds?: string[];
                    url?: string | undefined;
                } | undefined): InfoRequest;
                fromPartial(object: {
                    subreddits?: string[];
                    thingIds?: string[];
                    url?: string | undefined;
                }): InfoRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Disable comments for a Post or Comment
         * Note: `id` must be a single thing ID for a Post or Comment
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_lock}
         */
        readonly lock: {
            readonly name: "Lock";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Marks a Post as Not-Safe-For-Work
         *
         * @see {@link UnmarkNSFW}
         * @see {@link https://www.reddit.com/dev/api#POST_api_marknsfw}
         */
        readonly markNSFW: {
            readonly name: "MarkNSFW";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Get more comments from a truncated Comment tree
         *
         * A comment tree has been truncated if it ends with an entry of kind "more"
         * instead of "t1".  Use this API to fetch the additional comments listed in
         * the "children" array of the "more" entry.
         *
         * @see {@link https://www.reddit.com/dev/api#GET_api_morechildren}
         */
        readonly moreChildren: {
            readonly name: "MoreChildren";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.MoreChildrenRequest";
                encode(message: MoreChildrenRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MoreChildrenRequest;
                fromJSON(object: any): MoreChildrenRequest;
                toJSON(message: MoreChildrenRequest): unknown;
                create(base?: {
                    children?: string[];
                    depth?: number | undefined;
                    limitChildren?: boolean | undefined;
                    linkId?: string;
                    sort?: string | undefined;
                    id?: string | undefined;
                } | undefined): MoreChildrenRequest;
                fromPartial(object: {
                    children?: string[];
                    depth?: number | undefined;
                    limitChildren?: boolean | undefined;
                    linkId?: string;
                    sort?: string | undefined;
                    id?: string | undefined;
                }): MoreChildrenRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment";
                encode(message: JsonWrappedComment, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonWrappedComment;
                fromJSON(object: any): JsonWrappedComment;
                toJSON(message: JsonWrappedComment): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                        data?: {
                            things?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        awardSubType?: string | undefined;
                                        awardType?: string | undefined;
                                        awardingsRequiredToGrantBenefits?: number | undefined;
                                        coinPrice?: number | undefined;
                                        coinReward?: number | undefined;
                                        count?: number | undefined;
                                        daysOfDripExtension?: number | undefined;
                                        daysOfPremium?: number | undefined;
                                        description?: string | undefined;
                                        endDate?: string | undefined;
                                        giverCoinReward?: number | undefined;
                                        iconFormat?: string | undefined;
                                        iconHeight?: number | undefined;
                                        iconUrl?: string | undefined;
                                        iconWidth?: number | undefined;
                                        id?: string | undefined;
                                        isEnabled?: boolean | undefined;
                                        isNew?: boolean | undefined;
                                        name?: string | undefined;
                                        pennyDonate?: number | undefined;
                                        pennyPrice?: number | undefined;
                                        resizedIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        resizedStaticIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        startDate?: string | undefined;
                                        staticIconHeight?: number | undefined;
                                        staticIconUrl?: string | undefined;
                                        staticIconWidth?: number | undefined;
                                        stickyDurationSeconds?: number | undefined;
                                        subredditCoinReward?: number | undefined;
                                        subredditId?: string | undefined;
                                        tiersByRequiredAwardings?: string | undefined;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    depth?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        gid1?: number | undefined;
                                        gid2?: number | undefined;
                                        gid3?: number | undefined;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    modReports?: any[][];
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: string[];
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: string[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    userReports?: any[][];
                                    count?: number | undefined;
                                    children?: string[];
                                    banInfo?: {
                                        auto?: boolean | undefined;
                                        bannedAt?: number | undefined;
                                        banner?: string | undefined;
                                        moderatorBanned?: boolean | undefined;
                                        note?: string | undefined;
                                        unbanner?: string | undefined;
                                        unbannedAt?: number | undefined;
                                        resetUsed?: boolean | undefined;
                                        reasonId?: string | undefined;
                                        reasonTitle?: string | undefined;
                                        reasonMessage?: string | undefined;
                                        reasonBy?: string | undefined;
                                        modNote?: string | undefined;
                                        banAllTriggered?: boolean | undefined;
                                        subredditMessage?: string | undefined;
                                        removeAction?: BanInfo_BanInfoAction_2;
                                    } | undefined;
                                    markedSpam?: boolean | undefined;
                                    verdict?: string | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    } | undefined;
                } | undefined): JsonWrappedComment;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                        data?: {
                            things?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        awardSubType?: string | undefined;
                                        awardType?: string | undefined;
                                        awardingsRequiredToGrantBenefits?: number | undefined;
                                        coinPrice?: number | undefined;
                                        coinReward?: number | undefined;
                                        count?: number | undefined;
                                        daysOfDripExtension?: number | undefined;
                                        daysOfPremium?: number | undefined;
                                        description?: string | undefined;
                                        endDate?: string | undefined;
                                        giverCoinReward?: number | undefined;
                                        iconFormat?: string | undefined;
                                        iconHeight?: number | undefined;
                                        iconUrl?: string | undefined;
                                        iconWidth?: number | undefined;
                                        id?: string | undefined;
                                        isEnabled?: boolean | undefined;
                                        isNew?: boolean | undefined;
                                        name?: string | undefined;
                                        pennyDonate?: number | undefined;
                                        pennyPrice?: number | undefined;
                                        resizedIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        resizedStaticIcons?: {
                                            height?: number | undefined;
                                            url?: string | undefined;
                                            width?: number | undefined;
                                        }[];
                                        startDate?: string | undefined;
                                        staticIconHeight?: number | undefined;
                                        staticIconUrl?: string | undefined;
                                        staticIconWidth?: number | undefined;
                                        stickyDurationSeconds?: number | undefined;
                                        subredditCoinReward?: number | undefined;
                                        subredditId?: string | undefined;
                                        tiersByRequiredAwardings?: string | undefined;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    depth?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        gid1?: number | undefined;
                                        gid2?: number | undefined;
                                        gid3?: number | undefined;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    modReports?: any[][];
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: string[];
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: string[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    userReports?: any[][];
                                    count?: number | undefined;
                                    children?: string[];
                                    banInfo?: {
                                        auto?: boolean | undefined;
                                        bannedAt?: number | undefined;
                                        banner?: string | undefined;
                                        moderatorBanned?: boolean | undefined;
                                        note?: string | undefined;
                                        unbanner?: string | undefined;
                                        unbannedAt?: number | undefined;
                                        resetUsed?: boolean | undefined;
                                        reasonId?: string | undefined;
                                        reasonTitle?: string | undefined;
                                        reasonMessage?: string | undefined;
                                        reasonBy?: string | undefined;
                                        modNote?: string | undefined;
                                        banAllTriggered?: boolean | undefined;
                                        subredditMessage?: string | undefined;
                                        removeAction?: BanInfo_BanInfoAction_2;
                                    } | undefined;
                                    markedSpam?: boolean | undefined;
                                    verdict?: string | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    } | undefined;
                }): JsonWrappedComment;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Report a Post, Comment, or Private Message
         *
         * If reporting a Post or Comment the report is sent to the moderators of the subreddit for review.
         * If reporting a Private Message the report is sent to Reddit for review.
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_report}
         */
        readonly report: {
            readonly name: "Report";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.ReportRequest";
                encode(message: ReportRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ReportRequest;
                fromJSON(object: any): ReportRequest;
                toJSON(message: ReportRequest): unknown;
                create(base?: {
                    additionalInfo?: string | undefined;
                    customText?: string | undefined;
                    modmailConvId?: string | undefined;
                    otherReason?: string | undefined;
                    reason?: string;
                    ruleReason?: string | undefined;
                    siteReason?: string | undefined;
                    srName?: string | undefined;
                    thingId?: string;
                    usernames?: string | undefined;
                } | undefined): ReportRequest;
                fromPartial(object: {
                    additionalInfo?: string | undefined;
                    customText?: string | undefined;
                    modmailConvId?: string | undefined;
                    otherReason?: string | undefined;
                    reason?: string;
                    ruleReason?: string | undefined;
                    siteReason?: string | undefined;
                    srName?: string | undefined;
                    thingId?: string;
                    usernames?: string | undefined;
                }): ReportRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Report an award to Reddit for review
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_report_award}
         */
        readonly reportAward: {
            readonly name: "ReportAward";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.ReportAwardRequest";
                encode(message: ReportAwardRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ReportAwardRequest;
                fromJSON(object: any): ReportAwardRequest;
                toJSON(message: ReportAwardRequest): unknown;
                create(base?: {
                    awardId?: string;
                    reason?: string | undefined;
                } | undefined): ReportAwardRequest;
                fromPartial(object: {
                    awardId?: string;
                    reason?: string | undefined;
                }): ReportAwardRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Save a Post or Comment to the user's Saved list
         *
         * @see {@link Unsave}
         * @see {@link https://www.reddit.com/dev/api#POST_api_save}
         */
        readonly save: {
            readonly name: "Save";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.SaveRequest";
                encode(message: SaveRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SaveRequest;
                fromJSON(object: any): SaveRequest;
                toJSON(message: SaveRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): SaveRequest;
                fromPartial(object: {
                    id?: string;
                }): SaveRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Enable or disable reply notifications for a Post or Comment
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_sendreplies}
         */
        readonly sendReplies: {
            readonly name: "SendReplies";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.SendRepliesRequest";
                encode(message: SendRepliesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SendRepliesRequest;
                fromJSON(object: any): SendRepliesRequest;
                toJSON(message: SendRepliesRequest): unknown;
                create(base?: {
                    id?: string;
                    state?: boolean;
                } | undefined): SendRepliesRequest;
                fromPartial(object: {
                    id?: string;
                    state?: boolean;
                }): SendRepliesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Toggle Contest Mode for a Post's comments
         *
         * Contest Mode randomizes the sort order and hides the vote score for comments
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_set_contest_mode}
         */
        readonly setContestMode: {
            readonly name: "SetContestMode";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.SetContestModeRequest";
                encode(message: SetContestModeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SetContestModeRequest;
                fromJSON(object: any): SetContestModeRequest;
                toJSON(message: SetContestModeRequest): unknown;
                create(base?: {
                    id?: string;
                    state?: boolean;
                } | undefined): SetContestModeRequest;
                fromPartial(object: {
                    id?: string;
                    state?: boolean;
                }): SetContestModeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Set the "sticky" or "pinned" status of a Post
         *
         * If the post was created by the current user they can pin the post
         * to the top of their user profile.  Otherwise they must be a moderator
         * of the subreddit to stick it to the top of the subreddit it was posted in.
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_set_subreddit_sticky}
         */
        readonly setSubredditSticky: {
            readonly name: "SetSubredditSticky";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.SetSubredditStickyRequest";
                encode(message: SetSubredditStickyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SetSubredditStickyRequest;
                fromJSON(object: any): SetSubredditStickyRequest;
                toJSON(message: SetSubredditStickyRequest): unknown;
                create(base?: {
                    id?: string;
                    num?: number | undefined;
                    state?: boolean;
                    toProfile?: boolean | undefined;
                } | undefined): SetSubredditStickyRequest;
                fromPartial(object: {
                    id?: string;
                    num?: number | undefined;
                    state?: boolean;
                    toProfile?: boolean | undefined;
                }): SetSubredditStickyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Set the default sort order for comments in the given Post
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_set_suggested_sort}
         */
        readonly setSuggestedSort: {
            readonly name: "SetSuggestedSort";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.SetSuggestedSortRequest";
                encode(message: SetSuggestedSortRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SetSuggestedSortRequest;
                fromJSON(object: any): SetSuggestedSortRequest;
                toJSON(message: SetSuggestedSortRequest): unknown;
                create(base?: {
                    id?: string;
                    sort?: string;
                } | undefined): SetSuggestedSortRequest;
                fromPartial(object: {
                    id?: string;
                    sort?: string;
                }): SetSuggestedSortRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Sets the spoiler tag on a given Post to hide its contents by default
         * Note: `id` must be a single thing ID for a Post
         *
         * @see {@link Unspoiler}
         * @see {@link https://www.reddit.com/dev/api#POST_api_spoiler}
         */
        readonly spoiler: {
            readonly name: "Spoiler";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Create a new Post
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_submit}
         *
         * Note: not specifying ApiClientConfig to avoid automatic generation.
         * Submit has extra logic that needs to be manually implemented.
         */
        readonly submit: {
            readonly name: "Submit";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.SubmitRequest";
                encode(message: SubmitRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubmitRequest;
                fromJSON(object: any): SubmitRequest;
                toJSON(message: SubmitRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    flairId?: string | undefined;
                    flairText?: string | undefined;
                    kind?: string;
                    nsfw?: boolean | undefined;
                    richtextJson?: string | undefined;
                    sendreplies?: boolean | undefined;
                    spoiler?: boolean | undefined;
                    sr?: string;
                    text?: string | undefined;
                    title?: string;
                    url?: string | undefined;
                    videoPosterUrl?: string | undefined;
                    crosspostFullname?: string | undefined;
                } | undefined): SubmitRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    flairId?: string | undefined;
                    flairText?: string | undefined;
                    kind?: string;
                    nsfw?: boolean | undefined;
                    richtextJson?: string | undefined;
                    sendreplies?: boolean | undefined;
                    spoiler?: boolean | undefined;
                    sr?: string;
                    text?: string | undefined;
                    title?: string;
                    url?: string | undefined;
                    videoPosterUrl?: string | undefined;
                    crosspostFullname?: string | undefined;
                }): SubmitRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse";
                encode(message: SubmitResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubmitResponse;
                fromJSON(object: any): SubmitResponse;
                toJSON(message: SubmitResponse): unknown;
                create(base?: {
                    json?: {
                        errors?: {
                            typeUrl?: string;
                            value?: Uint8Array;
                        }[];
                        data?: {
                            url?: string | undefined;
                            draftsCount?: number | undefined;
                            id?: string | undefined;
                            name?: string | undefined;
                        } | undefined;
                    } | undefined;
                } | undefined): SubmitResponse;
                fromPartial(object: {
                    json?: {
                        errors?: {
                            typeUrl?: string;
                            value?: Uint8Array;
                        }[];
                        data?: {
                            url?: string | undefined;
                            draftsCount?: number | undefined;
                            id?: string | undefined;
                            name?: string | undefined;
                        } | undefined;
                    } | undefined;
                }): SubmitResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /**
         * Unhide one or more Posts for the user
         * Note: `id` must be one or more comma-separated Post thing IDs
         *
         * @see {@link Hide}
         * @see {@link https://www.reddit.com/dev/api#POST_api_unhide}
         */
        readonly unhide: {
            readonly name: "Unhide";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Enable comments for a Post or Comment
         * Note: `id` must be a single thing ID for a Post or Comment
         *
         * @see {@link Lock}
         * @see {@link https://www.reddit.com/dev/api#POST_api_unlock}
         */
        readonly unlock: {
            readonly name: "Unlock";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Clears the Not-Safe-For-Work status from a Post
         *
         * @see {@link MarkNSFW}
         * @see {@link https://www.reddit.com/dev/api#POST_api_unmarknsfw}
         */
        readonly unmarkNSFW: {
            readonly name: "UnmarkNSFW";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Remove a Post or Comment from the user's Saved list
         *
         * @see {@link Save}
         * @see {@link https://www.reddit.com/dev/api#POST_api_unsave}
         */
        readonly unsave: {
            readonly name: "Unsave";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Clears the spoiler tag on a given Post
         *
         * @see {@link Spoiler}
         * @see {@link https://www.reddit.com/dev/api#POST_api_unspoiler}
         */
        readonly unspoiler: {
            readonly name: "Unspoiler";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest";
                encode(message: BasicIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicIdRequest;
                fromJSON(object: any): BasicIdRequest;
                toJSON(message: BasicIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Vote or clear a vote on a Post or Comment
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_vote}
         */
        readonly vote: {
            readonly name: "Vote";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.linksandcomments.VoteRequest";
                encode(message: VoteRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): VoteRequest;
                fromJSON(object: any): VoteRequest;
                toJSON(message: VoteRequest): unknown;
                create(base?: {
                    dir?: number;
                    id?: string;
                } | undefined): VoteRequest;
                fromPartial(object: {
                    dir?: number;
                    id?: string;
                }): VoteRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown; /**
                * Edit the body text of a Comment or Post
                * Note: `thing_id` refers to the Post or Comment being edited
                *
                * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
                */
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
    };
};

declare const LinksAndCommentsServiceName = "devvit.plugin.redditapi.linksandcomments.LinksAndComments";

declare interface ListActionRequest {
    before?: Date | undefined;
    after?: Date | undefined;
}

declare const ListActionRequest: {
    $type: "devvit.plugin.scheduler.ListActionRequest";
    encode(message: ListActionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ListActionRequest;
    fromJSON(object: any): ListActionRequest;
    toJSON(message: ListActionRequest): unknown;
    create(base?: DeepPartial_89<ListActionRequest>): ListActionRequest;
    fromPartial(object: DeepPartial_89<ListActionRequest>): ListActionRequest;
};

declare interface ListActionResponse {
    actions: GetActionResponse[];
}

declare const ListActionResponse: {
    $type: "devvit.plugin.scheduler.ListActionResponse";
    encode(message: ListActionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ListActionResponse;
    fromJSON(object: any): ListActionResponse;
    toJSON(message: ListActionResponse): unknown;
    create(base?: DeepPartial_89<ListActionResponse>): ListActionResponse;
    fromPartial(object: DeepPartial_89<ListActionResponse>): ListActionResponse;
};

/**
 * @mixin
 */
declare type ListContainer<Context> = {
    /**
     * Append a List
     * @param opts {@link ListOptions}
     * @param cb scoped callback to add child elements to this List
     */
    list(opts: ListOptions, cb: (list: ListContext) => void): Context;
};

/**
 * @borrows ListItemContainer
 */
declare interface ListContext extends ListItemContainer<ListContext> {
}

declare interface ListFilter {
    filter: string;
}

declare const ListFilter: {
    $type: "devvit.plugin.kvstore.ListFilter";
    encode(message: ListFilter, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ListFilter;
    fromJSON(object: any): ListFilter;
    toJSON(message: ListFilter): unknown;
    create(base?: DeepPartial_61<ListFilter>): ListFilter;
    fromPartial(object: DeepPartial_61<ListFilter>): ListFilter;
};

export declare interface Listing<T> {
}

export declare class Listing<T> {
    #private;
    pageSize: number;
    limit: number;
    children: T[];
    get hasMore(): boolean;
    [Symbol.asyncIterator](): AsyncIterator<T>;
    setMore(more: MoreObject | undefined): void;
    preventInitialFetch(): void;
    all(): Promise<T[]>;
    get(count: number): Promise<T[]>;
}

/** A Listing is a paginated list of Things such as Subreddits, Posts, or Comments */
declare interface Listing_2 {
    /** String value: "Listing" */
    kind: string;
    /** Contents of the listing */
    data?: Listing_ListingData | undefined;
}

declare const Listing_2: {
    $type: "devvit.plugin.redditapi.common.Listing";
    encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Listing_2;
    fromJSON(object: any): Listing_2;
    toJSON(message: Listing_2): unknown;
    create(base?: DeepPartial_8<Listing_2>): Listing_2;
    fromPartial(object: DeepPartial_8<Listing_2>): Listing_2;
};

declare interface Listing_ListingData {
    /**
     * If present, use this as the `after` parameter when calling the same
     * API again to fetch the next page
     */
    after?: string | undefined;
    /**
     * If present, use this as the `before` parameter when calling the same
     * API again to fetch the previous page
     */
    before?: string | undefined;
    /** Contents of the current page of the listing */
    children: WrappedRedditObject[];
    /**
     * Number of objects in `children`
     * Note: Only counts immediate entries in `children` and does not count
     *       nested objects such as comment trees
     */
    dist?: number | undefined;
}

declare const Listing_ListingData: {
    $type: "devvit.plugin.redditapi.common.Listing.ListingData";
    encode(message: Listing_ListingData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Listing_ListingData;
    fromJSON(object: any): Listing_ListingData;
    toJSON(message: Listing_ListingData): unknown;
    create(base?: DeepPartial_8<Listing_ListingData>): Listing_ListingData;
    fromPartial(object: DeepPartial_8<Listing_ListingData>): Listing_ListingData;
};

export declare type ListingFetchOptions = {
    after?: string;
    before?: string;
    limit?: number;
    pageSize?: number;
    more?: MoreObject;
};

export declare type ListingFetchResponse<T> = {
    children: T[];
    before?: string;
    after?: string;
    more?: MoreObject;
};

/** Responses */
declare interface ListingResponse {
    listings: Listing_2[];
}

declare const ListingResponse: {
    $type: "devvit.plugin.redditapi.listings.ListingResponse";
    encode(message: ListingResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ListingResponse;
    fromJSON(object: any): ListingResponse;
    toJSON(message: ListingResponse): unknown;
    create(base?: DeepPartial_66<ListingResponse>): ListingResponse;
    fromPartial(object: DeepPartial_66<ListingResponse>): ListingResponse;
};

/** LISTINGS - https://www.reddit.com/dev/api#section_listings */
declare interface Listings {
    /**
     * Home listing
     *
     * @see {@link https://www.reddit.com/dev/api#GET_best}
     */
    Best(request: GetBestRequest, metadata?: Metadata): Promise<Listing_2>;
    /**
     * Create a custom listing with the Post IDs provided
     *
     * @see {@link https://www.reddit.com/dev/api#GET_by_id_\{names\}}
     */
    ById(request: GetByIdRequest, metadata?: Metadata): Promise<Listing_2>;
    /**
     * Get a comment tree for a Post
     *
     * @see {@link https://www.reddit.com/dev/api#GET_comments_\{article\}}
     */
    Comments(request: GetCommentsRequest, metadata?: Metadata): Promise<ListingResponse>;
    /**
     * Find duplicate posts that reference the same URL as this Post
     *
     * @see {@link https://www.reddit.com/dev/api#GET_duplicates_\{article\}}
     */
    Duplicates(request: GetDuplicatesRequest, metadata?: Metadata): Promise<ListingResponse>;
    /**
     * Listing with Hot sort
     *
     * @see {@link https://www.reddit.com/dev/api#GET_hot}
     */
    Hot(request: GetHotRequest, metadata?: Metadata): Promise<Listing_2>;
    /**
     * Listing with New sort
     *
     * @see {@link https://www.reddit.com/dev/api#GET_new}
     */
    New(request: GetNewRequest, metadata?: Metadata): Promise<Listing_2>;
    /**
     * Listing with Rising sort
     *
     * @see {@link https://www.reddit.com/dev/api#GET_rising}
     */
    Rising(request: GetRisingRequest, metadata?: Metadata): Promise<Listing_2>;
    /**
     * Listing with Top or Controversial sort
     *
     * @see {@link https://www.reddit.com/dev/api#GET_\{sort\}}
     */
    Sort(request: GetSortRequest, metadata?: Metadata): Promise<Listing_2>;
}

declare class ListingsClientImpl implements Listings {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_57, opts?: {
        service?: string;
    });
    Best(request: GetBestRequest, metadata?: Metadata): Promise<Listing_2>;
    ById(request: GetByIdRequest, metadata?: Metadata): Promise<Listing_2>;
    Comments(request: GetCommentsRequest, metadata?: Metadata): Promise<ListingResponse>;
    Duplicates(request: GetDuplicatesRequest, metadata?: Metadata): Promise<ListingResponse>;
    Hot(request: GetHotRequest, metadata?: Metadata): Promise<Listing_2>;
    New(request: GetNewRequest, metadata?: Metadata): Promise<Listing_2>;
    Rising(request: GetRisingRequest, metadata?: Metadata): Promise<Listing_2>;
    Sort(request: GetSortRequest, metadata?: Metadata): Promise<Listing_2>;
}

/** LISTINGS - https://www.reddit.com/dev/api#section_listings */
declare type ListingsDefinition = typeof ListingsDefinition;

declare const ListingsDefinition: {
    readonly name: "Listings";
    readonly fullName: "devvit.plugin.redditapi.listings.Listings";
    readonly methods: {
        /**
         * Home listing
         *
         * @see {@link https://www.reddit.com/dev/api#GET_best}
         */
        readonly best: {
            readonly name: "Best";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.listings.GetBestRequest";
                encode(message: GetBestRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetBestRequest;
                fromJSON(object: any): GetBestRequest;
                toJSON(message: GetBestRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                } | undefined): GetBestRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                }): GetBestRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Create a custom listing with the Post IDs provided
         *
         * @see {@link https://www.reddit.com/dev/api#GET_by_id_\{names\}}
         */
        readonly byId: {
            readonly name: "ById";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.listings.GetByIdRequest";
                encode(message: GetByIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetByIdRequest;
                fromJSON(object: any): GetByIdRequest;
                toJSON(message: GetByIdRequest): unknown;
                create(base?: {
                    postIds?: string;
                } | undefined): GetByIdRequest;
                fromPartial(object: {
                    postIds?: string;
                }): GetByIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Get a comment tree for a Post
         *
         * @see {@link https://www.reddit.com/dev/api#GET_comments_\{article\}}
         */
        readonly comments: {
            readonly name: "Comments";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.listings.GetCommentsRequest";
                encode(message: GetCommentsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetCommentsRequest;
                fromJSON(object: any): GetCommentsRequest;
                toJSON(message: GetCommentsRequest): unknown;
                create(base?: {
                    article?: string;
                    comment?: string | undefined;
                    context?: number | undefined;
                    depth?: number | undefined;
                    limit?: number | undefined;
                    sort?: string | undefined;
                    threaded?: boolean | undefined;
                    truncate?: number | undefined;
                } | undefined): GetCommentsRequest;
                fromPartial(object: {
                    article?: string;
                    comment?: string | undefined;
                    context?: number | undefined;
                    depth?: number | undefined;
                    limit?: number | undefined;
                    sort?: string | undefined;
                    threaded?: boolean | undefined;
                    truncate?: number | undefined;
                }): GetCommentsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.listings.ListingResponse";
                encode(message: ListingResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ListingResponse;
                fromJSON(object: any): ListingResponse;
                toJSON(message: ListingResponse): unknown;
                create(base?: {
                    listings?: {
                        kind?: string;
                        data?: {
                            after?: string | undefined;
                            before?: string | undefined;
                            children?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: any[] | undefined;
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    depth?: number | undefined;
                                    linkTitle?: string | undefined;
                                    linkAuthor?: string | undefined;
                                    numComments?: number | undefined;
                                    over18?: boolean | undefined;
                                    linkPermalink?: string | undefined;
                                    quarantine?: boolean | undefined;
                                    linkUrl?: string | undefined;
                                    selftext?: string | undefined;
                                    selftextHtml?: string | undefined;
                                    thumbnail?: string | undefined;
                                    thumbnailWidth?: number | undefined;
                                    thumbnailHeight?: number | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    displayName?: string | undefined;
                                    modPermissions?: string[];
                                    count?: number | undefined;
                                    children?: any[] | undefined;
                                    replyList?: any | undefined;
                                    hidden?: boolean | undefined;
                                    linkFlairBackgroundColor?: string | undefined;
                                    linkFlairCssClass?: string | undefined;
                                    linkFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    linkFlairTemplateId?: string | undefined;
                                    linkFlairText?: string | undefined;
                                    linkFlairTextColor?: string | undefined;
                                    linkFlairType?: string | undefined;
                                    secureMedia?: {
                                        type?: string;
                                        oembed?: {
                                            type?: string;
                                            title?: string | undefined;
                                            providerName?: string | undefined;
                                            providerUrl?: string | undefined;
                                            version?: string;
                                            thumbnailWidth?: number | undefined;
                                            thumbnailHeight?: number | undefined;
                                            thumbnailUrl?: string | undefined;
                                            html?: string;
                                            height?: number | undefined;
                                            width?: number | undefined;
                                            authorUrl?: string | undefined;
                                            authorName?: string | undefined;
                                        } | undefined;
                                        redditVideo?: {
                                            bitrateKbps?: number | undefined;
                                            dashUrl?: string | undefined;
                                            duration?: number | undefined;
                                            fallbackUrl?: string | undefined;
                                            height?: number | undefined;
                                            hlsUrl?: string | undefined;
                                            isGif?: boolean | undefined;
                                            scrubberMediaUrl?: string | undefined;
                                            transcodingStatus?: string | undefined;
                                            width?: number | undefined;
                                        } | undefined;
                                    } | undefined;
                                    spoiler?: boolean;
                                    modReports?: any[][];
                                    userReports?: any[][];
                                    removedBy?: string | undefined;
                                    removedByCategory?: string | undefined;
                                } | undefined;
                            }[];
                            dist?: number | undefined;
                        } | undefined;
                    }[];
                } | undefined): ListingResponse;
                fromPartial(object: {
                    listings?: {
                        kind?: string;
                        data?: {
                            after?: string | undefined;
                            before?: string | undefined;
                            children?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: any[] | undefined;
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    depth?: number | undefined;
                                    linkTitle?: string | undefined;
                                    linkAuthor?: string | undefined;
                                    numComments?: number | undefined;
                                    over18?: boolean | undefined;
                                    linkPermalink?: string | undefined;
                                    quarantine?: boolean | undefined;
                                    linkUrl?: string | undefined;
                                    selftext?: string | undefined;
                                    selftextHtml?: string | undefined;
                                    thumbnail?: string | undefined;
                                    thumbnailWidth?: number | undefined;
                                    thumbnailHeight?: number | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    displayName?: string | undefined;
                                    modPermissions?: string[];
                                    count?: number | undefined;
                                    children?: any[] | undefined;
                                    replyList?: any | undefined;
                                    hidden?: boolean | undefined;
                                    linkFlairBackgroundColor?: string | undefined;
                                    linkFlairCssClass?: string | undefined;
                                    linkFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    linkFlairTemplateId?: string | undefined;
                                    linkFlairText?: string | undefined;
                                    linkFlairTextColor?: string | undefined;
                                    linkFlairType?: string | undefined;
                                    secureMedia?: {
                                        type?: string;
                                        oembed?: {
                                            type?: string;
                                            title?: string | undefined;
                                            providerName?: string | undefined;
                                            providerUrl?: string | undefined;
                                            version?: string;
                                            thumbnailWidth?: number | undefined;
                                            thumbnailHeight?: number | undefined;
                                            thumbnailUrl?: string | undefined;
                                            html?: string;
                                            height?: number | undefined;
                                            width?: number | undefined;
                                            authorUrl?: string | undefined;
                                            authorName?: string | undefined;
                                        } | undefined;
                                        redditVideo?: {
                                            bitrateKbps?: number | undefined;
                                            dashUrl?: string | undefined;
                                            duration?: number | undefined;
                                            fallbackUrl?: string | undefined;
                                            height?: number | undefined;
                                            hlsUrl?: string | undefined;
                                            isGif?: boolean | undefined;
                                            scrubberMediaUrl?: string | undefined;
                                            transcodingStatus?: string | undefined;
                                            width?: number | undefined;
                                        } | undefined;
                                    } | undefined;
                                    spoiler?: boolean;
                                    modReports?: any[][];
                                    userReports?: any[][];
                                    removedBy?: string | undefined;
                                    removedByCategory?: string | undefined;
                                } | undefined;
                            }[];
                            dist?: number | undefined;
                        } | undefined;
                    }[];
                }): ListingResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Find duplicate posts that reference the same URL as this Post
         *
         * @see {@link https://www.reddit.com/dev/api#GET_duplicates_\{article\}}
         */
        readonly duplicates: {
            readonly name: "Duplicates";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.listings.GetDuplicatesRequest";
                encode(message: GetDuplicatesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetDuplicatesRequest;
                fromJSON(object: any): GetDuplicatesRequest;
                toJSON(message: GetDuplicatesRequest): unknown;
                create(base?: {
                    article?: string;
                    before?: string | undefined;
                    after?: string | undefined;
                    limit?: number | undefined;
                    sort?: string | undefined;
                    sr?: string | undefined;
                    count?: number | undefined;
                    crosspostsOnly?: boolean | undefined;
                    show?: string | undefined;
                } | undefined): GetDuplicatesRequest;
                fromPartial(object: {
                    article?: string;
                    before?: string | undefined;
                    after?: string | undefined;
                    limit?: number | undefined;
                    sort?: string | undefined;
                    sr?: string | undefined;
                    count?: number | undefined;
                    crosspostsOnly?: boolean | undefined;
                    show?: string | undefined;
                }): GetDuplicatesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.listings.ListingResponse";
                encode(message: ListingResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ListingResponse;
                fromJSON(object: any): ListingResponse;
                toJSON(message: ListingResponse): unknown;
                create(base?: {
                    listings?: {
                        kind?: string;
                        data?: {
                            after?: string | undefined;
                            before?: string | undefined;
                            children?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: any[] | undefined;
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    depth?: number | undefined;
                                    linkTitle?: string | undefined;
                                    linkAuthor?: string | undefined;
                                    numComments?: number | undefined;
                                    over18?: boolean | undefined;
                                    linkPermalink?: string | undefined;
                                    quarantine?: boolean | undefined;
                                    linkUrl?: string | undefined;
                                    selftext?: string | undefined;
                                    selftextHtml?: string | undefined;
                                    thumbnail?: string | undefined;
                                    thumbnailWidth?: number | undefined;
                                    thumbnailHeight?: number | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    displayName?: string | undefined;
                                    modPermissions?: string[];
                                    count?: number | undefined;
                                    children?: any[] | undefined;
                                    replyList?: any | undefined;
                                    hidden?: boolean | undefined;
                                    linkFlairBackgroundColor?: string | undefined;
                                    linkFlairCssClass?: string | undefined;
                                    linkFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    linkFlairTemplateId?: string | undefined;
                                    linkFlairText?: string | undefined;
                                    linkFlairTextColor?: string | undefined;
                                    linkFlairType?: string | undefined;
                                    secureMedia?: {
                                        type?: string;
                                        oembed?: {
                                            type?: string;
                                            title?: string | undefined;
                                            providerName?: string | undefined;
                                            providerUrl?: string | undefined;
                                            version?: string;
                                            thumbnailWidth?: number | undefined;
                                            thumbnailHeight?: number | undefined;
                                            thumbnailUrl?: string | undefined;
                                            html?: string;
                                            height?: number | undefined;
                                            width?: number | undefined;
                                            authorUrl?: string | undefined;
                                            authorName?: string | undefined;
                                        } | undefined;
                                        redditVideo?: {
                                            bitrateKbps?: number | undefined;
                                            dashUrl?: string | undefined;
                                            duration?: number | undefined;
                                            fallbackUrl?: string | undefined;
                                            height?: number | undefined;
                                            hlsUrl?: string | undefined;
                                            isGif?: boolean | undefined;
                                            scrubberMediaUrl?: string | undefined;
                                            transcodingStatus?: string | undefined;
                                            width?: number | undefined;
                                        } | undefined;
                                    } | undefined;
                                    spoiler?: boolean;
                                    modReports?: any[][];
                                    userReports?: any[][];
                                    removedBy?: string | undefined;
                                    removedByCategory?: string | undefined;
                                } | undefined;
                            }[];
                            dist?: number | undefined;
                        } | undefined;
                    }[];
                } | undefined): ListingResponse;
                fromPartial(object: {
                    listings?: {
                        kind?: string;
                        data?: {
                            after?: string | undefined;
                            before?: string | undefined;
                            children?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: any[] | undefined;
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    depth?: number | undefined;
                                    linkTitle?: string | undefined;
                                    linkAuthor?: string | undefined;
                                    numComments?: number | undefined;
                                    over18?: boolean | undefined;
                                    linkPermalink?: string | undefined;
                                    quarantine?: boolean | undefined;
                                    linkUrl?: string | undefined;
                                    selftext?: string | undefined;
                                    selftextHtml?: string | undefined;
                                    thumbnail?: string | undefined;
                                    thumbnailWidth?: number | undefined;
                                    thumbnailHeight?: number | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    displayName?: string | undefined;
                                    modPermissions?: string[];
                                    count?: number | undefined;
                                    children?: any[] | undefined;
                                    replyList?: any | undefined;
                                    hidden?: boolean | undefined;
                                    linkFlairBackgroundColor?: string | undefined;
                                    linkFlairCssClass?: string | undefined;
                                    linkFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    linkFlairTemplateId?: string | undefined;
                                    linkFlairText?: string | undefined;
                                    linkFlairTextColor?: string | undefined;
                                    linkFlairType?: string | undefined;
                                    secureMedia?: {
                                        type?: string;
                                        oembed?: {
                                            type?: string;
                                            title?: string | undefined;
                                            providerName?: string | undefined;
                                            providerUrl?: string | undefined;
                                            version?: string;
                                            thumbnailWidth?: number | undefined;
                                            thumbnailHeight?: number | undefined;
                                            thumbnailUrl?: string | undefined;
                                            html?: string;
                                            height?: number | undefined;
                                            width?: number | undefined;
                                            authorUrl?: string | undefined;
                                            authorName?: string | undefined;
                                        } | undefined;
                                        redditVideo?: {
                                            bitrateKbps?: number | undefined;
                                            dashUrl?: string | undefined;
                                            duration?: number | undefined;
                                            fallbackUrl?: string | undefined;
                                            height?: number | undefined;
                                            hlsUrl?: string | undefined;
                                            isGif?: boolean | undefined;
                                            scrubberMediaUrl?: string | undefined;
                                            transcodingStatus?: string | undefined;
                                            width?: number | undefined;
                                        } | undefined;
                                    } | undefined;
                                    spoiler?: boolean;
                                    modReports?: any[][];
                                    userReports?: any[][];
                                    removedBy?: string | undefined;
                                    removedByCategory?: string | undefined;
                                } | undefined;
                            }[];
                            dist?: number | undefined;
                        } | undefined;
                    }[];
                }): ListingResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Listing with Hot sort
         *
         * @see {@link https://www.reddit.com/dev/api#GET_hot}
         */
        readonly hot: {
            readonly name: "Hot";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.listings.GetHotRequest";
                encode(message: GetHotRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetHotRequest;
                fromJSON(object: any): GetHotRequest;
                toJSON(message: GetHotRequest): unknown;
                create(base?: {
                    subreddit?: string | undefined;
                    before?: string | undefined;
                    after?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: string | undefined;
                    g?: string | undefined;
                } | undefined): GetHotRequest;
                fromPartial(object: {
                    subreddit?: string | undefined;
                    before?: string | undefined;
                    after?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: string | undefined;
                    g?: string | undefined;
                }): GetHotRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Listing with New sort
         *
         * @see {@link https://www.reddit.com/dev/api#GET_new}
         */
        readonly new: {
            readonly name: "New";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.listings.GetNewRequest";
                encode(message: GetNewRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetNewRequest;
                fromJSON(object: any): GetNewRequest;
                toJSON(message: GetNewRequest): unknown;
                create(base?: {
                    subreddit?: string | undefined;
                    before?: string | undefined;
                    after?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: string | undefined;
                } | undefined): GetNewRequest;
                fromPartial(object: {
                    subreddit?: string | undefined;
                    before?: string | undefined;
                    after?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: string | undefined;
                }): GetNewRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Listing with Rising sort
         *
         * @see {@link https://www.reddit.com/dev/api#GET_rising}
         */
        readonly rising: {
            readonly name: "Rising";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.listings.GetRisingRequest";
                encode(message: GetRisingRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetRisingRequest;
                fromJSON(object: any): GetRisingRequest;
                toJSON(message: GetRisingRequest): unknown;
                create(base?: {
                    subreddit?: string | undefined;
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                } | undefined): GetRisingRequest;
                fromPartial(object: {
                    subreddit?: string | undefined;
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                }): GetRisingRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Listing with Top or Controversial sort
         *
         * @see {@link https://www.reddit.com/dev/api#GET_\{sort\}}
         */
        readonly sort: {
            readonly name: "Sort";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.listings.GetSortRequest";
                encode(message: GetSortRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetSortRequest;
                fromJSON(object: any): GetSortRequest;
                toJSON(message: GetSortRequest): unknown;
                create(base?: {
                    subreddit?: string | undefined;
                    sort?: string;
                    after?: string | undefined;
                    before?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: string | undefined;
                    t?: string | undefined;
                } | undefined): GetSortRequest;
                fromPartial(object: {
                    subreddit?: string | undefined;
                    sort?: string;
                    after?: string | undefined;
                    before?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: string | undefined;
                    t?: string | undefined;
                }): GetSortRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
    };
};

declare const ListingsServiceName = "devvit.plugin.redditapi.listings.Listings";

/**
 * @mixin
 */
declare type ListItemContainer<Context> = {
    /**
     * Append a List Item to a List
     * @param cb scoped callback to add child elements to this List Item
     */
    item(cb: (item: ListItemContext) => void): Context;
};

/**
 * @borrows BlockQuoteContainer
 * @borrows CodeBlockContainer
 * @borrows HeadingContainer
 * @borrows HorizontalRuleContainer
 * @borrows ListContainer
 * @borrows ParagraphContainer
 * @borrows TableContainer
 */
declare interface ListItemContext extends BlockQuoteContainer<ListItemContext>, CodeBlockContainer<ListItemContext>, HeadingContainer<ListItemContext>, HorizontalRuleContainer<ListItemContext>, ListContainer<ListItemContext>, ParagraphContainer<ListItemContext>, TableContainer<ListItemContext> {
}

declare type ListOptions = {
    /** Whether to use numbers or dots as list item markers */
    ordered: boolean;
};

/**
 * `ListValue` is a wrapper around a repeated field of values.
 *
 * The JSON representation for `ListValue` is JSON array.
 */
declare interface ListValue {
    /** Repeated field of dynamically typed values. */
    values: any[];
}

declare const ListValue: {
    $type: "google.protobuf.ListValue";
    encode(message: ListValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ListValue;
    fromJSON(object: any): ListValue;
    toJSON(message: ListValue): unknown;
    create(base?: DeepPartial_103<ListValue>): ListValue;
    fromPartial(object: DeepPartial_103<ListValue>): ListValue;
    wrap(array: Array<any> | undefined): ListValue;
    unwrap(message: ListValue): Array<any>;
};

/** Permitted and forbidden execution environments. */
declare interface LocationFilter {
    allow: string[];
    deny: string[];
}

declare const LocationFilter: {
    $type: "devvit.runtime.LocationFilter";
    encode(message: LocationFilter, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LocationFilter;
    fromJSON(object: any): LocationFilter;
    toJSON(message: LocationFilter): unknown;
    create(base?: DeepPartial_14<LocationFilter>): LocationFilter;
    fromPartial(object: DeepPartial_14<LocationFilter>): LocationFilter;
};

declare interface LogErrorMessage {
    message: string;
    name: string;
    fileName?: string | undefined;
    lineNumber?: number | undefined;
    columnNumber?: number | undefined;
    stack?: string | undefined;
    timestamp?: Date | undefined;
    /**
     * to-do: add labels like LogEventMessage.
     * Deprecated 2023-01-25: Use labels instead.
     *
     * @deprecated
     */
    tags: string[];
}

declare const LogErrorMessage: {
    $type: "devvit.plugin.logger.LogErrorMessage";
    encode(message: LogErrorMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LogErrorMessage;
    fromJSON(object: any): LogErrorMessage;
    toJSON(message: LogErrorMessage): unknown;
    create(base?: DeepPartial_67<LogErrorMessage>): LogErrorMessage;
    fromPartial(object: DeepPartial_67<LogErrorMessage>): LogErrorMessage;
};

declare interface LogErrorResponse {
}

declare const LogErrorResponse: {
    $type: "devvit.plugin.logger.LogErrorResponse";
    encode(_: LogErrorResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LogErrorResponse;
    fromJSON(_: any): LogErrorResponse;
    toJSON(_: LogErrorResponse): unknown;
    create(base?: DeepPartial_67<LogErrorResponse>): LogErrorResponse;
    fromPartial(_: DeepPartial_67<LogErrorResponse>): LogErrorResponse;
};

/**
 * A notable event or historical record for analytics and security.
 *
 * Do not record sensitive data.
 */
declare interface LogEventMessage {
    /**
     * The event kind. Events with the same type are considered instances of that
     * event. Eg, 'AppLoad' or 'AppHTTPRequest'.
     *
     * Unexpected event types may not be logged.
     */
    type: string;
    /** The occurence time. */
    timestamp?: Date | undefined;
    /**
     * Optional additional indexed information. Eg, 'direction'  'Up' or
     * 'appName'  'com.example.test'.
     *
     * Unexpected label keys may be stripped.
     *
     * Labels and data are the same except that labels are indexed.
     */
    labels: {
        [key: string]: string;
    };
    /**
     * Optional additional non-indexed information. Eg, 'dynamicString'  'abc'
     * 'verboseDetail' -> '123'.
     *
     * Any key-value may safely be included without coordination.
     *
     * Labels and data are the same except that labels are indexed.
     */
    data: {
        [key: string]: string;
    };
}

declare const LogEventMessage: {
    $type: "devvit.plugin.logger.LogEventMessage";
    encode(message: LogEventMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LogEventMessage;
    fromJSON(object: any): LogEventMessage;
    toJSON(message: LogEventMessage): unknown;
    create(base?: DeepPartial_67<LogEventMessage>): LogEventMessage;
    fromPartial(object: DeepPartial_67<LogEventMessage>): LogEventMessage;
};

declare interface LogEventMessage_DataEntry {
    key: string;
    value: string;
}

declare const LogEventMessage_DataEntry: {
    $type: "devvit.plugin.logger.LogEventMessage.DataEntry";
    encode(message: LogEventMessage_DataEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LogEventMessage_DataEntry;
    fromJSON(object: any): LogEventMessage_DataEntry;
    toJSON(message: LogEventMessage_DataEntry): unknown;
    create(base?: DeepPartial_67<LogEventMessage_DataEntry>): LogEventMessage_DataEntry;
    fromPartial(object: DeepPartial_67<LogEventMessage_DataEntry>): LogEventMessage_DataEntry;
};

declare interface LogEventMessage_LabelsEntry {
    key: string;
    value: string;
}

declare const LogEventMessage_LabelsEntry: {
    $type: "devvit.plugin.logger.LogEventMessage.LabelsEntry";
    encode(message: LogEventMessage_LabelsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LogEventMessage_LabelsEntry;
    fromJSON(object: any): LogEventMessage_LabelsEntry;
    toJSON(message: LogEventMessage_LabelsEntry): unknown;
    create(base?: DeepPartial_67<LogEventMessage_LabelsEntry>): LogEventMessage_LabelsEntry;
    fromPartial(object: DeepPartial_67<LogEventMessage_LabelsEntry>): LogEventMessage_LabelsEntry;
};

declare interface LogEventResponse {
}

declare const LogEventResponse: {
    $type: "devvit.plugin.logger.LogEventResponse";
    encode(_: LogEventResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LogEventResponse;
    fromJSON(_: any): LogEventResponse;
    toJSON(_: LogEventResponse): unknown;
    create(base?: DeepPartial_67<LogEventResponse>): LogEventResponse;
    fromPartial(_: DeepPartial_67<LogEventResponse>): LogEventResponse;
};

declare interface Logger {
    Error(request: LogErrorMessage, metadata?: Metadata): Promise<LogErrorResponse>;
    /**
     * Record a notable event or historical record for analytics and security.
     *
     * @internal
     */
    Event(request: LogEventMessage, metadata?: Metadata): Promise<LogEventResponse>;
    Log(request: LogMessage, metadata?: Metadata): Promise<LogResponse>;
    LogBatch(request: LogMessages, metadata?: Metadata): Promise<LogResponse>;
}

declare interface LoggerClient {
    Error(request: LogErrorMessage): Promise<LogErrorResponse>;
    Event(request: LogEventMessage): Promise<LogEventResponse>;
    Log(request: LogMessage): Promise<LogResponse>;
    LogBatch(request: LogMessages): Promise<LogResponse>;
}

declare class LoggerClientImpl implements Logger {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_20, opts?: {
        service?: string;
    });
    Error(request: LogErrorMessage, metadata?: Metadata): Promise<LogErrorResponse>;
    Event(request: LogEventMessage, metadata?: Metadata): Promise<LogEventResponse>;
    Log(request: LogMessage, metadata?: Metadata): Promise<LogResponse>;
    LogBatch(request: LogMessages, metadata?: Metadata): Promise<LogResponse>;
}

declare class LoggerClientJSON implements LoggerClient {
    private readonly rpc;
    constructor(rpc: Rpc_19);
    Error(request: LogErrorMessage): Promise<LogErrorResponse>;
    Event(request: LogEventMessage): Promise<LogEventResponse>;
    Log(request: LogMessage): Promise<LogResponse>;
    LogBatch(request: LogMessages): Promise<LogResponse>;
}

declare class LoggerClientProtobuf implements LoggerClient {
    private readonly rpc;
    constructor(rpc: Rpc_19);
    Error(request: LogErrorMessage): Promise<LogErrorResponse>;
    Event(request: LogEventMessage): Promise<LogEventResponse>;
    Log(request: LogMessage): Promise<LogResponse>;
    LogBatch(request: LogMessages): Promise<LogResponse>;
}

declare type LoggerDefinition = typeof LoggerDefinition;

declare const LoggerDefinition: {
    readonly name: "Logger";
    readonly fullName: "devvit.plugin.logger.Logger";
    readonly methods: {
        readonly error: {
            readonly name: "Error";
            readonly requestType: {
                $type: "devvit.plugin.logger.LogErrorMessage";
                encode(message: LogErrorMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): LogErrorMessage;
                fromJSON(object: any): LogErrorMessage;
                toJSON(message: LogErrorMessage): unknown;
                create(base?: DeepPartial_67<LogErrorMessage>): LogErrorMessage;
                fromPartial(object: DeepPartial_67<LogErrorMessage>): LogErrorMessage;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.logger.LogErrorResponse";
                encode(_: LogErrorResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): LogErrorResponse;
                fromJSON(_: any): LogErrorResponse;
                toJSON(_: LogErrorResponse): unknown;
                create(base?: DeepPartial_67<LogErrorResponse>): LogErrorResponse;
                fromPartial(_: DeepPartial_67<LogErrorResponse>): LogErrorResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /**
         * Record a notable event or historical record for analytics and security.
         *
         * @internal
         */
        readonly event: {
            readonly name: "Event";
            readonly requestType: {
                $type: "devvit.plugin.logger.LogEventMessage";
                encode(message: LogEventMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): LogEventMessage;
                fromJSON(object: any): LogEventMessage;
                toJSON(message: LogEventMessage): unknown;
                create(base?: DeepPartial_67<LogEventMessage>): LogEventMessage;
                fromPartial(object: DeepPartial_67<LogEventMessage>): LogEventMessage;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.logger.LogEventResponse";
                encode(_: LogEventResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): LogEventResponse;
                fromJSON(_: any): LogEventResponse;
                toJSON(_: LogEventResponse): unknown;
                create(base?: DeepPartial_67<LogEventResponse>): LogEventResponse;
                fromPartial(_: DeepPartial_67<LogEventResponse>): LogEventResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly log: {
            readonly name: "Log";
            readonly requestType: {
                $type: "devvit.plugin.logger.LogMessage";
                encode(message: LogMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): LogMessage;
                fromJSON(object: any): LogMessage;
                toJSON(message: LogMessage): unknown;
                create(base?: DeepPartial_67<LogMessage>): LogMessage;
                fromPartial(object: DeepPartial_67<LogMessage>): LogMessage;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.logger.LogResponse";
                encode(_: LogResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): LogResponse;
                fromJSON(_: any): LogResponse;
                toJSON(_: LogResponse): unknown;
                create(base?: DeepPartial_67<LogResponse>): LogResponse;
                fromPartial(_: DeepPartial_67<LogResponse>): LogResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly logBatch: {
            readonly name: "LogBatch";
            readonly requestType: {
                $type: "devvit.plugin.logger.LogMessages";
                encode(message: LogMessages, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): LogMessages;
                fromJSON(object: any): LogMessages;
                toJSON(message: LogMessages): unknown;
                create(base?: DeepPartial_67<LogMessages>): LogMessages;
                fromPartial(object: DeepPartial_67<LogMessages>): LogMessages;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.logger.LogResponse";
                encode(_: LogResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): LogResponse;
                fromJSON(_: any): LogResponse;
                toJSON(_: LogResponse): unknown;
                create(base?: DeepPartial_67<LogResponse>): LogResponse;
                fromPartial(_: DeepPartial_67<LogResponse>): LogResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const LoggerServiceName = "devvit.plugin.logger.Logger";

declare interface LogMessage {
    severity: Severity;
    message: string;
    /**
     * Most service implementations default to call time if a timestamp is not
     * provided.
     */
    timestamp?: Date | undefined;
    /**
     * to-do: add labels like LogEventMessage.
     * Deprecated 2023-01-25: Use labels instead.
     *
     * @deprecated
     */
    tags: string[];
}

declare const LogMessage: {
    $type: "devvit.plugin.logger.LogMessage";
    encode(message: LogMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LogMessage;
    fromJSON(object: any): LogMessage;
    toJSON(message: LogMessage): unknown;
    create(base?: DeepPartial_67<LogMessage>): LogMessage;
    fromPartial(object: DeepPartial_67<LogMessage>): LogMessage;
};

declare interface LogMessages {
    messages: LogMessage[];
}

declare const LogMessages: {
    $type: "devvit.plugin.logger.LogMessages";
    encode(message: LogMessages, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LogMessages;
    fromJSON(object: any): LogMessages;
    toJSON(message: LogMessages): unknown;
    create(base?: DeepPartial_67<LogMessages>): LogMessages;
    fromPartial(object: DeepPartial_67<LogMessages>): LogMessages;
};

declare interface LogResponse {
}

declare const LogResponse: {
    $type: "devvit.plugin.logger.LogResponse";
    encode(_: LogResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LogResponse;
    fromJSON(_: any): LogResponse;
    toJSON(_: LogResponse): unknown;
    create(base?: DeepPartial_67<LogResponse>): LogResponse;
    fromPartial(_: DeepPartial_67<LogResponse>): LogResponse;
};

declare interface Media {
    redditVideo?: Media_RedditVideo | undefined;
}

declare const Media: {
    $type: "devvit.reddit.Media";
    encode(message: Media, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Media;
    fromJSON(object: any): Media;
    toJSON(message: Media): unknown;
    create(base?: DeepPartial_82<Media>): Media;
    fromPartial(object: DeepPartial_82<Media>): Media;
};

declare interface Media_RedditVideo {
    bitrateKbps?: number | undefined;
    dashUrl?: string | undefined;
    duration?: number | undefined;
    fallbackUrl?: string | undefined;
    height?: number | undefined;
    hlsUrl?: string | undefined;
    isGif?: boolean | undefined;
    scrubberMediaUrl?: string | undefined;
    transcodingStatus?: string | undefined;
    width?: number | undefined;
}

declare const Media_RedditVideo: {
    $type: "devvit.reddit.Media.RedditVideo";
    encode(message: Media_RedditVideo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Media_RedditVideo;
    fromJSON(object: any): Media_RedditVideo;
    toJSON(message: Media_RedditVideo): unknown;
    create(base?: DeepPartial_82<Media_RedditVideo>): Media_RedditVideo;
    fromPartial(object: DeepPartial_82<Media_RedditVideo>): Media_RedditVideo;
};

export declare type MediaAsset = {
    mediaId: string;
    mediaUrl: string;
};

declare type MediaAssetId = string;

declare interface MediaEmbed {
    content?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    sandbox?: boolean | undefined;
    scrolling?: boolean | undefined;
    publicThumbnailUrl?: string | undefined;
}

declare const MediaEmbed: {
    $type: "devvit.reddit.MediaEmbed";
    encode(message: MediaEmbed, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MediaEmbed;
    fromJSON(object: any): MediaEmbed;
    toJSON(message: MediaEmbed): unknown;
    create(base?: DeepPartial_5<MediaEmbed>): MediaEmbed;
    fromPartial(object: DeepPartial_5<MediaEmbed>): MediaEmbed;
};

declare interface MediaObject {
    type: string;
    oembed?: Oembed | undefined;
    redditVideo?: RedditVideo_2 | undefined;
}

declare const MediaObject: {
    $type: "devvit.reddit.v2alpha.MediaObject";
    encode(message: MediaObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MediaObject;
    fromJSON(object: any): MediaObject;
    toJSON(message: MediaObject): unknown;
    create(base?: DeepPartial_78<MediaObject>): MediaObject;
    fromPartial(object: DeepPartial_78<MediaObject>): MediaObject;
};

declare type MediaOptions = {
    /** Reddit media ID provided after uploading media */
    mediaId: string;
    /** Media description */
    caption?: string;
    /**
     * If provided, the content should be blurred by default for the provided reason
     * @see {@link ObfuscationReason}
     */
    blur?: ObfuscationReason;
};

export declare type MediaPlugin = {
    /**
     * Uploads media from external URL to Reddit
     *
     * @param options - URL and media type (image, gif, video)
     * @returns A Promise that resolves to a MediaAsset object.
     * @example
     * ```ts
     *  const response = await context.media.upload({
     *    url: "https://media2.giphy.com/media/xTiN0CNHgoRf1Ha7CM/giphy.gif",
     *    type: "gif"
     *  });
     *  await context.reddit.submitPost(
     *     {
     *       subredditName: subreddit.name,
     *       title: 'Hello World with Media',
     *       richtext: new RichTextBuilder()
     *            .image({mediaId: response.mediaId})
     *            .codeBlock({}, (cb) => cb.rawText('This post was created from a Devvit App'))
     *     }
     *   );
     * ```
     */
    upload(opts: UploadMediaOptions): Promise<MediaAsset>;
};

declare interface MediaService {
    Upload(request: MediaUploadRequest, metadata?: Metadata): Promise<MediaUploadResponse>;
}

declare class MediaServiceClientImpl implements MediaService {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_18, opts?: {
        service?: string;
    });
    Upload(request: MediaUploadRequest, metadata?: Metadata): Promise<MediaUploadResponse>;
}

declare type MediaServiceDefinition = typeof MediaServiceDefinition;

declare const MediaServiceDefinition: {
    readonly name: "MediaService";
    readonly fullName: "devvit.plugin.media.MediaService";
    readonly methods: {
        readonly upload: {
            readonly name: "Upload";
            readonly requestType: {
                $type: "devvit.plugin.media.MediaUploadRequest";
                encode(message: MediaUploadRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): MediaUploadRequest;
                fromJSON(object: any): MediaUploadRequest;
                toJSON(message: MediaUploadRequest): unknown;
                create(base?: DeepPartial_68<MediaUploadRequest>): MediaUploadRequest;
                fromPartial(object: DeepPartial_68<MediaUploadRequest>): MediaUploadRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.media.MediaUploadResponse";
                encode(message: MediaUploadResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): MediaUploadResponse;
                fromJSON(object: any): MediaUploadResponse;
                toJSON(message: MediaUploadResponse): unknown;
                create(base?: DeepPartial_68<MediaUploadResponse>): MediaUploadResponse;
                fromPartial(object: DeepPartial_68<MediaUploadResponse>): MediaUploadResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const MediaServiceServiceName = "devvit.plugin.media.MediaService";

declare interface MediaUploadRequest {
    url: string;
    type: string;
}

declare const MediaUploadRequest: {
    $type: "devvit.plugin.media.MediaUploadRequest";
    encode(message: MediaUploadRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MediaUploadRequest;
    fromJSON(object: any): MediaUploadRequest;
    toJSON(message: MediaUploadRequest): unknown;
    create(base?: DeepPartial_68<MediaUploadRequest>): MediaUploadRequest;
    fromPartial(object: DeepPartial_68<MediaUploadRequest>): MediaUploadRequest;
};

declare interface MediaUploadResponse {
    mediaId: string;
    mediaUrl: string;
}

declare const MediaUploadResponse: {
    $type: "devvit.plugin.media.MediaUploadResponse";
    encode(message: MediaUploadResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MediaUploadResponse;
    fromJSON(object: any): MediaUploadResponse;
    toJSON(message: MediaUploadResponse): unknown;
    create(base?: DeepPartial_68<MediaUploadResponse>): MediaUploadResponse;
    fromPartial(object: DeepPartial_68<MediaUploadResponse>): MediaUploadResponse;
};

export declare type MenuItem = {
    /** The label of the menu item */
    label: string;
    /** An optional description for the menu item */
    description?: string;
    /** The location(s) where the menu item should be displayed */
    location: MenuItemLocation | MenuItemLocation[];
    /**
     * @experimental
     * The filter that applies to post menu items and has no effect on non-post actions
     * */
    postFilter?: MenuItemPostFilter;
    /** The user type(s) that the menu item should be displayed for */
    forUserType?: MenuItemUserType | MenuItemUserType[];
    /** A function that is called when the menu item is pressed */
    onPress: (event: MenuItemOnPressEvent, context: Devvit.Context) => void | Promise<void>;
};

export declare type MenuItemLocation = 'subreddit' | 'post' | 'comment';

export declare type MenuItemOnPressEvent = {
    /** The location where the menu item was pressed */
    location: MenuItemLocation;
    /**
     * The ID of subreddit, post, or comment that the menu item was pressed;
     * includes Thing ID prefix:
     * - t1_ - comment
     * - t5_ - subreddit
     * - t3_ - post
     */
    targetId: string;
};

/**
 * You can use the "currentApp" filter to only display the menu item on custom posts that were created by your app.
 */
export declare type MenuItemPostFilter = 'currentApp';

export declare type MenuItemUserType = 'loggedOut' | 'member' | 'moderator';

declare interface MenuWidgetItem {
    text?: string | undefined;
    url?: string | undefined;
    children: MenuWidgetItem[];
}

declare const MenuWidgetItem: {
    $type: "devvit.plugin.redditapi.widgets.MenuWidgetItem";
    encode(message: MenuWidgetItem, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MenuWidgetItem;
    fromJSON(object: any): MenuWidgetItem;
    toJSON(message: MenuWidgetItem): unknown;
    create(base?: DeepPartial_4<MenuWidgetItem>): MenuWidgetItem;
    fromPartial(object: DeepPartial_4<MenuWidgetItem>): MenuWidgetItem;
};

declare interface Message {
    topic: string;
    value: string;
}

declare const Message: {
    $type: "devvit.plugin.streambroker.Message";
    encode(message: Message, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Message;
    fromJSON(object: any): Message;
    toJSON(message: Message): unknown;
    create(base?: DeepPartial_91<Message>): Message;
    fromPartial(object: DeepPartial_91<Message>): Message;
};

export declare type MessageData = {
    /** Message ID */
    id?: string;
    /** Message body */
    body?: string;
    /** When was created */
    date?: string;
    author?: Participant;
    isInternal?: boolean;
    bodyMarkdown?: string;
    participatingAs?: string;
};

declare interface MessageData_2 {
    body?: string | undefined;
    author?: Participant_2 | undefined;
    isInternal?: boolean | undefined;
    date?: string | undefined;
    bodyMarkdown?: string | undefined;
    id?: string | undefined;
    participatingAs?: string | undefined;
}

declare const MessageData_2: {
    $type: "devvit.plugin.redditapi.newmodmail.MessageData";
    encode(message: MessageData_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MessageData_2;
    fromJSON(object: any): MessageData_2;
    toJSON(message: MessageData_2): unknown;
    create(base?: DeepPartial_71<MessageData_2>): MessageData_2;
    fromPartial(object: DeepPartial_71<MessageData_2>): MessageData_2;
};

declare interface MessageOptions {
    /**
     * Set true to use the old proto1 MessageSet wire format for extensions.
     * This is provided for backwards-compatibility with the MessageSet wire
     * format.  You should not use this for any other reason:  It's less
     * efficient, has fewer features, and is more complicated.
     *
     * The message must be defined exactly as follows:
     *   message Foo {
     *     option message_set_wire_format = true;
     *     extensions 4 to max;
     *   }
     * Note that the message cannot have any defined fields; MessageSets only
     * have extensions.
     *
     * All extensions of your type must be singular messages; e.g. they cannot
     * be int32s, enums, or repeated messages.
     *
     * Because this is an option, the above two restrictions are not enforced by
     * the protocol compiler.
     */
    messageSetWireFormat?: boolean | undefined;
    /**
     * Disables the generation of the standard "descriptor()" accessor, which can
     * conflict with a field of the same name.  This is meant to make migration
     * from proto1 easier; new code should avoid fields named "descriptor".
     */
    noStandardDescriptorAccessor?: boolean | undefined;
    /**
     * Is this message deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the message, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating messages.
     */
    deprecated?: boolean | undefined;
    /**
     * Whether the message is an automatically generated map entry type for the
     * maps field.
     *
     * For maps fields:
     *     map<KeyType, ValueType> map_field = 1;
     * The parsed descriptor looks like:
     *     message MapFieldEntry {
     *         option map_entry = true;
     *         optional KeyType key = 1;
     *         optional ValueType value = 2;
     *     }
     *     repeated MapFieldEntry map_field = 1;
     *
     * Implementations may choose not to generate the map_entry=true message, but
     * use a native map in the target language to hold the keys and values.
     * The reflection APIs in such implementations still need to work as
     * if the field is a repeated message field.
     *
     * NOTE: Do not set the option in .proto files. Always use the maps syntax
     * instead. The option should only be implicitly set by the proto compiler
     * parser.
     */
    mapEntry?: boolean | undefined;
    /**
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     *
     * This should only be used as a temporary measure against broken builds due
     * to the change in behavior for JSON field name conflicts.
     *
     * TODO This is legacy behavior we plan to remove once downstream
     * teams have had time to migrate.
     *
     * @deprecated
     */
    deprecatedLegacyJsonFieldConflicts?: boolean | undefined;
    /** Any features defined in the specific edition. */
    features?: FeatureSet | undefined;
    /** The parser stores options it doesn't recognize here. See above. */
    uninterpretedOption: UninterpretedOption[];
}

declare const MessageOptions: {
    $type: "google.protobuf.MessageOptions";
    encode(message: MessageOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MessageOptions;
    fromJSON(object: any): MessageOptions;
    toJSON(message: MessageOptions): unknown;
    create(base?: DeepPartial_104<MessageOptions>): MessageOptions;
    fromPartial(object: DeepPartial_104<MessageOptions>): MessageOptions;
};

declare interface MessageSet {
    messages: {
        [key: string]: string;
    };
}

declare const MessageSet: {
    $type: "devvit.plugin.kvstore.MessageSet";
    encode(message: MessageSet, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MessageSet;
    fromJSON(object: any): MessageSet;
    toJSON(message: MessageSet): unknown;
    create(base?: DeepPartial_61<MessageSet>): MessageSet;
    fromPartial(object: DeepPartial_61<MessageSet>): MessageSet;
};

declare interface MessageSet_MessagesEntry {
    key: string;
    value: string;
}

declare const MessageSet_MessagesEntry: {
    $type: "devvit.plugin.kvstore.MessageSet.MessagesEntry";
    encode(message: MessageSet_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MessageSet_MessagesEntry;
    fromJSON(object: any): MessageSet_MessagesEntry;
    toJSON(message: MessageSet_MessagesEntry): unknown;
    create(base?: DeepPartial_61<MessageSet_MessagesEntry>): MessageSet_MessagesEntry;
    fromPartial(object: DeepPartial_61<MessageSet_MessagesEntry>): MessageSet_MessagesEntry;
};

declare interface MessageType<Message extends UnknownMessage = UnknownMessage> {
    $type: string;
    encode(message: Message, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Message;
    fromJSON(object: any): Message;
    toJSON(message: Message): unknown;
    fromPartial(object: DeepPartial_13<Message>): Message;
}

declare const messageTypeRegistry: Map<string, MessageType<unknown>>;

declare interface MessageWhereRequest {
    /** one "inbox", "unread", or "sent" */
    where: string;
    /** true or false */
    mark?: boolean | undefined;
    /** message id */
    mid?: string | undefined;
    /** fullname of a thing */
    after?: string | undefined;
    /** fullname of a thing */
    before?: string | undefined;
    /** a positive integer (default: 0) */
    count?: number | undefined;
    /** the maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    /** (optional) the string all */
    show?: string | undefined;
}

declare const MessageWhereRequest: {
    $type: "devvit.plugin.redditapi.privatemessages.MessageWhereRequest";
    encode(message: MessageWhereRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MessageWhereRequest;
    fromJSON(object: any): MessageWhereRequest;
    toJSON(message: MessageWhereRequest): unknown;
    create(base?: DeepPartial_84<MessageWhereRequest>): MessageWhereRequest;
    fromPartial(object: DeepPartial_84<MessageWhereRequest>): MessageWhereRequest;
};

/** Optional RPC metadata passed with every request. */
declare type Metadata = {
    [key: string]: Strings;
};

declare type MethodDefinition = {
    /** The name of the method in PascalCase. Eg, "Log" or "LoadActor". */
    name: string;
    requestType: MessageType;
    requestStream: boolean;
    responseType: MessageType;
    responseStream: boolean;
};

/** Describes a method of a service. */
declare interface MethodDescriptorProto {
    name?: string | undefined;
    /**
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     */
    inputType?: string | undefined;
    outputType?: string | undefined;
    options?: MethodOptions | undefined;
    /** Identifies if client streams multiple client messages */
    clientStreaming?: boolean | undefined;
    /** Identifies if server streams multiple server messages */
    serverStreaming?: boolean | undefined;
}

declare const MethodDescriptorProto: {
    $type: "google.protobuf.MethodDescriptorProto";
    encode(message: MethodDescriptorProto, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MethodDescriptorProto;
    fromJSON(object: any): MethodDescriptorProto;
    toJSON(message: MethodDescriptorProto): unknown;
    create(base?: DeepPartial_104<MethodDescriptorProto>): MethodDescriptorProto;
    fromPartial(object: DeepPartial_104<MethodDescriptorProto>): MethodDescriptorProto;
};

declare interface MethodOptions {
    /**
     * Is this method deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the method, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating methods.
     */
    deprecated?: boolean | undefined;
    idempotencyLevel?: MethodOptions_IdempotencyLevel | undefined;
    /** Any features defined in the specific edition. */
    features?: FeatureSet | undefined;
    /** The parser stores options it doesn't recognize here. See above. */
    uninterpretedOption: UninterpretedOption[];
}

declare const MethodOptions: {
    $type: "google.protobuf.MethodOptions";
    encode(message: MethodOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MethodOptions;
    fromJSON(object: any): MethodOptions;
    toJSON(message: MethodOptions): unknown;
    create(base?: DeepPartial_104<MethodOptions>): MethodOptions;
    fromPartial(object: DeepPartial_104<MethodOptions>): MethodOptions;
};

/**
 * Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
 * or neither? HTTP based RPC implementation may choose GET verb for safe
 * methods, and PUT verb for idempotent methods instead of the default POST.
 */
declare enum MethodOptions_IdempotencyLevel {
    IDEMPOTENCY_UNKNOWN = 0,
    /** NO_SIDE_EFFECTS - implies idempotent */
    NO_SIDE_EFFECTS = 1,
    /** IDEMPOTENT - idempotent, but may have side effects */
    IDEMPOTENT = 2,
    UNRECOGNIZED = -1
}

declare function methodOptions_IdempotencyLevelFromJSON(object: any): MethodOptions_IdempotencyLevel;

declare function methodOptions_IdempotencyLevelToJSON(object: MethodOptions_IdempotencyLevel): number;

declare enum Minify {
    /** NONE - Disable minification. The default. */
    NONE = 0,
    /** ALL - Minify everything. */
    ALL = 1,
    UNRECOGNIZED = -1
}

declare function minifyFromJSON(object: any): Minify;

declare function minifyToJSON(object: Minify): number;

export declare interface ModAction {
    id: string;
    type: ModActionType;
    moderatorName: string;
    moderatorId: string;
    createdAt: Date;
    subredditName: string;
    subredditId: string;
    description?: string;
    details?: string;
    target?: ModActionTarget;
}

declare interface ModAction_2 {
    /**
     * Replaces the action_type enum. The same string used internally (e.g. "removelink")
     * Marking as optional only for typescript compatibility (public-api).
     */
    action?: string | undefined;
    actionedAt?: Date | undefined;
    subreddit?: SubredditV2 | undefined;
    moderator?: UserV2 | undefined;
    targetUser?: UserV2 | undefined;
    targetComment?: CommentV2 | undefined;
    targetPost?: PostV2 | undefined;
}

declare const ModAction_2: {
    $type: "devvit.reddit.v2alpha.ModAction";
    encode(message: ModAction_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModAction_2;
    fromJSON(object: any): ModAction_2;
    toJSON(message: ModAction_2): unknown;
    create(base?: DeepPartial_79<ModAction_2>): ModAction_2;
    fromPartial(object: DeepPartial_79<ModAction_2>): ModAction_2;
};

export declare type ModActionData = {
    /** Action id */
    id?: string;
    /** Type of the action */
    actionType: ModMailActionType;
    /** When the action happened */
    date?: string;
    /** Action author */
    author?: {
        /** User id  */
        id?: number;
        /** User name */
        name?: string;
        isMod?: boolean;
        isAdmin?: boolean;
        isHidden?: boolean;
        isDeleted?: boolean;
    };
};

declare interface ModActionData_2 {
    date?: string | undefined;
    actionTypeId?: number | undefined;
    id?: string | undefined;
    author?: ModActionData_ModActionAuthor | undefined;
}

declare const ModActionData_2: {
    $type: "devvit.plugin.redditapi.newmodmail.ModActionData";
    encode(message: ModActionData_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModActionData_2;
    fromJSON(object: any): ModActionData_2;
    toJSON(message: ModActionData_2): unknown;
    create(base?: DeepPartial_71<ModActionData_2>): ModActionData_2;
    fromPartial(object: DeepPartial_71<ModActionData_2>): ModActionData_2;
};

declare interface ModActionData_ModActionAuthor {
    isMod?: boolean | undefined;
    isAdmin?: boolean | undefined;
    name?: string | undefined;
    isHidden?: boolean | undefined;
    id?: number | undefined;
    isDeleted?: boolean | undefined;
}

declare const ModActionData_ModActionAuthor: {
    $type: "devvit.plugin.redditapi.newmodmail.ModActionData.ModActionAuthor";
    encode(message: ModActionData_ModActionAuthor, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModActionData_ModActionAuthor;
    fromJSON(object: any): ModActionData_ModActionAuthor;
    toJSON(message: ModActionData_ModActionAuthor): unknown;
    create(base?: DeepPartial_71<ModActionData_ModActionAuthor>): ModActionData_ModActionAuthor;
    fromPartial(object: DeepPartial_71<ModActionData_ModActionAuthor>): ModActionData_ModActionAuthor;
};

export declare type ModActionDefinition = {
    event: ModActionTrigger;
    onEvent: TriggerOnEventHandler<protos.ModAction>;
};

export declare type ModActionTarget = {
    id: string;
    author?: string;
    body?: string;
    permalink?: string;
    title?: string;
};

/** The event name for when a moderator action is recorded to a subreddit's modlog */
export declare type ModActionTrigger = 'ModAction';

export declare type ModActionType = 'banuser' | 'unbanuser' | 'spamlink' | 'removelink' | 'approvelink' | 'spamcomment' | 'removecomment' | 'approvecomment' | 'addmoderator' | 'showcomment' | 'invitemoderator' | 'uninvitemoderator' | 'acceptmoderatorinvite' | 'removemoderator' | 'addcontributor' | 'removecontributor' | 'editsettings' | 'editflair' | 'distinguish' | 'marknsfw' | 'wikibanned' | 'wikicontributor' | 'wikiunbanned' | 'wikipagelisted' | 'removewikicontributor' | 'wikirevise' | 'wikipermlevel' | 'ignorereports' | 'unignorereports' | 'setpermissions' | 'setsuggestedsort' | 'sticky' | 'unsticky' | 'setcontestmode' | 'unsetcontestmode' | 'lock' | 'unlock' | 'muteuser' | 'unmuteuser' | 'createrule' | 'editrule' | 'reorderrules' | 'deleterule' | 'spoiler' | 'unspoiler' | 'modmail_enrollment' | 'community_styling' | 'community_widgets' | 'markoriginalcontent' | 'collections' | 'events' | 'create_award' | 'disable_award' | 'delete_award' | 'enable_award' | 'mod_award_given' | 'hidden_award' | 'add_community_topics' | 'remove_community_topics' | 'create_scheduled_post' | 'edit_scheduled_post' | 'delete_scheduled_post' | 'submit_scheduled_post' | 'edit_post_requirements' | 'invitesubscriber' | 'submit_content_rating_survey' | 'adjust_post_crowd_control_level' | 'enable_post_crowd_control_filter' | 'disable_post_crowd_control_filter' | 'deleteoverriddenclassification' | 'overrideclassification' | 'reordermoderators' | 'snoozereports' | 'unsnoozereports' | 'addnote' | 'deletenote' | 'addremovalreason' | 'createremovalreason' | 'updateremovalreason' | 'deleteremovalreason' | 'reorderremovalreason' | 'dev_platform_app_changed' | 'dev_platform_app_disabled' | 'dev_platform_app_enabled' | 'dev_platform_app_installed' | 'dev_platform_app_uninstalled';

declare enum ModActionType_2 {
    UNKNOWN = 0,
    REMOVE_POST = 1,
    REMOVE_COMMENT = 2,
    APPROVE_POST = 3,
    APPROVE_COMMENT = 4,
    EDIT_POST_FLAIR = 5,
    EDIT_USER_FLAIR = 6,
    LOCK_POST = 7,
    LOCK_COMMENT = 8,
    SPAM_POST = 9,
    SPAM_COMMENT = 10,
    DISTINGUISH_POST = 11,
    DISTINGUISH_COMMENT = 12,
    STICKY_POST = 13,
    STICKY_COMMENT = 14,
    UNRECOGNIZED = -1
}

declare function modActionTypeFromJSON(object: any): ModActionType_2;

declare function modActionTypeToJSON(object: ModActionType_2): number;

/** MODERATION -  https://www.reddit.com/dev/api#section_moderation */
declare interface Moderation {
    /** https://www.reddit.com/dev/api#GET_about_log */
    AboutLog(request: AboutLogRequest, metadata?: Metadata): Promise<AboutLogResponse>;
    /** https://www.reddit.com/dev/api#GET_about_\{location\} */
    AboutLocation(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    /** https://www.reddit.com/dev/api#GET_about_\reports */
    AboutReports(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    /** https://www.reddit.com/dev/api#GET_about_\spam */
    AboutSpam(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    /** https://www.reddit.com/dev/api#GET_about_\modqueue */
    AboutModqueue(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    /** https://www.reddit.com/dev/api#GET_about_\unmoderated */
    AboutUnmoderated(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    /** https://www.reddit.com/dev/api#GET_about_\edited */
    AboutEdited(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    /** https://www.reddit.com/dev/api#POST_api_accept_moderator_invite */
    AcceptModeratorInvite(request: AcceptModeratorInviteRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_approve */
    Approve(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_distinguish */
    Distinguish(request: DistinguishRequest, metadata?: Metadata): Promise<JsonRedditObjects>;
    /** https://www.reddit.com/dev/api#POST_api_ignore_reports */
    IgnoreReports(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_leavecontributor */
    LeaveContributor(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_leavemoderator */
    LeaveModerator(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_mute_message_author */
    MuteMessageAuthor(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_remove */
    Remove(request: RemoveRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_show_comment */
    ShowComment(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_snooze_reports */
    SnoozeReports(request: SnoozeReportsRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_unignore_reports */
    UnignoreReports(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_unmute_message_author */
    UnmuteMessageAuthor(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_unsnooze_reports */
    UnsnoozeReports(request: SnoozeReportsRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_update_crowd_control_level */
    UpdateCrowdControlLevel(request: UpdateCrowdControlLevelRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#GET_stylesheet */
    Stylesheet(request: StylesheetRequest, metadata?: Metadata): Promise<StringValue>;
}

declare class ModerationClientImpl implements Moderation {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_56, opts?: {
        service?: string;
    });
    AboutLog(request: AboutLogRequest, metadata?: Metadata): Promise<AboutLogResponse>;
    AboutLocation(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    AboutReports(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    AboutSpam(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    AboutModqueue(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    AboutUnmoderated(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    AboutEdited(request: AboutLocationRequest, metadata?: Metadata): Promise<Listing_2>;
    AcceptModeratorInvite(request: AcceptModeratorInviteRequest, metadata?: Metadata): Promise<JsonStatus>;
    Approve(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    Distinguish(request: DistinguishRequest, metadata?: Metadata): Promise<JsonRedditObjects>;
    IgnoreReports(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    LeaveContributor(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    LeaveModerator(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    MuteMessageAuthor(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    Remove(request: RemoveRequest, metadata?: Metadata): Promise<Empty>;
    ShowComment(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    SnoozeReports(request: SnoozeReportsRequest, metadata?: Metadata): Promise<Empty>;
    UnignoreReports(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    UnmuteMessageAuthor(request: BasicModerationIdRequest, metadata?: Metadata): Promise<Empty>;
    UnsnoozeReports(request: SnoozeReportsRequest, metadata?: Metadata): Promise<Empty>;
    UpdateCrowdControlLevel(request: UpdateCrowdControlLevelRequest, metadata?: Metadata): Promise<Empty>;
    Stylesheet(request: StylesheetRequest, metadata?: Metadata): Promise<StringValue>;
}

/** MODERATION -  https://www.reddit.com/dev/api#section_moderation */
declare type ModerationDefinition = typeof ModerationDefinition;

declare const ModerationDefinition: {
    readonly name: "Moderation";
    readonly fullName: "devvit.plugin.redditapi.moderation.Moderation";
    readonly methods: {
        /** https://www.reddit.com/dev/api#GET_about_log */
        readonly aboutLog: {
            readonly name: "AboutLog";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.AboutLogRequest";
                encode(message: AboutLogRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AboutLogRequest;
                fromJSON(object: any): AboutLogRequest;
                toJSON(message: AboutLogRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    mod?: string | undefined;
                    type?: string | undefined;
                    subreddit?: string | undefined;
                } | undefined): AboutLogRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    mod?: string | undefined;
                    type?: string | undefined;
                    subreddit?: string | undefined;
                }): AboutLogRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.moderation.AboutLogResponse";
                encode(message: AboutLogResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AboutLogResponse;
                fromJSON(object: any): AboutLogResponse;
                toJSON(message: AboutLogResponse): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                description?: string | undefined;
                                targetBody?: string | undefined;
                                modId36?: string | undefined;
                                createdUtc?: number | undefined;
                                subreddit?: string | undefined;
                                targetTitle?: string | undefined;
                                targetPermalink?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                details?: string | undefined;
                                action?: string | undefined;
                                targetAuthor?: string | undefined;
                                targetFullname?: string | undefined;
                                srId36?: string | undefined;
                                id?: string | undefined;
                                mod?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): AboutLogResponse;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                description?: string | undefined;
                                targetBody?: string | undefined;
                                modId36?: string | undefined;
                                createdUtc?: number | undefined;
                                subreddit?: string | undefined;
                                targetTitle?: string | undefined;
                                targetPermalink?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                details?: string | undefined;
                                action?: string | undefined;
                                targetAuthor?: string | undefined;
                                targetFullname?: string | undefined;
                                srId36?: string | undefined;
                                id?: string | undefined;
                                mod?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): AboutLogResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_about_\{location\} */
        readonly aboutLocation: {
            readonly name: "AboutLocation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest";
                encode(message: AboutLocationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AboutLocationRequest;
                fromJSON(object: any): AboutLocationRequest;
                toJSON(message: AboutLocationRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                } | undefined): AboutLocationRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                }): AboutLocationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_about_\reports */
        readonly aboutReports: {
            readonly name: "AboutReports";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest";
                encode(message: AboutLocationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AboutLocationRequest;
                fromJSON(object: any): AboutLocationRequest;
                toJSON(message: AboutLocationRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                } | undefined): AboutLocationRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                }): AboutLocationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_about_\spam */
        readonly aboutSpam: {
            readonly name: "AboutSpam";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest";
                encode(message: AboutLocationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AboutLocationRequest;
                fromJSON(object: any): AboutLocationRequest;
                toJSON(message: AboutLocationRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                } | undefined): AboutLocationRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                }): AboutLocationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_about_\modqueue */
        readonly aboutModqueue: {
            readonly name: "AboutModqueue";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest";
                encode(message: AboutLocationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AboutLocationRequest;
                fromJSON(object: any): AboutLocationRequest;
                toJSON(message: AboutLocationRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                } | undefined): AboutLocationRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                }): AboutLocationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_about_\unmoderated */
        readonly aboutUnmoderated: {
            readonly name: "AboutUnmoderated";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest";
                encode(message: AboutLocationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AboutLocationRequest;
                fromJSON(object: any): AboutLocationRequest;
                toJSON(message: AboutLocationRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                } | undefined): AboutLocationRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                }): AboutLocationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_about_\edited */
        readonly aboutEdited: {
            readonly name: "AboutEdited";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest";
                encode(message: AboutLocationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AboutLocationRequest;
                fromJSON(object: any): AboutLocationRequest;
                toJSON(message: AboutLocationRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                } | undefined): AboutLocationRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    location?: string;
                    only?: string | undefined;
                    show?: string | undefined;
                    subreddit?: string;
                }): AboutLocationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_accept_moderator_invite */
        readonly acceptModeratorInvite: {
            readonly name: "AcceptModeratorInvite";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.AcceptModeratorInviteRequest";
                encode(message: AcceptModeratorInviteRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AcceptModeratorInviteRequest;
                fromJSON(object: any): AcceptModeratorInviteRequest;
                toJSON(message: AcceptModeratorInviteRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): AcceptModeratorInviteRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): AcceptModeratorInviteRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_approve */
        readonly approve: {
            readonly name: "Approve";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest";
                encode(message: BasicModerationIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicModerationIdRequest;
                fromJSON(object: any): BasicModerationIdRequest;
                toJSON(message: BasicModerationIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicModerationIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicModerationIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_distinguish */
        readonly distinguish: {
            readonly name: "Distinguish";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.DistinguishRequest";
                encode(message: DistinguishRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DistinguishRequest;
                fromJSON(object: any): DistinguishRequest;
                toJSON(message: DistinguishRequest): unknown;
                create(base?: {
                    how?: string;
                    id?: string;
                    sticky?: boolean;
                } | undefined): DistinguishRequest;
                fromPartial(object: {
                    how?: string;
                    id?: string;
                    sticky?: boolean;
                }): DistinguishRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonRedditObjects";
                encode(message: JsonRedditObjects, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonRedditObjects;
                fromJSON(object: any): JsonRedditObjects;
                toJSON(message: JsonRedditObjects): unknown;
                create(base?: {
                    json?: {
                        errors?: {
                            typeUrl?: string;
                            value?: Uint8Array;
                        }[];
                        data?: {
                            things?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: any[] | undefined;
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    depth?: number | undefined;
                                    linkTitle?: string | undefined;
                                    linkAuthor?: string | undefined;
                                    numComments?: number | undefined;
                                    over18?: boolean | undefined;
                                    linkPermalink?: string | undefined;
                                    quarantine?: boolean | undefined;
                                    linkUrl?: string | undefined;
                                    selftext?: string | undefined;
                                    selftextHtml?: string | undefined;
                                    thumbnail?: string | undefined;
                                    thumbnailWidth?: number | undefined;
                                    thumbnailHeight?: number | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    displayName?: string | undefined;
                                    modPermissions?: string[];
                                    count?: number | undefined;
                                    children?: any[] | undefined;
                                    replyList?: {
                                        kind?: string;
                                        data?: {
                                            after?: string | undefined;
                                            before?: string | undefined;
                                            children?: any[];
                                            dist?: number | undefined;
                                        } | undefined;
                                    } | undefined;
                                    hidden?: boolean | undefined;
                                    linkFlairBackgroundColor?: string | undefined;
                                    linkFlairCssClass?: string | undefined;
                                    linkFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    linkFlairTemplateId?: string | undefined;
                                    linkFlairText?: string | undefined;
                                    linkFlairTextColor?: string | undefined;
                                    linkFlairType?: string | undefined;
                                    secureMedia?: {
                                        type?: string;
                                        oembed?: {
                                            type?: string;
                                            title?: string | undefined;
                                            providerName?: string | undefined;
                                            providerUrl?: string | undefined;
                                            version?: string;
                                            thumbnailWidth?: number | undefined;
                                            thumbnailHeight?: number | undefined;
                                            thumbnailUrl?: string | undefined;
                                            html?: string;
                                            height?: number | undefined;
                                            width?: number | undefined;
                                            authorUrl?: string | undefined;
                                            authorName?: string | undefined;
                                        } | undefined;
                                        redditVideo?: {
                                            bitrateKbps?: number | undefined;
                                            dashUrl?: string | undefined;
                                            duration?: number | undefined;
                                            fallbackUrl?: string | undefined;
                                            height?: number | undefined;
                                            hlsUrl?: string | undefined;
                                            isGif?: boolean | undefined;
                                            scrubberMediaUrl?: string | undefined;
                                            transcodingStatus?: string | undefined;
                                            width?: number | undefined;
                                        } | undefined;
                                    } | undefined;
                                    spoiler?: boolean;
                                    modReports?: any[][];
                                    userReports?: any[][];
                                    removedBy?: string | undefined;
                                    removedByCategory?: string | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    } | undefined;
                } | undefined): JsonRedditObjects;
                fromPartial(object: {
                    json?: {
                        errors?: {
                            typeUrl?: string;
                            value?: Uint8Array;
                        }[];
                        data?: {
                            things?: {
                                kind?: string;
                                data?: {
                                    allAwardings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    approved?: boolean | undefined;
                                    approvedAtUtc?: number | undefined;
                                    approvedBy?: string | undefined;
                                    archived?: boolean | undefined;
                                    associatedAward?: string | undefined;
                                    author?: string | undefined;
                                    authorFlairBackgroundColor?: string | undefined;
                                    authorFlairCssClass?: string | undefined;
                                    authorFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    authorFlairTemplateId?: string | undefined;
                                    authorFlairText?: string | undefined;
                                    authorFlairTextColor?: string | undefined;
                                    authorFlairType?: string | undefined;
                                    authorFullname?: string | undefined;
                                    authorIsBlocked?: boolean | undefined;
                                    authorPatreonFlair?: boolean | undefined;
                                    authorPremium?: boolean | undefined;
                                    awarders?: string[];
                                    bannedAtUtc?: number | undefined;
                                    bannedBy?: string | undefined;
                                    body?: string | undefined;
                                    bodyHtml?: string | undefined;
                                    canGild?: boolean | undefined;
                                    canModPost?: boolean | undefined;
                                    collapsed?: boolean | undefined;
                                    collapsedBecauseCrowdControl?: boolean | undefined;
                                    collapsedReason?: string | undefined;
                                    collapsedReasonCode?: string | undefined;
                                    commentType?: string | undefined;
                                    controversiality?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    distinguished?: string | undefined;
                                    downs?: number | undefined;
                                    edited?: boolean | undefined;
                                    gilded?: number | undefined;
                                    gildings?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    } | undefined;
                                    id?: string | undefined;
                                    ignoreReports?: boolean | undefined;
                                    isSubmitter?: boolean | undefined;
                                    likes?: boolean | undefined;
                                    linkId?: string | undefined;
                                    locked?: boolean | undefined;
                                    modNote?: string | undefined;
                                    modReasonBy?: string | undefined;
                                    modReasonTitle?: string | undefined;
                                    name?: string | undefined;
                                    noFollow?: boolean | undefined;
                                    numReports?: number | undefined;
                                    parentId?: string | undefined;
                                    permalink?: string | undefined;
                                    removalReason?: string | undefined;
                                    removed?: boolean | undefined;
                                    replies?: string | undefined;
                                    reportReasons?: any[] | undefined;
                                    rteMode?: string | undefined;
                                    saved?: boolean | undefined;
                                    score?: number | undefined;
                                    scoreHidden?: boolean | undefined;
                                    sendReplies?: boolean | undefined;
                                    spam?: boolean | undefined;
                                    stickied?: boolean | undefined;
                                    subreddit?: string | undefined;
                                    subredditId?: string | undefined;
                                    subredditNamePrefixed?: string | undefined;
                                    subredditType?: string | undefined;
                                    topAwardedType?: string | undefined;
                                    totalAwardsReceived?: number | undefined;
                                    treatmentTags?: {
                                        typeUrl?: string;
                                        value?: Uint8Array;
                                    }[];
                                    unrepliableReason?: string | undefined;
                                    ups?: number | undefined;
                                    depth?: number | undefined;
                                    linkTitle?: string | undefined;
                                    linkAuthor?: string | undefined;
                                    numComments?: number | undefined;
                                    over18?: boolean | undefined;
                                    linkPermalink?: string | undefined;
                                    quarantine?: boolean | undefined;
                                    linkUrl?: string | undefined;
                                    selftext?: string | undefined;
                                    selftextHtml?: string | undefined;
                                    thumbnail?: string | undefined;
                                    thumbnailWidth?: number | undefined;
                                    thumbnailHeight?: number | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    displayName?: string | undefined;
                                    modPermissions?: string[];
                                    count?: number | undefined;
                                    children?: any[] | undefined;
                                    replyList?: {
                                        kind?: string;
                                        data?: {
                                            after?: string | undefined;
                                            before?: string | undefined;
                                            children?: any[];
                                            dist?: number | undefined;
                                        } | undefined;
                                    } | undefined;
                                    hidden?: boolean | undefined;
                                    linkFlairBackgroundColor?: string | undefined;
                                    linkFlairCssClass?: string | undefined;
                                    linkFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                        a?: string | undefined;
                                        u?: string | undefined;
                                    }[];
                                    linkFlairTemplateId?: string | undefined;
                                    linkFlairText?: string | undefined;
                                    linkFlairTextColor?: string | undefined;
                                    linkFlairType?: string | undefined;
                                    secureMedia?: {
                                        type?: string;
                                        oembed?: {
                                            type?: string;
                                            title?: string | undefined;
                                            providerName?: string | undefined;
                                            providerUrl?: string | undefined;
                                            version?: string;
                                            thumbnailWidth?: number | undefined;
                                            thumbnailHeight?: number | undefined;
                                            thumbnailUrl?: string | undefined;
                                            html?: string;
                                            height?: number | undefined;
                                            width?: number | undefined;
                                            authorUrl?: string | undefined;
                                            authorName?: string | undefined;
                                        } | undefined;
                                        redditVideo?: {
                                            bitrateKbps?: number | undefined;
                                            dashUrl?: string | undefined;
                                            duration?: number | undefined;
                                            fallbackUrl?: string | undefined;
                                            height?: number | undefined;
                                            hlsUrl?: string | undefined;
                                            isGif?: boolean | undefined;
                                            scrubberMediaUrl?: string | undefined;
                                            transcodingStatus?: string | undefined;
                                            width?: number | undefined;
                                        } | undefined;
                                    } | undefined;
                                    spoiler?: boolean;
                                    modReports?: any[][];
                                    userReports?: any[][];
                                    removedBy?: string | undefined;
                                    removedByCategory?: string | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    } | undefined;
                }): JsonRedditObjects;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_ignore_reports */
        readonly ignoreReports: {
            readonly name: "IgnoreReports";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest";
                encode(message: BasicModerationIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicModerationIdRequest;
                fromJSON(object: any): BasicModerationIdRequest;
                toJSON(message: BasicModerationIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicModerationIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicModerationIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_leavecontributor */
        readonly leaveContributor: {
            readonly name: "LeaveContributor";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest";
                encode(message: BasicModerationIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicModerationIdRequest;
                fromJSON(object: any): BasicModerationIdRequest;
                toJSON(message: BasicModerationIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicModerationIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicModerationIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_leavemoderator */
        readonly leaveModerator: {
            readonly name: "LeaveModerator";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest";
                encode(message: BasicModerationIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicModerationIdRequest;
                fromJSON(object: any): BasicModerationIdRequest;
                toJSON(message: BasicModerationIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicModerationIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicModerationIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mute_message_author */
        readonly muteMessageAuthor: {
            readonly name: "MuteMessageAuthor";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest";
                encode(message: BasicModerationIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicModerationIdRequest;
                fromJSON(object: any): BasicModerationIdRequest;
                toJSON(message: BasicModerationIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicModerationIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicModerationIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_remove */
        readonly remove: {
            readonly name: "Remove";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.RemoveRequest";
                encode(message: RemoveRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): RemoveRequest;
                fromJSON(object: any): RemoveRequest;
                toJSON(message: RemoveRequest): unknown;
                create(base?: {
                    id?: string;
                    spam?: boolean;
                } | undefined): RemoveRequest;
                fromPartial(object: {
                    id?: string;
                    spam?: boolean;
                }): RemoveRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_show_comment */
        readonly showComment: {
            readonly name: "ShowComment";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest";
                encode(message: BasicModerationIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicModerationIdRequest;
                fromJSON(object: any): BasicModerationIdRequest;
                toJSON(message: BasicModerationIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicModerationIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicModerationIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_snooze_reports */
        readonly snoozeReports: {
            readonly name: "SnoozeReports";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.SnoozeReportsRequest";
                encode(message: SnoozeReportsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SnoozeReportsRequest;
                fromJSON(object: any): SnoozeReportsRequest;
                toJSON(message: SnoozeReportsRequest): unknown;
                create(base?: {
                    id?: string;
                    reason?: string;
                } | undefined): SnoozeReportsRequest;
                fromPartial(object: {
                    id?: string;
                    reason?: string;
                }): SnoozeReportsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_unignore_reports */
        readonly unignoreReports: {
            readonly name: "UnignoreReports";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest";
                encode(message: BasicModerationIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicModerationIdRequest;
                fromJSON(object: any): BasicModerationIdRequest;
                toJSON(message: BasicModerationIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicModerationIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicModerationIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_unmute_message_author */
        readonly unmuteMessageAuthor: {
            readonly name: "UnmuteMessageAuthor";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest";
                encode(message: BasicModerationIdRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicModerationIdRequest;
                fromJSON(object: any): BasicModerationIdRequest;
                toJSON(message: BasicModerationIdRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): BasicModerationIdRequest;
                fromPartial(object: {
                    id?: string;
                }): BasicModerationIdRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_unsnooze_reports */
        readonly unsnoozeReports: {
            readonly name: "UnsnoozeReports";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.SnoozeReportsRequest";
                encode(message: SnoozeReportsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SnoozeReportsRequest;
                fromJSON(object: any): SnoozeReportsRequest;
                toJSON(message: SnoozeReportsRequest): unknown;
                create(base?: {
                    id?: string;
                    reason?: string;
                } | undefined): SnoozeReportsRequest;
                fromPartial(object: {
                    id?: string;
                    reason?: string;
                }): SnoozeReportsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_update_crowd_control_level */
        readonly updateCrowdControlLevel: {
            readonly name: "UpdateCrowdControlLevel";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.UpdateCrowdControlLevelRequest";
                encode(message: UpdateCrowdControlLevelRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateCrowdControlLevelRequest;
                fromJSON(object: any): UpdateCrowdControlLevelRequest;
                toJSON(message: UpdateCrowdControlLevelRequest): unknown;
                create(base?: {
                    id?: string;
                    level?: number;
                } | undefined): UpdateCrowdControlLevelRequest;
                fromPartial(object: {
                    id?: string;
                    level?: number;
                }): UpdateCrowdControlLevelRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_stylesheet */
        readonly stylesheet: {
            readonly name: "Stylesheet";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.moderation.StylesheetRequest";
                encode(message: StylesheetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StylesheetRequest;
                fromJSON(object: any): StylesheetRequest;
                toJSON(message: StylesheetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): StylesheetRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): StylesheetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.StringValue";
                encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StringValue;
                fromJSON(object: any): StringValue;
                toJSON(message: StringValue): unknown;
                create(base?: {
                    value?: string;
                } | undefined): StringValue;
                fromPartial(object: {
                    value?: string;
                }): StringValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const ModerationServiceName = "devvit.plugin.redditapi.moderation.Moderation";

export declare type ModeratorPermission = 'all' | 'wiki' | 'posts' | 'access' | 'mail' | 'config' | 'flair' | 'chat_operator' | 'chat_config' | 'channels' | 'chat_community';

declare interface ModInviteUtils {
    AcceptInvite(request: AcceptInviteRequest, metadata?: Metadata): Promise<AcceptInviteResponse>;
}

declare class ModInviteUtilsClientImpl implements ModInviteUtils {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_61, opts?: {
        service?: string;
    });
    AcceptInvite(request: AcceptInviteRequest, metadata?: Metadata): Promise<AcceptInviteResponse>;
}

declare type ModInviteUtilsDefinition = typeof ModInviteUtilsDefinition;

declare const ModInviteUtilsDefinition: {
    readonly name: "ModInviteUtils";
    readonly fullName: "devvit.gateway.utils.v1alpha.ModInviteUtils";
    readonly methods: {
        readonly acceptInvite: {
            readonly name: "AcceptInvite";
            readonly requestType: {
                $type: "devvit.gateway.utils.v1alpha.AcceptInviteRequest";
                encode(message: AcceptInviteRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): AcceptInviteRequest;
                fromJSON(object: any): AcceptInviteRequest;
                toJSON(message: AcceptInviteRequest): unknown;
                create(base?: DeepPartial_26<AcceptInviteRequest>): AcceptInviteRequest;
                fromPartial(object: DeepPartial_26<AcceptInviteRequest>): AcceptInviteRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gateway.utils.v1alpha.AcceptInviteResponse";
                encode(_: AcceptInviteResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): AcceptInviteResponse;
                fromJSON(_: any): AcceptInviteResponse;
                toJSON(_: AcceptInviteResponse): unknown;
                create(base?: DeepPartial_26<AcceptInviteResponse>): AcceptInviteResponse;
                fromPartial(_: DeepPartial_26<AcceptInviteResponse>): AcceptInviteResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const ModInviteUtilsServiceName = "devvit.gateway.utils.v1alpha.ModInviteUtils";

/**
 * You must have the `modLog` enabled in `Devvit.configure` to use this client.
 *
 * @example
 * ```ts
 * Devvit.configure({
 *   modLog: true
 * });
 * ```
 */
declare type ModLog = {
    /**
     * Adds a record to the Mod log of the current subreddit
     *
     * @example
     * ```ts
     *
     * await context.modLog.add({
     *   action: 'approvecomment',
     *   target: commentId,
     *   note: "Banned for breaking the rules"
     * });
     * ```
     */
    add(options: Readonly<ModLogAddOptions>): Promise<void>;
};

/**
 * The Modlog plugin allows an app to insert an arbitrary entry
 * to a subreddit's modlog.
 */
declare interface Modlog {
    Add(request: ModlogRequest, metadata?: Metadata): Promise<ModlogResponse>;
}

declare type ModLogAddOptions = {
    action: ModActionType;
    details?: string | undefined;
    description?: string | undefined;
    note?: string | undefined;
    target?: string | undefined;
};

declare class ModLogClient implements ModLog {
    #private;
    constructor(metadata: Metadata);
    add(options: Readonly<ModLogAddOptions>): Promise<void>;
}

declare class ModlogClientImpl implements Modlog {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_17, opts?: {
        service?: string;
    });
    Add(request: ModlogRequest, metadata?: Metadata): Promise<ModlogResponse>;
}

/**
 * The Modlog plugin allows an app to insert an arbitrary entry
 * to a subreddit's modlog.
 */
declare type ModlogDefinition = typeof ModlogDefinition;

declare const ModlogDefinition: {
    readonly name: "Modlog";
    readonly fullName: "devvit.plugin.modlog.Modlog";
    readonly methods: {
        readonly add: {
            readonly name: "Add";
            readonly requestType: {
                $type: "devvit.plugin.modlog.ModlogRequest";
                encode(message: ModlogRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ModlogRequest;
                fromJSON(object: any): ModlogRequest;
                toJSON(message: ModlogRequest): unknown;
                create(base?: DeepPartial_70<ModlogRequest>): ModlogRequest;
                fromPartial(object: DeepPartial_70<ModlogRequest>): ModlogRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.modlog.ModlogResponse";
                encode(message: ModlogResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ModlogResponse;
                fromJSON(object: any): ModlogResponse;
                toJSON(message: ModlogResponse): unknown;
                create(base?: DeepPartial_70<ModlogResponse>): ModlogResponse;
                fromPartial(object: DeepPartial_70<ModlogResponse>): ModlogResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

export declare type ModLogOptions<T extends AboutSubredditTypes> = Omit<AboutSubredditHelperOptions<T>, 'location'>;

declare interface ModlogRequest {
    /** The action (available actions here: https://github.snooguts.net/reddit/reddit-public/blob/master/r2/r2/models/modaction.py#L192) */
    action: string;
    /** Optional Details string */
    details?: string | undefined;
    /** Optional Description */
    description?: string | undefined;
    /** Optional Note */
    note?: string | undefined;
    /** Optional action target */
    target?: string | undefined;
}

declare const ModlogRequest: {
    $type: "devvit.plugin.modlog.ModlogRequest";
    encode(message: ModlogRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModlogRequest;
    fromJSON(object: any): ModlogRequest;
    toJSON(message: ModlogRequest): unknown;
    create(base?: DeepPartial_70<ModlogRequest>): ModlogRequest;
    fromPartial(object: DeepPartial_70<ModlogRequest>): ModlogRequest;
};

/** Generic response interface (mimics response from r2) */
declare interface ModlogResponse {
    success: boolean;
}

declare const ModlogResponse: {
    $type: "devvit.plugin.modlog.ModlogResponse";
    encode(message: ModlogResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModlogResponse;
    fromJSON(object: any): ModlogResponse;
    toJSON(message: ModlogResponse): unknown;
    create(base?: DeepPartial_70<ModlogResponse>): ModlogResponse;
    fromPartial(object: DeepPartial_70<ModlogResponse>): ModlogResponse;
};

declare const ModlogServiceName = "devvit.plugin.modlog.Modlog";

declare interface ModMail {
    /** author of the message */
    messageAuthor?: UserV2 | undefined;
    /** message creation timestamp */
    createdAt?: Date | undefined;
    /**
     * what type of user is the message author participating as:
     * moderator - as a mod of the owning subreddit
     * participant_user - as a non-mod user
     * participant_sr - as a mod of the participant subreddit (see conversation_type field)
     */
    messageAuthorType: string;
    /** state of the conversation: new, in-progress, archived */
    conversationState: string;
    /** type of conversation: internal (mod discussion), sr_user (between a subreddit and user), sr_sr (between two subreddits) */
    conversationType: string;
    /** is the conversation auto generated? (from automod, u/reddit etc) */
    isAutoGenerated: boolean;
    /** subreddit owning the modmail conversation */
    conversationSubreddit?: SubredditV2 | undefined;
    /** the subreddit that the modmail is sent to or nil */
    destinationSubreddit?: SubredditV2 | undefined;
    /** Conversation ID (base36 encoded string, does not have a thing-type prefix) */
    conversationId: string;
    /** Message ID (base36 encoded string, does not have a thing-type prefix) */
    messageId: string;
}

declare const ModMail: {
    $type: "devvit.reddit.v2alpha.ModMail";
    encode(message: ModMail, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModMail;
    fromJSON(object: any): ModMail;
    toJSON(message: ModMail): unknown;
    create(base?: DeepPartial_80<ModMail>): ModMail;
    fromPartial(object: DeepPartial_80<ModMail>): ModMail;
};

/**
 * An ActionType describes a particular logged action within a conversation. For example,
 * if a mod highlights a conversation, a ModerationAction record with the type `Highlighted`
 * would be created.
 */
export declare enum ModMailActionType {
    Highlighted = "Highlighted",
    Unhighlighted = "Unhighlighted",
    Archived = "Archived",
    Unarchived = "Unarchived",
    ReportedToAdmins = "ReportedToAdmins",
    Muted = "Muted",
    Unmuted = "Unmuted",
    Banned = "Banned",
    Unbanned = "Unbanned",
    Approved = "Approved",
    Disapproved = "Disapproved",
    Filtered = "Filtered",
    Unfiltered = "Unfiltered"
}

export declare enum ModMailConversationState {
    New = "New",
    InProgress = "InProgress",
    Archived = "Archived",
    Appeals = "Appeals",
    JoinRequests = "JoinRequests",
    Filtered = "Filtered"
}

export declare type ModMailDefinition = {
    event: ModMailTrigger;
    onEvent: TriggerOnEventHandler<protos.ModMail>;
};

/**
 * Class providing the methods for working with Mod Mail
 */
export declare class ModMailService {
    #private;
    /**
     * Marks all conversations read for a particular conversation state within the passed list of subreddits.
     *
     * @param subreddits Array of subreddit names
     * @param state One of the possible conversation states ('all' to read all conversations)
     *
     * @returns conversationIds
     *
     * @example
     * ```ts
     * const conversationIds = await reddit.modMail.bulkReadConversations(
     *   ['askReddit', 'myAwesomeSubreddit'],
     *   'filtered'
     * );
     * ```
     */
    bulkReadConversations(subreddits: string[], state: ConversationStateFilter): Promise<string[]>;
    /**
     * Get conversations for a logged in user or subreddits
     *
     * @param params.after id of a modmail
     * @param params.subreddits array of subreddit names
     * @param params.limit an integer between 1 and 100 (default: 25)
     * @param params.sort one of (recent, mod, user, unread)
     * @param params.state One of the possible conversation states ('all' to read all conversations)
     *
     * @example
     * ```ts
     * const {viewerId, conversations} = await reddit.modMail.getConversations({
     *   after: 'abcdef',
     *   limit: 42
     * });
     *
     * const arrayOfConversations = Object.values(conversations);
     * ```
     */
    getConversations(params: GetConversationsRequest): Promise<GetConversationsResponse>;
    /**
     * Returns all messages, mod actions and conversation metadata for a given conversation id
     *
     * @param params.conversationId id of a modmail conversation
     * @param params.markRead should be marked as read (default: false)
     *
     * @example
     * ```ts
     * const { conversation, messages, modActions, user } = await reddit.modMail.getConversation({ conversationId: 'abcdef', markRead: true });
     * ```
     */
    getConversation(params: {
        /** a modmail conversation id */
        conversationId: string;
        /** mark read? */
        markRead?: boolean;
    }): Promise<GetConversationResponse>;
    /**
     * Returns a list of Subreddits that the user moderates with mail permission
     *
     * @example
     * ```ts
     * const subredditsData = await reddit.modMail.getSubreddits();
     *
     * for (const subreddit of Object.values(subreddits)) {
     *   console.log(subreddit.id);
     *   console.log(subreddit.name);
     * }
     * ```
     */
    getSubreddits(): Promise<{
        [key: string]: SubredditData;
    }>;
    /**
     * Creates a new conversation for a particular SR.
     *
     * This endpoint will create a ModmailConversation object
     * as well as the first ModmailMessage within the ModmailConversation object.
     *
     * @note
     * Note on {param.to}:
     * The to field for this endpoint is somewhat confusing. It can be:
     * - A User, passed like "username" or "u/username"
     * - A Subreddit, passed like "r/subreddit"
     * - null, meaning an internal moderator discussion
     *
     * In this way to is a bit of a misnomer in modmail conversations.
     * What it really means is the participant of the conversation who is not a mod of the subreddit.
     *
     * @param params.body markdown text
     * @param params.isAuthorHidden is author hidden? (default: false)
     * @param params.subredditName subreddit name
     * @param params.subject subject of the conversation. max 100 characters
     * @param params.to a user (e.g. u/username), a subreddit (e.g. r/subreddit) or null
     *
     * @example
     * ```ts
     * const { conversation, messages, modActions } = await reddit.modMail.createConversation({
     *   subredditName: 'askReddit',
     *   subject: 'Test conversation',
     *   body: 'Lorem ipsum sit amet',
     *   to: null,
     * });
     * ```
     */
    createConversation(params: {
        body: string;
        isAuthorHidden?: boolean;
        subredditName: string;
        subject: string;
        to?: string | null;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Creates a new message for a particular conversation.
     *
     * @param params.conversationId Id of a modmail conversation
     * @param params.body markdown text
     * @param params.isInternal is internal message? (default: false)
     * @param params.isAuthorHidden is author hidden? (default: false)
     *
     * @example
     * ```ts
     * await reddit.modMail.reply({
     *   body: 'Lorem ipsum sit amet',
     *   conversationId: 'abcdef',
     * });
     * ```
     */
    reply(params: {
        body: string;
        isAuthorHidden?: boolean;
        isInternal?: boolean;
        conversationId: string;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Marks a conversation as highlighted.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.highlightConversation('abcdef');
     * ```
     */
    highlightConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Removes a highlight from a conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unhighlightConversation('abcdef');
     * ```
     */
    unhighlightConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Marks a conversation as archived
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.archive('abcdef');
     * ```
     */
    archiveConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Marks conversation as unarchived.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unarchiveConversation('abcdef');
     * ```
     */
    unarchiveConversation(conversationId: string): Promise<ConversationResponse>;
    /**
     * Marks a conversation as read for the user.
     *
     * @param params.conversationId Id of a modmail conversation
     * @param params.numHours For how many hous the conversation needs to be muted
     *
     * @example
     * ```ts
     * await reddit.modMail.muteConversation({ conversationId: 'abcdef', numHours: 2 });
     * ```
     */
    muteConversation(params: {
        conversationId: string;
        numHours: number;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Unmutes the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.unmuteConversation('abcdef');
     * ```
     */
    unmuteConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Marks a conversations as read for the user.
     *
     * @param conversationIds An array of ids
     *
     * @example
     * ```ts
     * await reddit.modMail.readConversations(['abcdef', 'qwerty']);
     * ```
     */
    readConversations(conversationIds: string[]): Promise<void>;
    /**
     * Marks conversations as unread for the user.
     *
     * @param conversationIds An array of ids
     *
     * @example
     * ```ts
     * await reddit.modMail.unreadConversations(['abcdef', 'qwerty']);
     * ```
     */
    unreadConversations(conversationIds: string[]): Promise<void>;
    /**
     * Approve the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.approveConversation('abcdef');
     * ```
     */
    approveConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Disapprove the non mod user associated with a particular conversation.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * await reddit.modMail.disapproveConversation('abcdef');
     * ```
     */
    disapproveConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Temporary ban (switch from permanent to temporary ban) the non mod user associated with a particular conversation.
     *
     * @param params.conversationId a modmail conversation id
     * @param params.duration duration in days, max 999
     *
     * @example
     * ```ts
     * await reddit.modMail.tempBanConversation({ conversationId: 'abcdef', duration: 42 });
     * ```
     */
    tempBanConversation(params: {
        conversationId: string;
        duration: number;
    }): Promise<ConversationResponse & WithUserData>;
    /**
     * Unban the non mod user associated with a particular conversation.
     *
     * @param conversationId a modmail conversation id
     *
     * @example
     * ```ts
     * await reddit.modMail.unbanConversation('abcdef');
     * ```
     */
    unbanConversation(conversationId: string): Promise<ConversationResponse & WithUserData>;
    /**
     * Endpoint to retrieve the unread conversation count by conversation state.
     *
     * @example
     * ```ts
     * const response = await reddit.modMail.getUnreadCount();
     *
     * console.log(response.highlighted);
     * console.log(response.new);
     * ```
     */
    getUnreadCount(): Promise<UnreadCountResponse>;
    /**
     * Returns recent posts, comments and modmail conversations for a given user.
     *
     * @param conversationId Id of a modmail conversation
     *
     * @example
     * ```ts
     * const data = await reddit.modMail.getUserConversations('abcdef');
     *
     * console.log(data.recentComments);
     * console.log(data.recentPosts);
     * ```
     */
    getUserConversations(conversationId: string): Promise<ConversationUserData>;
}

/** The event name for when a mod mail is sent/received */
export declare type ModMailTrigger = 'ModMail';

export declare interface ModNote {
    id: string;
    operator: {
        id?: T2ID | undefined;
        name?: string | undefined;
    };
    user: {
        id?: T2ID | undefined;
        name?: string | undefined;
    };
    subreddit: {
        id?: T5ID | undefined;
        name?: string | undefined;
    };
    type: ModNoteType;
    createdAt: Date;
    userNote?: UserNote;
    modAction?: ModAction;
}

export declare class ModNote {
    #private;
}

/** MODNOTE - https://www.reddit.com/dev/api#section_modnote */
declare interface ModNote_2 {
    /** @see {@link https://www.reddit.com/dev/api#GET_api_mod_notes} */
    GetNotes(request: GetNotesRequest, metadata?: Metadata): Promise<ModNotesResponse>;
    /** @see {@link https://www.reddit.com/dev/api/#DELETE_api_mod_notes} */
    DeleteNotes(request: DeleteNotesRequest, metadata?: Metadata): Promise<DeleteNotesResponse>;
    /** @see {@link https://www.reddit.com/dev/api#POST_api_mod_notes} */
    PostNotes(request: PostNotesRequest, metadata?: Metadata): Promise<PostModNotesResponse>;
    /** Add a mod note for why a post or comment was removed */
    PostRemovalNote(request: PostRemovalNoteRequest, metadata?: Metadata): Promise<Empty>;
    /** @see {@link https://www.reddit.com/dev/api#GET_api_mod_notes_recent} */
    RecentNotes(request: RecentNotesRequest, metadata?: Metadata): Promise<ModNotesResponse>;
}

declare class ModNoteClientImpl implements ModNote_2 {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_55, opts?: {
        service?: string;
    });
    GetNotes(request: GetNotesRequest, metadata?: Metadata): Promise<ModNotesResponse>;
    DeleteNotes(request: DeleteNotesRequest, metadata?: Metadata): Promise<DeleteNotesResponse>;
    PostNotes(request: PostNotesRequest, metadata?: Metadata): Promise<PostModNotesResponse>;
    PostRemovalNote(request: PostRemovalNoteRequest, metadata?: Metadata): Promise<Empty>;
    RecentNotes(request: RecentNotesRequest, metadata?: Metadata): Promise<ModNotesResponse>;
}

/** MODNOTE - https://www.reddit.com/dev/api#section_modnote */
declare type ModNoteDefinition = typeof ModNoteDefinition;

declare const ModNoteDefinition: {
    readonly name: "ModNote";
    readonly fullName: "devvit.plugin.redditapi.modnote.ModNote";
    readonly methods: {
        /** @see {@link https://www.reddit.com/dev/api#GET_api_mod_notes} */
        readonly getNotes: {
            readonly name: "GetNotes";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.modnote.GetNotesRequest";
                encode(message: GetNotesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetNotesRequest;
                fromJSON(object: any): GetNotesRequest;
                toJSON(message: GetNotesRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    before?: string | undefined;
                    filter?: string | undefined;
                    limit?: number | undefined;
                    user?: string;
                } | undefined): GetNotesRequest;
                fromPartial(object: {
                    subreddit?: string;
                    before?: string | undefined;
                    filter?: string | undefined;
                    limit?: number | undefined;
                    user?: string;
                }): GetNotesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.modnote.ModNotesResponse";
                encode(message: ModNotesResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ModNotesResponse;
                fromJSON(object: any): ModNotesResponse;
                toJSON(message: ModNotesResponse): unknown;
                create(base?: {
                    modNotes?: {
                        subredditId?: string | undefined;
                        operatorId?: string | undefined;
                        modActionData?: {
                            action?: string | undefined;
                            redditId?: string | undefined;
                            details?: string | undefined;
                            description?: string | undefined;
                        } | undefined;
                        userNoteData?: {
                            note?: string | undefined;
                            redditId?: string | undefined;
                            label?: string | undefined;
                        } | undefined;
                        subreddit?: string | undefined;
                        user?: string | undefined;
                        operator?: string | undefined;
                        id?: string | undefined;
                        userId?: string | undefined;
                        createdAt?: number | undefined;
                        cursor?: string | undefined;
                        type?: string | undefined;
                    }[];
                    startCursor?: string | undefined;
                    endCursor?: string | undefined;
                    hasNextPage?: boolean | undefined;
                } | undefined): ModNotesResponse;
                fromPartial(object: {
                    modNotes?: {
                        subredditId?: string | undefined;
                        operatorId?: string | undefined;
                        modActionData?: {
                            action?: string | undefined;
                            redditId?: string | undefined;
                            details?: string | undefined;
                            description?: string | undefined;
                        } | undefined;
                        userNoteData?: {
                            note?: string | undefined;
                            redditId?: string | undefined;
                            label?: string | undefined;
                        } | undefined;
                        subreddit?: string | undefined;
                        user?: string | undefined;
                        operator?: string | undefined;
                        id?: string | undefined;
                        userId?: string | undefined;
                        createdAt?: number | undefined;
                        cursor?: string | undefined;
                        type?: string | undefined;
                    }[];
                    startCursor?: string | undefined;
                    endCursor?: string | undefined;
                    hasNextPage?: boolean | undefined;
                }): ModNotesResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** @see {@link https://www.reddit.com/dev/api/#DELETE_api_mod_notes} */
        readonly deleteNotes: {
            readonly name: "DeleteNotes";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.modnote.DeleteNotesRequest";
                encode(message: DeleteNotesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DeleteNotesRequest;
                fromJSON(object: any): DeleteNotesRequest;
                toJSON(message: DeleteNotesRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    noteId?: string;
                    user?: string;
                } | undefined): DeleteNotesRequest;
                fromPartial(object: {
                    subreddit?: string;
                    noteId?: string;
                    user?: string;
                }): DeleteNotesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.modnote.DeleteNotesResponse";
                encode(message: DeleteNotesResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DeleteNotesResponse;
                fromJSON(object: any): DeleteNotesResponse;
                toJSON(message: DeleteNotesResponse): unknown;
                create(base?: {
                    deleted?: boolean | undefined;
                } | undefined): DeleteNotesResponse;
                fromPartial(object: {
                    deleted?: boolean | undefined;
                }): DeleteNotesResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** @see {@link https://www.reddit.com/dev/api#POST_api_mod_notes} */
        readonly postNotes: {
            readonly name: "PostNotes";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.modnote.PostNotesRequest";
                encode(message: PostNotesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostNotesRequest;
                fromJSON(object: any): PostNotesRequest;
                toJSON(message: PostNotesRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    label?: string;
                    note?: string;
                    redditId?: string | undefined;
                    user?: string;
                } | undefined): PostNotesRequest;
                fromPartial(object: {
                    subreddit?: string;
                    label?: string;
                    note?: string;
                    redditId?: string | undefined;
                    user?: string;
                }): PostNotesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.modnote.PostModNotesResponse";
                encode(message: PostModNotesResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostModNotesResponse;
                fromJSON(object: any): PostModNotesResponse;
                toJSON(message: PostModNotesResponse): unknown;
                create(base?: {
                    created?: {
                        subredditId?: string | undefined;
                        operatorId?: string | undefined;
                        modActionData?: {
                            action?: string | undefined;
                            redditId?: string | undefined;
                            details?: string | undefined;
                            description?: string | undefined;
                        } | undefined;
                        userNoteData?: {
                            note?: string | undefined;
                            redditId?: string | undefined;
                            label?: string | undefined;
                        } | undefined;
                        subreddit?: string | undefined;
                        user?: string | undefined;
                        operator?: string | undefined;
                        id?: string | undefined;
                        userId?: string | undefined;
                        createdAt?: number | undefined;
                        cursor?: string | undefined;
                        type?: string | undefined;
                    } | undefined;
                } | undefined): PostModNotesResponse;
                fromPartial(object: {
                    created?: {
                        subredditId?: string | undefined;
                        operatorId?: string | undefined;
                        modActionData?: {
                            action?: string | undefined;
                            redditId?: string | undefined;
                            details?: string | undefined;
                            description?: string | undefined;
                        } | undefined;
                        userNoteData?: {
                            note?: string | undefined;
                            redditId?: string | undefined;
                            label?: string | undefined;
                        } | undefined;
                        subreddit?: string | undefined;
                        user?: string | undefined;
                        operator?: string | undefined;
                        id?: string | undefined;
                        userId?: string | undefined;
                        createdAt?: number | undefined;
                        cursor?: string | undefined;
                        type?: string | undefined;
                    } | undefined;
                }): PostModNotesResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** Add a mod note for why a post or comment was removed */
        readonly postRemovalNote: {
            readonly name: "PostRemovalNote";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.modnote.PostRemovalNoteRequest";
                encode(message: PostRemovalNoteRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostRemovalNoteRequest;
                fromJSON(object: any): PostRemovalNoteRequest;
                toJSON(message: PostRemovalNoteRequest): unknown;
                create(base?: {
                    itemIds?: string[];
                    reasonId?: string;
                    modNote?: string | undefined;
                } | undefined): PostRemovalNoteRequest;
                fromPartial(object: {
                    itemIds?: string[];
                    reasonId?: string;
                    modNote?: string | undefined;
                }): PostRemovalNoteRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** @see {@link https://www.reddit.com/dev/api#GET_api_mod_notes_recent} */
        readonly recentNotes: {
            readonly name: "RecentNotes";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.modnote.RecentNotesRequest";
                encode(message: RecentNotesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): RecentNotesRequest;
                fromJSON(object: any): RecentNotesRequest;
                toJSON(message: RecentNotesRequest): unknown;
                create(base?: {
                    subreddits?: string;
                    users?: string;
                } | undefined): RecentNotesRequest;
                fromPartial(object: {
                    subreddits?: string;
                    users?: string;
                }): RecentNotesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.modnote.ModNotesResponse";
                encode(message: ModNotesResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ModNotesResponse;
                fromJSON(object: any): ModNotesResponse;
                toJSON(message: ModNotesResponse): unknown;
                create(base?: {
                    modNotes?: {
                        subredditId?: string | undefined;
                        operatorId?: string | undefined;
                        modActionData?: {
                            action?: string | undefined;
                            redditId?: string | undefined;
                            details?: string | undefined;
                            description?: string | undefined;
                        } | undefined;
                        userNoteData?: {
                            note?: string | undefined;
                            redditId?: string | undefined;
                            label?: string | undefined;
                        } | undefined;
                        subreddit?: string | undefined;
                        user?: string | undefined;
                        operator?: string | undefined;
                        id?: string | undefined;
                        userId?: string | undefined;
                        createdAt?: number | undefined;
                        cursor?: string | undefined;
                        type?: string | undefined;
                    }[];
                    startCursor?: string | undefined;
                    endCursor?: string | undefined;
                    hasNextPage?: boolean | undefined;
                } | undefined): ModNotesResponse;
                fromPartial(object: {
                    modNotes?: {
                        subredditId?: string | undefined;
                        operatorId?: string | undefined;
                        modActionData?: {
                            action?: string | undefined;
                            redditId?: string | undefined;
                            details?: string | undefined;
                            description?: string | undefined;
                        } | undefined;
                        userNoteData?: {
                            note?: string | undefined;
                            redditId?: string | undefined;
                            label?: string | undefined;
                        } | undefined;
                        subreddit?: string | undefined;
                        user?: string | undefined;
                        operator?: string | undefined;
                        id?: string | undefined;
                        userId?: string | undefined;
                        createdAt?: number | undefined;
                        cursor?: string | undefined;
                        type?: string | undefined;
                    }[];
                    startCursor?: string | undefined;
                    endCursor?: string | undefined;
                    hasNextPage?: boolean | undefined;
                }): ModNotesResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
    };
};

declare interface ModNoteObject {
    subredditId?: string | undefined;
    operatorId?: string | undefined;
    modActionData?: ModNoteObject_ModActionData | undefined;
    userNoteData?: ModNoteObject_UserNoteData | undefined;
    subreddit?: string | undefined;
    user?: string | undefined;
    operator?: string | undefined;
    id?: string | undefined;
    userId?: string | undefined;
    createdAt?: number | undefined;
    cursor?: string | undefined;
    type?: string | undefined;
}

declare const ModNoteObject: {
    $type: "devvit.plugin.redditapi.modnote.ModNoteObject";
    encode(message: ModNoteObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModNoteObject;
    fromJSON(object: any): ModNoteObject;
    toJSON(message: ModNoteObject): unknown;
    create(base?: DeepPartial_3<ModNoteObject>): ModNoteObject;
    fromPartial(object: DeepPartial_3<ModNoteObject>): ModNoteObject;
};

declare interface ModNoteObject_ModActionData {
    action?: string | undefined;
    redditId?: string | undefined;
    details?: string | undefined;
    description?: string | undefined;
}

declare const ModNoteObject_ModActionData: {
    $type: "devvit.plugin.redditapi.modnote.ModNoteObject.ModActionData";
    encode(message: ModNoteObject_ModActionData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModNoteObject_ModActionData;
    fromJSON(object: any): ModNoteObject_ModActionData;
    toJSON(message: ModNoteObject_ModActionData): unknown;
    create(base?: DeepPartial_3<ModNoteObject_ModActionData>): ModNoteObject_ModActionData;
    fromPartial(object: DeepPartial_3<ModNoteObject_ModActionData>): ModNoteObject_ModActionData;
};

declare interface ModNoteObject_UserNoteData {
    note?: string | undefined;
    redditId?: string | undefined;
    label?: string | undefined;
}

declare const ModNoteObject_UserNoteData: {
    $type: "devvit.plugin.redditapi.modnote.ModNoteObject.UserNoteData";
    encode(message: ModNoteObject_UserNoteData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModNoteObject_UserNoteData;
    fromJSON(object: any): ModNoteObject_UserNoteData;
    toJSON(message: ModNoteObject_UserNoteData): unknown;
    create(base?: DeepPartial_3<ModNoteObject_UserNoteData>): ModNoteObject_UserNoteData;
    fromPartial(object: DeepPartial_3<ModNoteObject_UserNoteData>): ModNoteObject_UserNoteData;
};

declare const ModNoteServiceName = "devvit.plugin.redditapi.modnote.ModNote";

/** Responses */
declare interface ModNotesResponse {
    modNotes: ModNoteObject[];
    startCursor?: string | undefined;
    endCursor?: string | undefined;
    hasNextPage?: boolean | undefined;
}

declare const ModNotesResponse: {
    $type: "devvit.plugin.redditapi.modnote.ModNotesResponse";
    encode(message: ModNotesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ModNotesResponse;
    fromJSON(object: any): ModNotesResponse;
    toJSON(message: ModNotesResponse): unknown;
    create(base?: DeepPartial_3<ModNotesResponse>): ModNotesResponse;
    fromPartial(object: DeepPartial_3<ModNotesResponse>): ModNotesResponse;
};

export declare type ModNoteType = 'NOTE' | 'APPROVAL' | 'REMOVAL' | 'BAN' | 'MUTE' | 'INVITE' | 'SPAM' | 'CONTENT_CHANGE' | 'MOD_ACTION' | 'ALL';

declare interface MoreChildrenRequest {
    /**
     * List of Comment thing IDs without their "t1_" prefixes
     * @example ["foo123", "bar456", "baz789"]
     */
    children: string[];
    /** Maximum comment depth */
    depth?: number | undefined;
    /** Only return the comments explicitly listed in `children`, otherwise return as many as available */
    limitChildren?: boolean | undefined;
    /**
     * Post thing ID
     * @example "t3_abc123"
     */
    linkId: string;
    /** Optional, one of: "confidence", "top", "new", "controversial", "old", "random", "qa", "live" */
    sort?: string | undefined;
    /** Optional, id of the associated MoreChildren object */
    id?: string | undefined;
}

declare const MoreChildrenRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.MoreChildrenRequest";
    encode(message: MoreChildrenRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MoreChildrenRequest;
    fromJSON(object: any): MoreChildrenRequest;
    toJSON(message: MoreChildrenRequest): unknown;
    create(base?: DeepPartial_64<MoreChildrenRequest>): MoreChildrenRequest;
    fromPartial(object: DeepPartial_64<MoreChildrenRequest>): MoreChildrenRequest;
};

export declare type MoreObject = {
    parentId: T1ID | T3ID;
    children: T1ID[];
    depth: number;
};

export declare type MultiTriggerDefinition<Event extends TriggerEvent> = {
    events: readonly Event[];
    onEvent: TriggerOnEventHandler<TriggerEventType[Event]>;
};

declare interface MuteConversationRequest {
    /** id36 of a modmail conversation id */
    conversationId: string;
    /** how long? one of (72, 168, 672) */
    numHours: number;
}

declare const MuteConversationRequest: {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationRequest";
    encode(message: MuteConversationRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MuteConversationRequest;
    fromJSON(object: any): MuteConversationRequest;
    toJSON(message: MuteConversationRequest): unknown;
    create(base?: DeepPartial_71<MuteConversationRequest>): MuteConversationRequest;
    fromPartial(object: DeepPartial_71<MuteConversationRequest>): MuteConversationRequest;
};

declare interface MuteConversationResponse {
    conversations?: ConversationData_2 | undefined;
    messages: {
        [key: string]: MessageData_2;
    };
    user?: ConversationUserData_2 | undefined;
    modActions: {
        [key: string]: ModActionData_2;
    };
}

declare const MuteConversationResponse: {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse";
    encode(message: MuteConversationResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MuteConversationResponse;
    fromJSON(object: any): MuteConversationResponse;
    toJSON(message: MuteConversationResponse): unknown;
    create(base?: DeepPartial_71<MuteConversationResponse>): MuteConversationResponse;
    fromPartial(object: DeepPartial_71<MuteConversationResponse>): MuteConversationResponse;
};

declare interface MuteConversationResponse_MessagesEntry {
    key: string;
    value?: MessageData_2 | undefined;
}

declare const MuteConversationResponse_MessagesEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.MessagesEntry";
    encode(message: MuteConversationResponse_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MuteConversationResponse_MessagesEntry;
    fromJSON(object: any): MuteConversationResponse_MessagesEntry;
    toJSON(message: MuteConversationResponse_MessagesEntry): unknown;
    create(base?: DeepPartial_71<MuteConversationResponse_MessagesEntry>): MuteConversationResponse_MessagesEntry;
    fromPartial(object: DeepPartial_71<MuteConversationResponse_MessagesEntry>): MuteConversationResponse_MessagesEntry;
};

declare interface MuteConversationResponse_ModActionsEntry {
    key: string;
    value?: ModActionData_2 | undefined;
}

declare const MuteConversationResponse_ModActionsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.ModActionsEntry";
    encode(message: MuteConversationResponse_ModActionsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MuteConversationResponse_ModActionsEntry;
    fromJSON(object: any): MuteConversationResponse_ModActionsEntry;
    toJSON(message: MuteConversationResponse_ModActionsEntry): unknown;
    create(base?: DeepPartial_71<MuteConversationResponse_ModActionsEntry>): MuteConversationResponse_ModActionsEntry;
    fromPartial(object: DeepPartial_71<MuteConversationResponse_ModActionsEntry>): MuteConversationResponse_ModActionsEntry;
};

declare type MuteUserOptions = {
    /** The name of the subreddit to mute the user in */
    subredditName: string;
    /** The name of the user to mute */
    username: string;
    /** A mod note on why the user was muted. (optional) */
    note?: string;
};

declare type Namespace = {
    /**
     * Nonnullish address when bound. Set when bound but may be set sooner. May
     * not be unset when unbound.
     *
     * Hostnames are not necessarily unique. Clients always have the same hostname
     * as their EnvelopeDispatcher. Stream IDs are used to distinguish duplicate
     * hostnames.
     */
    hostname: string | undefined;
};

/** Request the client to navigate to a specific url */
declare interface NavigateToUrlEffect {
    url: string;
    target?: string | undefined;
}

declare const NavigateToUrlEffect: {
    $type: "devvit.ui.effects.v1alpha.NavigateToUrlEffect";
    encode(message: NavigateToUrlEffect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): NavigateToUrlEffect;
    fromJSON(object: any): NavigateToUrlEffect;
    toJSON(message: NavigateToUrlEffect): unknown;
    create(base?: DeepPartial_37<NavigateToUrlEffect>): NavigateToUrlEffect;
    fromPartial(object: DeepPartial_37<NavigateToUrlEffect>): NavigateToUrlEffect;
};

declare interface NestedRule {
    requires: PermissionOrRule[];
}

declare const NestedRule: {
    $type: "devvit.actor.permissions.NestedRule";
    encode(message: NestedRule, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): NestedRule;
    fromJSON(object: any): NestedRule;
    toJSON(message: NestedRule): unknown;
    create(base?: DeepPartial_110<NestedRule>): NestedRule;
    fromPartial(object: DeepPartial_110<NestedRule>): NestedRule;
};

/** NEWMODMAIL - https://www.reddit.com/dev/api#section_modmail */
declare interface NewModmail {
    /** https://www.reddit.com/dev/api#POST_api_mod_bulk_read */
    BulkReadConversations(request: BulkReadConversationsRequest, metadata?: Metadata): Promise<BulkReadConversationsResponse>;
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations */
    GetConversations(request: GetConversationsRequest_2, metadata?: Metadata): Promise<GetConversationsResponse_2>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations */
    CreateConversation(request: CreateConversationRequest, metadata?: Metadata): Promise<CreateConversationResponse>;
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations_:conversation_id */
    GetConversation(request: GetConversationRequest, metadata?: Metadata): Promise<GetConversationResponse_2>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id */
    CreateConversationMessage(request: CreateConversationMessageRequest, metadata?: Metadata): Promise<CreateConversationMessageResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_approve */
    ApproveConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<ApproveConversationResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_archive */
    ArchiveConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<ArchiveConversationResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_disapprove */
    DisapproveConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<ApproveConversationResponse>;
    /** https://www.reddit.com/dev/api#DELETE_api_mod_conversations_:conversation_id_highlight */
    UnhighlightConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<HighlightConversationResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_highlight */
    HighlightConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<HighlightConversationResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_mute */
    MuteConversation(request: MuteConversationRequest, metadata?: Metadata): Promise<MuteConversationResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_temp_ban */
    TempBan(request: TempBanRequest, metadata?: Metadata): Promise<TempBanResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_unarchive */
    UnarchiveConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<ArchiveConversationResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_unban */
    Unban(request: BasicConversationRequest, metadata?: Metadata): Promise<TempBanResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_unmute */
    UnmuteConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<MuteConversationResponse>;
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations_:conversation_id_user */
    UserConversations(request: BasicConversationRequest, metadata?: Metadata): Promise<ConversationUserData_2>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_read */
    Read(request: BasicConversationsRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations_subreddits */
    Subreddits(request: Empty, metadata?: Metadata): Promise<SubredditsResponse>;
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_unread */
    Unread(request: BasicConversationsRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations_unread_count */
    UnreadCount(request: Empty, metadata?: Metadata): Promise<UnreadCountResponse_2>;
}

declare class NewModmailClientImpl implements NewModmail {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_54, opts?: {
        service?: string;
    });
    BulkReadConversations(request: BulkReadConversationsRequest, metadata?: Metadata): Promise<BulkReadConversationsResponse>;
    GetConversations(request: GetConversationsRequest_2, metadata?: Metadata): Promise<GetConversationsResponse_2>;
    CreateConversation(request: CreateConversationRequest, metadata?: Metadata): Promise<CreateConversationResponse>;
    GetConversation(request: GetConversationRequest, metadata?: Metadata): Promise<GetConversationResponse_2>;
    CreateConversationMessage(request: CreateConversationMessageRequest, metadata?: Metadata): Promise<CreateConversationMessageResponse>;
    ApproveConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<ApproveConversationResponse>;
    ArchiveConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<ArchiveConversationResponse>;
    DisapproveConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<ApproveConversationResponse>;
    UnhighlightConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<HighlightConversationResponse>;
    HighlightConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<HighlightConversationResponse>;
    MuteConversation(request: MuteConversationRequest, metadata?: Metadata): Promise<MuteConversationResponse>;
    TempBan(request: TempBanRequest, metadata?: Metadata): Promise<TempBanResponse>;
    UnarchiveConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<ArchiveConversationResponse>;
    Unban(request: BasicConversationRequest, metadata?: Metadata): Promise<TempBanResponse>;
    UnmuteConversation(request: BasicConversationRequest, metadata?: Metadata): Promise<MuteConversationResponse>;
    UserConversations(request: BasicConversationRequest, metadata?: Metadata): Promise<ConversationUserData_2>;
    Read(request: BasicConversationsRequest, metadata?: Metadata): Promise<Empty>;
    Subreddits(request: Empty, metadata?: Metadata): Promise<SubredditsResponse>;
    Unread(request: BasicConversationsRequest, metadata?: Metadata): Promise<Empty>;
    UnreadCount(request: Empty, metadata?: Metadata): Promise<UnreadCountResponse_2>;
}

/** NEWMODMAIL - https://www.reddit.com/dev/api#section_modmail */
declare type NewModmailDefinition = typeof NewModmailDefinition;

declare const NewModmailDefinition: {
    readonly name: "NewModmail";
    readonly fullName: "devvit.plugin.redditapi.newmodmail.NewModmail";
    readonly methods: {
        /** https://www.reddit.com/dev/api#POST_api_mod_bulk_read */
        readonly bulkReadConversations: {
            readonly name: "BulkReadConversations";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsRequest";
                encode(message: BulkReadConversationsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BulkReadConversationsRequest;
                fromJSON(object: any): BulkReadConversationsRequest;
                toJSON(message: BulkReadConversationsRequest): unknown;
                create(base?: {
                    entity?: string;
                    state?: string;
                } | undefined): BulkReadConversationsRequest;
                fromPartial(object: {
                    entity?: string;
                    state?: string;
                }): BulkReadConversationsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsResponse";
                encode(message: BulkReadConversationsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BulkReadConversationsResponse;
                fromJSON(object: any): BulkReadConversationsResponse;
                toJSON(message: BulkReadConversationsResponse): unknown;
                create(base?: {
                    conversationIds?: string[];
                } | undefined): BulkReadConversationsResponse;
                fromPartial(object: {
                    conversationIds?: string[];
                }): BulkReadConversationsResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_mod_conversations */
        readonly getConversations: {
            readonly name: "GetConversations";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.GetConversationsRequest";
                encode(message: GetConversationsRequest_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetConversationsRequest_2;
                fromJSON(object: any): GetConversationsRequest_2;
                toJSON(message: GetConversationsRequest_2): unknown;
                create(base?: {
                    after?: string | undefined;
                    entity?: string | undefined;
                    limit?: number | undefined;
                    sort?: string | undefined;
                    state?: string | undefined;
                } | undefined): GetConversationsRequest_2;
                fromPartial(object: {
                    after?: string | undefined;
                    entity?: string | undefined;
                    limit?: number | undefined;
                    sort?: string | undefined;
                    state?: string | undefined;
                }): GetConversationsRequest_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse";
                encode(message: GetConversationsResponse_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetConversationsResponse_2;
                fromJSON(object: any): GetConversationsResponse_2;
                toJSON(message: GetConversationsResponse_2): unknown;
                create(base?: {
                    conversations?: {
                        [x: string]: {
                            isAuto?: boolean | undefined;
                            participant?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            objIds?: {
                                id?: string | undefined;
                                key?: string | undefined;
                            }[];
                            isRepliable?: boolean | undefined;
                            lastUserUpdate?: string | undefined;
                            isInternal?: boolean | undefined;
                            lastModUpdate?: string | undefined;
                            authors?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            }[];
                            lastUpdated?: string | undefined;
                            legacyFirstMessageId?: string | undefined;
                            state?: number | undefined;
                            conversationType?: string | undefined;
                            lastUnread?: string | undefined;
                            owner?: {
                                displayName?: string | undefined;
                                type?: string | undefined;
                                id?: string | undefined;
                            } | undefined;
                            subject?: string | undefined;
                            id?: string | undefined;
                            isHighlighted?: boolean | undefined;
                            numMessages?: number | undefined;
                            modActions?: {
                                [x: string]: {
                                    date?: string | undefined;
                                    actionTypeId?: number | undefined;
                                    id?: string | undefined;
                                    author?: {
                                        isMod?: boolean | undefined;
                                        isAdmin?: boolean | undefined;
                                        name?: string | undefined;
                                        isHidden?: boolean | undefined;
                                        id?: number | undefined;
                                        isDeleted?: boolean | undefined;
                                    } | undefined;
                                } | undefined;
                            };
                        } | undefined;
                    };
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    viewerId?: string | undefined;
                    conversationIds?: string[];
                } | undefined): GetConversationsResponse_2;
                fromPartial(object: {
                    conversations?: {
                        [x: string]: {
                            isAuto?: boolean | undefined;
                            participant?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            objIds?: {
                                id?: string | undefined;
                                key?: string | undefined;
                            }[];
                            isRepliable?: boolean | undefined;
                            lastUserUpdate?: string | undefined;
                            isInternal?: boolean | undefined;
                            lastModUpdate?: string | undefined;
                            authors?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            }[];
                            lastUpdated?: string | undefined;
                            legacyFirstMessageId?: string | undefined;
                            state?: number | undefined;
                            conversationType?: string | undefined;
                            lastUnread?: string | undefined;
                            owner?: {
                                displayName?: string | undefined;
                                type?: string | undefined;
                                id?: string | undefined;
                            } | undefined;
                            subject?: string | undefined;
                            id?: string | undefined;
                            isHighlighted?: boolean | undefined;
                            numMessages?: number | undefined;
                            modActions?: {
                                [x: string]: {
                                    date?: string | undefined;
                                    actionTypeId?: number | undefined;
                                    id?: string | undefined;
                                    author?: {
                                        isMod?: boolean | undefined;
                                        isAdmin?: boolean | undefined;
                                        name?: string | undefined;
                                        isHidden?: boolean | undefined;
                                        id?: number | undefined;
                                        isDeleted?: boolean | undefined;
                                    } | undefined;
                                } | undefined;
                            };
                        } | undefined;
                    };
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    viewerId?: string | undefined;
                    conversationIds?: string[];
                }): GetConversationsResponse_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations */
        readonly createConversation: {
            readonly name: "CreateConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.CreateConversationRequest";
                encode(message: CreateConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CreateConversationRequest;
                fromJSON(object: any): CreateConversationRequest;
                toJSON(message: CreateConversationRequest): unknown;
                create(base?: {
                    body?: string;
                    isAuthorHidden?: boolean;
                    srName?: string;
                    subject?: string;
                    to?: string | undefined;
                } | undefined): CreateConversationRequest;
                fromPartial(object: {
                    body?: string;
                    isAuthorHidden?: boolean;
                    srName?: string;
                    subject?: string;
                    to?: string | undefined;
                }): CreateConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse";
                encode(message: CreateConversationResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CreateConversationResponse;
                fromJSON(object: any): CreateConversationResponse;
                toJSON(message: CreateConversationResponse): unknown;
                create(base?: {
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                    explanation?: string | undefined;
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                } | undefined): CreateConversationResponse;
                fromPartial(object: {
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                    explanation?: string | undefined;
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                }): CreateConversationResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_mod_conversations_:conversation_id */
        readonly getConversation: {
            readonly name: "GetConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.GetConversationRequest";
                encode(message: GetConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetConversationRequest;
                fromJSON(object: any): GetConversationRequest;
                toJSON(message: GetConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                    markRead?: boolean;
                } | undefined): GetConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                    markRead?: boolean;
                }): GetConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse";
                encode(message: GetConversationResponse_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetConversationResponse_2;
                fromJSON(object: any): GetConversationResponse_2;
                toJSON(message: GetConversationResponse_2): unknown;
                create(base?: {
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    participantSubreddit?: {
                        typeUrl?: string;
                        value?: Uint8Array;
                    } | undefined;
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                } | undefined): GetConversationResponse_2;
                fromPartial(object: {
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    participantSubreddit?: {
                        typeUrl?: string;
                        value?: Uint8Array;
                    } | undefined;
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                }): GetConversationResponse_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id */
        readonly createConversationMessage: {
            readonly name: "CreateConversationMessage";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageRequest";
                encode(message: CreateConversationMessageRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CreateConversationMessageRequest;
                fromJSON(object: any): CreateConversationMessageRequest;
                toJSON(message: CreateConversationMessageRequest): unknown;
                create(base?: {
                    body?: string;
                    isAuthorHidden?: boolean;
                    isInternal?: boolean;
                    conversationId?: string;
                } | undefined): CreateConversationMessageRequest;
                fromPartial(object: {
                    body?: string;
                    isAuthorHidden?: boolean;
                    isInternal?: boolean;
                    conversationId?: string;
                }): CreateConversationMessageRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse";
                encode(message: CreateConversationMessageResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CreateConversationMessageResponse;
                fromJSON(object: any): CreateConversationMessageResponse;
                toJSON(message: CreateConversationMessageResponse): unknown;
                create(base?: {
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                } | undefined): CreateConversationMessageResponse;
                fromPartial(object: {
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                }): CreateConversationMessageResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_approve */
        readonly approveConversation: {
            readonly name: "ApproveConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
                encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationRequest;
                fromJSON(object: any): BasicConversationRequest;
                toJSON(message: BasicConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                } | undefined): BasicConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                }): BasicConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse";
                encode(message: ApproveConversationResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ApproveConversationResponse;
                fromJSON(object: any): ApproveConversationResponse;
                toJSON(message: ApproveConversationResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                    explanation?: string | undefined;
                } | undefined): ApproveConversationResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                    explanation?: string | undefined;
                }): ApproveConversationResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_archive */
        readonly archiveConversation: {
            readonly name: "ArchiveConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
                encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationRequest;
                fromJSON(object: any): BasicConversationRequest;
                toJSON(message: BasicConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                } | undefined): BasicConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                }): BasicConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse";
                encode(message: ArchiveConversationResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ArchiveConversationResponse;
                fromJSON(object: any): ArchiveConversationResponse;
                toJSON(message: ArchiveConversationResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                } | undefined): ArchiveConversationResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                }): ArchiveConversationResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_disapprove */
        readonly disapproveConversation: {
            readonly name: "DisapproveConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
                encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationRequest;
                fromJSON(object: any): BasicConversationRequest;
                toJSON(message: BasicConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                } | undefined): BasicConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                }): BasicConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse";
                encode(message: ApproveConversationResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ApproveConversationResponse;
                fromJSON(object: any): ApproveConversationResponse;
                toJSON(message: ApproveConversationResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                    explanation?: string | undefined;
                } | undefined): ApproveConversationResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                    explanation?: string | undefined;
                }): ApproveConversationResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#DELETE_api_mod_conversations_:conversation_id_highlight */
        readonly unhighlightConversation: {
            readonly name: "UnhighlightConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
                encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationRequest;
                fromJSON(object: any): BasicConversationRequest;
                toJSON(message: BasicConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                } | undefined): BasicConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                }): BasicConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse";
                encode(message: HighlightConversationResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): HighlightConversationResponse;
                fromJSON(object: any): HighlightConversationResponse;
                toJSON(message: HighlightConversationResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                } | undefined): HighlightConversationResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                }): HighlightConversationResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_highlight */
        readonly highlightConversation: {
            readonly name: "HighlightConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
                encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationRequest;
                fromJSON(object: any): BasicConversationRequest;
                toJSON(message: BasicConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                } | undefined): BasicConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                }): BasicConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse";
                encode(message: HighlightConversationResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): HighlightConversationResponse;
                fromJSON(object: any): HighlightConversationResponse;
                toJSON(message: HighlightConversationResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                } | undefined): HighlightConversationResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                }): HighlightConversationResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_mute */
        readonly muteConversation: {
            readonly name: "MuteConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.MuteConversationRequest";
                encode(message: MuteConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MuteConversationRequest;
                fromJSON(object: any): MuteConversationRequest;
                toJSON(message: MuteConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                    numHours?: number;
                } | undefined): MuteConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                    numHours?: number;
                }): MuteConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse";
                encode(message: MuteConversationResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MuteConversationResponse;
                fromJSON(object: any): MuteConversationResponse;
                toJSON(message: MuteConversationResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                } | undefined): MuteConversationResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                }): MuteConversationResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_temp_ban */
        readonly tempBan: {
            readonly name: "TempBan";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.TempBanRequest";
                encode(message: TempBanRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): TempBanRequest;
                fromJSON(object: any): TempBanRequest;
                toJSON(message: TempBanRequest): unknown;
                create(base?: {
                    conversationId?: string;
                    duration?: number;
                } | undefined): TempBanRequest;
                fromPartial(object: {
                    conversationId?: string;
                    duration?: number;
                }): TempBanRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse";
                encode(message: TempBanResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): TempBanResponse;
                fromJSON(object: any): TempBanResponse;
                toJSON(message: TempBanResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                } | undefined): TempBanResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                }): TempBanResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_unarchive */
        readonly unarchiveConversation: {
            readonly name: "UnarchiveConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
                encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationRequest;
                fromJSON(object: any): BasicConversationRequest;
                toJSON(message: BasicConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                } | undefined): BasicConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                }): BasicConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse";
                encode(message: ArchiveConversationResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ArchiveConversationResponse;
                fromJSON(object: any): ArchiveConversationResponse;
                toJSON(message: ArchiveConversationResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                } | undefined): ArchiveConversationResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    conversation?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                }): ArchiveConversationResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_unban */
        readonly unban: {
            readonly name: "Unban";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
                encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationRequest;
                fromJSON(object: any): BasicConversationRequest;
                toJSON(message: BasicConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                } | undefined): BasicConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                }): BasicConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse";
                encode(message: TempBanResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): TempBanResponse;
                fromJSON(object: any): TempBanResponse;
                toJSON(message: TempBanResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                } | undefined): TempBanResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                    fields?: string[];
                    reason?: string | undefined;
                    message?: string | undefined;
                }): TempBanResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_unmute */
        readonly unmuteConversation: {
            readonly name: "UnmuteConversation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
                encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationRequest;
                fromJSON(object: any): BasicConversationRequest;
                toJSON(message: BasicConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                } | undefined): BasicConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                }): BasicConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse";
                encode(message: MuteConversationResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MuteConversationResponse;
                fromJSON(object: any): MuteConversationResponse;
                toJSON(message: MuteConversationResponse): unknown;
                create(base?: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                } | undefined): MuteConversationResponse;
                fromPartial(object: {
                    conversations?: {
                        isAuto?: boolean | undefined;
                        participant?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        } | undefined;
                        objIds?: {
                            id?: string | undefined;
                            key?: string | undefined;
                        }[];
                        isRepliable?: boolean | undefined;
                        lastUserUpdate?: string | undefined;
                        isInternal?: boolean | undefined;
                        lastModUpdate?: string | undefined;
                        authors?: {
                            isMod?: boolean | undefined;
                            isAdmin?: boolean | undefined;
                            name?: string | undefined;
                            isOp?: boolean | undefined;
                            isParticipant?: boolean | undefined;
                            isApproved?: boolean | undefined;
                            isHidden?: boolean | undefined;
                            id?: number | undefined;
                            isDeleted?: boolean | undefined;
                        }[];
                        lastUpdated?: string | undefined;
                        legacyFirstMessageId?: string | undefined;
                        state?: number | undefined;
                        conversationType?: string | undefined;
                        lastUnread?: string | undefined;
                        owner?: {
                            displayName?: string | undefined;
                            type?: string | undefined;
                            id?: string | undefined;
                        } | undefined;
                        subject?: string | undefined;
                        id?: string | undefined;
                        isHighlighted?: boolean | undefined;
                        numMessages?: number | undefined;
                        modActions?: {
                            [x: string]: {
                                date?: string | undefined;
                                actionTypeId?: number | undefined;
                                id?: string | undefined;
                                author?: {
                                    isMod?: boolean | undefined;
                                    isAdmin?: boolean | undefined;
                                    name?: string | undefined;
                                    isHidden?: boolean | undefined;
                                    id?: number | undefined;
                                    isDeleted?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        };
                    } | undefined;
                    messages?: {
                        [x: string]: {
                            body?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isOp?: boolean | undefined;
                                isParticipant?: boolean | undefined;
                                isApproved?: boolean | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                            isInternal?: boolean | undefined;
                            date?: string | undefined;
                            bodyMarkdown?: string | undefined;
                            id?: string | undefined;
                            participatingAs?: string | undefined;
                        } | undefined;
                    };
                    user?: {
                        recentComments?: {
                            [x: string]: {
                                comment?: string | undefined;
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        muteStatus?: {
                            muteCount?: number | undefined;
                            isMuted?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        name?: string | undefined;
                        created?: string | undefined;
                        banStatus?: {
                            isBanned?: boolean | undefined;
                            isPermanent?: boolean | undefined;
                            endDate?: string | undefined;
                            reason?: string | undefined;
                        } | undefined;
                        isSuspended?: boolean | undefined;
                        approveStatus?: {
                            isApproved?: boolean | undefined;
                        } | undefined;
                        isShadowBanned?: boolean | undefined;
                        recentPosts?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                title?: string | undefined;
                            } | undefined;
                        };
                        recentConvos?: {
                            [x: string]: {
                                date?: string | undefined;
                                permalink?: string | undefined;
                                id?: string | undefined;
                                subject?: string | undefined;
                            } | undefined;
                        };
                        id?: string | undefined;
                    } | undefined;
                    modActions?: {
                        [x: string]: {
                            date?: string | undefined;
                            actionTypeId?: number | undefined;
                            id?: string | undefined;
                            author?: {
                                isMod?: boolean | undefined;
                                isAdmin?: boolean | undefined;
                                name?: string | undefined;
                                isHidden?: boolean | undefined;
                                id?: number | undefined;
                                isDeleted?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    };
                }): MuteConversationResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_mod_conversations_:conversation_id_user */
        readonly userConversations: {
            readonly name: "UserConversations";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest";
                encode(message: BasicConversationRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationRequest;
                fromJSON(object: any): BasicConversationRequest;
                toJSON(message: BasicConversationRequest): unknown;
                create(base?: {
                    conversationId?: string;
                } | undefined): BasicConversationRequest;
                fromPartial(object: {
                    conversationId?: string;
                }): BasicConversationRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData";
                encode(message: ConversationUserData_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ConversationUserData_2;
                fromJSON(object: any): ConversationUserData_2;
                toJSON(message: ConversationUserData_2): unknown;
                create(base?: {
                    recentComments?: {
                        [x: string]: {
                            comment?: string | undefined;
                            date?: string | undefined;
                            permalink?: string | undefined;
                            title?: string | undefined;
                        } | undefined;
                    };
                    muteStatus?: {
                        muteCount?: number | undefined;
                        isMuted?: boolean | undefined;
                        endDate?: string | undefined;
                        reason?: string | undefined;
                    } | undefined;
                    name?: string | undefined;
                    created?: string | undefined;
                    banStatus?: {
                        isBanned?: boolean | undefined;
                        isPermanent?: boolean | undefined;
                        endDate?: string | undefined;
                        reason?: string | undefined;
                    } | undefined;
                    isSuspended?: boolean | undefined;
                    approveStatus?: {
                        isApproved?: boolean | undefined;
                    } | undefined;
                    isShadowBanned?: boolean | undefined;
                    recentPosts?: {
                        [x: string]: {
                            date?: string | undefined;
                            permalink?: string | undefined;
                            title?: string | undefined;
                        } | undefined;
                    };
                    recentConvos?: {
                        [x: string]: {
                            date?: string | undefined;
                            permalink?: string | undefined;
                            id?: string | undefined;
                            subject?: string | undefined;
                        } | undefined;
                    };
                    id?: string | undefined;
                } | undefined): ConversationUserData_2;
                fromPartial(object: {
                    recentComments?: {
                        [x: string]: {
                            comment?: string | undefined;
                            date?: string | undefined;
                            permalink?: string | undefined;
                            title?: string | undefined;
                        } | undefined;
                    };
                    muteStatus?: {
                        muteCount?: number | undefined;
                        isMuted?: boolean | undefined;
                        endDate?: string | undefined;
                        reason?: string | undefined;
                    } | undefined;
                    name?: string | undefined;
                    created?: string | undefined;
                    banStatus?: {
                        isBanned?: boolean | undefined;
                        isPermanent?: boolean | undefined;
                        endDate?: string | undefined;
                        reason?: string | undefined;
                    } | undefined;
                    isSuspended?: boolean | undefined;
                    approveStatus?: {
                        isApproved?: boolean | undefined;
                    } | undefined;
                    isShadowBanned?: boolean | undefined;
                    recentPosts?: {
                        [x: string]: {
                            date?: string | undefined;
                            permalink?: string | undefined;
                            title?: string | undefined;
                        } | undefined;
                    };
                    recentConvos?: {
                        [x: string]: {
                            date?: string | undefined;
                            permalink?: string | undefined;
                            id?: string | undefined;
                            subject?: string | undefined;
                        } | undefined;
                    };
                    id?: string | undefined;
                }): ConversationUserData_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_read */
        readonly read: {
            readonly name: "Read";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationsRequest";
                encode(message: BasicConversationsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationsRequest;
                fromJSON(object: any): BasicConversationsRequest;
                toJSON(message: BasicConversationsRequest): unknown;
                create(base?: {
                    conversationIds?: string;
                } | undefined): BasicConversationsRequest;
                fromPartial(object: {
                    conversationIds?: string;
                }): BasicConversationsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_mod_conversations_subreddits */
        readonly subreddits: {
            readonly name: "Subreddits";
            readonly requestType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse";
                encode(message: SubredditsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditsResponse;
                fromJSON(object: any): SubredditsResponse;
                toJSON(message: SubredditsResponse): unknown;
                create(base?: {
                    subreddits?: {
                        [x: string]: {
                            communityIcon?: string | undefined;
                            keyColor?: string | undefined;
                            displayName?: string | undefined;
                            name?: string | undefined;
                            subscribers?: number | undefined;
                            primaryColor?: string | undefined;
                            id?: string | undefined;
                            lastUpdated?: string | undefined;
                            icon?: string | undefined;
                        } | undefined;
                    };
                } | undefined): SubredditsResponse;
                fromPartial(object: {
                    subreddits?: {
                        [x: string]: {
                            communityIcon?: string | undefined;
                            keyColor?: string | undefined;
                            displayName?: string | undefined;
                            name?: string | undefined;
                            subscribers?: number | undefined;
                            primaryColor?: string | undefined;
                            id?: string | undefined;
                            lastUpdated?: string | undefined;
                            icon?: string | undefined;
                        } | undefined;
                    };
                }): SubredditsResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_mod_conversations_unread */
        readonly unread: {
            readonly name: "Unread";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.newmodmail.BasicConversationsRequest";
                encode(message: BasicConversationsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicConversationsRequest;
                fromJSON(object: any): BasicConversationsRequest;
                toJSON(message: BasicConversationsRequest): unknown;
                create(base?: {
                    conversationIds?: string;
                } | undefined): BasicConversationsRequest;
                fromPartial(object: {
                    conversationIds?: string;
                }): BasicConversationsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_mod_conversations_unread_count */
        readonly unreadCount: {
            readonly name: "UnreadCount";
            readonly requestType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.newmodmail.UnreadCountResponse";
                encode(message: UnreadCountResponse_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UnreadCountResponse_2;
                fromJSON(object: any): UnreadCountResponse_2;
                toJSON(message: UnreadCountResponse_2): unknown;
                create(base?: {
                    archived?: number | undefined;
                    appeals?: number | undefined;
                    highlighted?: number | undefined;
                    notifications?: number | undefined;
                    joinRequests?: number | undefined;
                    filtered?: number | undefined;
                    new?: number | undefined;
                    inprogress?: number | undefined;
                    mod?: number | undefined;
                } | undefined): UnreadCountResponse_2;
                fromPartial(object: {
                    archived?: number | undefined;
                    appeals?: number | undefined;
                    highlighted?: number | undefined;
                    notifications?: number | undefined;
                    joinRequests?: number | undefined;
                    filtered?: number | undefined;
                    new?: number | undefined;
                    inprogress?: number | undefined;
                    mod?: number | undefined;
                }): UnreadCountResponse_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
    };
};

declare const NewModmailServiceName = "devvit.plugin.redditapi.newmodmail.NewModmail";

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
 * `Value` type union.
 *
 * The JSON representation for `NullValue` is JSON `null`.
 */
declare enum NullValue {
    /** NULL_VALUE - Null value. */
    NULL_VALUE = 0,
    UNRECOGNIZED = -1
}

declare function nullValueFromJSON(object: any): NullValue;

declare function nullValueToJSON(object: NullValue): number;

/** A number field */
export declare type NumberField = Prettify<BaseField<number> & Omit<FieldConfig_Number, 'min' | 'max' | 'step'> & {
    type: 'number';
}>;

declare type ObfuscationReason = 'nsfw' | 'spoiler';

/**
 * oEmbed is a format for allowing an embedded representation of a URL on third party sites.
 * The simple API allows a website to display embedded content (such as photos or videos)
 * when a user posts a link to that resource, without having to parse the resource directly.
 * See: https://oembed.com/
 */
export declare type OEmbed = {
    /** The resource type. Valid values, along with value-specific parameters, are described below. E.g. "video" */
    type: string;
    /** A text title, describing the resource. */
    title?: string | undefined;
    /** A URL for the author/owner of the resource. E.g. "YouTube" */
    providerName?: string | undefined;
    /** The name of the resource provider. E.g "https://www.youtube.com/" */
    providerUrl?: string | undefined;
    /** The oEmbed version number. This must be 1.0. */
    version: string;
    /** The width of the optional thumbnail in pixels */
    thumbnailWidth?: number;
    /** The height of the optional thumbnail in pixels */
    thumbnailHeight?: number;
    /** A URL to a thumbnail image representing the resource. */
    thumbnailUrl?: string | undefined;
    /** The HTML required to embed a video player. The HTML should have no padding or margins. Consumers may wish to load the HTML in an off-domain iframe to avoid XSS vulnerabilities. */
    html: string;
    /** The width in pixels required to display the HTML. */
    height?: number;
    /** The height in pixels required to display the HTML. */
    width?: number;
    /** A URL for the author/owner of the resource. E.g. "https://www.youtube.com/@Reddit" */
    authorUrl?: string | undefined;
    /** The name of the author/owner of the resource. E.g. "Reddit" */
    authorName?: string | undefined;
};

declare interface Oembed {
    type: string;
    version: string;
    title: string;
    description: string;
    authorName: string;
    authorUrl: string;
    providerName: string;
    providerUrl: string;
    thumbnailUrl: string;
    thumbnailWidth: number;
    thumbnailHeight: number;
    html: string;
    width: number;
    height: number;
}

declare const Oembed: {
    $type: "devvit.reddit.v2alpha.Oembed";
    encode(message: Oembed, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Oembed;
    fromJSON(object: any): Oembed;
    toJSON(message: Oembed): unknown;
    create(base?: DeepPartial_78<Oembed>): Oembed;
    fromPartial(object: DeepPartial_78<Oembed>): Oembed;
};

declare interface OEmbed_2 {
    authorName?: string | undefined;
    authorUrl?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
}

declare const OEmbed_2: {
    $type: "devvit.reddit.OEmbed";
    encode(message: OEmbed_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): OEmbed_2;
    fromJSON(object: any): OEmbed_2;
    toJSON(message: OEmbed_2): unknown;
    create(base?: DeepPartial_82<OEmbed_2>): OEmbed_2;
    fromPartial(object: DeepPartial_82<OEmbed_2>): OEmbed_2;
};

declare interface OnAccountDelete {
    OnAccountDelete(request: AccountDelete, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnAccountDeleteClientImpl implements OnAccountDelete {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnAccountDelete(request: AccountDelete, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnAccountDeleteDefinition = typeof OnAccountDeleteDefinition;

declare const OnAccountDeleteDefinition: {
    readonly name: "OnAccountDelete";
    readonly fullName: "devvit.actor.automation.v1alpha.OnAccountDelete";
    readonly methods: {
        readonly onAccountDelete: {
            readonly name: "OnAccountDelete";
            readonly requestType: {
                $type: "devvit.events.v1alpha.AccountDelete";
                encode(message: AccountDelete, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AccountDelete;
                fromJSON(object: any): AccountDelete;
                toJSON(message: AccountDelete): unknown;
                create(base?: {
                    userId?: string;
                    deletedAt?: Date | undefined;
                    user?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                } | undefined): AccountDelete;
                fromPartial(object: {
                    userId?: string;
                    deletedAt?: Date | undefined;
                    user?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                }): AccountDelete;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnAccountDeleteServiceName = "devvit.actor.automation.v1alpha.OnAccountDelete";

declare interface OnActionRequest {
    /** Matches the action_id in the action description */
    actionId: string;
    /** The type of menu from which the action was executed */
    thingType: ThingType;
    /** The source Thing ID from which the action was executed */
    thingId: string;
}

declare const OnActionRequest: {
    $type: "devvit.reddit.custom_actions.v2alpha.OnActionRequest";
    encode(message: OnActionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): OnActionRequest;
    fromJSON(object: any): OnActionRequest;
    toJSON(message: OnActionRequest): unknown;
    create(base?: DeepPartial_41<OnActionRequest>): OnActionRequest;
    fromPartial(object: DeepPartial_41<OnActionRequest>): OnActionRequest;
};

declare interface OnActionResponse {
    /** Stateful data to send back to your app with events */
    state?: {
        [key: string]: any;
    } | undefined;
    /** Optional list of Effects to execute on the client */
    effects: Effect[];
}

declare const OnActionResponse: {
    $type: "devvit.reddit.custom_actions.v2alpha.OnActionResponse";
    encode(message: OnActionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): OnActionResponse;
    fromJSON(object: any): OnActionResponse;
    toJSON(message: OnActionResponse): unknown;
    create(base?: DeepPartial_41<OnActionResponse>): OnActionResponse;
    fromPartial(object: DeepPartial_41<OnActionResponse>): OnActionResponse;
};

declare interface OnAppInstall {
    OnAppInstall(request: AppInstall_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnAppInstallClientImpl implements OnAppInstall {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnAppInstall(request: AppInstall_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnAppInstallDefinition = typeof OnAppInstallDefinition;

declare const OnAppInstallDefinition: {
    readonly name: "OnAppInstall";
    readonly fullName: "devvit.actor.automation.v1alpha.OnAppInstall";
    readonly methods: {
        readonly onAppInstall: {
            readonly name: "OnAppInstall";
            readonly requestType: {
                $type: "devvit.events.v1alpha.AppInstall";
                encode(message: AppInstall_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AppInstall_2;
                fromJSON(object: any): AppInstall_2;
                toJSON(message: AppInstall_2): unknown;
                create(base?: {
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    installer?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                } | undefined): AppInstall_2;
                fromPartial(object: {
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    installer?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                }): AppInstall_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnAppInstallServiceName = "devvit.actor.automation.v1alpha.OnAppInstall";

declare interface OnAppUpgrade {
    OnAppUpgrade(request: AppUpgrade_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnAppUpgradeClientImpl implements OnAppUpgrade {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnAppUpgrade(request: AppUpgrade_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnAppUpgradeDefinition = typeof OnAppUpgradeDefinition;

declare const OnAppUpgradeDefinition: {
    readonly name: "OnAppUpgrade";
    readonly fullName: "devvit.actor.automation.v1alpha.OnAppUpgrade";
    readonly methods: {
        readonly onAppUpgrade: {
            readonly name: "OnAppUpgrade";
            readonly requestType: {
                $type: "devvit.events.v1alpha.AppUpgrade";
                encode(message: AppUpgrade_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AppUpgrade_2;
                fromJSON(object: any): AppUpgrade_2;
                toJSON(message: AppUpgrade_2): unknown;
                create(base?: {
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    installer?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                } | undefined): AppUpgrade_2;
                fromPartial(object: {
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    installer?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                }): AppUpgrade_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnAppUpgradeServiceName = "devvit.actor.automation.v1alpha.OnAppUpgrade";

declare interface OnCommentApprove {
    OnCommentApprove(request: CommentApprove, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnCommentApproveClientImpl implements OnCommentApprove {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnCommentApprove(request: CommentApprove, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnCommentApproveDefinition = typeof OnCommentApproveDefinition;

declare const OnCommentApproveDefinition: {
    readonly name: "OnCommentApprove";
    readonly fullName: "devvit.actor.automation.v1alpha.OnCommentApprove";
    readonly methods: {
        readonly onCommentApprove: {
            readonly name: "OnCommentApprove";
            readonly requestType: {
                $type: "devvit.events.v1alpha.CommentApprove";
                encode(message: CommentApprove, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CommentApprove;
                fromJSON(object: any): CommentApprove;
                toJSON(message: CommentApprove): unknown;
                create(base?: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    approvedAt?: Date | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    source?: EventSource_3;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): CommentApprove;
                fromPartial(object: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    approvedAt?: Date | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    source?: EventSource_3;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): CommentApprove;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnCommentApproveServiceName = "devvit.actor.automation.v1alpha.OnCommentApprove";

declare interface OnCommentCreate {
    OnCommentCreate(request: CommentCreate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnCommentCreateClientImpl implements OnCommentCreate {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnCommentCreate(request: CommentCreate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnCommentCreateDefinition = typeof OnCommentCreateDefinition;

declare const OnCommentCreateDefinition: {
    readonly name: "OnCommentCreate";
    readonly fullName: "devvit.actor.automation.v1alpha.OnCommentCreate";
    readonly methods: {
        readonly onCommentCreate: {
            readonly name: "OnCommentCreate";
            readonly requestType: {
                $type: "devvit.events.v1alpha.CommentCreate";
                encode(message: CommentCreate_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CommentCreate_2;
                fromJSON(object: any): CommentCreate_2;
                toJSON(message: CommentCreate_2): unknown;
                create(base?: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): CommentCreate_2;
                fromPartial(object: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): CommentCreate_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnCommentCreateServiceName = "devvit.actor.automation.v1alpha.OnCommentCreate";

declare interface OnCommentDelete {
    OnCommentDelete(request: CommentDelete_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnCommentDeleteClientImpl implements OnCommentDelete {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnCommentDelete(request: CommentDelete_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnCommentDeleteDefinition = typeof OnCommentDeleteDefinition;

declare const OnCommentDeleteDefinition: {
    readonly name: "OnCommentDelete";
    readonly fullName: "devvit.actor.automation.v1alpha.OnCommentDelete";
    readonly methods: {
        readonly onCommentDelete: {
            readonly name: "OnCommentDelete";
            readonly requestType: {
                $type: "devvit.events.v1alpha.CommentDelete";
                encode(message: CommentDelete_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CommentDelete_2;
                fromJSON(object: any): CommentDelete_2;
                toJSON(message: CommentDelete_2): unknown;
                create(base?: {
                    commentId?: string;
                    postId?: string;
                    parentId?: string;
                    deletedAt?: Date | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    createdAt?: Date | undefined;
                    source?: EventSource_3;
                    reason?: DeletionReason_2;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): CommentDelete_2;
                fromPartial(object: {
                    commentId?: string;
                    postId?: string;
                    parentId?: string;
                    deletedAt?: Date | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    createdAt?: Date | undefined;
                    source?: EventSource_3;
                    reason?: DeletionReason_2;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): CommentDelete_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnCommentDeleteServiceName = "devvit.actor.automation.v1alpha.OnCommentDelete";

declare interface OnCommentReport {
    OnCommentReport(request: CommentReport_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnCommentReportClientImpl implements OnCommentReport {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnCommentReport(request: CommentReport_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnCommentReportDefinition = typeof OnCommentReportDefinition;

declare const OnCommentReportDefinition: {
    readonly name: "OnCommentReport";
    readonly fullName: "devvit.actor.automation.v1alpha.OnCommentReport";
    readonly methods: {
        readonly onCommentReport: {
            readonly name: "OnCommentReport";
            readonly requestType: {
                $type: "devvit.events.v1alpha.CommentReport";
                encode(message: CommentReport_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CommentReport_2;
                fromJSON(object: any): CommentReport_2;
                toJSON(message: CommentReport_2): unknown;
                create(base?: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    reason?: string;
                } | undefined): CommentReport_2;
                fromPartial(object: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    reason?: string;
                }): CommentReport_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnCommentReportServiceName = "devvit.actor.automation.v1alpha.OnCommentReport";

declare interface OnCommentSubmit {
    OnCommentSubmit(request: CommentSubmit_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnCommentSubmitClientImpl implements OnCommentSubmit {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnCommentSubmit(request: CommentSubmit_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnCommentSubmitDefinition = typeof OnCommentSubmitDefinition;

declare const OnCommentSubmitDefinition: {
    readonly name: "OnCommentSubmit";
    readonly fullName: "devvit.actor.automation.v1alpha.OnCommentSubmit";
    readonly methods: {
        readonly onCommentSubmit: {
            readonly name: "OnCommentSubmit";
            readonly requestType: {
                $type: "devvit.events.v1alpha.CommentSubmit";
                encode(message: CommentSubmit_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CommentSubmit_2;
                fromJSON(object: any): CommentSubmit_2;
                toJSON(message: CommentSubmit_2): unknown;
                create(base?: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): CommentSubmit_2;
                fromPartial(object: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): CommentSubmit_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnCommentSubmitServiceName = "devvit.actor.automation.v1alpha.OnCommentSubmit";

declare interface OnCommentUpdate {
    OnCommentUpdate(request: CommentUpdate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnCommentUpdateClientImpl implements OnCommentUpdate {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnCommentUpdate(request: CommentUpdate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnCommentUpdateDefinition = typeof OnCommentUpdateDefinition;

declare const OnCommentUpdateDefinition: {
    readonly name: "OnCommentUpdate";
    readonly fullName: "devvit.actor.automation.v1alpha.OnCommentUpdate";
    readonly methods: {
        readonly onCommentUpdate: {
            readonly name: "OnCommentUpdate";
            readonly requestType: {
                $type: "devvit.events.v1alpha.CommentUpdate";
                encode(message: CommentUpdate_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CommentUpdate_2;
                fromJSON(object: any): CommentUpdate_2;
                toJSON(message: CommentUpdate_2): unknown;
                create(base?: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    previousBody?: string;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): CommentUpdate_2;
                fromPartial(object: {
                    comment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    previousBody?: string;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): CommentUpdate_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnCommentUpdateServiceName = "devvit.actor.automation.v1alpha.OnCommentUpdate";

/** Describes a oneof. */
declare interface OneofDescriptorProto {
    name?: string | undefined;
    options?: OneofOptions | undefined;
}

declare const OneofDescriptorProto: {
    $type: "google.protobuf.OneofDescriptorProto";
    encode(message: OneofDescriptorProto, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): OneofDescriptorProto;
    fromJSON(object: any): OneofDescriptorProto;
    toJSON(message: OneofDescriptorProto): unknown;
    create(base?: DeepPartial_104<OneofDescriptorProto>): OneofDescriptorProto;
    fromPartial(object: DeepPartial_104<OneofDescriptorProto>): OneofDescriptorProto;
};

declare interface OneofOptions {
    /** Any features defined in the specific edition. */
    features?: FeatureSet | undefined;
    /** The parser stores options it doesn't recognize here. See above. */
    uninterpretedOption: UninterpretedOption[];
}

declare const OneofOptions: {
    $type: "google.protobuf.OneofOptions";
    encode(message: OneofOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): OneofOptions;
    fromJSON(object: any): OneofOptions;
    toJSON(message: OneofOptions): unknown;
    create(base?: DeepPartial_104<OneofOptions>): OneofOptions;
    fromPartial(object: DeepPartial_104<OneofOptions>): OneofOptions;
};

declare interface OnModAction {
    OnModAction(request: ModAction_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnModActionClientImpl implements OnModAction {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnModAction(request: ModAction_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnModActionDefinition = typeof OnModActionDefinition;

declare const OnModActionDefinition: {
    readonly name: "OnModAction";
    readonly fullName: "devvit.actor.automation.v1alpha.OnModAction";
    readonly methods: {
        readonly onModAction: {
            readonly name: "OnModAction";
            readonly requestType: {
                $type: "devvit.reddit.v2alpha.ModAction";
                encode(message: ModAction_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ModAction_2;
                fromJSON(object: any): ModAction_2;
                toJSON(message: ModAction_2): unknown;
                create(base?: {
                    action?: string | undefined;
                    actionedAt?: Date | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    moderator?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    targetUser?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    targetComment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    targetPost?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                } | undefined): ModAction_2;
                fromPartial(object: {
                    action?: string | undefined;
                    actionedAt?: Date | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    moderator?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    targetUser?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    targetComment?: {
                        id?: string;
                        parentId?: string;
                        body?: string;
                        author?: string;
                        numReports?: number;
                        collapsedBecauseCrowdControl?: boolean;
                        spam?: boolean;
                        deleted?: boolean;
                        createdAt?: number;
                        upvotes?: number;
                        downvotes?: number;
                        languageCode?: string;
                        lastModifiedAt?: number;
                        gilded?: boolean;
                        score?: number;
                        permalink?: string;
                        hasMedia?: boolean;
                        postId?: string;
                        subredditId?: string;
                        elementTypes?: string[];
                    } | undefined;
                    targetPost?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                }): ModAction_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnModActionServiceName = "devvit.actor.automation.v1alpha.OnModAction";

declare interface OnModMail {
    OnModMail(request: ModMail, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnModMailClientImpl implements OnModMail {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnModMail(request: ModMail, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnModMailDefinition = typeof OnModMailDefinition;

declare const OnModMailDefinition: {
    readonly name: "OnModMail";
    readonly fullName: "devvit.actor.automation.v1alpha.OnModMail";
    readonly methods: {
        readonly onModMail: {
            readonly name: "OnModMail";
            readonly requestType: {
                $type: "devvit.reddit.v2alpha.ModMail";
                encode(message: ModMail, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ModMail;
                fromJSON(object: any): ModMail;
                toJSON(message: ModMail): unknown;
                create(base?: {
                    messageAuthor?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    createdAt?: Date | undefined;
                    messageAuthorType?: string;
                    conversationState?: string;
                    conversationType?: string;
                    isAutoGenerated?: boolean;
                    conversationSubreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    destinationSubreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    conversationId?: string;
                    messageId?: string;
                } | undefined): ModMail;
                fromPartial(object: {
                    messageAuthor?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    createdAt?: Date | undefined;
                    messageAuthorType?: string;
                    conversationState?: string;
                    conversationType?: string;
                    isAutoGenerated?: boolean;
                    conversationSubreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    destinationSubreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    conversationId?: string;
                    messageId?: string;
                }): ModMail;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnModMailServiceName = "devvit.actor.automation.v1alpha.OnModMail";

declare interface OnPostApprove {
    OnPostApprove(request: PostApprove, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnPostApproveClientImpl implements OnPostApprove {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnPostApprove(request: PostApprove, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnPostApproveDefinition = typeof OnPostApproveDefinition;

declare const OnPostApproveDefinition: {
    readonly name: "OnPostApprove";
    readonly fullName: "devvit.actor.automation.v1alpha.OnPostApprove";
    readonly methods: {
        readonly onPostApprove: {
            readonly name: "OnPostApprove";
            readonly requestType: {
                $type: "devvit.events.v1alpha.PostApprove";
                encode(message: PostApprove, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostApprove;
                fromJSON(object: any): PostApprove;
                toJSON(message: PostApprove): unknown;
                create(base?: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    approvedAt?: Date | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    source?: EventSource_3;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): PostApprove;
                fromPartial(object: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    approvedAt?: Date | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    source?: EventSource_3;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): PostApprove;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnPostApproveServiceName = "devvit.actor.automation.v1alpha.OnPostApprove";

declare interface OnPostCreate {
    OnPostCreate(request: PostCreate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnPostCreateClientImpl implements OnPostCreate {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnPostCreate(request: PostCreate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnPostCreateDefinition = typeof OnPostCreateDefinition;

declare const OnPostCreateDefinition: {
    readonly name: "OnPostCreate";
    readonly fullName: "devvit.actor.automation.v1alpha.OnPostCreate";
    readonly methods: {
        readonly onPostCreate: {
            readonly name: "OnPostCreate";
            readonly requestType: {
                $type: "devvit.events.v1alpha.PostCreate";
                encode(message: PostCreate_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostCreate_2;
                fromJSON(object: any): PostCreate_2;
                toJSON(message: PostCreate_2): unknown;
                create(base?: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): PostCreate_2;
                fromPartial(object: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): PostCreate_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnPostCreateServiceName = "devvit.actor.automation.v1alpha.OnPostCreate";

declare interface OnPostDelete {
    OnPostDelete(request: PostDelete_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnPostDeleteClientImpl implements OnPostDelete {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnPostDelete(request: PostDelete_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnPostDeleteDefinition = typeof OnPostDeleteDefinition;

declare const OnPostDeleteDefinition: {
    readonly name: "OnPostDelete";
    readonly fullName: "devvit.actor.automation.v1alpha.OnPostDelete";
    readonly methods: {
        readonly onPostDelete: {
            readonly name: "OnPostDelete";
            readonly requestType: {
                $type: "devvit.events.v1alpha.PostDelete";
                encode(message: PostDelete_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostDelete_2;
                fromJSON(object: any): PostDelete_2;
                toJSON(message: PostDelete_2): unknown;
                create(base?: {
                    postId?: string;
                    deletedAt?: Date | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    createdAt?: Date | undefined;
                    source?: EventSource_3;
                    reason?: DeletionReason_2;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): PostDelete_2;
                fromPartial(object: {
                    postId?: string;
                    deletedAt?: Date | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    createdAt?: Date | undefined;
                    source?: EventSource_3;
                    reason?: DeletionReason_2;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): PostDelete_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnPostDeleteServiceName = "devvit.actor.automation.v1alpha.OnPostDelete";

declare interface OnPostFlairUpdate {
    OnPostFlairUpdate(request: PostFlairUpdate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnPostFlairUpdateClientImpl implements OnPostFlairUpdate {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnPostFlairUpdate(request: PostFlairUpdate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnPostFlairUpdateDefinition = typeof OnPostFlairUpdateDefinition;

declare const OnPostFlairUpdateDefinition: {
    readonly name: "OnPostFlairUpdate";
    readonly fullName: "devvit.actor.automation.v1alpha.OnPostFlairUpdate";
    readonly methods: {
        readonly onPostFlairUpdate: {
            readonly name: "OnPostFlairUpdate";
            readonly requestType: {
                $type: "devvit.events.v1alpha.PostFlairUpdate";
                encode(message: PostFlairUpdate_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostFlairUpdate_2;
                fromJSON(object: any): PostFlairUpdate_2;
                toJSON(message: PostFlairUpdate_2): unknown;
                create(base?: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): PostFlairUpdate_2;
                fromPartial(object: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): PostFlairUpdate_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnPostFlairUpdateServiceName = "devvit.actor.automation.v1alpha.OnPostFlairUpdate";

declare interface OnPostReport {
    OnPostReport(request: PostReport_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnPostReportClientImpl implements OnPostReport {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnPostReport(request: PostReport_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnPostReportDefinition = typeof OnPostReportDefinition;

declare const OnPostReportDefinition: {
    readonly name: "OnPostReport";
    readonly fullName: "devvit.actor.automation.v1alpha.OnPostReport";
    readonly methods: {
        readonly onPostReport: {
            readonly name: "OnPostReport";
            readonly requestType: {
                $type: "devvit.events.v1alpha.PostReport";
                encode(message: PostReport_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostReport_2;
                fromJSON(object: any): PostReport_2;
                toJSON(message: PostReport_2): unknown;
                create(base?: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    reason?: string;
                } | undefined): PostReport_2;
                fromPartial(object: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    reason?: string;
                }): PostReport_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnPostReportServiceName = "devvit.actor.automation.v1alpha.OnPostReport";

declare interface OnPostSubmit {
    OnPostSubmit(request: PostSubmit_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnPostSubmitClientImpl implements OnPostSubmit {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnPostSubmit(request: PostSubmit_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnPostSubmitDefinition = typeof OnPostSubmitDefinition;

declare const OnPostSubmitDefinition: {
    readonly name: "OnPostSubmit";
    readonly fullName: "devvit.actor.automation.v1alpha.OnPostSubmit";
    readonly methods: {
        readonly onPostSubmit: {
            readonly name: "OnPostSubmit";
            readonly requestType: {
                $type: "devvit.events.v1alpha.PostSubmit";
                encode(message: PostSubmit_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostSubmit_2;
                fromJSON(object: any): PostSubmit_2;
                toJSON(message: PostSubmit_2): unknown;
                create(base?: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): PostSubmit_2;
                fromPartial(object: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): PostSubmit_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnPostSubmitServiceName = "devvit.actor.automation.v1alpha.OnPostSubmit";

declare interface OnPostUpdate {
    OnPostUpdate(request: PostUpdate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnPostUpdateClientImpl implements OnPostUpdate {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnPostUpdate(request: PostUpdate_2, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnPostUpdateDefinition = typeof OnPostUpdateDefinition;

declare const OnPostUpdateDefinition: {
    readonly name: "OnPostUpdate";
    readonly fullName: "devvit.actor.automation.v1alpha.OnPostUpdate";
    readonly methods: {
        readonly onPostUpdate: {
            readonly name: "OnPostUpdate";
            readonly requestType: {
                $type: "devvit.events.v1alpha.PostUpdate";
                encode(message: PostUpdate_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostUpdate_2;
                fromJSON(object: any): PostUpdate_2;
                toJSON(message: PostUpdate_2): unknown;
                create(base?: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    previousBody?: string;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                } | undefined): PostUpdate_2;
                fromPartial(object: {
                    post?: {
                        id?: string;
                        title?: string;
                        selftext?: string;
                        nsfw?: boolean;
                        authorId?: string;
                        crowdControlLevel?: CrowdControlLevel_2;
                        numReports?: number;
                        isGallery?: boolean;
                        isMeta?: boolean;
                        createdAt?: number;
                        isApproved?: boolean;
                        isArchived?: boolean;
                        distinguished?: DistinguishType_2;
                        ignoreReports?: boolean;
                        isSelf?: boolean;
                        isVideo?: boolean;
                        isLocked?: boolean;
                        isSpoiler?: boolean;
                        subredditId?: string;
                        upvotes?: number;
                        downvotes?: number;
                        url?: string;
                        isSticky?: boolean;
                        linkFlair?: {
                            text?: string;
                            cssClass?: string;
                            backgroundColor?: string;
                            templateId?: string;
                            textColor?: string;
                        } | undefined;
                        authorFlair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        spam?: boolean;
                        deleted?: boolean;
                        languageCode?: string;
                        updatedAt?: number;
                        gildings?: number;
                        score?: number;
                        numComments?: number;
                        thumbnail?: string;
                        media?: {
                            type?: string;
                            oembed?: {
                                type?: string;
                                version?: string;
                                title?: string;
                                description?: string;
                                authorName?: string;
                                authorUrl?: string;
                                providerName?: string;
                                providerUrl?: string;
                                thumbnailUrl?: string;
                                thumbnailWidth?: number;
                                thumbnailHeight?: number;
                                html?: string;
                                width?: number;
                                height?: number;
                            } | undefined;
                            redditVideo?: {
                                bitrateKbps?: number;
                                fallbackUrl?: string;
                                height?: number;
                                width?: number;
                                scrubberMediaUrl?: string;
                                dashUrl?: string;
                                duration?: number;
                                hlsUrl?: string;
                                isGif?: boolean;
                                transcodingStatus?: string;
                            } | undefined;
                        } | undefined;
                        crosspostParentId?: string;
                        permalink?: string;
                        isPoll?: boolean;
                        isPromoted?: boolean;
                        isMultiMedia?: boolean;
                        type?: string;
                        unlisted?: boolean;
                    } | undefined;
                    author?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                    previousBody?: string;
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                }): PostUpdate_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnPostUpdateServiceName = "devvit.actor.automation.v1alpha.OnPostUpdate";

declare interface OnSubredditSubscribe {
    OnSubredditSubscribe(request: SubredditSubscribe, metadata?: Metadata): Promise<HandlerResult>;
}

declare class OnSubredditSubscribeClientImpl implements OnSubredditSubscribe {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_68, opts?: {
        service?: string;
    });
    OnSubredditSubscribe(request: SubredditSubscribe, metadata?: Metadata): Promise<HandlerResult>;
}

declare type OnSubredditSubscribeDefinition = typeof OnSubredditSubscribeDefinition;

declare const OnSubredditSubscribeDefinition: {
    readonly name: "OnSubredditSubscribe";
    readonly fullName: "devvit.actor.automation.v1alpha.OnSubredditSubscribe";
    readonly methods: {
        readonly onSubredditSubscribe: {
            readonly name: "OnSubredditSubscribe";
            readonly requestType: {
                $type: "devvit.events.v1alpha.SubredditSubscribe";
                encode(message: SubredditSubscribe, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditSubscribe;
                fromJSON(object: any): SubredditSubscribe;
                toJSON(message: SubredditSubscribe): unknown;
                create(base?: {
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    subscriber?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                } | undefined): SubredditSubscribe;
                fromPartial(object: {
                    subreddit?: {
                        id?: string;
                        name?: string;
                        nsfw?: boolean;
                        type?: SubredditType_3;
                        spam?: boolean;
                        quarantined?: boolean;
                        topics?: string[];
                        rating?: SubredditRating_2;
                        subscribersCount?: number;
                        permalink?: string;
                    } | undefined;
                    subscriber?: {
                        id?: string;
                        name?: string;
                        isGold?: boolean;
                        snoovatarImage?: string;
                        url?: string;
                        spam?: boolean;
                        banned?: boolean;
                        flair?: {
                            userId?: string;
                            subredditId?: string;
                            text?: string;
                            cssClass?: string;
                            templateId?: string;
                            textColor?: string;
                            backgroundColor?: string;
                            enabled?: boolean;
                        } | undefined;
                        karma?: number;
                        iconImage?: string;
                    } | undefined;
                }): SubredditSubscribe;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.automation.v1alpha.HandlerResult";
                encode(_: HandlerResult, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandlerResult;
                fromJSON(_: any): HandlerResult;
                toJSON(_: HandlerResult): unknown;
                create(base?: DeepPartial_75<HandlerResult>): HandlerResult;
                fromPartial(_: DeepPartial_75<HandlerResult>): HandlerResult;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const OnSubredditSubscribeServiceName = "devvit.actor.automation.v1alpha.OnSubredditSubscribe";

export declare type OnTriggerRequest = protos.PostFlairUpdate | protos.PostSubmit | protos.PostCreate | protos.PostUpdate | protos.PostReport | protos.PostDelete | protos.CommentSubmit | protos.CommentCreate | protos.CommentUpdate | protos.CommentReport | protos.CommentDelete | protos.AppInstall | protos.AppUpgrade | protos.ModAction | protos.ModMail;

export declare type OnValidateHandler<ValueType> = (event: SettingsFormFieldValidatorEvent<ValueType>, context: Devvit.Context) => void | string | Promise<void | string>;

declare interface OrderWidgetsRequest {
    subreddit: string;
    order: string[];
}

declare const OrderWidgetsRequest: {
    $type: "devvit.plugin.redditapi.widgets.OrderWidgetsRequest";
    encode(message: OrderWidgetsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): OrderWidgetsRequest;
    fromJSON(object: any): OrderWidgetsRequest;
    toJSON(message: OrderWidgetsRequest): unknown;
    create(base?: DeepPartial_4<OrderWidgetsRequest>): OrderWidgetsRequest;
    fromPartial(object: DeepPartial_4<OrderWidgetsRequest>): OrderWidgetsRequest;
};

declare interface Organization {
    id: string;
    name: string;
    subscriptions: DataSubscription[];
    tokens: DataToken[];
}

declare const Organization: {
    $type: "devvit.data.api.v1alpha.Organization";
    encode(message: Organization, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Organization;
    fromJSON(object: any): Organization;
    toJSON(message: Organization): unknown;
    create(base?: DeepPartial_52<Organization>): Organization;
    fromPartial(object: DeepPartial_52<Organization>): Organization;
};

/**
 * A dependency use requirement specified by a Bundle or plugin. See
 * Config.use() and DependencySpec.uses. Dependencies may resolve to different
 * implementations in different execution environments.
 */
declare interface PackageQuery {
    /**
     * Limit resolution to a Bundle or plugins (PLUGIN_APP_NAME). Eg,
     * com.devvit.example/foo.
     */
    name?: string | undefined;
    /** Limit resolution to owner. Eg, com.reddit. */
    owner?: string | undefined;
    /**
     * Limit resolution to type. No slashes. Eg,
     * "devvit.plugin.logger.Logger". See Definition.fullName.
     */
    typeName: string;
    /** Limit resolution to versions. Eg, ">=0" or "1.0.0". */
    versions?: string | undefined;
}

declare const PackageQuery: {
    $type: "devvit.runtime.PackageQuery";
    encode(message: PackageQuery, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PackageQuery;
    fromJSON(object: any): PackageQuery;
    toJSON(message: PackageQuery): unknown;
    create(base?: DeepPartial_14<PackageQuery>): PackageQuery;
    fromPartial(object: DeepPartial_14<PackageQuery>): PackageQuery;
};

/**
 * A provided implementation specified by a Bundle or plugin. See
 * Config.provides() and DependencySpec.provides.
 */
declare interface PackageSpec {
    actor?: ActorSpec | undefined;
    /** The version provided. */
    definition?: SerializableServiceDefinition | undefined;
    locations?: LocationFilter | undefined;
    partitionsBy: string[];
}

declare const PackageSpec: {
    $type: "devvit.runtime.PackageSpec";
    encode(message: PackageSpec, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PackageSpec;
    fromJSON(object: any): PackageSpec;
    toJSON(message: PackageSpec): unknown;
    create(base?: DeepPartial_14<PackageSpec>): PackageSpec;
    fromPartial(object: DeepPartial_14<PackageSpec>): PackageSpec;
};

/**
 * @mixin
 */
declare type ParagraphContainer<Context> = {
    /**
     * Append a Paragraph
     * @param cb scoped callback to add child elements to this Paragraph
     */
    paragraph(cb: (paragraph: ParagraphContext) => void): Context;
};

/**
 * @borrows TextContainer
 * @borrows ImageContainer
 * @borrows LinkContainer
 * @borrows LineBreakContainer
 */
declare interface ParagraphContext extends TextContainer<ParagraphContext>, ImageContainer<ParagraphContext>, LinkContainer<ParagraphContext>, LineBreakContainer<ParagraphContext> {
}

/** A paragraph or textarea field */
export declare type ParagraphField = Prettify<BaseField<string> & Omit<FieldConfig_Paragraph, 'maxCharacters'> & {
    type: 'paragraph';
}>;

/**
 * Conversation participant
 */
export declare type Participant = {
    isMod?: boolean;
    isAdmin?: boolean;
    name?: string;
    isOp?: boolean;
    isParticipant?: boolean;
    isApproved?: boolean;
    isHidden?: boolean;
    id?: number;
    isDeleted?: boolean;
};

declare interface Participant_2 {
    isMod?: boolean | undefined;
    isAdmin?: boolean | undefined;
    name?: string | undefined;
    isOp?: boolean | undefined;
    isParticipant?: boolean | undefined;
    isApproved?: boolean | undefined;
    isHidden?: boolean | undefined;
    id?: number | undefined;
    isDeleted?: boolean | undefined;
}

declare const Participant_2: {
    $type: "devvit.plugin.redditapi.newmodmail.Participant";
    encode(message: Participant_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Participant_2;
    fromJSON(object: any): Participant_2;
    toJSON(message: Participant_2): unknown;
    create(base?: DeepPartial_71<Participant_2>): Participant_2;
    fromPartial(object: DeepPartial_71<Participant_2>): Participant_2;
};

declare type ParticipantSubreddit = {
    id: string;
    name: string;
};

declare enum Permission {
    SYSTEM = 0,
    HTTP = 1,
    UNRECOGNIZED = -1
}

declare interface PermissionConfig {
    actor: string;
    has: Permission[];
    requires: PermissionOrRule[];
}

declare const PermissionConfig: {
    $type: "devvit.actor.permissions.PermissionConfig";
    encode(message: PermissionConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PermissionConfig;
    fromJSON(object: any): PermissionConfig;
    toJSON(message: PermissionConfig): unknown;
    create(base?: DeepPartial_110<PermissionConfig>): PermissionConfig;
    fromPartial(object: DeepPartial_110<PermissionConfig>): PermissionConfig;
};

declare function permissionFromJSON(object: any): Permission;

declare interface PermissionList {
    permissions: PermissionConfig[];
}

declare const PermissionList: {
    $type: "devvit.actor.permissions.PermissionList";
    encode(message: PermissionList, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PermissionList;
    fromJSON(object: any): PermissionList;
    toJSON(message: PermissionList): unknown;
    create(base?: DeepPartial_110<PermissionList>): PermissionList;
    fromPartial(object: DeepPartial_110<PermissionList>): PermissionList;
};

declare interface PermissionOrRule {
    permission?: Permission | undefined;
    and?: NestedRule | undefined;
    or?: NestedRule | undefined;
}

declare const PermissionOrRule: {
    $type: "devvit.actor.permissions.PermissionOrRule";
    encode(message: PermissionOrRule, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PermissionOrRule;
    fromJSON(object: any): PermissionOrRule;
    toJSON(message: PermissionOrRule): unknown;
    create(base?: DeepPartial_110<PermissionOrRule>): PermissionOrRule;
    fromPartial(object: DeepPartial_110<PermissionOrRule>): PermissionOrRule;
};

declare function permissionToJSON(object: Permission): number;

declare interface PersistedQueryRequest {
    /** id of a persisted operation */
    id: string;
    /** put the variables here */
    variables?: {
        [key: string]: any;
    } | undefined;
    /** the name of the persisted operation */
    operationName: string;
}

declare const PersistedQueryRequest: {
    $type: "devvit.plugin.redditapi.graphql.PersistedQueryRequest";
    encode(message: PersistedQueryRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PersistedQueryRequest;
    fromJSON(object: any): PersistedQueryRequest;
    toJSON(message: PersistedQueryRequest): unknown;
    create(base?: DeepPartial_57<PersistedQueryRequest>): PersistedQueryRequest;
    fromPartial(object: DeepPartial_57<PersistedQueryRequest>): PersistedQueryRequest;
};

declare interface PingMessage {
    message: string;
    delayMillis: number;
    successProbability: number;
}

declare const PingMessage: {
    $type: "devvit.actor.hello.PingMessage";
    encode(message: PingMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PingMessage;
    fromJSON(object: any): PingMessage;
    toJSON(message: PingMessage): unknown;
    create(base?: DeepPartial_59<PingMessage>): PingMessage;
    fromPartial(object: DeepPartial_59<PingMessage>): PingMessage;
};

declare type PlainText = Text | Link | RedditLink | LineBreak;

/** Playtest app install notification. */
declare interface PlaytestAppInstalled {
}

declare const PlaytestAppInstalled: {
    $type: "devvit.cli.PlaytestAppInstalled";
    encode(_: PlaytestAppInstalled, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlaytestAppInstalled;
    fromJSON(_: any): PlaytestAppInstalled;
    toJSON(_: PlaytestAppInstalled): unknown;
    create(base?: DeepPartial_106<PlaytestAppInstalled>): PlaytestAppInstalled;
    fromPartial(_: DeepPartial_106<PlaytestAppInstalled>): PlaytestAppInstalled;
};

/** Runtime.getCallState() reported by BrowserLiteClient. */
declare interface PlaytestCallState {
    logs: LogMessage[];
}

declare const PlaytestCallState: {
    $type: "devvit.cli.PlaytestCallState";
    encode(message: PlaytestCallState, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlaytestCallState;
    fromJSON(object: any): PlaytestCallState;
    toJSON(message: PlaytestCallState): unknown;
    create(base?: DeepPartial_106<PlaytestCallState>): PlaytestCallState;
    fromPartial(object: DeepPartial_106<PlaytestCallState>): PlaytestCallState;
};

/**
 * Connection details from BrowserLiteClient sent immediately after opening
 * socket.
 */
declare interface PlaytestConnect {
    /**
     * The full web address of the client. Eg,
     * https://www.reddit.com/r/pixelary?playtest=pixelary-game and
     * https://www.reddit.com/r/Pixelary/comments/1agoaja/what_is_this/?playtest&foo=bar.
     */
    url: string;
}

declare const PlaytestConnect: {
    $type: "devvit.cli.PlaytestConnect";
    encode(message: PlaytestConnect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlaytestConnect;
    fromJSON(object: any): PlaytestConnect;
    toJSON(message: PlaytestConnect): unknown;
    create(base?: DeepPartial_106<PlaytestConnect>): PlaytestConnect;
    fromPartial(object: DeepPartial_106<PlaytestConnect>): PlaytestConnect;
};

/** A message from a client (usually embedded in shreddit) to a server. */
declare interface PlaytestProviderMessage {
    callState?: PlaytestCallState | undefined;
    connect?: PlaytestConnect | undefined;
}

declare const PlaytestProviderMessage: {
    $type: "devvit.cli.PlaytestProviderMessage";
    encode(message: PlaytestProviderMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlaytestProviderMessage;
    fromJSON(object: any): PlaytestProviderMessage;
    toJSON(message: PlaytestProviderMessage): unknown;
    create(base?: DeepPartial_106<PlaytestProviderMessage>): PlaytestProviderMessage;
    fromPartial(object: DeepPartial_106<PlaytestProviderMessage>): PlaytestProviderMessage;
};

/** A message from a server (usually the Devvit CLI) to a client. */
declare interface PlaytestSubscriberMessage {
    appInstalled?: PlaytestAppInstalled | undefined;
}

declare const PlaytestSubscriberMessage: {
    $type: "devvit.cli.PlaytestSubscriberMessage";
    encode(message: PlaytestSubscriberMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlaytestSubscriberMessage;
    fromJSON(object: any): PlaytestSubscriberMessage;
    toJSON(message: PlaytestSubscriberMessage): unknown;
    create(base?: DeepPartial_106<PlaytestSubscriberMessage>): PlaytestSubscriberMessage;
    fromPartial(object: DeepPartial_106<PlaytestSubscriberMessage>): PlaytestSubscriberMessage;
};

export declare type PluginSettings = {
    /** Whether the plugin is enabled */
    enabled: boolean;
};

export declare class Post {
    #private;
    get id(): T3ID;
    get authorId(): T2ID | undefined;
    get authorName(): string;
    get subredditId(): T5ID;
    get subredditName(): string;
    get permalink(): string;
    get title(): string;
    get body(): string | undefined;
    get bodyHtml(): string | undefined;
    get url(): string;
    get thumbnail(): {
        url: string;
        height: number;
        width: number;
    } | undefined;
    get createdAt(): Date;
    get score(): number;
    get numberOfComments(): number;
    get numberOfReports(): number;
    get approved(): boolean;
    get spam(): boolean;
    get stickied(): boolean;
    get removed(): boolean;
    /**
     * Who removed this object (username)
     */
    get removedBy(): string | undefined;
    /**
     * who/what removed this object. It will return one of the following:
     * - "anti_evil_ops": object is removed by a aeops member
     * - "author": object is removed by author of the post
     * - "automod_filtered": object is filtered by automod
     * - "community_ops": object is removed by a community team member
     * - "content_takedown": object is removed due to content violation
     * - "copyright_takedown": object is removed due to copyright violation
     * - "deleted": object is deleted
     * - "moderator": object is removed by a mod of the sub
     * - "reddit": object is removed by anyone else
     * - undefined: object is not removed
     */
    get removedByCategory(): string | undefined;
    get archived(): boolean;
    get edited(): boolean;
    get locked(): boolean;
    get nsfw(): boolean;
    get quarantined(): boolean;
    get spoiler(): boolean;
    get hidden(): boolean;
    get ignoringReports(): boolean;
    get distinguishedBy(): string | undefined;
    get comments(): Listing<Comment>;
    get flair(): LinkFlair | undefined;
    get secureMedia(): SecureMedia | undefined;
    get userReportReasons(): string[];
    get modReportReasons(): string[];
    toJSON(): Pick<Post, 'id' | 'authorId' | 'authorName' | 'subredditId' | 'subredditName' | 'permalink' | 'title' | 'body' | 'bodyHtml' | 'url' | 'thumbnail' | 'score' | 'numberOfComments' | 'numberOfReports' | 'createdAt' | 'approved' | 'spam' | 'stickied' | 'removed' | 'removedBy' | 'removedByCategory' | 'archived' | 'edited' | 'locked' | 'nsfw' | 'quarantined' | 'spoiler' | 'hidden' | 'ignoringReports' | 'distinguishedBy' | 'flair' | 'secureMedia' | 'userReportReasons' | 'modReportReasons'>;
    isApproved(): boolean;
    isSpam(): boolean;
    isStickied(): boolean;
    isRemoved(): boolean;
    isArchived(): boolean;
    isEdited(): boolean;
    isLocked(): boolean;
    isNsfw(): boolean;
    isQuarantined(): boolean;
    isSpoiler(): boolean;
    isHidden(): boolean;
    isIgnoringReports(): boolean;
    isDistinguishedBy(): string | undefined;
    edit(options: PostTextOptions): Promise<void>;
    addComment(options: CommentSubmissionOptions): Promise<Comment>;
    delete(): Promise<void>;
    approve(): Promise<void>;
    remove(isSpam?: boolean): Promise<void>;
    lock(): Promise<void>;
    unlock(): Promise<void>;
    hide(): Promise<void>;
    unhide(): Promise<void>;
    markAsNsfw(): Promise<void>;
    unmarkAsNsfw(): Promise<void>;
    markAsSpoiler(): Promise<void>;
    unmarkAsSpoiler(): Promise<void>;
    sticky(position?: 1 | 2 | 3 | 4): Promise<void>;
    unsticky(): Promise<void>;
    distinguish(): Promise<void>;
    distinguishAsAdmin(): Promise<void>;
    undistinguish(): Promise<void>;
    ignoreReports(): Promise<void>;
    unignoreReports(): Promise<void>;
    getAuthor(): Promise<User>;
    crosspost(options: Omit<CrosspostOptions, 'postId'>): Promise<Post>;
    /**
     * Add a mod note for why the post was removed
     *
     * @param options.reasonId id of a Removal Reason - you can leave this as an empty string if you don't have one
     * @param options.modNote the reason for removal (maximum 100 characters) (optional)
     * @returns
     */
    addRemovalNote(options: {
        reasonId: string;
        modNote?: string;
    }): Promise<void>;
}

declare interface Post_2 {
    allAwardings: Awarding[];
    allowLiveComments?: boolean | undefined;
    approved?: boolean | undefined;
    approvedAtUtc?: number | undefined;
    approvedBy?: string | undefined;
    archived?: boolean | undefined;
    author?: string | undefined;
    authorFlairBackgroundColor?: string | undefined;
    authorFlairCssClass?: string | undefined;
    authorFlairRichtext: AuthorFlairRichText[];
    authorFlairTemplateId?: string | undefined;
    authorFlairText?: string | undefined;
    authorFlairTextColor?: string | undefined;
    authorFlairType?: string | undefined;
    authorFullname?: string | undefined;
    authorIsBlocked?: boolean | undefined;
    authorPatreonFlair?: boolean | undefined;
    authorPremium?: boolean | undefined;
    awarders: string[];
    bannedAtUtc?: number | undefined;
    bannedBy?: string | undefined;
    canGild?: boolean | undefined;
    canModPost?: boolean | undefined;
    category?: string | undefined;
    clicked?: boolean | undefined;
    contentCategories: string[];
    contestMode?: boolean | undefined;
    created?: number | undefined;
    createdUtc?: number | undefined;
    discussionType?: string | undefined;
    distinguished?: string | undefined;
    domain?: string | undefined;
    downs?: number | undefined;
    edited?: boolean | undefined;
    gilded?: number | undefined;
    gildings?: Gildings | undefined;
    hidden?: boolean | undefined;
    hideScore?: boolean | undefined;
    id?: string | undefined;
    ignoreReports?: boolean | undefined;
    isCreatedFromAdsUi?: boolean | undefined;
    isCrosspostable?: boolean | undefined;
    isMeta?: boolean | undefined;
    isOriginalContent?: boolean | undefined;
    isRedditMediaDomain?: boolean | undefined;
    isRobotIndexable?: boolean | undefined;
    isSelf?: boolean | undefined;
    isVideo?: boolean | undefined;
    likes?: boolean | undefined;
    linkFlairBackgroundColor?: string | undefined;
    linkFlairCssClass?: string | undefined;
    linkFlairRichtext: string[];
    linkFlairTextColor?: string | undefined;
    linkFlairText?: string | undefined;
    linkFlairType?: string | undefined;
    locked?: boolean | undefined;
    mediaEmbed?: MediaEmbed | undefined;
    mediaOnly?: boolean | undefined;
    media?: Media | undefined;
    modNote?: string | undefined;
    modReasonBy?: string | undefined;
    modReasonTitle?: string | undefined;
    /** array of array of strings :-/ */
    modReports: Array<any>[];
    name?: string | undefined;
    noFollow?: boolean | undefined;
    numComments?: number | undefined;
    numCrossposts?: number | undefined;
    numDuplicates?: number | undefined;
    numReports?: number | undefined;
    over18?: boolean | undefined;
    parentWhitelistStatus?: string | undefined;
    permalink?: string | undefined;
    pinned?: boolean | undefined;
    postHint?: string | undefined;
    preview?: Preview | undefined;
    pwls?: number | undefined;
    quarantine?: boolean | undefined;
    removalReason?: string | undefined;
    removedByCategory?: string | undefined;
    removedBy?: string | undefined;
    removed?: boolean | undefined;
    reportReasons: string[];
    rteMode?: string | undefined;
    saved?: boolean | undefined;
    score?: number | undefined;
    secureMediaEmbed?: MediaEmbed | undefined;
    secureMedia?: Media | undefined;
    selftextHtml?: string | undefined;
    selftext?: string | undefined;
    sendReplies?: boolean | undefined;
    spam?: boolean | undefined;
    spoiler?: boolean | undefined;
    stickied?: boolean | undefined;
    subredditId?: string | undefined;
    subredditNamePrefixed?: string | undefined;
    subredditSubscribers?: number | undefined;
    subredditType?: string | undefined;
    subreddit?: string | undefined;
    suggestedSort?: string | undefined;
    thumbnailHeight?: number | undefined;
    thumbnailWidth?: number | undefined;
    thumbnail?: string | undefined;
    title?: string | undefined;
    topAwardedType?: string | undefined;
    totalAwardsReceived?: number | undefined;
    treatmentTags: string[];
    ups?: number | undefined;
    upvoteRatio?: number | undefined;
    urlOverriddenByDest?: string | undefined;
    url?: string | undefined;
    /** array of array of strings :-/ */
    userReports: Array<any>[];
    viewCount?: number | undefined;
    visited?: boolean | undefined;
    whitelistStatus?: string | undefined;
    wls?: number | undefined;
    /** properties for automod invocation */
    linkFlairTemplateId?: string | undefined;
    crowdControlLevel?: number | undefined;
    isGallery?: boolean | undefined;
    isLiveStream?: boolean | undefined;
    isMetaDiscussion?: boolean | undefined;
    oembed?: OEmbed_2 | undefined;
    banInfo?: BanInfo | undefined;
    /** PRIVATE - DO NOT SET FOR PUBLIC USE */
    markedSpam?: boolean | undefined;
    /** properties for automod invocation */
    verdict?: string | undefined;
    gallery?: RedditPostGallery | undefined;
}

declare const Post_2: {
    $type: "devvit.reddit.Post";
    encode(message: Post_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Post_2;
    fromJSON(object: any): Post_2;
    toJSON(message: Post_2): unknown;
    create(base?: DeepPartial_82<Post_2>): Post_2;
    fromPartial(object: DeepPartial_82<Post_2>): Post_2;
};

declare const POST_LINK_ELEMENT = "p/";

declare interface PostApprove {
    post?: PostV2 | undefined;
    approvedAt?: Date | undefined;
    author?: UserV2 | undefined;
    source: EventSource_2;
    subreddit?: SubredditV2 | undefined;
}

declare const PostApprove: {
    $type: "devvit.events.v1alpha.PostApprove";
    encode(message: PostApprove, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostApprove;
    fromJSON(object: any): PostApprove;
    toJSON(message: PostApprove): unknown;
    create(base?: DeepPartial_74<PostApprove>): PostApprove;
    fromPartial(object: DeepPartial_74<PostApprove>): PostApprove;
};

export declare class PostCollection {
    #private;
    /**
     * The ID of the collection
     */
    get id(): string;
    /**
     * The subreddit ID of the subreddit where the collection belongs.
     */
    get subredditId(): string;
    /**
     * The title of the collection.
     */
    get title(): string;
    /**
     * The description of the collection.
     */
    get description(): string;
    /**
     * The user ID of the author of the collection.
     */
    get authorId(): string;
    /**
     * The username of the author of the collection.
     */
    get authorName(): string;
    /**
     * The permalink to the collection.
     */
    get permalink(): string | undefined;
    /**
     * The primaryLinkId in the collection.
     */
    get primaryLinkId(): string | undefined;
    /**
     * The post IDs of the posts in the collection.
     */
    get linkIds(): string[];
    /**
     * The timestamp when this collection was created.
     */
    get createdAtUtc(): Date;
    /**
     * The timestamp when this collection was last updated.
     */
    get lastUpdateUtc(): Date;
    /**
     * The layout used to display this collection in the UI.
     */
    get displayLayout(): CollectionDisplayLayout;
    /**
     * Adds a post to the collection.
     *
     * @param postId The id of the post to add to the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.addPost("t3_asd")
     * ```
     */
    addPost(postId: string): Promise<void>;
    /**
     * Remove a post from the collection.
     *
     * @param postId The id of the post to add to the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.removePost("t3_asd")
     * ```
     */
    removePost(postId: string): Promise<void>;
    /**
     * Deletes the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.delete()
     * ```
     */
    delete(): Promise<void>;
    /**
     * Follows the collection.
     *
     * @param follow True to follow the collection, false to unfollow the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * // Follow the collection
     * await collection.follow(true)
     * // Unfollow the collection
     * await collection.follow(false)
     * ```
     */
    follow(follow: boolean): Promise<void>;
    /**
     * Sets the order of the posts in the collection.
     *
     * @param postIds Array of post ids that determins the order of the posts in the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.reorder(["t3_asd", "t3_fgh"])
     * ```
     */
    reorder(postIds: string[]): Promise<void>;
    /**
     * Sets the title of the collection.
     *
     * @param title The new title of the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.updateTitle("Dogs")
     * ```
     */
    updateTitle(title: string): Promise<void>;
    /**
     * Sets the description of the collection.
     *
     * @param description The new description of the collection.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.updateDescription("Posts about dogs")
     * ```
     */
    updateDescription(description: string): Promise<void>;
    /**
     * Sets the display layout of the collection
     *
     * @param displayLayout One of: TIMELINE | GALLERY. This determines the layout of posts in the collection UI.
     *
     * @returns Void
     *
     * @example
     * ```ts
     * const collection = await reddit.getCollectionById("198febf6-084c-4a21-bdbd-a014e5fd0d4d")
     * await collection.updateLayout("GALLERY")
     * ```
     */
    updateLayout(displayLayout: CollectionDisplayLayout): Promise<void>;
}

/** COLLECTIONS - https://www.reddit.com/dev/api#section_collections */
declare interface PostCollections {
    /** https://www.reddit.com/dev/api/#GET_api_v1_collections_collection */
    Collection(request: CollectionRequest, metadata?: Metadata): Promise<CollectionResponse>;
    /** https://www.reddit.com/dev/api/#GET_api_v1_collections_subreddit_collections */
    SubredditCollections(request: SubredditCollectionsRequest, metadata?: Metadata): Promise<SubredditCollectionsResponse>;
    /** https://www.reddit.com/dev/api/#POST_api_v1_collections_create_collection */
    Create(request: CreateCollectionRequest, metadata?: Metadata): Promise<CollectionResponse>;
    /** https://www.reddit.com/dev/api/#POST_api_v1_collections_delete_collection */
    Delete(request: DeleteCollectionRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api/#POST_api_v1_collections_add_post_to_collection */
    AddPost(request: AddPostToCollectionRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api/#POST_api_v1_collections_remove_post_in_collection */
    RemovePost(request: RemovePostInCollectionRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api/#POST_api_v1_collections_follow_collection */
    Follow(request: FollowCollectionRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api/#POST_api_v1_collections_reorder_collection */
    Reorder(request: ReorderCollectionRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api/#POST_api_v1_collections_update_collection_title */
    UpdateTitle(request: UpdateCollectionTitleRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api/#POST_api_v1_collections_update_collection_description */
    UpdateDescription(request: UpdateCollectionDescriptionRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api/#POST_api_v1_collections_update_collection_display_layout */
    UpdateDisplayLayout(request: UpdateCollectionDisplayLayoutRequest, metadata?: Metadata): Promise<Empty>;
}

declare class PostCollectionsClientImpl implements PostCollections {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_53, opts?: {
        service?: string;
    });
    Collection(request: CollectionRequest, metadata?: Metadata): Promise<CollectionResponse>;
    SubredditCollections(request: SubredditCollectionsRequest, metadata?: Metadata): Promise<SubredditCollectionsResponse>;
    Create(request: CreateCollectionRequest, metadata?: Metadata): Promise<CollectionResponse>;
    Delete(request: DeleteCollectionRequest, metadata?: Metadata): Promise<Empty>;
    AddPost(request: AddPostToCollectionRequest, metadata?: Metadata): Promise<Empty>;
    RemovePost(request: RemovePostInCollectionRequest, metadata?: Metadata): Promise<Empty>;
    Follow(request: FollowCollectionRequest, metadata?: Metadata): Promise<Empty>;
    Reorder(request: ReorderCollectionRequest, metadata?: Metadata): Promise<Empty>;
    UpdateTitle(request: UpdateCollectionTitleRequest, metadata?: Metadata): Promise<Empty>;
    UpdateDescription(request: UpdateCollectionDescriptionRequest, metadata?: Metadata): Promise<Empty>;
    UpdateDisplayLayout(request: UpdateCollectionDisplayLayoutRequest, metadata?: Metadata): Promise<Empty>;
}

/** COLLECTIONS - https://www.reddit.com/dev/api#section_collections */
declare type PostCollectionsDefinition = typeof PostCollectionsDefinition;

declare const PostCollectionsDefinition: {
    readonly name: "PostCollections";
    readonly fullName: "devvit.plugin.redditapi.postcollections.PostCollections";
    readonly methods: {
        /** https://www.reddit.com/dev/api/#GET_api_v1_collections_collection */
        readonly collection: {
            readonly name: "Collection";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.CollectionRequest";
                encode(message: CollectionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CollectionRequest;
                fromJSON(object: any): CollectionRequest;
                toJSON(message: CollectionRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    includeLinks?: boolean | undefined;
                } | undefined): CollectionRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    includeLinks?: boolean | undefined;
                }): CollectionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.postcollections.CollectionResponse";
                encode(message: CollectionResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CollectionResponse;
                fromJSON(object: any): CollectionResponse;
                toJSON(message: CollectionResponse): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    subredditId?: string | undefined;
                    title?: string | undefined;
                    description?: string | undefined;
                    authorId?: string | undefined;
                    authorName?: string | undefined;
                    permalink?: string | undefined;
                    linkIds?: string[];
                    primaryLinkId?: string | undefined;
                    displayLayout?: string | undefined;
                    createdAtUtc?: Date | undefined;
                    lastUpdateUtc?: Date | undefined;
                } | undefined): CollectionResponse;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    subredditId?: string | undefined;
                    title?: string | undefined;
                    description?: string | undefined;
                    authorId?: string | undefined;
                    authorName?: string | undefined;
                    permalink?: string | undefined;
                    linkIds?: string[];
                    primaryLinkId?: string | undefined;
                    displayLayout?: string | undefined;
                    createdAtUtc?: Date | undefined;
                    lastUpdateUtc?: Date | undefined;
                }): CollectionResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#GET_api_v1_collections_subreddit_collections */
        readonly subredditCollections: {
            readonly name: "SubredditCollections";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsRequest";
                encode(message: SubredditCollectionsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditCollectionsRequest;
                fromJSON(object: any): SubredditCollectionsRequest;
                toJSON(message: SubredditCollectionsRequest): unknown;
                create(base?: {
                    srFullname?: string | undefined;
                } | undefined): SubredditCollectionsRequest;
                fromPartial(object: {
                    srFullname?: string | undefined;
                }): SubredditCollectionsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsResponse";
                encode(message: SubredditCollectionsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditCollectionsResponse;
                fromJSON(object: any): SubredditCollectionsResponse;
                toJSON(message: SubredditCollectionsResponse): unknown;
                create(base?: {
                    collections?: {
                        collectionId?: string | undefined;
                        subredditId?: string | undefined;
                        title?: string | undefined;
                        description?: string | undefined;
                        authorId?: string | undefined;
                        authorName?: string | undefined;
                        permalink?: string | undefined;
                        linkIds?: string[];
                        primaryLinkId?: string | undefined;
                        displayLayout?: string | undefined;
                        createdAtUtc?: Date | undefined;
                        lastUpdateUtc?: Date | undefined;
                    }[];
                } | undefined): SubredditCollectionsResponse;
                fromPartial(object: {
                    collections?: {
                        collectionId?: string | undefined;
                        subredditId?: string | undefined;
                        title?: string | undefined;
                        description?: string | undefined;
                        authorId?: string | undefined;
                        authorName?: string | undefined;
                        permalink?: string | undefined;
                        linkIds?: string[];
                        primaryLinkId?: string | undefined;
                        displayLayout?: string | undefined;
                        createdAtUtc?: Date | undefined;
                        lastUpdateUtc?: Date | undefined;
                    }[];
                }): SubredditCollectionsResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#POST_api_v1_collections_create_collection */
        readonly create: {
            readonly name: "Create";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.CreateCollectionRequest";
                encode(message: CreateCollectionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CreateCollectionRequest;
                fromJSON(object: any): CreateCollectionRequest;
                toJSON(message: CreateCollectionRequest): unknown;
                create(base?: {
                    title?: string | undefined;
                    srFullname?: string | undefined;
                    description?: string | undefined;
                    displayLayout?: string | undefined;
                } | undefined): CreateCollectionRequest;
                fromPartial(object: {
                    title?: string | undefined;
                    srFullname?: string | undefined;
                    description?: string | undefined;
                    displayLayout?: string | undefined;
                }): CreateCollectionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.postcollections.CollectionResponse";
                encode(message: CollectionResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CollectionResponse;
                fromJSON(object: any): CollectionResponse;
                toJSON(message: CollectionResponse): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    subredditId?: string | undefined;
                    title?: string | undefined;
                    description?: string | undefined;
                    authorId?: string | undefined;
                    authorName?: string | undefined;
                    permalink?: string | undefined;
                    linkIds?: string[];
                    primaryLinkId?: string | undefined;
                    displayLayout?: string | undefined;
                    createdAtUtc?: Date | undefined;
                    lastUpdateUtc?: Date | undefined;
                } | undefined): CollectionResponse;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    subredditId?: string | undefined;
                    title?: string | undefined;
                    description?: string | undefined;
                    authorId?: string | undefined;
                    authorName?: string | undefined;
                    permalink?: string | undefined;
                    linkIds?: string[];
                    primaryLinkId?: string | undefined;
                    displayLayout?: string | undefined;
                    createdAtUtc?: Date | undefined;
                    lastUpdateUtc?: Date | undefined;
                }): CollectionResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#POST_api_v1_collections_delete_collection */
        readonly delete: {
            readonly name: "Delete";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.DeleteCollectionRequest";
                encode(message: DeleteCollectionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DeleteCollectionRequest;
                fromJSON(object: any): DeleteCollectionRequest;
                toJSON(message: DeleteCollectionRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                } | undefined): DeleteCollectionRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                }): DeleteCollectionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#POST_api_v1_collections_add_post_to_collection */
        readonly addPost: {
            readonly name: "AddPost";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.AddPostToCollectionRequest";
                encode(message: AddPostToCollectionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AddPostToCollectionRequest;
                fromJSON(object: any): AddPostToCollectionRequest;
                toJSON(message: AddPostToCollectionRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    linkFullname?: string | undefined;
                } | undefined): AddPostToCollectionRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    linkFullname?: string | undefined;
                }): AddPostToCollectionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#POST_api_v1_collections_remove_post_in_collection */
        readonly removePost: {
            readonly name: "RemovePost";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.RemovePostInCollectionRequest";
                encode(message: RemovePostInCollectionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): RemovePostInCollectionRequest;
                fromJSON(object: any): RemovePostInCollectionRequest;
                toJSON(message: RemovePostInCollectionRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    linkFullname?: string | undefined;
                } | undefined): RemovePostInCollectionRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    linkFullname?: string | undefined;
                }): RemovePostInCollectionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#POST_api_v1_collections_follow_collection */
        readonly follow: {
            readonly name: "Follow";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.FollowCollectionRequest";
                encode(message: FollowCollectionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FollowCollectionRequest;
                fromJSON(object: any): FollowCollectionRequest;
                toJSON(message: FollowCollectionRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    follow?: boolean | undefined;
                } | undefined): FollowCollectionRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    follow?: boolean | undefined;
                }): FollowCollectionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#POST_api_v1_collections_reorder_collection */
        readonly reorder: {
            readonly name: "Reorder";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.ReorderCollectionRequest";
                encode(message: ReorderCollectionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ReorderCollectionRequest;
                fromJSON(object: any): ReorderCollectionRequest;
                toJSON(message: ReorderCollectionRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    linkIds?: string | undefined;
                } | undefined): ReorderCollectionRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    linkIds?: string | undefined;
                }): ReorderCollectionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#POST_api_v1_collections_update_collection_title */
        readonly updateTitle: {
            readonly name: "UpdateTitle";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionTitleRequest";
                encode(message: UpdateCollectionTitleRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateCollectionTitleRequest;
                fromJSON(object: any): UpdateCollectionTitleRequest;
                toJSON(message: UpdateCollectionTitleRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    title?: string | undefined;
                } | undefined): UpdateCollectionTitleRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    title?: string | undefined;
                }): UpdateCollectionTitleRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#POST_api_v1_collections_update_collection_description */
        readonly updateDescription: {
            readonly name: "UpdateDescription";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDescriptionRequest";
                encode(message: UpdateCollectionDescriptionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateCollectionDescriptionRequest;
                fromJSON(object: any): UpdateCollectionDescriptionRequest;
                toJSON(message: UpdateCollectionDescriptionRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    description?: string | undefined;
                } | undefined): UpdateCollectionDescriptionRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    description?: string | undefined;
                }): UpdateCollectionDescriptionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api/#POST_api_v1_collections_update_collection_display_layout */
        readonly updateDisplayLayout: {
            readonly name: "UpdateDisplayLayout";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDisplayLayoutRequest";
                encode(message: UpdateCollectionDisplayLayoutRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateCollectionDisplayLayoutRequest;
                fromJSON(object: any): UpdateCollectionDisplayLayoutRequest;
                toJSON(message: UpdateCollectionDisplayLayoutRequest): unknown;
                create(base?: {
                    collectionId?: string | undefined;
                    displayLayout?: string | undefined;
                } | undefined): UpdateCollectionDisplayLayoutRequest;
                fromPartial(object: {
                    collectionId?: string | undefined;
                    displayLayout?: string | undefined;
                }): UpdateCollectionDisplayLayoutRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const PostCollectionsServiceName = "devvit.plugin.redditapi.postcollections.PostCollections";

/** The event name for when a post is created, after safety delay */
export declare type PostCreate = 'PostCreate';

declare interface PostCreate_2 {
    post?: PostV2 | undefined;
    author?: UserV2 | undefined;
    subreddit?: SubredditV2 | undefined;
}

declare const PostCreate_2: {
    $type: "devvit.events.v1alpha.PostCreate";
    encode(message: PostCreate_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostCreate_2;
    fromJSON(object: any): PostCreate_2;
    toJSON(message: PostCreate_2): unknown;
    create(base?: DeepPartial_74<PostCreate_2>): PostCreate_2;
    fromPartial(object: DeepPartial_74<PostCreate_2>): PostCreate_2;
};

export declare type PostCreateDefinition = {
    event: PostCreate;
    onEvent: TriggerOnEventHandler<protos.PostCreate>;
};

/** The event name for when a post is deleted */
export declare type PostDelete = 'PostDelete';

declare interface PostDelete_2 {
    postId: string;
    deletedAt?: Date | undefined;
    author?: UserV2 | undefined;
    createdAt?: Date | undefined;
    source: EventSource_2;
    reason: DeletionReason;
    subreddit?: SubredditV2 | undefined;
}

declare const PostDelete_2: {
    $type: "devvit.events.v1alpha.PostDelete";
    encode(message: PostDelete_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostDelete_2;
    fromJSON(object: any): PostDelete_2;
    toJSON(message: PostDelete_2): unknown;
    create(base?: DeepPartial_74<PostDelete_2>): PostDelete_2;
    fromPartial(object: DeepPartial_74<PostDelete_2>): PostDelete_2;
};

export declare type PostDeleteDefinition = {
    event: PostDelete;
    onEvent: TriggerOnEventHandler<protos.PostDelete>;
};

declare interface PostFilter {
    Filter(request: PostFilterRequest, metadata?: Metadata): Promise<Response_2>;
}

declare class PostFilterClientImpl implements PostFilter {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_37, opts?: {
        service?: string;
    });
    Filter(request: PostFilterRequest, metadata?: Metadata): Promise<Response_2>;
}

declare type PostFilterDefinition = typeof PostFilterDefinition;

declare const PostFilterDefinition: {
    readonly name: "PostFilter";
    readonly fullName: "devvit.actor.reddit.PostFilter";
    readonly methods: {
        readonly filter: {
            readonly name: "Filter";
            readonly requestType: {
                $type: "devvit.actor.reddit.PostFilterRequest";
                encode(message: PostFilterRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): PostFilterRequest;
                fromJSON(object: any): PostFilterRequest;
                toJSON(message: PostFilterRequest): unknown;
                create(base?: DeepPartial_83<PostFilterRequest>): PostFilterRequest;
                fromPartial(object: DeepPartial_83<PostFilterRequest>): PostFilterRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.reddit.Response";
                encode(message: Response_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): Response_2;
                fromJSON(object: any): Response_2;
                toJSON(message: Response_2): unknown;
                create(base?: DeepPartial_83<Response_2>): Response_2;
                fromPartial(object: DeepPartial_83<Response_2>): Response_2;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare interface PostFilterRequest {
    post?: Post_2 | undefined;
}

declare const PostFilterRequest: {
    $type: "devvit.actor.reddit.PostFilterRequest";
    encode(message: PostFilterRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostFilterRequest;
    fromJSON(object: any): PostFilterRequest;
    toJSON(message: PostFilterRequest): unknown;
    create(base?: DeepPartial_83<PostFilterRequest>): PostFilterRequest;
    fromPartial(object: DeepPartial_83<PostFilterRequest>): PostFilterRequest;
};

declare const PostFilterServiceName = "devvit.actor.reddit.PostFilter";

/** The event name for when the flair of a post is updated */
export declare type PostFlairUpdate = 'PostFlairUpdate';

declare interface PostFlairUpdate_2 {
    post?: PostV2 | undefined;
    author?: UserV2 | undefined;
    subreddit?: SubredditV2 | undefined;
}

declare const PostFlairUpdate_2: {
    $type: "devvit.events.v1alpha.PostFlairUpdate";
    encode(message: PostFlairUpdate_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostFlairUpdate_2;
    fromJSON(object: any): PostFlairUpdate_2;
    toJSON(message: PostFlairUpdate_2): unknown;
    create(base?: DeepPartial_74<PostFlairUpdate_2>): PostFlairUpdate_2;
    fromPartial(object: DeepPartial_74<PostFlairUpdate_2>): PostFlairUpdate_2;
};

export declare type PostFlairUpdateDefinition = {
    event: PostFlairUpdate;
    onEvent: TriggerOnEventHandler<protos.PostFlairUpdate>;
};

export declare class PostFlairWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get styles(): WidgetStyles;
    get templates(): GetWidgetsResponse_WidgetItem_PostFlairTemplate[];
    get display(): 'list' | 'cloud';
    toJSON(): ReturnType<Widget['toJSON']> & Pick<PostFlairWidget, 'templates' | 'display' | 'styles'>;
}

declare interface PostFlairWidget_2 {
    id: string;
    kind: string;
    display: string;
    order: string[];
    shortName: string;
    styles?: WidgetStyles | undefined;
    subreddit?: string | undefined;
}

declare const PostFlairWidget_2: {
    $type: "devvit.plugin.redditapi.widgets.PostFlairWidget";
    encode(message: PostFlairWidget_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostFlairWidget_2;
    fromJSON(object: any): PostFlairWidget_2;
    toJSON(message: PostFlairWidget_2): unknown;
    create(base?: DeepPartial_4<PostFlairWidget_2>): PostFlairWidget_2;
    fromPartial(object: DeepPartial_4<PostFlairWidget_2>): PostFlairWidget_2;
};

declare type PostLink = {
    e: typeof POST_LINK_ELEMENT;
    t: string;
};

/**
 * @borrows RedditPermalinkOptions
 */
declare type PostLinkOptions = RedditPermalinkOptions;

declare interface PostModNotesResponse {
    created?: ModNoteObject | undefined;
}

declare const PostModNotesResponse: {
    $type: "devvit.plugin.redditapi.modnote.PostModNotesResponse";
    encode(message: PostModNotesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostModNotesResponse;
    fromJSON(object: any): PostModNotesResponse;
    toJSON(message: PostModNotesResponse): unknown;
    create(base?: DeepPartial_3<PostModNotesResponse>): PostModNotesResponse;
    fromPartial(object: DeepPartial_3<PostModNotesResponse>): PostModNotesResponse;
};

declare interface PostNotesRequest {
    subreddit: string;
    /** (optional) one of (BOT_BAN, PERMA_BAN, BAN, ABUSE_WARNING, SPAM_WARNING, SPAM_WATCH, SOLID_CONTRIBUTOR, HELPFUL_USER) */
    label: string;
    /** Content of the note, should be a string with a maximum character limit of 250 */
    note: string;
    /** (optional) a fullname of a comment or post (should have either a t1 or t3 prefix) */
    redditId?: string | undefined;
    /** account username */
    user: string;
}

declare const PostNotesRequest: {
    $type: "devvit.plugin.redditapi.modnote.PostNotesRequest";
    encode(message: PostNotesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostNotesRequest;
    fromJSON(object: any): PostNotesRequest;
    toJSON(message: PostNotesRequest): unknown;
    create(base?: DeepPartial_3<PostNotesRequest>): PostNotesRequest;
    fromPartial(object: DeepPartial_3<PostNotesRequest>): PostNotesRequest;
};

declare interface PostRemovalNoteRequest {
    /** list of thing ids */
    itemIds: string[];
    /** id of a Removal Reason - you can leave this as an empty string if you don't have one */
    reasonId: string;
    /** the reason for removal (maximum 100 characters) */
    modNote?: string | undefined;
}

declare const PostRemovalNoteRequest: {
    $type: "devvit.plugin.redditapi.modnote.PostRemovalNoteRequest";
    encode(message: PostRemovalNoteRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostRemovalNoteRequest;
    fromJSON(object: any): PostRemovalNoteRequest;
    toJSON(message: PostRemovalNoteRequest): unknown;
    create(base?: DeepPartial_3<PostRemovalNoteRequest>): PostRemovalNoteRequest;
    fromPartial(object: DeepPartial_3<PostRemovalNoteRequest>): PostRemovalNoteRequest;
};

/** The event name for when a post is reported */
export declare type PostReport = 'PostReport';

declare interface PostReport_2 {
    post?: PostV2 | undefined;
    subreddit?: SubredditV2 | undefined;
    reason: string;
}

declare const PostReport_2: {
    $type: "devvit.events.v1alpha.PostReport";
    encode(message: PostReport_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostReport_2;
    fromJSON(object: any): PostReport_2;
    toJSON(message: PostReport_2): unknown;
    create(base?: DeepPartial_74<PostReport_2>): PostReport_2;
    fromPartial(object: DeepPartial_74<PostReport_2>): PostReport_2;
};

export declare type PostReportDefinition = {
    event: PostReport;
    onEvent: TriggerOnEventHandler<protos.PostReport>;
};

/** The event name for when a post is submitted */
export declare type PostSubmit = 'PostSubmit';

declare interface PostSubmit_2 {
    post?: PostV2 | undefined;
    author?: UserV2 | undefined;
    subreddit?: SubredditV2 | undefined;
}

declare const PostSubmit_2: {
    $type: "devvit.events.v1alpha.PostSubmit";
    encode(message: PostSubmit_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostSubmit_2;
    fromJSON(object: any): PostSubmit_2;
    toJSON(message: PostSubmit_2): unknown;
    create(base?: DeepPartial_74<PostSubmit_2>): PostSubmit_2;
    fromPartial(object: DeepPartial_74<PostSubmit_2>): PostSubmit_2;
};

export declare type PostSubmitDefinition = {
    event: PostSubmit;
    onEvent: TriggerOnEventHandler<protos.PostSubmit>;
};

export declare type PostTextOptions = {
    text: string;
} | {
    richtext: object | RichTextBuilder;
};

/** The event name for when a post is updated */
export declare type PostUpdate = 'PostUpdate';

declare interface PostUpdate_2 {
    post?: PostV2 | undefined;
    author?: UserV2 | undefined;
    previousBody: string;
    subreddit?: SubredditV2 | undefined;
}

declare const PostUpdate_2: {
    $type: "devvit.events.v1alpha.PostUpdate";
    encode(message: PostUpdate_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostUpdate_2;
    fromJSON(object: any): PostUpdate_2;
    toJSON(message: PostUpdate_2): unknown;
    create(base?: DeepPartial_74<PostUpdate_2>): PostUpdate_2;
    fromPartial(object: DeepPartial_74<PostUpdate_2>): PostUpdate_2;
};

export declare type PostUpdateDefinition = {
    event: PostUpdate;
    onEvent: TriggerOnEventHandler<protos.PostUpdate>;
};

declare interface PostV2 {
    id: string;
    title: string;
    /** rename to text? */
    selftext: string;
    nsfw: boolean;
    authorId: string;
    crowdControlLevel: CrowdControlLevel;
    numReports: number;
    isGallery: boolean;
    isMeta: boolean;
    createdAt: number;
    isApproved: boolean;
    isArchived: boolean;
    distinguished: DistinguishType;
    ignoreReports: boolean;
    isSelf: boolean;
    isVideo: boolean;
    isLocked: boolean;
    isSpoiler: boolean;
    subredditId: string;
    upvotes: number;
    downvotes: number;
    url: string;
    isSticky: boolean;
    linkFlair?: LinkFlairV2 | undefined;
    authorFlair?: UserFlairV2 | undefined;
    spam: boolean;
    deleted: boolean;
    languageCode: string;
    updatedAt: number;
    gildings: number;
    score: number;
    numComments: number;
    thumbnail: string;
    media?: MediaObject | undefined;
    crosspostParentId: string;
    permalink: string;
    isPoll: boolean;
    isPromoted: boolean;
    isMultiMedia: boolean;
    type: string;
    unlisted: boolean;
}

declare const PostV2: {
    $type: "devvit.reddit.v2alpha.PostV2";
    encode(message: PostV2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PostV2;
    fromJSON(object: any): PostV2;
    toJSON(message: PostV2): unknown;
    create(base?: DeepPartial_78<PostV2>): PostV2;
    fromPartial(object: DeepPartial_78<PostV2>): PostV2;
};

/**
 * @borrows PrefixedRedditLinkOptions
 */
declare type PrefixedRedditLinkOptions = {
    /** Whether to render a type prefix on the link (such as "r/" or "u/") */
    showPrefix: boolean;
};

declare type Prettify<T> = {
    [K in keyof T]: T[K];
};

declare interface Preview {
    enabled?: boolean | undefined;
    images: Preview_PreviewImage[];
}

declare const Preview: {
    $type: "devvit.reddit.Preview";
    encode(message: Preview, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Preview;
    fromJSON(object: any): Preview;
    toJSON(message: Preview): unknown;
    create(base?: DeepPartial_82<Preview>): Preview;
    fromPartial(object: DeepPartial_82<Preview>): Preview;
};

declare interface Preview_PreviewImage {
    id?: string | undefined;
    resolutions: Preview_PreviewImage_Image[];
    source?: Preview_PreviewImage_Image | undefined;
    variants?: Preview_PreviewImage_Image | undefined;
}

declare const Preview_PreviewImage: {
    $type: "devvit.reddit.Preview.PreviewImage";
    encode(message: Preview_PreviewImage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Preview_PreviewImage;
    fromJSON(object: any): Preview_PreviewImage;
    toJSON(message: Preview_PreviewImage): unknown;
    create(base?: DeepPartial_82<Preview_PreviewImage>): Preview_PreviewImage;
    fromPartial(object: DeepPartial_82<Preview_PreviewImage>): Preview_PreviewImage;
};

declare interface Preview_PreviewImage_Image {
    height?: number | undefined;
    url?: string | undefined;
    width?: number | undefined;
}

declare const Preview_PreviewImage_Image: {
    $type: "devvit.reddit.Preview.PreviewImage.Image";
    encode(message: Preview_PreviewImage_Image, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Preview_PreviewImage_Image;
    fromJSON(object: any): Preview_PreviewImage_Image;
    toJSON(message: Preview_PreviewImage_Image): unknown;
    create(base?: DeepPartial_82<Preview_PreviewImage_Image>): Preview_PreviewImage_Image;
    fromPartial(object: DeepPartial_82<Preview_PreviewImage_Image>): Preview_PreviewImage_Image;
};

export declare class PrivateMessage {
    #private;
    get id(): TID;
    get from(): PrivateMessageAuthor;
    get body(): string;
    get bodyHtml(): string;
    get created(): Date;
    markAsRead(): Promise<void>;
}

declare type PrivateMessageAuthor = (Pick<User, 'username'> & {
    type: 'user';
    id?: T2ID;
}) | (Pick<Subreddit, 'name'> & {
    type: 'subreddit';
    id?: T5ID;
});

/**
 * PRIVATE MESSAGES - https://www.reddit.com/dev/api#section_messages
 * Note: all endpoints require oauth
 */
declare interface PrivateMessages {
    /** https://www.reddit.com/dev/api#POST_api_block */
    Block(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_collapse_message */
    CollapseMessage(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_compose */
    Compose(request: ComposeRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_del_msg */
    DelMsg(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_read_all_messages */
    ReadAllMessages(request: ReadAllMessagesRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_read_message */
    ReadMessage(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_unblock_subreddit */
    UnblockSubreddit(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_uncollapse_message */
    UncollapseMessage(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_unread_message */
    UnreadMessage(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#GET_message_where */
    MessageWhere(request: MessageWhereRequest, metadata?: Metadata): Promise<Listing_2>;
}

declare class PrivateMessagesClientImpl implements PrivateMessages {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_52, opts?: {
        service?: string;
    });
    Block(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    CollapseMessage(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    Compose(request: ComposeRequest, metadata?: Metadata): Promise<Empty>;
    DelMsg(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    ReadAllMessages(request: ReadAllMessagesRequest, metadata?: Metadata): Promise<Empty>;
    ReadMessage(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    UnblockSubreddit(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    UncollapseMessage(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    UnreadMessage(request: GenericPrivateMessagesRequest, metadata?: Metadata): Promise<Empty>;
    MessageWhere(request: MessageWhereRequest, metadata?: Metadata): Promise<Listing_2>;
}

/**
 * PRIVATE MESSAGES - https://www.reddit.com/dev/api#section_messages
 * Note: all endpoints require oauth
 */
declare type PrivateMessagesDefinition = typeof PrivateMessagesDefinition;

declare const PrivateMessagesDefinition: {
    readonly name: "PrivateMessages";
    readonly fullName: "devvit.plugin.redditapi.privatemessages.PrivateMessages";
    readonly methods: {
        /** https://www.reddit.com/dev/api#POST_api_block */
        readonly block: {
            readonly name: "Block";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest";
                encode(message: GenericPrivateMessagesRequest, writer?: _m0.Writer): _m0.Writer;
                /** https://www.reddit.com/dev/api#POST_api_unread_message */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericPrivateMessagesRequest;
                fromJSON(object: any): GenericPrivateMessagesRequest;
                toJSON(message: GenericPrivateMessagesRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): GenericPrivateMessagesRequest;
                fromPartial(object: {
                    id?: string;
                }): GenericPrivateMessagesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_collapse_message */
        readonly collapseMessage: {
            readonly name: "CollapseMessage";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest";
                encode(message: GenericPrivateMessagesRequest, writer?: _m0.Writer): _m0.Writer;
                /** https://www.reddit.com/dev/api#POST_api_unread_message */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericPrivateMessagesRequest;
                fromJSON(object: any): GenericPrivateMessagesRequest;
                toJSON(message: GenericPrivateMessagesRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): GenericPrivateMessagesRequest;
                fromPartial(object: {
                    id?: string;
                }): GenericPrivateMessagesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_compose */
        readonly compose: {
            readonly name: "Compose";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.ComposeRequest";
                encode(message: ComposeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ComposeRequest;
                fromJSON(object: any): ComposeRequest;
                toJSON(message: ComposeRequest): unknown;
                create(base?: {
                    to?: string;
                    subject?: string;
                    text?: string;
                    fromSr?: string;
                } | undefined): ComposeRequest;
                fromPartial(object: {
                    to?: string;
                    subject?: string;
                    text?: string;
                    fromSr?: string;
                }): ComposeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_del_msg */
        readonly delMsg: {
            readonly name: "DelMsg";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest";
                encode(message: GenericPrivateMessagesRequest, writer?: _m0.Writer): _m0.Writer;
                /** https://www.reddit.com/dev/api#POST_api_unread_message */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericPrivateMessagesRequest;
                fromJSON(object: any): GenericPrivateMessagesRequest;
                toJSON(message: GenericPrivateMessagesRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): GenericPrivateMessagesRequest;
                fromPartial(object: {
                    id?: string;
                }): GenericPrivateMessagesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_read_all_messages */
        readonly readAllMessages: {
            readonly name: "ReadAllMessages";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.ReadAllMessagesRequest";
                encode(message: ReadAllMessagesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ReadAllMessagesRequest;
                fromJSON(object: any): ReadAllMessagesRequest;
                toJSON(message: ReadAllMessagesRequest): unknown;
                create(base?: {
                    filterTypes?: string;
                } | undefined): ReadAllMessagesRequest;
                fromPartial(object: {
                    filterTypes?: string;
                }): ReadAllMessagesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_read_message */
        readonly readMessage: {
            readonly name: "ReadMessage";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest";
                encode(message: GenericPrivateMessagesRequest, writer?: _m0.Writer): _m0.Writer;
                /** https://www.reddit.com/dev/api#POST_api_unread_message */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericPrivateMessagesRequest;
                fromJSON(object: any): GenericPrivateMessagesRequest;
                toJSON(message: GenericPrivateMessagesRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): GenericPrivateMessagesRequest;
                fromPartial(object: {
                    id?: string;
                }): GenericPrivateMessagesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_unblock_subreddit */
        readonly unblockSubreddit: {
            readonly name: "UnblockSubreddit";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest";
                encode(message: GenericPrivateMessagesRequest, writer?: _m0.Writer): _m0.Writer;
                /** https://www.reddit.com/dev/api#POST_api_unread_message */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericPrivateMessagesRequest;
                fromJSON(object: any): GenericPrivateMessagesRequest;
                toJSON(message: GenericPrivateMessagesRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): GenericPrivateMessagesRequest;
                fromPartial(object: {
                    id?: string;
                }): GenericPrivateMessagesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_uncollapse_message */
        readonly uncollapseMessage: {
            readonly name: "UncollapseMessage";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest";
                encode(message: GenericPrivateMessagesRequest, writer?: _m0.Writer): _m0.Writer;
                /** https://www.reddit.com/dev/api#POST_api_unread_message */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericPrivateMessagesRequest;
                fromJSON(object: any): GenericPrivateMessagesRequest;
                toJSON(message: GenericPrivateMessagesRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): GenericPrivateMessagesRequest;
                fromPartial(object: {
                    id?: string;
                }): GenericPrivateMessagesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_unread_message */
        readonly unreadMessage: {
            readonly name: "UnreadMessage";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest";
                encode(message: GenericPrivateMessagesRequest, writer?: _m0.Writer): _m0.Writer;
                /** https://www.reddit.com/dev/api#POST_api_unread_message */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericPrivateMessagesRequest;
                fromJSON(object: any): GenericPrivateMessagesRequest;
                toJSON(message: GenericPrivateMessagesRequest): unknown;
                create(base?: {
                    id?: string;
                } | undefined): GenericPrivateMessagesRequest;
                fromPartial(object: {
                    id?: string;
                }): GenericPrivateMessagesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_message_where */
        readonly messageWhere: {
            readonly name: "MessageWhere";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.privatemessages.MessageWhereRequest";
                encode(message: MessageWhereRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MessageWhereRequest;
                fromJSON(object: any): MessageWhereRequest;
                toJSON(message: MessageWhereRequest): unknown;
                create(base?: {
                    where?: string;
                    mark?: boolean | undefined;
                    mid?: string | undefined;
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                } | undefined): MessageWhereRequest;
                fromPartial(object: {
                    where?: string;
                    mark?: boolean | undefined;
                    mid?: string | undefined;
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                }): MessageWhereRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
    };
};

declare const PrivateMessagesServiceName = "devvit.plugin.redditapi.privatemessages.PrivateMessages";

declare interface Producer {
    Produce(request: Args, metadata?: Metadata): Observable<Arg>;
}

declare class ProducerClientImpl implements Producer {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_39, opts?: {
        service?: string;
    });
    Produce(request: Args, metadata?: Metadata): Observable<Arg>;
}

declare type ProducerDefinition = typeof ProducerDefinition;

declare const ProducerDefinition: {
    readonly name: "Producer";
    readonly fullName: "devvit.actor.producer.Producer";
    readonly methods: {
        readonly produce: {
            readonly name: "Produce";
            readonly requestType: {
                $type: "devvit.actor.producer.Args";
                encode(message: Args, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): Args;
                fromJSON(object: any): Args;
                toJSON(message: Args): unknown;
                create(base?: DeepPartial_85<Args>): Args;
                fromPartial(object: DeepPartial_85<Args>): Args;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.producer.Arg";
                encode(message: Arg, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): Arg;
                fromJSON(object: any): Arg;
                toJSON(message: Arg): unknown;
                create(base?: DeepPartial_85<Arg>): Arg;
                fromPartial(object: DeepPartial_85<Arg>): Arg;
            };
            readonly responseStream: true;
            readonly options: {};
        };
    };
};

declare const ProducerServiceName = "devvit.actor.producer.Producer";

declare namespace protos {
    export {
        ActorDefinition,
        ActorNameClientMap,
        MessageType,
        UnknownMessage,
        messageTypeRegistry,
        UUID,
        DoubleValue,
        FloatValue,
        Int64Value,
        UInt64Value,
        Int32Value,
        UInt32Value,
        BoolValue,
        StringValue,
        BytesValue,
        Timestamp,
        nullValueFromJSON,
        nullValueToJSON,
        NullValue,
        Struct,
        Struct_FieldsEntry,
        Value,
        ListValue,
        Empty,
        Duration,
        editionFromJSON,
        editionToJSON,
        extensionRangeOptions_VerificationStateFromJSON,
        extensionRangeOptions_VerificationStateToJSON,
        fieldDescriptorProto_TypeFromJSON,
        fieldDescriptorProto_TypeToJSON,
        fieldDescriptorProto_LabelFromJSON,
        fieldDescriptorProto_LabelToJSON,
        fileOptions_OptimizeModeFromJSON,
        fileOptions_OptimizeModeToJSON,
        fieldOptions_CTypeFromJSON,
        fieldOptions_CTypeToJSON,
        fieldOptions_JSTypeFromJSON,
        fieldOptions_JSTypeToJSON,
        fieldOptions_OptionRetentionFromJSON,
        fieldOptions_OptionRetentionToJSON,
        fieldOptions_OptionTargetTypeFromJSON,
        fieldOptions_OptionTargetTypeToJSON,
        methodOptions_IdempotencyLevelFromJSON,
        methodOptions_IdempotencyLevelToJSON,
        featureSet_FieldPresenceFromJSON,
        featureSet_FieldPresenceToJSON,
        featureSet_EnumTypeFromJSON,
        featureSet_EnumTypeToJSON,
        featureSet_RepeatedFieldEncodingFromJSON,
        featureSet_RepeatedFieldEncodingToJSON,
        featureSet_Utf8ValidationFromJSON,
        featureSet_Utf8ValidationToJSON,
        featureSet_MessageEncodingFromJSON,
        featureSet_MessageEncodingToJSON,
        featureSet_JsonFormatFromJSON,
        featureSet_JsonFormatToJSON,
        generatedCodeInfo_Annotation_SemanticFromJSON,
        generatedCodeInfo_Annotation_SemanticToJSON,
        Edition,
        FileDescriptorSet,
        FileDescriptorProto,
        DescriptorProto,
        DescriptorProto_ExtensionRange,
        DescriptorProto_ReservedRange,
        ExtensionRangeOptions,
        ExtensionRangeOptions_VerificationState,
        ExtensionRangeOptions_Declaration,
        FieldDescriptorProto,
        FieldDescriptorProto_Type,
        FieldDescriptorProto_Label,
        OneofDescriptorProto,
        EnumDescriptorProto,
        EnumDescriptorProto_EnumReservedRange,
        EnumValueDescriptorProto,
        ServiceDescriptorProto,
        MethodDescriptorProto,
        FileOptions,
        FileOptions_OptimizeMode,
        MessageOptions,
        FieldOptions,
        FieldOptions_CType,
        FieldOptions_JSType,
        FieldOptions_OptionRetention,
        FieldOptions_OptionTargetType,
        FieldOptions_EditionDefault,
        OneofOptions,
        EnumOptions,
        EnumValueOptions,
        ServiceOptions,
        MethodOptions,
        MethodOptions_IdempotencyLevel,
        UninterpretedOption,
        UninterpretedOption_NamePart,
        FeatureSet,
        FeatureSet_FieldPresence,
        FeatureSet_EnumType,
        FeatureSet_RepeatedFieldEncoding,
        FeatureSet_Utf8Validation,
        FeatureSet_MessageEncoding,
        FeatureSet_JsonFormat,
        FeatureSetDefaults,
        FeatureSetDefaults_FeatureSetEditionDefault,
        SourceCodeInfo,
        SourceCodeInfo_Location,
        GeneratedCodeInfo,
        GeneratedCodeInfo_Annotation,
        GeneratedCodeInfo_Annotation_Semantic,
        Any,
        EnvelopeReceiverPort,
        EnvelopeReceiverPortServiceName,
        EnvelopeReceiverPortClientImpl,
        EnvelopeReceiverPortDefinition,
        BundleRequest,
        BundleService,
        BundleServiceServiceName,
        BundleServiceClientImpl,
        BundleServiceDefinition,
        SerializableServiceDefinition,
        SerializableMethodDefinition,
        Ack,
        Debug,
        Strings,
        Str,
        Envelope,
        Envelope_MetadataEntry,
        linkedBundleTargetPlatformFromJSON,
        linkedBundleTargetPlatformToJSON,
        LinkedBundleTargetPlatform,
        ActorSpec,
        LocationFilter,
        PackageSpec,
        PackageQuery,
        DependencySpec,
        LinkedBundle,
        LinkedBundle_AssetsEntry,
        BuildInfo,
        BuildInfo_DependenciesEntry,
        RemoteLogPublisherClient,
        RemoteLogPublisherClientJSON,
        RemoteLogPublisherClientProtobuf,
        RemoteLogConsumerClient,
        RemoteLogConsumerClientJSON,
        RemoteLogConsumerClientProtobuf,
        remoteLogTypeFromJSON,
        remoteLogTypeToJSON,
        RemoteLogType,
        RemoteLogMessages,
        RemoteLogPutResponse,
        KeepAliveMessage,
        RemoteLogMessage,
        RemoteLogInstallationFilter,
        RemoteLogSubredditAppNameFilter,
        RemoteLogQuery,
        RemoteLogPublisher,
        RemoteLogPublisherServiceName,
        RemoteLogPublisherClientImpl,
        RemoteLogPublisherDefinition,
        RemoteLogConsumer,
        RemoteLogConsumerServiceName,
        RemoteLogConsumerClientImpl,
        RemoteLogConsumerDefinition,
        User_2 as User,
        UserFeatures,
        UserFeatures_Experiment,
        thingTypeFromJSON,
        thingTypeToJSON,
        ThingType,
        Subreddit_2 as Subreddit,
        Subreddit_PostRequirements,
        Post_2 as Post,
        Media,
        Media_RedditVideo,
        Preview,
        Preview_PreviewImage,
        Preview_PreviewImage_Image,
        OEmbed_2 as OEmbed,
        RedditPostGallery,
        banInfo_BanInfoActionFromJSON,
        banInfo_BanInfoActionToJSON,
        AuthorFlairRichText,
        Awarding,
        Awarding_Icon,
        CommentContributionSettings,
        Gildings,
        MediaEmbed,
        UserFlairRichtext,
        BanInfo,
        BanInfo_BanInfoAction,
        Comment_2 as Comment,
        dataTierFromJSON,
        dataTierToJSON,
        selectorFromJSON,
        selectorToJSON,
        deliveryLocationFromJSON,
        deliveryLocationToJSON,
        firehoseEventFromJSON,
        firehoseEventToJSON,
        DataTier,
        Selector,
        DeliveryLocation,
        FirehoseEvent,
        EventSpec,
        DeliverTo,
        SubredditContextActions,
        DevvitSubredditMetadata,
        DevvitSubredditMetadata_AppInfo,
        ErrorMessage,
        CustomPostSnapshot,
        SubredditMetadataRequest,
        SubredditMetadataResolver,
        SubredditMetadataResolverServiceName,
        SubredditMetadataResolverClientImpl,
        SubredditMetadataResolverDefinition,
        CustomPostSnapshotRequest,
        CustomPostSnapshotResolver,
        CustomPostSnapshotResolverServiceName,
        CustomPostSnapshotResolverClientImpl,
        CustomPostSnapshotResolverDefinition,
        PlaytestProviderMessage,
        PlaytestSubscriberMessage,
        PlaytestAppInstalled,
        PlaytestCallState,
        PlaytestConnect,
        toastAppearanceFromJSON,
        toastAppearanceToJSON,
        ToastAppearance,
        ToastLeadingElement,
        ToastTrailingElement,
        Toast_2 as Toast,
        UnloadRequest,
        Supervisor,
        SupervisorServiceName,
        SupervisorClientImpl,
        SupervisorDefinition,
        WorkerQuery,
        RuntimeActor,
        RuntimeActorServiceName,
        RuntimeActorClientImpl,
        RuntimeActorDefinition,
        Echo,
        EchoServiceName,
        EchoClientImpl,
        EchoDefinition,
        BootstrapActor,
        BootstrapActorServiceName,
        BootstrapActorClientImpl,
        BootstrapActorDefinition,
        UserV2,
        subredditTypeFromJSON,
        subredditTypeToJSON,
        subredditRatingFromJSON,
        subredditRatingToJSON,
        SubredditType_2 as SubredditType,
        SubredditRating,
        SubredditV2,
        crowdControlLevelFromJSON,
        crowdControlLevelToJSON,
        distinguishTypeFromJSON,
        distinguishTypeToJSON,
        CrowdControlLevel,
        DistinguishType,
        PostV2,
        Oembed,
        RedditVideo_2 as RedditVideo,
        MediaObject,
        ModMail,
        modActionTypeFromJSON,
        modActionTypeToJSON,
        ModActionType_2 as ModActionType,
        ModAction_2 as ModAction,
        LinkFlairV2,
        UserFlairV2,
        CommentV2,
        V2EventsActionInfo,
        V2EventsPostGuidanceCreate,
        V2EventsPostGuidanceUpdate,
        V2EventsPublishRequest,
        V2EventsPublishResponse,
        V2Events,
        V2EventsServiceName,
        V2EventsClientImpl,
        V2EventsDefinition,
        TimerMessage,
        Timer,
        TimerServiceName,
        TimerClientImpl,
        TimerDefinition,
        Message,
        Cursor,
        StreamBroker,
        StreamBrokerServiceName,
        StreamBrokerClientImpl,
        StreamBrokerDefinition,
        storableAction_StateFromJSON,
        storableAction_StateToJSON,
        ScheduledActionRequest,
        ScheduledActionResponse,
        CancelActionRequest,
        StorableAction,
        StorableAction_State,
        StorableAction_MetadataEntry,
        ListActionRequest,
        GetActionResponse,
        ListActionResponse,
        Scheduler_2 as Scheduler,
        SchedulerServiceName,
        SchedulerClientImpl,
        SchedulerDefinition,
        redisKeyScopeFromJSON,
        redisKeyScopeToJSON,
        RedisKeyScope,
        TransactionResponses,
        TransactionResponse,
        ZRangeRequest,
        ZRangeByLexRequest,
        ZRangeByScoreRequest,
        ZRemRequest,
        ZRemRangeByLexRequest,
        ZRemRangeByRankRequest,
        ZRemRangeByScoreRequest,
        ZScoreRequest,
        ZRankRequest,
        ZIncrByRequest,
        KeyRequest,
        IncrByRequest,
        SetRequest,
        KeyRangeRequest,
        SetRangeRequest,
        KeysRequest,
        KeysResponse,
        HGetRequest,
        HSetRequest,
        HDelRequest,
        HScanRequest,
        HScanResponse,
        HIncrByRequest,
        RedisFieldValue,
        RedisFieldValues,
        RedisFieldValues_FieldValuesEntry,
        KeyValuesRequest,
        RedisKeyValue,
        RedisValues,
        ExpireRequest,
        ZAddRequest,
        ZScanRequest,
        ZScanResponse,
        ZMembers,
        ZMember_2 as ZMember,
        TransactionId,
        WatchRequest,
        RedisAPI,
        RedisAPIServiceName,
        RedisAPIClientImpl,
        RedisAPIDefinition,
        RedditAPIV2,
        RedditAPIV2ServiceName,
        RedditAPIV2ClientImpl,
        RedditAPIV2Definition,
        ModlogRequest,
        ModlogResponse,
        Modlog,
        ModlogServiceName,
        ModlogClientImpl,
        ModlogDefinition,
        MediaUploadRequest,
        MediaUploadResponse,
        MediaService,
        MediaServiceServiceName,
        MediaServiceClientImpl,
        MediaServiceDefinition,
        LoggerClient,
        LoggerClientJSON,
        LoggerClientProtobuf,
        severityFromJSON,
        severityToJSON,
        Severity,
        LogErrorMessage,
        LogEventMessage,
        LogEventMessage_LabelsEntry,
        LogEventMessage_DataEntry,
        LogMessage,
        LogMessages,
        LogErrorResponse,
        LogEventResponse,
        LogResponse,
        Logger,
        LoggerServiceName,
        LoggerClientImpl,
        LoggerDefinition,
        Resolution,
        ResolutionError,
        Resolver,
        ResolverServiceName,
        ResolverClientImpl,
        ResolverDefinition,
        LinkerResponse,
        Linker,
        LinkerServiceName,
        LinkerClientImpl,
        LinkerDefinition,
        MessageSet,
        MessageSet_MessagesEntry,
        KeySet,
        ListFilter,
        KVStore_2 as KVStore,
        KVStoreServiceName,
        KVStoreClientImpl,
        KVStoreDefinition,
        inspectorUpdateTypeFromJSON,
        inspectorUpdateTypeToJSON,
        InspectorUpdateType,
        InspectorQuery,
        InspectorDescription,
        InspectorDescriptions,
        InspectorUpdate,
        Inspector,
        InspectorServiceName,
        InspectorClientImpl,
        InspectorDefinition,
        FetchRequest,
        RequestData,
        RequestData_HeadersEntry,
        FetchResponse,
        FetchResponse_HeadersEntry,
        HTTP,
        HTTPServiceName,
        HTTPClientImpl,
        HTTPDefinition,
        Clock,
        ClockServiceName,
        ClockClientImpl,
        ClockDefinition,
        File_2 as File,
        FileSystem,
        minifyFromJSON,
        minifyToJSON,
        Minify,
        Bundle,
        Bundle_AssetIdsEntry,
        CompileParams,
        CompileLog,
        CompileLogLineDetail,
        CompileResponse,
        BuildPack,
        BuildPackServiceName,
        BuildPackClientImpl,
        BuildPackDefinition,
        BuildResponse,
        Builder,
        BuilderServiceName,
        BuilderClientImpl,
        BuilderDefinition,
        GetAssetURLRequest,
        GetAssetURLResponse,
        GetMultipleAssetURLsRequest,
        GetMultipleAssetURLsResponse,
        GetMultipleAssetURLsResponse_GlobResult,
        GetMultipleAssetURLsResponse_UrlsEntry,
        AssetResolver,
        AssetResolverServiceName,
        AssetResolverClientImpl,
        AssetResolverDefinition,
        TriggerResponse,
        TriggerResponse_ErrorsEntry,
        TriggerFanOutResponse,
        TriggerInvocation,
        Triggers,
        TriggersServiceName,
        TriggersClientImpl,
        TriggersDefinition,
        WqCleanup,
        RealtimeRequest,
        RealtimeEvent,
        Realtime,
        RealtimeServiceName,
        RealtimeClientImpl,
        RealtimeDefinition,
        eventSourceFromJSON,
        eventSourceToJSON,
        deletionReasonFromJSON,
        deletionReasonToJSON,
        EventSource_2 as EventSource,
        DeletionReason,
        PostSubmit_2 as PostSubmit,
        PostCreate_2 as PostCreate,
        PostUpdate_2 as PostUpdate,
        PostReport_2 as PostReport,
        PostFlairUpdate_2 as PostFlairUpdate,
        PostDelete_2 as PostDelete,
        PostApprove,
        CommentApprove,
        CommentSubmit_2 as CommentSubmit,
        CommentCreate_2 as CommentCreate,
        CommentUpdate_2 as CommentUpdate,
        CommentReport_2 as CommentReport,
        CommentDelete_2 as CommentDelete,
        SubredditSubscribe,
        AppInstall_2 as AppInstall,
        AppUpgrade_2 as AppUpgrade,
        AccountDelete,
        Vote,
        GetProfileRequest,
        GetProfileResponse,
        DevvitProfiler,
        DevvitProfilerServiceName,
        DevvitProfilerClientImpl,
        DevvitProfilerDefinition,
        configFieldTypeFromJSON,
        configFieldTypeToJSON,
        ConfigFieldType,
        ConfigForm,
        ConfigField,
        FormResponse,
        UserConfigurable,
        UserConfigurableServiceName,
        UserConfigurableClientImpl,
        UserConfigurableDefinition,
        WrapperTypes,
        WrapperTypesServiceName,
        WrapperTypesClientImpl,
        WrapperTypesDefinition,
        TestMessage,
        Streams,
        StreamsServiceName,
        StreamsClientImpl,
        StreamsDefinition,
        SchedulerHandler,
        SchedulerHandlerServiceName,
        SchedulerHandlerClientImpl,
        SchedulerHandlerDefinition,
        ScheduledAction,
        PostFilterRequest,
        Response_2 as Response,
        PostFilter,
        PostFilterServiceName,
        PostFilterClientImpl,
        PostFilterDefinition,
        contextTypeFromJSON,
        contextTypeToJSON,
        ContextType,
        ContextActionAllowedContexts,
        ContextActionAllowedUsers,
        ContextActionPostFilters,
        ContextActionDescription,
        ContextActionList,
        ContextActionRequest,
        ContextActionResponse,
        ContextAction,
        ContextActionServiceName,
        ContextActionClientImpl,
        ContextActionDefinition,
        Arg,
        Args,
        Producer,
        ProducerServiceName,
        ProducerClientImpl,
        ProducerDefinition,
        permissionFromJSON,
        permissionToJSON,
        Permission,
        NestedRule,
        PermissionOrRule,
        PermissionConfig,
        PermissionList,
        PingMessage,
        Hello,
        HelloServiceName,
        HelloClientImpl,
        HelloDefinition,
        CommandDescription,
        CommandsList,
        CommandContext,
        CommandRequest,
        Bot,
        BotServiceName,
        BotClientImpl,
        BotDefinition,
        FormFieldValue,
        FormFieldValue_ListValue,
        FormFieldValue_SelectionValue,
        FormFieldValue_GroupValue,
        formFieldTypeFromJSON,
        formFieldTypeToJSON,
        FormFieldType,
        Form_2 as Form,
        FormField_2 as FormField,
        FieldConfig,
        FieldConfig_String,
        FieldConfig_Paragraph,
        FieldConfig_Number,
        FieldConfig_Boolean,
        FieldConfig_List,
        FieldConfig_Selection,
        FieldConfig_Selection_Item,
        FieldConfig_Group,
        HandleUIEventRequest,
        HandleUIEventResponse,
        UIEventHandler,
        UIEventHandlerServiceName,
        UIEventHandlerClientImpl,
        UIEventHandlerDefinition,
        UIEvent,
        BlockingRenderEvent,
        ResizeEvent,
        TimerEvent,
        AsyncError_2 as AsyncError,
        AsyncRequest,
        AsyncResponse,
        UserAction,
        ShowToastEffect,
        ToastActionEvent,
        ShowFormEffect,
        FormSubmittedEvent,
        FormSubmittedEvent_ResultsEntry,
        RerenderEffect,
        ReloadPartEffect,
        ReloadPartEffect_Subreddit,
        ReloadPartEffect_Post,
        ReloadPartEffect_Comment,
        realtimeSubscriptionStatusFromJSON,
        realtimeSubscriptionStatusToJSON,
        RealtimeSubscriptionStatus,
        RealtimeSubscriptionsEffect,
        RealtimeSubscriptionEvent,
        NavigateToUrlEffect,
        SetIntervalsEffect,
        SetIntervalsEffect_IntervalsEntry,
        IntervalDetails,
        effectTypeFromJSON,
        effectTypeToJSON,
        EffectType,
        Effect,
        UIDimensions,
        UIRequest,
        UIResponse,
        UIEnvironment,
        BlockRenderRequest,
        BlockRenderResponse,
        blockTypeFromJSON,
        blockTypeToJSON,
        blockActionTypeFromJSON,
        blockActionTypeToJSON,
        blockRenderEventTypeFromJSON,
        blockRenderEventTypeToJSON,
        blockStackDirectionFromJSON,
        blockStackDirectionToJSON,
        blockBorderWidthFromJSON,
        blockBorderWidthToJSON,
        blockVerticalAlignmentFromJSON,
        blockVerticalAlignmentToJSON,
        blockHorizontalAlignmentFromJSON,
        blockHorizontalAlignmentToJSON,
        blockPaddingFromJSON,
        blockPaddingToJSON,
        blockGapFromJSON,
        blockGapToJSON,
        blockRadiusFromJSON,
        blockRadiusToJSON,
        blockTextSizeFromJSON,
        blockTextSizeToJSON,
        blockTextWeightFromJSON,
        blockTextWeightToJSON,
        blockTextOutlineFromJSON,
        blockTextOutlineToJSON,
        blockTextStyleFromJSON,
        blockTextStyleToJSON,
        blockButtonSizeFromJSON,
        blockButtonSizeToJSON,
        blockButtonAppearanceFromJSON,
        blockButtonAppearanceToJSON,
        blockImageResizeModeFromJSON,
        blockImageResizeModeToJSON,
        blockSpacerSizeFromJSON,
        blockSpacerSizeToJSON,
        blockSpacerShapeFromJSON,
        blockSpacerShapeToJSON,
        blockIconSizeFromJSON,
        blockIconSizeToJSON,
        blockAvatarFacingFromJSON,
        blockAvatarFacingToJSON,
        blockAvatarSizeFromJSON,
        blockAvatarSizeToJSON,
        blockAvatarBackgroundFromJSON,
        blockAvatarBackgroundToJSON,
        blockFullSnooSizeFromJSON,
        blockFullSnooSizeToJSON,
        blockAnimationTypeFromJSON,
        blockAnimationTypeToJSON,
        blockAnimationLoopModeFromJSON,
        blockAnimationLoopModeToJSON,
        blockAnimationDirectionFromJSON,
        blockAnimationDirectionToJSON,
        blockSizeUnitFromJSON,
        blockSizeUnitToJSON,
        blockTextOverflowFromJSON,
        blockTextOverflowToJSON,
        BlockType,
        BlockActionType,
        BlockRenderEventType,
        BlockStackDirection,
        BlockBorderWidth,
        BlockVerticalAlignment,
        BlockHorizontalAlignment,
        BlockPadding,
        BlockGap,
        BlockRadius,
        BlockTextSize,
        BlockTextWeight,
        BlockTextOutline,
        BlockTextStyle,
        BlockButtonSize,
        BlockButtonAppearance,
        BlockImageResizeMode,
        BlockSpacerSize,
        BlockSpacerShape,
        BlockIconSize,
        BlockAvatarFacing,
        BlockAvatarSize,
        BlockAvatarBackground,
        BlockFullSnooSize,
        BlockAnimationType,
        BlockAnimationLoopMode,
        BlockAnimationDirection,
        BlockSizeUnit,
        BlockTextOverflow,
        Block,
        BlockConfig,
        BlockConfig_Root,
        BlockConfig_Stack,
        BlockConfig_Text,
        BlockConfig_Button,
        BlockConfig_Image,
        BlockConfig_Spacer,
        BlockConfig_Icon,
        BlockConfig_Avatar,
        BlockConfig_FullSnoo,
        BlockConfig_Animation,
        BlockConfig_WebView,
        BlockAlignment,
        BlockBorder,
        BlockSizes,
        BlockSizes_Dimension,
        BlockSizes_Dimension_Value,
        BlockSize,
        BlockAction,
        BlockColor,
        HealthStatus,
        Health,
        HealthServiceName,
        HealthClientImpl,
        HealthDefinition,
        Dimensions,
        RenderPostRequest,
        RenderPostResponse,
        CustomPost,
        CustomPostServiceName,
        CustomPostClientImpl,
        CustomPostDefinition,
        CustomAction,
        CustomAction_Menus,
        CustomAction_Options,
        GetActionsRequest,
        GetActionsResponse,
        OnActionRequest,
        OnActionResponse,
        CustomActions,
        CustomActionsServiceName,
        CustomActionsClientImpl,
        CustomActionsDefinition,
        SettingsClient_2 as SettingsClient,
        SettingsClientJSON,
        SettingsClientProtobuf,
        SettingsValues_2 as SettingsValues,
        SettingsValues_SettingsEntry,
        SettingsRequest,
        SettingsResponse,
        Settings,
        SettingsServiceName,
        SettingsClientImpl,
        SettingsDefinition,
        Wiki,
        WikiServiceName,
        WikiClientImpl,
        WikiDefinition,
        GetWikiPagesRequest,
        GetWikiPagesResponse,
        GetWikiPageRequest,
        WikiPage_2 as WikiPage,
        GetWikiPageResponse,
        EditWikiPageRequest,
        HideWikiPageRevisionRequest,
        HideWikiPageRevisionResponse,
        GetWikiPageRevisionsRequest,
        WikiPageRevision_2 as WikiPageRevision,
        WikiPageRevisionListing,
        WikiPageRevisionListing_Data,
        GetWikiRevisionsRequest,
        RevertWikiPageRequest,
        GetWikiPageSettingsRequest,
        WikiPageSettings_2 as WikiPageSettings,
        WikiPageSettings_Data,
        UpdateWikiPageSettingsRequest,
        AllowEditorRequest,
        Widgets,
        WidgetsServiceName,
        WidgetsClientImpl,
        WidgetsDefinition,
        WidgetStyles,
        WidgetImage,
        ImageWidget_2 as ImageWidget,
        AddImageWidgetRequest,
        UpdateImageWidgetRequest,
        CalendarWidgetConfiguration,
        CalendarWidget_2 as CalendarWidget,
        AddCalendarWidgetRequest,
        UpdateCalendarWidgetRequest,
        TextAreaWidget_2 as TextAreaWidget,
        AddTextAreaWidgetRequest,
        UpdateTextAreaWidgetRequest,
        WidgetButton,
        WidgetButton_HoverState,
        ButtonWidget_2 as ButtonWidget,
        AddButtonWidgetRequest,
        UpdateButtonWidgetRequest,
        CommunityListWidget_2 as CommunityListWidget,
        CommunityListWidget_CommunityData,
        AddCommunityListWidgetRequest,
        UpdateCommunityListWidgetRequest,
        UpdateCommunityListWidgetResponse,
        PostFlairWidget_2 as PostFlairWidget,
        AddPostFlairWidgetRequest,
        UpdatePostFlairWidgetRequest,
        DeleteWidgetRequest,
        GetWidgetsRequest,
        GetWidgetsResponse,
        GetWidgetsResponse_WidgetOrdering,
        GetWidgetsResponse_Layout,
        GetWidgetsResponse_WidgetItem,
        GetWidgetsResponse_WidgetItem_Data,
        GetWidgetsResponse_WidgetItem_Moderator,
        GetWidgetsResponse_WidgetItem_PostFlairTemplate,
        GetWidgetsResponse_WidgetItem_TemplatesEntry,
        GetWidgetsResponse_ItemsEntry,
        MenuWidgetItem,
        OrderWidgetsRequest,
        GetWidgetImageUploadLeaseRequest,
        GetWidgetImageUploadLeaseResponse,
        GetWidgetImageUploadLeaseResponse_S3UploadLease,
        GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair,
        CustomWidget_2 as CustomWidget,
        AddCustomWidgetRequest,
        UpdateCustomWidgetRequest,
        Users,
        UsersServiceName,
        UsersClientImpl,
        UsersDefinition,
        GenericUsersRequest,
        BlockUserRequest,
        FriendRequest,
        ReportUserRequest,
        SetPermissionsRequest,
        UnfriendRequest,
        UserDataByAccountIdsRequest,
        UsernameAvailableRequest,
        UpdateFriendRelationshipRequest,
        UserAboutRequest,
        UserWhereRequest,
        GeneralFriendResponse,
        BlockUserResponse,
        UserDataByAccountIdsResponse,
        UserDataByAccountIdsResponse_UserAccountData,
        UserDataByAccountIdsResponse_UsersEntry,
        UserTrophiesResponse,
        UserTrophiesResponse_TrophiesData,
        UserTrophiesResponse_TrophiesType,
        UserTrophiesResponse_UserTrophiesData,
        UserAboutResponse,
        Subreddits,
        SubredditsServiceName,
        SubredditsClientImpl,
        SubredditsDefinition,
        AboutWhereRequest,
        BasicSubredditRequest,
        DeleteSrImgRequest,
        BasicSearchRequest,
        SiteAdminRequest,
        SubredditAutocompleteRequest,
        SubredditStylesheetRequest,
        SubscribeRequest,
        UploadSrImgRequest,
        SubredditAboutEditRequest,
        StickyRequest,
        BasicWhereRequest,
        SubredditsSearchRequest,
        UsersSearchRequest,
        SearchRedditNamesResponse,
        SearchSubredditsResponse,
        SearchSubredditsResponse_SubredditData,
        SubmitTextResponse,
        SubredditAutocompleteResponse,
        SubredditAutocompleteResponse_AutocompleteAccount,
        SubredditAutocompleteResponse_AutocompleteAccount_Subreddit,
        SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit,
        SubredditAutocompleteResponse_WrappedAutoCompleteAccount,
        SubredditAutocompleteResponse_AutocompleteResponse,
        UploadSrImgResponse,
        SubredditPostRequirementsResponse,
        SubredditAboutResponse,
        SubredditAboutResponse_AboutData,
        SubredditAboutEditResponse,
        SubredditAboutEditResponse_SubredditSettings,
        SubredditAboutRulesResponse,
        SubredditAboutRulesResponse_SubredditRule,
        SubredditAboutRulesResponse_RuleFlow,
        SubredditAboutTrafficResponse,
        SubredditAboutTrafficResponse_Data,
        StickyResponse,
        StickyResponse_LinkData,
        StickyResponse_WrappedStickyListing,
        StickyResponse_StickyResponseData,
        FullSubredditObject,
        SubredditsSearchResponse,
        SubredditsSearchResponse_WrappedSubredditObject,
        SubredditsSearchResponse_WrappedSubredditObject_SubredditData,
        UserSearchResponse,
        UserSearchResponse_AccData,
        UserSearchResponse_Account,
        UserSearchResponse_AccountData,
        UserSearchResponse_AccountData_Subreddit,
        SubredditAddRemovalReasonRequest,
        SubredditAddRemovalReasonResponse,
        SubredditGetRemovalReasonsRequest,
        SubredditGetRemovalReasonsResponse,
        SubredditGetRemovalReasonsResponse_SubredditRemovalReason,
        SubredditGetRemovalReasonsResponse_DataEntry,
        PrivateMessages,
        PrivateMessagesServiceName,
        PrivateMessagesClientImpl,
        PrivateMessagesDefinition,
        GenericPrivateMessagesRequest,
        ComposeRequest,
        ReadAllMessagesRequest,
        MessageWhereRequest,
        PostCollections,
        PostCollectionsServiceName,
        PostCollectionsClientImpl,
        PostCollectionsDefinition,
        CollectionRequest,
        CreateCollectionRequest,
        AddPostToCollectionRequest,
        DeleteCollectionRequest,
        FollowCollectionRequest,
        RemovePostInCollectionRequest,
        ReorderCollectionRequest,
        SubredditCollectionsRequest,
        UpdateCollectionDescriptionRequest,
        UpdateCollectionTitleRequest,
        UpdateCollectionDisplayLayoutRequest,
        CollectionResponse,
        SubredditCollectionsResponse,
        NewModmail,
        NewModmailServiceName,
        NewModmailClientImpl,
        NewModmailDefinition,
        ConversationData_2 as ConversationData,
        ConversationData_ObjId,
        ConversationData_Owner,
        ConversationData_ModActionsEntry,
        MessageData_2 as MessageData,
        ConversationUserData_2 as ConversationUserData,
        ConversationUserData_CommentData,
        ConversationUserData_MuteStatus,
        ConversationUserData_BanStatus,
        ConversationUserData_ApproveStatus,
        ConversationUserData_PostData,
        ConversationUserData_ConvoData,
        ConversationUserData_RecentCommentsEntry,
        ConversationUserData_RecentPostsEntry,
        ConversationUserData_RecentConvosEntry,
        Participant_2 as Participant,
        ModActionData_2 as ModActionData,
        ModActionData_ModActionAuthor,
        BulkReadConversationsRequest,
        GetConversationsRequest_2 as GetConversationsRequest,
        CreateConversationRequest,
        GetConversationRequest,
        CreateConversationMessageRequest,
        BasicConversationRequest,
        BasicConversationsRequest,
        MuteConversationRequest,
        TempBanRequest,
        BulkReadConversationsResponse,
        GetConversationsResponse_2 as GetConversationsResponse,
        GetConversationsResponse_ConversationsEntry,
        GetConversationsResponse_MessagesEntry,
        CreateConversationResponse,
        CreateConversationResponse_MessagesEntry,
        CreateConversationResponse_ModActionsEntry,
        GetConversationResponse_2 as GetConversationResponse,
        GetConversationResponse_MessagesEntry,
        GetConversationResponse_ModActionsEntry,
        CreateConversationMessageResponse,
        CreateConversationMessageResponse_MessagesEntry,
        ApproveConversationResponse,
        ApproveConversationResponse_MessagesEntry,
        ApproveConversationResponse_ModActionsEntry,
        ArchiveConversationResponse,
        ArchiveConversationResponse_MessagesEntry,
        ArchiveConversationResponse_ModActionsEntry,
        HighlightConversationResponse,
        HighlightConversationResponse_MessagesEntry,
        HighlightConversationResponse_ModActionsEntry,
        MuteConversationResponse,
        MuteConversationResponse_MessagesEntry,
        MuteConversationResponse_ModActionsEntry,
        TempBanResponse,
        TempBanResponse_MessagesEntry,
        TempBanResponse_ModActionsEntry,
        SubredditsResponse,
        SubredditsResponse_SubredditData,
        SubredditsResponse_SubredditsEntry,
        UnreadCountResponse_2 as UnreadCountResponse,
        ModNote_2 as ModNote,
        ModNoteServiceName,
        ModNoteClientImpl,
        ModNoteDefinition,
        DeleteNotesRequest,
        GetNotesRequest,
        PostNotesRequest,
        RecentNotesRequest,
        PostRemovalNoteRequest,
        ModNotesResponse,
        DeleteNotesResponse,
        ModNoteObject,
        ModNoteObject_ModActionData,
        ModNoteObject_UserNoteData,
        PostModNotesResponse,
        Moderation,
        ModerationServiceName,
        ModerationClientImpl,
        ModerationDefinition,
        AboutLogRequest,
        AboutLocationRequest,
        AcceptModeratorInviteRequest,
        BasicModerationIdRequest,
        DistinguishRequest,
        RemoveRequest,
        SnoozeReportsRequest,
        UpdateCrowdControlLevelRequest,
        StylesheetRequest,
        AboutLogResponse,
        AboutLogResponse_LogObject,
        AboutLogResponse_AboutLogListing,
        AboutLogResponse_AboutLogListing_WrappedLogObject,
        Listings,
        ListingsServiceName,
        ListingsClientImpl,
        ListingsDefinition,
        GetBestRequest,
        GetSortRequest,
        GetCommentsRequest,
        GetByIdRequest,
        GetDuplicatesRequest,
        GetHotRequest,
        GetNewRequest,
        GetRisingRequest,
        ListingResponse,
        LinksAndComments,
        LinksAndCommentsServiceName,
        LinksAndCommentsClientImpl,
        LinksAndCommentsDefinition,
        CommentRequest,
        FollowPostRequest,
        BasicIdRequest,
        InfoRequest,
        MoreChildrenRequest,
        ReportRequest,
        ReportAwardRequest,
        SaveRequest,
        SendRepliesRequest,
        SetContestModeRequest,
        SetSubredditStickyRequest,
        SetSuggestedSortRequest,
        SubmitRequest,
        VoteRequest,
        JsonWrappedComment,
        JsonWrappedComment_WrappedComment,
        JsonWrappedComment_JsonData,
        JsonWrappedComment_Json,
        SubmitResponse,
        SubmitResponse_JsonType,
        SubmitResponse_JsonType_JsonData,
        GraphQL,
        GraphQLServiceName,
        GraphQLClientImpl,
        GraphQLDefinition,
        QueryRequest,
        PersistedQueryRequest,
        QueryResponse,
        Flair_2 as Flair,
        FlairServiceName,
        FlairClientImpl,
        FlairDefinition,
        ClearFlairTemplatesRequest,
        DeleteFlairRequest,
        DeleteFlairTemplateRequest,
        FlairRequest,
        FlairTemplateOrderRequest,
        FlairConfigRequest,
        FlairCsvRequest,
        FlairListRequest,
        FlairSelectorRequest,
        FlairTemplateRequest,
        LinkFlairRequest,
        SelectFlairRequest,
        SetFlairEnabledRequest,
        FlairObject,
        FlairArray,
        FlairSelectorResponseOption,
        FlairSelectorResponse,
        UserFlair_2 as UserFlair,
        FlairListResponse,
        FlairCsvResultError,
        FlairCsvResultWarning,
        FlairCsvResult,
        FlairCsvResponse,
        apiClientConfig_BodyTypeFromJSON,
        apiClientConfig_BodyTypeToJSON,
        Listing_2 as Listing,
        Listing_ListingData,
        WrappedRedditObject,
        JsonRedditObjects,
        JsonRedditObjects_JsonType,
        JsonRedditObjects_JsonType_JsonData,
        RedditObject,
        RedditObject_OEmbed,
        RedditObject_RedditVideo,
        RedditObject_AuthorFlairRichText,
        RedditObject_LinkFlairRichText,
        RedditObject_SecureMedia,
        SubredditObject,
        JsonStatus,
        JsonStatus_JsonErrorType,
        WrappedUserObject,
        ApiClientConfig,
        ApiClientConfig_BodyType,
        AccessKeyPurgeRequest,
        InstallationsPurgeRequest,
        InstallationPurgeRequest,
        AppVersionPurgeRequest,
        AppPurgeRequest,
        PurgeResult,
        AcceptInviteRequest,
        AcceptInviteResponse,
        CacheUtils,
        CacheUtilsServiceName,
        CacheUtilsClientImpl,
        CacheUtilsDefinition,
        ModInviteUtils,
        ModInviteUtilsServiceName,
        ModInviteUtilsClientImpl,
        ModInviteUtilsDefinition,
        TriggerEvent_2 as TriggerEvent,
        IntakeEvent,
        IntakeResponse,
        DataIntaker,
        DataIntakerServiceName,
        DataIntakerClientImpl,
        DataIntakerDefinition,
        firehoseFilterData_ApprovalStatusFromJSON,
        firehoseFilterData_ApprovalStatusToJSON,
        FirehoseFilterData,
        FirehoseFilterData_ApprovalStatus,
        FirehoseFilterData_SafetyTag,
        FirehoseFilterData_SafetyTag_VersionsEntry,
        FirehoseFilterData_PostFilterData,
        FirehoseFilterData_PostFilterData_PerspectiveScoresTitleEntry,
        FirehoseFilterData_PostFilterData_PerspectiveScoresBodyEntry,
        FirehoseFilterData_CommentFilterData,
        FirehoseFilterData_CommentFilterData_PerspectiveScoresEntry,
        DataApiAuthTokenIssuerClient,
        DataApiAuthTokenIssuerClientJSON,
        DataApiAuthTokenIssuerClientProtobuf,
        DataToken,
        DataSubscription,
        Organization,
        DataApiAuthTokenRequest,
        DataApiAuthTokenResponse,
        DataApiAuthTokenIssuer,
        DataApiAuthTokenIssuerServiceName,
        DataApiAuthTokenIssuerClientImpl,
        DataApiAuthTokenIssuerDefinition,
        GetFieldsRequest,
        GetFieldsResponse,
        ValidateFormRequest,
        ValidateFormRequest_FieldValuesEntry,
        ValidateFormResponse,
        ValidateFormResponse_ErrorsEntry,
        InstanceSettings,
        InstanceSettingsServiceName,
        InstanceSettingsClientImpl,
        InstanceSettingsDefinition,
        InstallationSettings,
        InstallationSettingsServiceName,
        InstallationSettingsClientImpl,
        InstallationSettingsDefinition,
        AppSettings,
        AppSettingsServiceName,
        AppSettingsClientImpl,
        AppSettingsDefinition,
        HandlerResult,
        OnPostSubmit,
        OnPostSubmitServiceName,
        OnPostSubmitClientImpl,
        OnPostSubmitDefinition,
        OnPostCreate,
        OnPostCreateServiceName,
        OnPostCreateClientImpl,
        OnPostCreateDefinition,
        OnPostUpdate,
        OnPostUpdateServiceName,
        OnPostUpdateClientImpl,
        OnPostUpdateDefinition,
        OnPostReport,
        OnPostReportServiceName,
        OnPostReportClientImpl,
        OnPostReportDefinition,
        OnPostFlairUpdate,
        OnPostFlairUpdateServiceName,
        OnPostFlairUpdateClientImpl,
        OnPostFlairUpdateDefinition,
        OnPostDelete,
        OnPostDeleteServiceName,
        OnPostDeleteClientImpl,
        OnPostDeleteDefinition,
        OnPostApprove,
        OnPostApproveServiceName,
        OnPostApproveClientImpl,
        OnPostApproveDefinition,
        OnCommentSubmit,
        OnCommentSubmitServiceName,
        OnCommentSubmitClientImpl,
        OnCommentSubmitDefinition,
        OnCommentCreate,
        OnCommentCreateServiceName,
        OnCommentCreateClientImpl,
        OnCommentCreateDefinition,
        OnCommentUpdate,
        OnCommentUpdateServiceName,
        OnCommentUpdateClientImpl,
        OnCommentUpdateDefinition,
        OnCommentReport,
        OnCommentReportServiceName,
        OnCommentReportClientImpl,
        OnCommentReportDefinition,
        OnCommentDelete,
        OnCommentDeleteServiceName,
        OnCommentDeleteClientImpl,
        OnCommentDeleteDefinition,
        OnCommentApprove,
        OnCommentApproveServiceName,
        OnCommentApproveClientImpl,
        OnCommentApproveDefinition,
        OnSubredditSubscribe,
        OnSubredditSubscribeServiceName,
        OnSubredditSubscribeClientImpl,
        OnSubredditSubscribeDefinition,
        OnAppInstall,
        OnAppInstallServiceName,
        OnAppInstallClientImpl,
        OnAppInstallDefinition,
        OnAppUpgrade,
        OnAppUpgradeServiceName,
        OnAppUpgradeClientImpl,
        OnAppUpgradeDefinition,
        OnModAction,
        OnModActionServiceName,
        OnModActionClientImpl,
        OnModActionDefinition,
        OnModMail,
        OnModMailServiceName,
        OnModMailClientImpl,
        OnModMailDefinition,
        OnAccountDelete,
        OnAccountDeleteServiceName,
        OnAccountDeleteClientImpl,
        OnAccountDeleteDefinition,
        Metadata,
        Definition,
        MethodDefinition,
        Rpc_69 as Rpc
    }
}

declare interface PurgeResult {
    /** Number of items purged */
    count: number;
}

declare const PurgeResult: {
    $type: "devvit.gateway.utils.v1alpha.PurgeResult";
    encode(message: PurgeResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PurgeResult;
    fromJSON(object: any): PurgeResult;
    toJSON(message: PurgeResult): unknown;
    create(base?: DeepPartial_26<PurgeResult>): PurgeResult;
    fromPartial(object: DeepPartial_26<PurgeResult>): PurgeResult;
};

declare interface QueryRequest {
    /** gql query string */
    query: string;
    /** put the variables here */
    variables?: {
        [key: string]: any;
    } | undefined;
}

declare const QueryRequest: {
    $type: "devvit.plugin.redditapi.graphql.QueryRequest";
    encode(message: QueryRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryRequest;
    fromJSON(object: any): QueryRequest;
    toJSON(message: QueryRequest): unknown;
    create(base?: DeepPartial_57<QueryRequest>): QueryRequest;
    fromPartial(object: DeepPartial_57<QueryRequest>): QueryRequest;
};

declare interface QueryResponse {
    data?: {
        [key: string]: any;
    } | undefined;
}

declare const QueryResponse: {
    $type: "devvit.plugin.redditapi.graphql.QueryResponse";
    encode(message: QueryResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryResponse;
    fromJSON(object: any): QueryResponse;
    toJSON(message: QueryResponse): unknown;
    create(base?: DeepPartial_57<QueryResponse>): QueryResponse;
    fromPartial(object: DeepPartial_57<QueryResponse>): QueryResponse;
};

/**
 * @mixin
 */
declare type RawTextContainer<Context> = {
    /**
     * Append unstyled text
     * @param text
     */
    rawText(text: string): Context;
};

declare type RawTextOptions = {
    text: string;
};

declare interface ReadAllMessagesRequest {
    /** A comma-separated list of items */
    filterTypes: string;
}

declare const ReadAllMessagesRequest: {
    $type: "devvit.plugin.redditapi.privatemessages.ReadAllMessagesRequest";
    encode(message: ReadAllMessagesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReadAllMessagesRequest;
    fromJSON(object: any): ReadAllMessagesRequest;
    toJSON(message: ReadAllMessagesRequest): unknown;
    create(base?: DeepPartial_84<ReadAllMessagesRequest>): ReadAllMessagesRequest;
    fromPartial(object: DeepPartial_84<ReadAllMessagesRequest>): ReadAllMessagesRequest;
};

declare interface Realtime {
    Subscribe(request: RealtimeRequest, metadata?: Metadata): Observable<RealtimeEvent>;
    Send(request: RealtimeEvent, metadata?: Metadata): Promise<Empty>;
}

declare class RealtimeClient {
    #private;
    constructor(metadata: Metadata);
    send(channel: string, data: Data): Promise<void>;
}

declare class RealtimeClientImpl implements Realtime {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_31, opts?: {
        service?: string;
    });
    Subscribe(request: RealtimeRequest, metadata?: Metadata): Observable<RealtimeEvent>;
    Send(request: RealtimeEvent, metadata?: Metadata): Promise<Empty>;
}

declare type RealtimeDefinition = typeof RealtimeDefinition;

declare const RealtimeDefinition: {
    readonly name: "Realtime";
    readonly fullName: "devvit.events.v1alpha.Realtime";
    readonly methods: {
        readonly subscribe: {
            readonly name: "Subscribe";
            readonly requestType: {
                $type: "devvit.events.v1alpha.RealtimeRequest";
                encode(message: RealtimeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RealtimeRequest;
                fromJSON(object: any): RealtimeRequest;
                toJSON(message: RealtimeRequest): unknown;
                create(base?: DeepPartial_48<RealtimeRequest>): RealtimeRequest;
                fromPartial(object: DeepPartial_48<RealtimeRequest>): RealtimeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.events.v1alpha.RealtimeEvent";
                encode(message: RealtimeEvent, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RealtimeEvent;
                fromJSON(object: any): RealtimeEvent;
                toJSON(message: RealtimeEvent): unknown;
                create(base?: DeepPartial_48<RealtimeEvent>): RealtimeEvent;
                fromPartial(object: DeepPartial_48<RealtimeEvent>): RealtimeEvent;
            };
            readonly responseStream: true;
            readonly options: {};
        };
        readonly send: {
            readonly name: "Send";
            readonly requestType: {
                $type: "devvit.events.v1alpha.RealtimeEvent";
                encode(message: RealtimeEvent, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RealtimeEvent;
                fromJSON(object: any): RealtimeEvent;
                toJSON(message: RealtimeEvent): unknown;
                create(base?: DeepPartial_48<RealtimeEvent>): RealtimeEvent;
                fromPartial(object: DeepPartial_48<RealtimeEvent>): RealtimeEvent;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare interface RealtimeEvent {
    /** The channel that received the message */
    channel: string;
    /** The data that was received */
    data?: any | undefined;
}

declare const RealtimeEvent: {
    $type: "devvit.events.v1alpha.RealtimeEvent";
    encode(message: RealtimeEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RealtimeEvent;
    fromJSON(object: any): RealtimeEvent;
    toJSON(message: RealtimeEvent): unknown;
    create(base?: DeepPartial_48<RealtimeEvent>): RealtimeEvent;
    fromPartial(object: DeepPartial_48<RealtimeEvent>): RealtimeEvent;
};

declare interface RealtimeRequest {
    channels: string[];
}

declare const RealtimeRequest: {
    $type: "devvit.events.v1alpha.RealtimeRequest";
    encode(message: RealtimeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RealtimeRequest;
    fromJSON(object: any): RealtimeRequest;
    toJSON(message: RealtimeRequest): unknown;
    create(base?: DeepPartial_48<RealtimeRequest>): RealtimeRequest;
    fromPartial(object: DeepPartial_48<RealtimeRequest>): RealtimeRequest;
};

declare const RealtimeServiceName = "devvit.events.v1alpha.Realtime";

declare interface RealtimeSubscriptionEvent {
    /** Event data from the subscription */
    event?: RealtimeEvent | undefined;
    /** If set, this event signals a change in the subscription status */
    status?: RealtimeSubscriptionStatus | undefined;
}

declare const RealtimeSubscriptionEvent: {
    $type: "devvit.ui.effects.v1alpha.RealtimeSubscriptionEvent";
    encode(message: RealtimeSubscriptionEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RealtimeSubscriptionEvent;
    fromJSON(object: any): RealtimeSubscriptionEvent;
    toJSON(message: RealtimeSubscriptionEvent): unknown;
    create(base?: DeepPartial_31<RealtimeSubscriptionEvent>): RealtimeSubscriptionEvent;
    fromPartial(object: DeepPartial_31<RealtimeSubscriptionEvent>): RealtimeSubscriptionEvent;
};

/** Instruct the client to subscribe to realtime events */
declare interface RealtimeSubscriptionsEffect {
    /** List of IDs the client should be subscribed to */
    subscriptionIds: string[];
}

declare const RealtimeSubscriptionsEffect: {
    $type: "devvit.ui.effects.v1alpha.RealtimeSubscriptionsEffect";
    encode(message: RealtimeSubscriptionsEffect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RealtimeSubscriptionsEffect;
    fromJSON(object: any): RealtimeSubscriptionsEffect;
    toJSON(message: RealtimeSubscriptionsEffect): unknown;
    create(base?: DeepPartial_31<RealtimeSubscriptionsEffect>): RealtimeSubscriptionsEffect;
    fromPartial(object: DeepPartial_31<RealtimeSubscriptionsEffect>): RealtimeSubscriptionsEffect;
};

declare enum RealtimeSubscriptionStatus {
    REALTIME_SUBSCRIBED = 0,
    REALTIME_UNSUBSCRIBED = 1,
    UNRECOGNIZED = -1
}

declare function realtimeSubscriptionStatusFromJSON(object: any): RealtimeSubscriptionStatus;

declare function realtimeSubscriptionStatusToJSON(object: RealtimeSubscriptionStatus): number;

declare interface RecentNotesRequest {
    /** a comma delimited list of subreddits by name (e.g. 'pics,worldnews') */
    subreddits: string;
    /** a comma delimited list of usernames (e.g. 'foo,bar') */
    users: string;
}

declare const RecentNotesRequest: {
    $type: "devvit.plugin.redditapi.modnote.RecentNotesRequest";
    encode(message: RecentNotesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RecentNotesRequest;
    fromJSON(object: any): RecentNotesRequest;
    toJSON(message: RecentNotesRequest): unknown;
    create(base?: DeepPartial_3<RecentNotesRequest>): RecentNotesRequest;
    fromPartial(object: DeepPartial_3<RecentNotesRequest>): RecentNotesRequest;
};

/**
 * The Reddit API Client
 *
 * To use the Reddit API Client, add it to the plugin configuration at the top of the file.
 *
 * @example
 * ```ts
 *
 * Devvit.configure({
 *    redditAPI: true,
 *    // other plugins
 * })

 * // use within one of our capability handlers e.g. Menu Actions, Triggers, Scheduled Job Type, etc
 * async (event, context) => {
 *     const { reddit } = context
 *     const subreddit = await reddit.getSubredditById(context.subredditId);
 *     context.reddit.submitPost({
 *       subredditName: subreddit.name,
 *       title: 'test post',
 *       text: 'test body',
 *     })
 *     // additional code
 * }
 * ```
 */
export declare class RedditAPIClient {
    #private;
    constructor(metadata: Metadata);
    /**
     * Get ModMail API object
     *
     * @example
     * ```ts
     * await reddit.modMail.reply({
     *   body: "Here is my message",
     *   conversationId: "abcd42";
     * })
     * ```
     */
    get modMail(): ModMailService;
    /**
     * Gets a {@link Subreddit} object by ID
     *
     * @param {string} id - The ID (starting with t5_) of the subreddit to retrieve. e.g. t5_2qjpg
     * @returns {Promise<Subreddit>} A Promise that resolves a Subreddit object.
     * @example
     * ```ts
     * const memes = await reddit.getSubredditById('t5_2qjpg');
     * ```
     */
    getSubredditById(id: string): Promise<Subreddit>;
    /**
     * Gets a {@link Subreddit} object by name
     *
     * @param {string} name The name of a subreddit omitting the r/. This is case insensitive.
     * @returns {Promise<Subreddit>} A Promise that resolves a Subreddit object.
     * @example
     * ```ts
     * const askReddit = await reddit.getSubredditByName('askReddit');
     * ```
     */
    getSubredditByName(name: string): Promise<Subreddit>;
    /**
     * Add a removal reason to a subreddit
     *
     * @param subredditName Name of the subreddit being removed.
     * @param options Options.
     * @param options.title The title of the removal reason.
     * @param options.message The message associated with the removal reason.
     * @example
     * ```ts
     * const newReason = await reddit.addSubredditRemovalReasons(
     *   'askReddit',
     *   {
     *     title: 'Spam',
     *     message: 'This is spam!'
     *   }
     * );
     * console.log(newReason.id)
     * ```
     *
     * @returns {string} Removal Reason ID
     */
    addSubredditRemovalReason(subredditName: string, options: {
        title: string;
        message: string;
    }): Promise<string>;
    /**
     * Get the list of subreddit's removal reasons (ordered)
     *
     * @param subredditName
     * @example
     * ```ts
     * const reasons = await reddit.getSubredditRemovalReasons('askReddit');
     *
     * for (let reason of reasons) {
     *   console.log(reason.id, reason.message, reason.title)
     * }
     * ```
     *
     * @returns Ordered array of Removal Reasons
     */
    getSubredditRemovalReasons(subredditName: string): Promise<RemovalReason[]>;
    /**
     * Retrieves the current subreddit based on the provided metadata.
     *
     * @returns {Promise<Subreddit>} A Promise that resolves a Subreddit object.
     * @example
     * ```ts
     * const currentSubreddit = await reddit.getCurrentSubreddit(metadata);
     * ```
     */
    getCurrentSubreddit(): Promise<Subreddit>;
    /**
     * Gets a {@link Post} object by ID
     *
     * @param id
     * @returns A Promise that resolves to a Post object.
     */
    getPostById(id: string): Promise<Post>;
    /**
     * Submits a new post to a subreddit.
     *
     * @param options - Either a self post or a link post.
     * @returns A Promise that resolves to a Post object.
     * @example
     * ```ts
     * const post = await reddit.submitPost({
     *   subredditName: 'devvit',
     *   title: 'Hello World',
     *   richtext: new RichTextBuilder()
     *     .heading({ level: 1 }, (h) => {
     *       h.rawText('Hello world');
     *     })
     *     .codeBlock({}, (cb) => cb.rawText('This post was created via the Devvit API'))
     *     .build()
     * });
     * ```
     */
    submitPost(options: SubmitPostOptions): Promise<Post>;
    /**
     * Crossposts a post to a subreddit.
     *
     * @param options - Options for crossposting a post
     * @param options.subredditName - The name of the subreddit to crosspost to
     * @param options.postId - The ID of the post to crosspost
     * @param options.title - The title of the crosspost
     * @returns - A Promise that resolves to a Post object.
     */
    crosspost(options: CrosspostOptions): Promise<Post>;
    /**
     * Gets a {@link User} object by ID
     *
     * @param id - The ID (starting with t2_) of the user to retrieve. e.g. t2_1qjpg
     * @returns A Promise that resolves to a User object.
     * @example
     * ```ts
     * const user = await reddit.getUserById('t2_1qjpg');
     * ```
     */
    getUserById(id: string): Promise<User>;
    getCollectionById(collectionId: string): Promise<PostCollection>;
    createCollection(options: CreateCollectionInput): Promise<PostCollection>;
    getCollectionsForSubreddit(subredditId: string): Promise<PostCollection[]>;
    /**
     * Gets a {@link User} object by username
     *
     * @param username - The username of the user omitting the u/. e.g. 'devvit'
     * @returns A Promise that resolves to a User object.
     * @example
     * ```ts
     * const user = await reddit.getUserByUsername('devvit');
     * ```
     */
    getUserByUsername(username: string): Promise<User>;
    /**
     * Get the current calling user based on the provided metadata.
     * Resolves to undefined for logged-out custom post renders.
     *
     * @returns A Promise that resolves to a User object or undefined
     * @example
     * ```ts
     * const user = await reddit.getCurrentUser(metadata);
     * ```
     */
    getCurrentUser(): Promise<User | undefined>;
    /**
     * Get the user that the app runs as on the provided metadata.
     *
     * @returns A Promise that resolves to a User object.
     * @example
     * ```ts
     * const user = await reddit.getAppUser(metadata);
     * ```
     */
    getAppUser(): Promise<User>;
    /**
     * Get the snoovatar URL for a given username.
     *
     * @param username - The username of the snoovatar to retrieve
     * @returns A Promise that resolves to a URL of the snoovatar image if it exists.
     */
    getSnoovatarUrl(username: string): Promise<string | undefined>;
    /**
     * Get a {@link Comment} object by ID
     *
     * @param id - The ID (starting with t1_) of the comment to retrieve. e.g. t1_1qjpg
     * @returns A Promise that resolves to a Comment object.
     * @example
     * ```ts
     * const comment = await reddit.getCommentById('t1_1qjpg');
     * ```
     */
    getCommentById(id: string): Promise<Comment>;
    /**
     * Get a list of comments from a specific post or comment.
     *
     * @param options - Options for the request
     * @param options.postId - The ID of the post e.g. 't3_1qjpg'
     * @param options.commentId - The ID of the comment e.g. 't1_1qjpg'
     * @param options.limit - The maximum number of comments to return. e.g. 1000
     * @param options.pageSize - The number of comments to return per request. e.g. 100
     * @param options.sort - The sort order of the comments. e.g. 'new'
     * @returns A Listing of Comment objects.
     * @example
     * ```ts
     * const comments = await reddit.getComments({
     *   postId: 't3_1qjpg',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getComments(options: GetCommentsOptions): Listing<Comment>;
    /**
     * Get a list of comments by a specific user.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user omitting the u/. e.g. 'spez'
     * @param options.sort - The sort order of the comments. e.g. 'new'
     * @param options.timeframe - The timeframe of the comments. e.g. 'all'
     * @param options.limit - The maximum number of comments to return. e.g. 1000
     * @param options.pageSize - The number of comments to return per request. e.g. 100
     * @returns A Listing of Comment objects.
     */
    getCommentsByUser(options: GetCommentsByUserOptions): Listing<Comment>;
    /**
     * Submit a new comment to a post or comment.
     *
     * @param options - You must provide either `options.text` or `options.richtext` but not both.
     * @param options.id - The ID of the post or comment to comment on. e.g. 't3_1qjpg' for post and 't1_1qgif' for comment
     * @param options.text - The text of the comment
     * @param options.richtext - The rich text of the comment
     * @returns A Promise that resolves to a Comment object.
     */
    submitComment(options: CommentSubmissionOptions & {
        id: string;
    }): Promise<Comment>;
    /**
     * Get a list of controversial posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getControversialPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getControversialPosts(options: GetPostsOptionsWithTimeframe): Listing<Post>;
    /**
     * Get a list of controversial posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getControversialPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getTopPosts(options: GetPostsOptionsWithTimeframe): Listing<Post>;
    /**
     * Get a list of hot posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getHotPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getHotPosts(options: GetHotPostsOptions): Listing<Post>;
    /**
     * Get a list of new posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getNewPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getNewPosts(options: GetPostsOptions): Listing<Post>;
    /**
     * Get a list of hot posts from a specific subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get posts from. e.g. 'memes'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     * @example
     * ```ts
     * const posts = await reddit.getRisingPosts({
     *   subredditName: 'memes',
     *   timeframe: 'day',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getRisingPosts(options: GetPostsOptions): Listing<Post>;
    /**
     * Get a list of posts from a specific user.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user omitting the u/. e.g. 'spez'
     * @param options.sort - The sort method to use. e.g. 'new'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     */
    getPostsByUser(options: GetPostsByUserOptions): Listing<Post>;
    /**
     * Get a list of posts and comments from a specific user.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user omitting the u/. e.g. 'spez'
     * @param options.sort - The sort method to use. e.g. 'new'
     * @param options.timeframe - The timeframe to get posts from. e.g. 'day'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of `Post` and `Comment` objects.
     */
    getCommentsAndPostsByUser(options: GetUserOverviewOptions): Listing<Post | Comment>;
    /**
     * Get the moderation log for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the moderation log from. e.g. 'memes'
     * @param options.moderatorUsernames (optional) A moderator filter. Accepts an array of usernames
     * @param options.type (optional) Filter the entries by the type of the Moderator action
     * @param options.limit - (optional) The maximum number of ModActions to return. e.g. 1000
     * @param options.pageSize - (optional) The number of ModActions to return per request. e.g. 100
     * @returns A Listing of ModAction objects.
     * @example
     * ```ts
     * const modActions = await reddit.getModerationLog({
     *   subredditName: 'memes',
     *   moderatorUsernames: ['spez'],
     *   type: 'banuser',
     *   limit: 1000,
     *   pageSize: 100
     * }).all();
     * ```
     */
    getModerationLog(options: GetModerationLogOptions): Listing<ModAction>;
    /**
     * Get a list of users who have been approved to post in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the approved users from. e.g. 'memes'
     * @param options.username - Use this to see if a user is approved to post in the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getApprovedUsers(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Approve a user to post in a subreddit.
     *
     * @param username - The username of the user to approve. e.g. 'spez'
     * @param subredditName - The name of the subreddit to approve the user in. e.g. 'memes'
     */
    approveUser(username: string, subredditName: string): Promise<void>;
    /**
     * Remove a user's approval to post in a subreddit.
     *
     * @param username - The username of the user to remove approval from. e.g. 'spez'
     * @param subredditName - The name of the subreddit to remove the user's approval from. e.g. 'memes'
     */
    removeUser(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of users who are wiki contributors of a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the wiki contributors from. e.g. 'memes'
     * @param options.username - Use this to see if a user is a wiki contributor for the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getWikiContributors(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Add a user as a wiki contributor for a subreddit.
     *
     * @param username - The username of the user to add as a wiki contributor. e.g. 'spez'
     * @param subredditName - The name of the subreddit to add the user as a wiki contributor. e.g. 'memes'
     */
    addWikiContributor(username: string, subredditName: string): Promise<void>;
    /**
     * Remove a user's wiki contributor status for a subreddit.
     *
     * @param username - The username of the user to remove wiki contributor status from. e.g. 'spez'
     * @param subredditName - The name of the subreddit to remove the user's wiki contributor status from. e.g. 'memes'
     */
    removeWikiContributor(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of users who are banned from a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the banned users from. e.g. 'memes'
     * @param options.username - Use this to see if a user is banned from the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getBannedUsers(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Ban a user from a subreddit.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user to ban. e.g. 'spez'
     * @param options.subredditName - The name of the subreddit to ban the user from. e.g. 'memes'
     * @param options.note - A mod note for the ban. (optional)
     * @param options.duration - The number of days the user should be banned for. (optional)
     * @param options.message - A message to send to the user when they are banned. (optional)
     * @param options.context - The ID of the post or comment that caused the ban. (optional)
     * @param options.reason - The reason for the ban. (optional)
     */
    banUser(options: BanUserOptions): Promise<void>;
    /**
     * Unban a user from a subreddit.
     *
     * @param username - The username of the user to unban. e.g. 'spez'
     * @param subredditName - The name of the subreddit to unban the user from. e.g. 'memes'
     */
    unbanUser(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of users who are banned from contributing to the wiki on a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the banned wiki contributors from. e.g. 'memes'
     * @param options.username - Use this to see if a user is banned from contributing to the wiki on a subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getBannedWikiContributors(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Ban a user from contributing to the wiki on a subreddit.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user to ban. e.g. 'spez'
     * @param options.subredditName - The name of the subreddit to ban the user from contributing to the wiki on. e.g. 'memes'
     * @param options.reason - The reason for the ban. (optional)
     * @param options.duration - The number of days the user should be banned for. (optional)
     * @param options.note - A mod note for the ban. (optional)
     */
    banWikiContributor(options: BanWikiContributorOptions): Promise<void>;
    /**
     *
     * @param username - The username of the user to unban. e.g. 'spez'
     * @param subredditName - The name of the subreddit to unban the user from contributing to the wiki on. e.g. 'memes'
     */
    unbanWikiContributor(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of users who are moderators for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the moderators from. e.g. 'memes'
     * @param options.username - Use this to see if a user is a moderator of the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A Listing of User objects.
     */
    getModerators(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Invite a user to become a moderator of a subreddit.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user to invite. e.g. 'spez'
     * @param options.subredditName - The name of the subreddit to invite the user to moderate. e.g. 'memes'
     * @param options.permissions - The permissions to give the user. (optional) Defaults to 'all'.
     */
    inviteModerator(options: InviteModeratorOptions): Promise<void>;
    /**
     * Revoke a moderator invite for a user to a subreddit.
     *
     * @param username - The username of the user to revoke the invite for. e.g. 'spez'
     * @param subredditName - The name of the subreddit to revoke the invite for. e.g. 'memes'
     */
    revokeModeratorInvite(username: string, subredditName: string): Promise<void>;
    /**
     * Remove a user as a moderator of a subreddit.
     *
     * @param username - The username of the user to remove as a moderator. e.g. 'spez'
     * @param subredditName - The name of the subreddit to remove the user as a moderator from. e.g. 'memes'
     */
    removeModerator(username: string, subredditName: string): Promise<void>;
    /**
     * Update the permissions of a moderator of a subreddit.
     *
     * @param username - The username of the user to update the permissions for. e.g. 'spez'
     * @param subredditName - The name of the subreddit. e.g. 'memes'
     * @param permissions - The permissions to give the user. e.g ['posts', 'wiki']
     */
    setModeratorPermissions(username: string, subredditName: string, permissions: ModeratorPermission[]): Promise<void>;
    /**
     * Get a list of users who are muted in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the muted users from. e.g. 'memes'
     * @param options.username - Use this to see if a user is muted in the subreddit.
     * @param options.limit - The maximum number of users to return. e.g. 1000
     * @param options.pageSize - The number of users to return per request. e.g. 100
     * @returns A listing of User objects.
     */
    getMutedUsers(options: GetSubredditUsersOptions): Listing<User>;
    /**
     * Mute a user in a subreddit. Muting a user prevents them from sending modmail.
     *
     * @param options - Options for the request
     * @param options.username - The username of the user to mute. e.g. 'spez'
     * @param options.subredditName - The name of the subreddit to mute the user in. e.g. 'memes'
     * @param options.note - A mod note on why the user was muted. (optional)
     */
    muteUser(options: MuteUserOptions): Promise<void>;
    /**
     * Unmute a user in a subreddit. Unmuting a user allows them to send modmail.
     *
     * @param username - The username of the user to unmute. e.g. 'spez'
     * @param subredditName - The name of the subreddit to unmute the user in. e.g. 'memes'
     */
    unmuteUser(username: string, subredditName: string): Promise<void>;
    /**
     * Get a list of mod notes related to a user in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to get the mod notes from. e.g. 'memes'
     * @param options.username - The username of the user to get the mod notes for. e.g. 'spez'
     * @param options.filter - Filter the mod notes by type. e.g. 'NOTE', 'BAN', 'APPROVAL'
     * @param options.limit - The maximum number of mod notes to return. e.g. 1000
     * @param options.pageSize - The number of mod notes to return per request. e.g. 100
     * @returns A listing of ModNote objects.
     */
    getModNotes(options: GetModNotesOptions): Listing<ModNote>;
    /**
     * Delete a mod note.
     *
     * @param options - Options for the request
     * @param options.subreddit - The name of the subreddit to delete the mod note from. e.g. 'memes'
     * @param options.noteId - The ID of the mod note to delete (should have a ModNote_ prefix).
     * @returns True if it was deleted successfully; false otherwise.
     */
    deleteModNote(options: DeleteNotesOptions): Promise<boolean>;
    /**
     * Add a mod note.
     *
     * @param options - Options for the request
     * @param options.subreddit - The name of the subreddit to add the mod note to. e.g. 'memes'
     * @param options.user - The username of the user to add the mod note to. e.g. 'spez'
     * @param options.redditId - The ID of the comment or post to add the mod note to. e.g. 't3_1234'
     * @param options.label - The label of the mod note. e.g. 'SPAM_WARNING'
     * @param options.note - The text of the mod note.
     * @returns A Promise that resolves if the mod note was successfully added.
     */
    addModNote(options: Omit<CreateModNoteOptions, 'redditId'> & {
        redditId: string;
    }): Promise<ModNote>;
    /**
     * Add a mod note for why a post or comment was removed
     *
     * @param options.itemIds list of thing ids
     * @param options.reasonId id of a Removal Reason - you can leave this as an empty string if you don't have one
     * @param options.modNote the reason for removal (maximum 100 characters) (optional)
     */
    addRemovalNote(options: AddRemovalNoteOptions): Promise<void>;
    /**
     * Sends a private message to a user.
     *
     * @param options - The options for sending the message.
     * @returns A Promise that resolves if the private message was successfully sent.
     */
    sendPrivateMessage(options: SendPrivateMessageOptions): Promise<void>;
    /**
     * Sends a private message to a user on behalf of a subreddit.
     *
     * @param options - The options for sending the message as a subreddit.
     * @returns A Promise that resolves if the private message was successfully sent.
     */
    sendPrivateMessageAsSubreddit(options: SendPrivateMessageAsSubredditOptions): Promise<void>;
    /**
     * Approve a post or comment.
     *
     * @param id - The id of the post (t3_) or comment (t1_) to approve.
     * @example
     * ```ts
     * await reddit.approve('t3_123456');
     * await reddit.approve('t1_123456');
     * ```
     */
    approve(id: string): Promise<void>;
    /**
     * Remove a post or comment.
     *
     * @param id - The id of the post (t3_) or comment (t1_) to remove.
     * @param isSpam - Is the post or comment being removed because it's spam?
     * @example
     * ```ts
     * await reddit.remove('t3_123456', false);
     * await reddit.remove('t1_123456', true);
     * ```
     */
    remove(id: string, isSpam: boolean): Promise<void>;
    /**
     * Get the list of post flair templates for a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the post flair templates for.
     * @returns A Promise that resolves with an array of FlairTemplate objects.
     */
    getPostFlairTemplates(subredditName: string): Promise<FlairTemplate[]>;
    /**
     * Get the list of user flair templates for a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the user flair templates for.
     * @returns A Promise that resolves with an array of FlairTemplate objects.
     */
    getUserFlairTemplates(subredditName: string): Promise<FlairTemplate[]>;
    /**
     * Create a post flair template for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to create the flair template for.
     * @param options.allowableContent - The content that is allowed to be used with this flair template. e.g. 'all' or 'text' or 'emoji'
     * @param options.backgroundColor - The background color of the flair template. e.g. '#ff0000' or 'transparent'
     * @param options.maxEmojis - The maximum number of emojis that can be used with this flair template.
     * @param options.modOnly - Whether or not this flair template is only available to mods.
     * @param options.text - The text of the flair template.
     * @param options.textColor - The text color of the flair template. Either 'dark' or 'light'.
     * @param options.allowUserEdits - Whether or not users can edit the flair template when selecting a flair.
     * @returns The created FlairTemplate object.
     */
    createPostFlairTemplate(options: CreateFlairTemplateOptions): Promise<FlairTemplate>;
    /**
     * Create a user flair template for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to create the flair template for.
     * @param options.allowableContent - The content that is allowed to be used with this flair template. e.g. 'all' or 'text' or 'emoji'
     * @param options.backgroundColor - The background color of the flair template. e.g. '#ff0000' or 'transparent'
     * @param options.maxEmojis - The maximum number of emojis that can be used with this flair template.
     * @param options.modOnly - Whether or not this flair template is only available to mods.
     * @param options.text - The text of the flair template.
     * @param options.textColor - The text color of the flair template. Either 'dark' or 'light'.
     * @param options.allowUserEdits - Whether or not users can edit the flair template when selecting a flair.
     * @returns The created FlairTemplate object.
     */
    createUserFlairTemplate(options: CreateFlairTemplateOptions): Promise<FlairTemplate>;
    /**
     * Edit a flair template for a subreddit. This can be either a post or user flair template.
     * Note: If you leave any of the options fields as undefined, they will reset to their default values.
     *
     * @param options - Options for the request
     * @param options.id - The ID of the flair template to edit.
     * @param options.subredditName - The name of the subreddit to create the flair template for.
     * @param options.allowableContent - The content that is allowed to be used with this flair template. e.g. 'all' or 'text' or 'emoji'
     * @param options.backgroundColor - The background color of the flair template. e.g. '#ff0000' or 'transparent'
     * @param options.maxEmojis - The maximum number of emojis that can be used with this flair template.
     * @param options.modOnly - Is this flair template only available to mods?
     * @param options.text - The text of the flair template.
     * @param options.textColor - The text color of the flair template. Either 'dark' or 'light'.
     * @param options.allowUserEdits - Can users can edit the flair template when selecting a flair?
     * @returns The edited FlairTemplate object.
     */
    editFlairTemplate(options: EditFlairTemplateOptions): Promise<FlairTemplate>;
    /**
     * Delete a flair template from a subreddit.
     *
     * @param subredditName - The name of the subreddit to delete the flair template from.
     * @param flairTemplateId - The ID of the flair template to delete.
     */
    deleteFlairTemplate(subredditName: string, flairTemplateId: string): Promise<void>;
    /**
     * Set the flair for a user in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to set the flair for.
     * @param options.username - The username of the user to set the flair for.
     * @param options.flairTemplateId - The ID of the flair template to use.
     * @param options.text - The text of the flair.
     * @param options.cssClass - The CSS class of the flair.
     * @param options.backgroundColor - The background color of the flair.
     * @param options.textColor - The text color of the flair.
     */
    setUserFlair(options: SetUserFlairOptions): Promise<void>;
    /**
     * Remove the flair for a user in a subreddit.
     *
     * @param subredditName - The name of the subreddit to remove the flair from.
     * @param username - The username of the user to remove the flair from.
     */
    removeUserFlair(subredditName: string, username: string): Promise<void>;
    /**
     * Set the flair for a post in a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit to set the flair for.
     * @param options.postId - The ID of the post to set the flair for.
     * @param options.flairTemplateId - The ID of the flair template to use.
     * @param options.text - The text of the flair.
     * @param options.cssClass - The CSS class of the flair.
     * @param options.backgroundColor - The background color of the flair.
     * @param options.textColor - The text color of the flair.
     */
    setPostFlair(options: SetPostFlairOptions): Promise<void>;
    /**
     * Remove the flair for a post in a subreddit.
     *
     * @param subredditName - The name of the subreddit to remove the flair from.
     * @param postId - The ID of the post to remove the flair from.
     */
    removePostFlair(subredditName: string, postId: string): Promise<void>;
    /**
     * Get the widgets for a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the widgets for.
     * @returns - An array of Widget objects.
     */
    getWidgets(subredditName: string): Promise<Widget[]>;
    /**
     * Delete a widget from a subreddit.
     *
     * @param subredditName - The name of the subreddit to delete the widget from.
     * @param widgetId - The ID of the widget to delete.
     */
    deleteWidget(subredditName: string, widgetId: string): Promise<void>;
    /**
     * Add a widget to a subreddit.
     *
     * @param widgetData - The data for the widget to add.
     * @returns - The added Widget object.
     */
    addWidget(widgetData: AddWidgetData): Promise<Widget>;
    /**
     * Reorder the widgets for a subreddit.
     *
     * @param subredditName - The name of the subreddit to reorder the widgets for.
     * @param orderByIds - An array of widget IDs in the order that they should be displayed.
     */
    reorderWidgets(subredditName: string, orderByIds: string[]): Promise<void>;
    /**
     * Get a wiki page from a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the wiki page from.
     * @param page - The name of the wiki page to get.
     * @returns The requested WikiPage object.
     */
    getWikiPage(subredditName: string, page: string): Promise<WikiPage>;
    /**
     * Get the wiki pages for a subreddit.
     *
     * @param subredditName - The name of the subreddit to get the wiki pages from.
     * @returns A list of the wiki page names for the subreddit.
     */
    getWikiPages(subredditName: string): Promise<string[]>;
    /**
     * Create a new wiki page for a subreddit.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit the wiki is in.
     * @param options.page - The name of the wiki page to create.
     * @param options.content - The Markdown content of the wiki page.
     * @param options.reason - The reason for creating the wiki page.
     * @returns - The created WikiPage object.
     */
    createWikiPage(options: CreateWikiPageOptions): Promise<WikiPage>;
    /**
     * Update a wiki page.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit the wiki is in.
     * @param options.page - The name of the wiki page to update.
     * @param options.content - The Markdown content of the wiki page.
     * @param options.reason - The reason for updating the wiki page.
     * @returns The updated WikiPage object.
     */
    updateWikiPage(options: UpdateWikiPageOptions): Promise<WikiPage>;
    /**
     * Get the revisions for a wiki page.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit the wiki is in.
     * @param options.page - The name of the wiki page to get the revisions for.
     * @param options.limit - The maximum number of revisions to return.
     * @param options.after - The ID of the revision to start after.
     * @returns A Listing of WikiPageRevision objects.
     */
    getWikiPageRevisions(options: GetPageRevisionsOptions): Listing<WikiPageRevision>;
    /**
     * Revert a wiki page to a previous revision.
     *
     * @param subredditName - The name of the subreddit the wiki is in.
     * @param page - The name of the wiki page to revert.
     * @param revisionId - The ID of the revision to revert to.
     */
    revertWikiPage(subredditName: string, page: string, revisionId: string): Promise<void>;
    /**
     * Get the settings for a wiki page.
     *
     * @param subredditName - The name of the subreddit the wiki is in.
     * @param page - The name of the wiki page to get the settings for.
     * @returns A WikiPageSettings object.
     */
    getWikiPageSettings(subredditName: string, page: string): Promise<WikiPageSettings>;
    /**
     * Update the settings for a wiki page.
     *
     * @param options - Options for the request
     * @param options.subredditName - The name of the subreddit the wiki is in.
     * @param options.page - The name of the wiki page to update the settings for.
     * @param options.listed - Whether the wiki page should be listed in the wiki index.
     * @param options.permLevel - The permission level required to edit the wiki page.
     * @returns A WikiPageSettings object.
     */
    updateWikiPageSettings(options: UpdatePageSettingsOptions): Promise<WikiPageSettings>;
    /**
     * Add an editor to a wiki page.
     *
     * @param subredditName - The name of the subreddit the wiki is in.
     * @param page - The name of the wiki page to add the editor to.
     * @param username - The username of the user to add as an editor.
     */
    addEditorToWikiPage(subredditName: string, page: string, username: string): Promise<void>;
    /**
     * Remove an editor from a wiki page.
     *
     * @param subredditName - The name of the subreddit the wiki is in.
     * @param page - The name of the wiki page to remove the editor from.
     * @param username - The username of the user to remove as an editor.
     */
    removeEditorFromWikiPage(subredditName: string, page: string, username: string): Promise<void>;
    /**
     * Get private messages sent to the currently authenticated user.
     *
     * @param options - Options for the request
     * @param options.type - The type of messages to get.
     */
    getMessages(options: GetPrivateMessagesOptions): Promise<Listing<PrivateMessage>>;
    /**
     * Mark all private messages as read.
     */
    markAllMessagesAsRead(): Promise<void>;
    /**
     * Report a Post or Comment
     *
     * The report is sent to the moderators of the subreddit for review.
     *
     * @param thing Post or Comment
     * @param options Options
     * @param options.reason Why the thing is reported
     *
     * @example
     * ```ts
     * await reddit.report(post, {
     *  reason: 'This is spam!',
     * })
     * ```
     */
    report(thing: Post | Comment, options: {
        reason: string;
    }): Promise<JsonStatus>;
    /**
     * Return a listing of things requiring moderator review, such as reported things and items.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getModQueue();
     * console.log("Posts and Comments: ",  await listing.all())
     * listing = await subreddit.getModQueue({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getModQueue(options: ModLogOptions<'comment'>): Listing<Comment>;
    getModQueue(options: ModLogOptions<'post'>): Listing<Post>;
    getModQueue(options: ModLogOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been reported.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getReports();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getReports({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getReports(options: ModLogOptions<'comment'>): Listing<Comment>;
    getReports(options: ModLogOptions<'post'>): Listing<Post>;
    getReports(options: ModLogOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been marked as spam or otherwise removed.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getSpam();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getSpam({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getSpam(options: ModLogOptions<'comment'>): Listing<Comment>;
    getSpam(options: ModLogOptions<'post'>): Listing<Post>;
    getSpam(options: ModLogOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have yet to be approved/removed by a mod.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getUnmoderated();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getUnmoderated({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getUnmoderated(options: ModLogOptions<'comment'>): Listing<Comment>;
    getUnmoderated(options: ModLogOptions<'post'>): Listing<Post>;
    getUnmoderated(options: ModLogOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been edited recently.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getEdited();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getEdited({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getEdited(options: ModLogOptions<'comment'>): Listing<Comment>;
    getEdited(options: ModLogOptions<'post'>): Listing<Post>;
    getEdited(options: ModLogOptions<'all'>): Listing<Post | Comment>;
    /**
     * Gets a {@link Vault} for the specified address.
     *
     * @param {string} address - The address (starting with 0x) of the Vault.
     * @example
     * ```ts
     * const vault = await reddit.getVaultByAddress('0x205ee28744456bDBf180A0Fa7De51e0F116d54Ed');
     * ```
     */
    getVaultByAddress(address: string): Promise<Vault>;
    /**
     * Gets a {@link Vault} for the specified user.
     *
     * @param {string} userId - The ID (starting with t2_) of the Vault owner.
     * @example
     * ```ts
     * const vault = await reddit.getVaultByUserId('t2_1w72');
     * ```
     */
    getVaultByUserId(userId: string): Promise<Vault>;
}

declare interface RedditAPIV2 {
    GetSubredditCollections(request: SubredditCollectionsRequest, metadata?: Metadata): Promise<SubredditCollectionsResponse>;
    DeleteFlairTemplate(request: DeleteFlairTemplateRequest, metadata?: Metadata): Promise<JsonStatus>;
}

declare class RedditAPIV2ClientImpl implements RedditAPIV2 {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_16, opts?: {
        service?: string;
    });
    GetSubredditCollections(request: SubredditCollectionsRequest, metadata?: Metadata): Promise<SubredditCollectionsResponse>;
    DeleteFlairTemplate(request: DeleteFlairTemplateRequest, metadata?: Metadata): Promise<JsonStatus>;
}

declare type RedditAPIV2Definition = typeof RedditAPIV2Definition;

declare const RedditAPIV2Definition: {
    readonly name: "RedditAPIV2";
    readonly fullName: "devvit.plugin.redditapiv2.RedditAPIV2";
    readonly methods: {
        readonly getSubredditCollections: {
            readonly name: "GetSubredditCollections";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsRequest";
                encode(message: SubredditCollectionsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditCollectionsRequest;
                fromJSON(object: any): SubredditCollectionsRequest;
                toJSON(message: SubredditCollectionsRequest): unknown;
                create(base?: {
                    srFullname?: string | undefined;
                } | undefined): SubredditCollectionsRequest;
                fromPartial(object: {
                    srFullname?: string | undefined;
                }): SubredditCollectionsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsResponse";
                encode(message: SubredditCollectionsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditCollectionsResponse;
                fromJSON(object: any): SubredditCollectionsResponse;
                toJSON(message: SubredditCollectionsResponse): unknown;
                create(base?: {
                    collections?: {
                        collectionId?: string | undefined;
                        subredditId?: string | undefined;
                        title?: string | undefined;
                        description?: string | undefined;
                        authorId?: string | undefined;
                        authorName?: string | undefined;
                        permalink?: string | undefined;
                        linkIds?: string[];
                        primaryLinkId?: string | undefined;
                        displayLayout?: string | undefined;
                        createdAtUtc?: Date | undefined;
                        lastUpdateUtc?: Date | undefined;
                    }[];
                } | undefined): SubredditCollectionsResponse;
                fromPartial(object: {
                    collections?: {
                        collectionId?: string | undefined;
                        subredditId?: string | undefined;
                        title?: string | undefined;
                        description?: string | undefined;
                        authorId?: string | undefined;
                        authorName?: string | undefined;
                        permalink?: string | undefined;
                        linkIds?: string[];
                        primaryLinkId?: string | undefined;
                        displayLayout?: string | undefined;
                        createdAtUtc?: Date | undefined;
                        lastUpdateUtc?: Date | undefined;
                    }[];
                }): SubredditCollectionsResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly deleteFlairTemplate: {
            readonly name: "DeleteFlairTemplate";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.flair.DeleteFlairTemplateRequest";
                encode(message: DeleteFlairTemplateRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DeleteFlairTemplateRequest;
                fromJSON(object: any): DeleteFlairTemplateRequest;
                toJSON(message: DeleteFlairTemplateRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    flairTemplateId?: string;
                } | undefined): DeleteFlairTemplateRequest;
                fromPartial(object: {
                    subreddit?: string;
                    flairTemplateId?: string;
                }): DeleteFlairTemplateRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const RedditAPIV2ServiceName = "devvit.plugin.redditapiv2.RedditAPIV2";

declare type RedditLink = CommentLink | PostLink | SubredditLink | UserLink | UserMention;

/**
 * @mixin
 */
declare type RedditLinkContainer<Context> = {
    /**
     * Append a link to a Reddit Comment
     * @param opts {@link CommentLinkOptions}
     */
    commentLink(opts: CommentLinkOptions): Context;
    /**
     * Append a link to a Reddit Post
     * @param opts {@link PostLinkOptions}
     */
    postLink(opts: PostLinkOptions): Context;
    /**
     * Append a link to a Reddit Subreddit
     * @param opts {@link SubredditLinkOptions}
     */
    subredditLink(opts: SubredditLinkOptions): Context;
    /**
     * Append a link to a Reddit User
     * @param opts {@link UserLinkOptions}
     */
    userLink(opts: UserLinkOptions): Context;
    /**
     * Append a link to a Reddit User as a @mention
     * @param opts {@link UserMentionOptions}
     */
    userMention(opts: UserMentionOptions): Context;
};

/**
 * A RedditObject can either be a Post (t3) or a Comment (t1)
 *
 * Note: Will be replaced by the discrete {@link Comment} and {@link Post} types
 */
declare interface RedditObject {
    /**
     * List of awards this object has received
     * Note: not yet parsed by RedditAPI
     * @ignore
     */
    allAwardings: Any[];
    /** If `true` this has been approved by a moderator */
    approved?: boolean | undefined;
    /** Timestamp when this was approved */
    approvedAtUtc?: number | undefined;
    /** Username of the moderator that manually approved this object */
    approvedBy?: string | undefined;
    /** If `true`, this object has been archived */
    archived?: boolean | undefined;
    associatedAward?: string | undefined;
    /**
     * The username of the author of this object
     * @example "spez"
     */
    author?: string | undefined;
    /**
     * Flair background color as a hex color string (# prefixed)
     * @example "#FF4500"
     */
    authorFlairBackgroundColor?: string | undefined;
    /**
     * Custom CSS classes from the subreddit's stylesheet
     * to apply to the flair if rendered as HTML
     */
    authorFlairCssClass?: string | undefined;
    /**
     * RichText representation of the author's flair
     * Note: incorrectly typed and not guaranteed to be useful
     */
    authorFlairRichtext: RedditObject_AuthorFlairRichText[];
    /**
     * Flair template ID to use when rendering this flair
     * @see Use {@link Flair.FlairList} to get flair templates for a subreddit
     * @example "813b473a-4d74-4933-ba79-a7f1b8b285ef"
     */
    authorFlairTemplateId?: string | undefined;
    /** Plain text representation of the flair RichText */
    authorFlairText?: string | undefined;
    /** One of: "light", "dark" */
    authorFlairTextColor?: string | undefined;
    /** One of: "text", "richtext" */
    authorFlairType?: string | undefined;
    /**
     * Thing ID of the author
     * @example "t2_abc123"
     */
    authorFullname?: string | undefined;
    /** If `true`, the current user has blocked the author */
    authorIsBlocked?: boolean | undefined;
    /**
     * @deprecated
     *
     * @deprecated
     */
    authorPatreonFlair?: boolean | undefined;
    /** If `true`, this author is subscribed to Reddit Premium */
    authorPremium?: boolean | undefined;
    /** List of usernames that have given awards to this object */
    awarders: string[];
    /** Timestamp when this was banned */
    bannedAtUtc?: number | undefined;
    /** Username of the moderator that banned this object */
    bannedBy?: string | undefined;
    /** Markdown body text if this is a Comment */
    body?: string | undefined;
    /** Pre-rendered HTML representing the Markdown or RichText body of a Comment */
    bodyHtml?: string | undefined;
    /** If `true`, the current user can award this object */
    canGild?: boolean | undefined;
    /** If `true`, the current user has adequate permission to moderate this object */
    canModPost?: boolean | undefined;
    /**
     * If `true`, this Comment is collapsed by default
     * @see {@link collapsed_reason} and {@link collapsed_reason_code} to determine why
     */
    collapsed?: boolean | undefined;
    /** Alias for collapsed_reason_code = "CROWD_CONTROL" */
    collapsedBecauseCrowdControl?: boolean | undefined;
    /** User-friendly string explaining why this Comment is collapsed */
    collapsedReason?: string | undefined;
    /** One of: "LOW_SCORE", "BLOCKED_AUTHOR", "POTENTIALLY_TOXIC", "CROWD_CONTROL", "DELETED" */
    collapsedReasonCode?: string | undefined;
    commentType?: string | undefined;
    /** If set to `1` this Comment is considered controversial */
    controversiality?: number | undefined;
    /**
     * Timestamp when this object was created
     * @see Alias for {@link created_utc}
     */
    created?: number | undefined;
    /**
     * Timestamp when this object was created
     * @see Alias for {@link created}
     */
    createdUtc?: number | undefined;
    /** If `true`, an admin has distinguished this object */
    distinguished?: string | undefined;
    /**
     * Previously displayed the number of downvotes this object received
     * @deprecated Always returns 0
     */
    downs?: number | undefined;
    /** If `true`, the body of this object has been edited since it was posted */
    edited?: boolean | undefined;
    /**
     * Number of times this object has received a Gold award
     * @deprecated
     *
     * @deprecated
     */
    gilded?: number | undefined;
    /**
     * Map of gold awards to the number of times received
     * Note: Incorrectly typed and may be unusable.
     * @deprecated
     *
     * @deprecated
     */
    gildings?: Any | undefined;
    /**
     * Thing ID for this Post or Comment without leading thing ID prefix
     * @example "abc123" // for: t1_abc123
     */
    id?: string | undefined;
    /** Whether or not a moderator has disabled reports for this object */
    ignoreReports?: boolean | undefined;
    /** If `true`, this object was submitted by the current user */
    isSubmitter?: boolean | undefined;
    /**
     * Upvote status where:
     *  - `true`: Upvote
     *  - `null`: No vote
     *  - `false`: Downvote
     */
    likes?: boolean | undefined;
    /**
     * Thing ID of the parent Post for this Comment
     * @example "t3_abc123"
     */
    linkId?: string | undefined;
    /** If `true`, this object has been locked and replies are disabled */
    locked?: boolean | undefined;
    /** Notes added by the moderator when a removal reason chosen */
    modNote?: string | undefined;
    /** Moderator username that chose the reason for the object to be removed */
    modReasonBy?: string | undefined;
    /** The title of the removal reason chosen by the moderator */
    modReasonTitle?: string | undefined;
    /**
     * Thing ID for this object
     * @example "t1_abc123"
     */
    name?: string | undefined;
    noFollow?: boolean | undefined;
    /** Total number of reports that have been filed against this object */
    numReports?: number | undefined;
    /**
     * Thing ID of the parent object immediately above this object in the tree
     * Note: If this is a top-level comment the parent would be the Post (t3)
     *       but if it was a reply to another comment the parent would be the
     *       Comment (t1) being replied to
     * @see {@link link_id} to skip to the root of the comment tree
     * @example "t1_abc123"
     */
    parentId?: string | undefined;
    /**
     * The path of this object relative to www.reddit.com
     * @example "/r/aww/comments/ze7u6n/oc_just_woke_up_from_his_nap/"
     */
    permalink?: string | undefined;
    removalReason?: string | undefined;
    /** If `true`, the object has been removed by a moderator */
    removed?: boolean | undefined;
    /**
     * Comments made directly to this object
     * Note: Incorrect type. Currently unusable.
     * @deprecated Please use replyList instead
     *
     * @deprecated
     */
    replies?: string | undefined;
    reportReasons?: Array<any> | undefined;
    /**
     * RichText editor mode
     * One of: "richtext", "markdown"
     */
    rteMode?: string | undefined;
    /** If `true`, the current user has saved this object to their profile */
    saved?: boolean | undefined;
    /** Current total score for this object */
    score?: number | undefined;
    /** If `true`, the `score` for this object is not visible to the current user */
    scoreHidden?: boolean | undefined;
    /** If `true` the current user will receive notifications when someone replies to this object */
    sendReplies?: boolean | undefined;
    /** If `true` this has been flagged as spam by a moderator */
    spam?: boolean | undefined;
    /** If `true` this should be presented before others relative to its type */
    stickied?: boolean | undefined;
    /**
     * Name of the Subreddit that owns this object
     * @example "AskReddit"
     */
    subreddit?: string | undefined;
    /**
     * Thing ID of the Subreddit that owns this object
     * @example "t5_abc123"
     */
    subredditId?: string | undefined;
    /**
     * Name of the Subreddit that owns this object prefixed with "r/"
     * @example "r/aww"
     */
    subredditNamePrefixed?: string | undefined;
    /**
     * One of: "public", "private", "restricted", "gold_only", "gold_restricted",
     *         "archived", "user", "employees_only"
     */
    subredditType?: string | undefined;
    /** One of: "ACTIVE", "INACTIVE" */
    topAwardedType?: string | undefined;
    /** Total count of awards this object has received */
    totalAwardsReceived?: number | undefined;
    treatmentTags: Any[];
    unrepliableReason?: string | undefined;
    /** Alias for score */
    ups?: number | undefined;
    /** The depth of this object relative to the Listing */
    depth?: number | undefined;
    /** If this is a Comment, the title of the parent Post */
    linkTitle?: string | undefined;
    /** If this is a Comment, the author of the parent Post */
    linkAuthor?: string | undefined;
    /** Total number of comments this object has received */
    numComments?: number | undefined;
    /** If `true`, mark as not-safe-for-work */
    over18?: boolean | undefined;
    /**
     * The path of this object relative to www.reddit.com
     * @example "/r/aww/comments/ze7u6n/oc_just_woke_up_from_his_nap/"
     */
    linkPermalink?: string | undefined;
    /** Whether this Thing has been */
    quarantine?: boolean | undefined;
    /** If this is a Comment, the URL associated with the parent Post */
    linkUrl?: string | undefined;
    /** Markdown body text if this is a Text Post */
    selftext?: string | undefined;
    /** Pre-rendered HTML representing the Markdown or RichText body of a Text Post */
    selftextHtml?: string | undefined;
    /** URL of a scaled down preview image of the media in this object */
    thumbnail?: string | undefined;
    /** Width of the thumbnail image, in pixels */
    thumbnailWidth?: number | undefined;
    /** Height of the thumbnail image, in pixels */
    thumbnailHeight?: number | undefined;
    /** Title of the Post if it is a Post */
    title?: string | undefined;
    /**
     * If this is a Post, contains one of the following:
     *  - Empty if this is a Text Post
     *  - The URL submitted by the user if this is a Link Post
     *  - The full-size image or video URL if this is an Image, Video, or VideoGif Post
     */
    url?: string | undefined;
    /**
     * The name of the Subreddit if this object represents a Subreddit
     *
     * Note: This object is intended for Post and Comment data but
     *       Listings.Info() returns a ListingObject which can only contain
     *       WrappedRedditObject data, though that endpoint is able to
     *       fetch Subreddit data if a t5_ ID is provided as an argument.
     */
    displayName?: string | undefined;
    /** The list of moderator permissions for a user */
    modPermissions: string[];
    /** Number of replies intended for More data */
    count?: number | undefined;
    /** Ids of children intended for More data (without leading thing ID prefix) */
    children?: Array<any> | undefined;
    /** List of replies if this is a comment */
    replyList?: Listing_2 | undefined;
    /** If `true` this post has been hidden */
    hidden?: boolean | undefined;
    /**
     * Post Flair aka Link Flair
     * Flair background color as a hex color string (# prefixed)
     * @example "#FF4500"
     */
    linkFlairBackgroundColor?: string | undefined;
    /**
     * Custom CSS classes from the subreddit's stylesheet
     * to apply to the flair if rendered as HTML
     */
    linkFlairCssClass?: string | undefined;
    /** RichText representation of the post's flair */
    linkFlairRichtext: RedditObject_LinkFlairRichText[];
    /**
     * Flair template ID to use when rendering this flair
     * @see Use {@link Flair.FlairList} to get flair templates for a subreddit
     * @example "813b473a-4d74-4933-ba79-a7f1b8b285ef"
     */
    linkFlairTemplateId?: string | undefined;
    /** Plain text representation of the flair RichText */
    linkFlairText?: string | undefined;
    /** One of: "light", "dark" */
    linkFlairTextColor?: string | undefined;
    /** One of: "text", "richtext" */
    linkFlairType?: string | undefined;
    /** Information about the media embedded to the post */
    secureMedia?: RedditObject_SecureMedia | undefined;
    /** If `true`, hide the contents of this post until the user explicitly opens it */
    spoiler: boolean;
    /** List of reports submitted by moderators against this object */
    modReports: Array<any>[];
    /** List of reports submitted by users against this object */
    userReports: Array<any>[];
    /** Who removed this object (username) */
    removedBy?: string | undefined;
    /**
     * Returns information about who/what removed this object. It will return one of the following:
     * - "anti_evil_ops": object is removed by a aeops member
     * - "author": object is removed by author of the post
     * - "automod_filtered": object is filtered by automod
     * - "community_ops": object is removed by a community team member
     * - "content_takedown": object is removed due to content violation
     * - "copyright_takedown": object is removed due to copyright violation
     * - "deleted": object is deleted
     * - "moderator": object is removed by a mod of the sub
     * - "reddit": object is removed by anyone else
     * - None: object is not removed
     */
    removedByCategory?: string | undefined;
}

declare const RedditObject: {
    $type: "devvit.plugin.redditapi.common.RedditObject";
    encode(message: RedditObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedditObject;
    fromJSON(object: any): RedditObject;
    toJSON(message: RedditObject): unknown;
    create(base?: DeepPartial_8<RedditObject>): RedditObject;
    fromPartial(object: DeepPartial_8<RedditObject>): RedditObject;
};

/** RichText document for author flair */
declare interface RedditObject_AuthorFlairRichText {
    /** enum of element types.  e.g. emoji or text */
    e?: string | undefined;
    /** text to show up in the flair, e.g. "power poster" */
    t?: string | undefined;
    /** emoji references, e.g. ":rainbow:" */
    a?: string | undefined;
    /** url string, e.g. "https://reddit.com/" */
    u?: string | undefined;
}

declare const RedditObject_AuthorFlairRichText: {
    $type: "devvit.plugin.redditapi.common.RedditObject.AuthorFlairRichText";
    encode(message: RedditObject_AuthorFlairRichText, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedditObject_AuthorFlairRichText;
    fromJSON(object: any): RedditObject_AuthorFlairRichText;
    toJSON(message: RedditObject_AuthorFlairRichText): unknown;
    create(base?: DeepPartial_8<RedditObject_AuthorFlairRichText>): RedditObject_AuthorFlairRichText;
    fromPartial(object: DeepPartial_8<RedditObject_AuthorFlairRichText>): RedditObject_AuthorFlairRichText;
};

/** RichText document for post flair */
declare interface RedditObject_LinkFlairRichText {
    /** enum of element types.  e.g. emoji or text */
    e?: string | undefined;
    /** text to show up in the flair, e.g. "Need Advice" */
    t?: string | undefined;
    /** emoji references, e.g. ":rainbow:" */
    a?: string | undefined;
    /** url string, e.g. "https://reddit.com/" */
    u?: string | undefined;
}

declare const RedditObject_LinkFlairRichText: {
    $type: "devvit.plugin.redditapi.common.RedditObject.LinkFlairRichText";
    encode(message: RedditObject_LinkFlairRichText, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedditObject_LinkFlairRichText;
    fromJSON(object: any): RedditObject_LinkFlairRichText;
    toJSON(message: RedditObject_LinkFlairRichText): unknown;
    create(base?: DeepPartial_8<RedditObject_LinkFlairRichText>): RedditObject_LinkFlairRichText;
    fromPartial(object: DeepPartial_8<RedditObject_LinkFlairRichText>): RedditObject_LinkFlairRichText;
};

/**
 * oEmbed is a format for allowing an embedded representation of a URL on third party sites.
 * The simple API allows a website to display embedded content (such as photos or videos)
 * when a user posts a link to that resource, without having to parse the resource directly.
 * See: https://oembed.com/
 */
declare interface RedditObject_OEmbed {
    /** The resource type. Valid values, along with value-specific parameters, are described below. E.g. "video" */
    type: string;
    /** A text title, describing the resource. */
    title?: string | undefined;
    /** A URL for the author/owner of the resource. E.g. "YouTube" */
    providerName?: string | undefined;
    /** The name of the resource provider. E.g https://www.youtube.com/ */
    providerUrl?: string | undefined;
    /** The oEmbed version number. This must be 1.0. */
    version: string;
    /** The width of the optional thumbnail in pixels */
    thumbnailWidth?: number | undefined;
    /** The height of the optional thumbnail in pixels */
    thumbnailHeight?: number | undefined;
    /** A URL to a thumbnail image representing the resource. */
    thumbnailUrl?: string | undefined;
    /** The HTML required to embed a video player. The HTML should have no padding or margins. Consumers may wish to load the HTML in an off-domain iframe to avoid XSS vulnerabilities. */
    html: string;
    /** The width in pixels required to display the HTML. */
    height?: number | undefined;
    /** The height in pixels required to display the HTML. */
    width?: number | undefined;
    /** A URL for the author/owner of the resource. E.g. https://www.youtube.com/@Reddit */
    authorUrl?: string | undefined;
    /** The name of the author/owner of the resource. E.g. "Reddit" */
    authorName?: string | undefined;
}

declare const RedditObject_OEmbed: {
    $type: "devvit.plugin.redditapi.common.RedditObject.OEmbed";
    encode(message: RedditObject_OEmbed, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedditObject_OEmbed;
    fromJSON(object: any): RedditObject_OEmbed;
    toJSON(message: RedditObject_OEmbed): unknown;
    create(base?: DeepPartial_8<RedditObject_OEmbed>): RedditObject_OEmbed;
    fromPartial(object: DeepPartial_8<RedditObject_OEmbed>): RedditObject_OEmbed;
};

/** Contains the data for a video hosted on Reddit that is in a post */
declare interface RedditObject_RedditVideo {
    /** The bitrate of the video in kilobits per second. E.g. 450 */
    bitrateKbps?: number | undefined;
    /** The URL to the DASH playlist file. E.g. "https://v.redd.it/abc123/DASHPlaylist.mpd" */
    dashUrl?: string | undefined;
    /** The duration of the video in seconds. E.g. 30 */
    duration?: number | undefined;
    /** The direct URL to the video. E.g. "https://v.redd.it/abc123/DASH_1080.mp4?source=fallback" */
    fallbackUrl?: string | undefined;
    /** The height of the video in pixels. E.g. 1080 */
    height?: number | undefined;
    /** The URL to the HLS playlist file. E.g. "https://v.redd.it/abc123/HLSPlaylist.m3u8" */
    hlsUrl?: string | undefined;
    /** If `true`, the video is a GIF */
    isGif?: boolean | undefined;
    /** The URL to the scrubber media file. E.g. "https://v.redd.it/abc123/DASH_96.mp4" */
    scrubberMediaUrl?: string | undefined;
    /** The status of the transcoding process. E.g. "completed" */
    transcodingStatus?: string | undefined;
    /** The width of the video in pixels. E.g. 1920 */
    width?: number | undefined;
}

declare const RedditObject_RedditVideo: {
    $type: "devvit.plugin.redditapi.common.RedditObject.RedditVideo";
    encode(message: RedditObject_RedditVideo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedditObject_RedditVideo;
    fromJSON(object: any): RedditObject_RedditVideo;
    toJSON(message: RedditObject_RedditVideo): unknown;
    create(base?: DeepPartial_8<RedditObject_RedditVideo>): RedditObject_RedditVideo;
    fromPartial(object: DeepPartial_8<RedditObject_RedditVideo>): RedditObject_RedditVideo;
};

/** Secure Media object */
declare interface RedditObject_SecureMedia {
    /** The type of the Secure Media (e.g. "youtube.com"). Populated when 'oembed' is present. */
    type: string;
    /** Populated when the post media is hosted on a third-party site. */
    oembed?: RedditObject_OEmbed | undefined;
    /** Populated when the post media is a video hosted on Reddit. */
    redditVideo?: RedditObject_RedditVideo | undefined;
}

declare const RedditObject_SecureMedia: {
    $type: "devvit.plugin.redditapi.common.RedditObject.SecureMedia";
    encode(message: RedditObject_SecureMedia, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedditObject_SecureMedia;
    fromJSON(object: any): RedditObject_SecureMedia;
    toJSON(message: RedditObject_SecureMedia): unknown;
    create(base?: DeepPartial_8<RedditObject_SecureMedia>): RedditObject_SecureMedia;
    fromPartial(object: DeepPartial_8<RedditObject_SecureMedia>): RedditObject_SecureMedia;
};

declare type RedditPermalinkOptions = {
    /**
     * Permalink to a Reddit page
     * @example { permalink: "/r/aww/comments/z9m1yj/one_of_them_isnt_a_dog" }
     */
    permalink: string;
};

declare interface RedditPostGallery {
    body?: string | undefined;
    domain?: string | undefined;
    url?: string | undefined;
}

declare const RedditPostGallery: {
    $type: "devvit.reddit.RedditPostGallery";
    encode(message: RedditPostGallery, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedditPostGallery;
    fromJSON(object: any): RedditPostGallery;
    toJSON(message: RedditPostGallery): unknown;
    create(base?: DeepPartial_82<RedditPostGallery>): RedditPostGallery;
    fromPartial(object: DeepPartial_82<RedditPostGallery>): RedditPostGallery;
};

/**
 * Contains the data for a video hosted on Reddit that is in a post
 */
export declare type RedditVideo = {
    /** The bitrate of the video in kilobits per second. E.g. 450 */
    bitrateKbps?: number;
    /** The URL to the DASH playlist file. E.g. "https://v.redd.it/abc123/DASHPlaylist.mpd" */
    dashUrl?: string;
    /** The duration of the video in seconds. E.g. 30 */
    duration?: number;
    /** The direct URL to the video. E.g. "https://v.redd.it/abc123/DASH_1080.mp4?source=fallback" */
    fallbackUrl?: string;
    /** The height of the video in pixels. E.g. 1080 */
    height?: number;
    /** The URL to the HLS playlist file. E.g. "https://v.redd.it/abc123/HLSPlaylist.m3u8" */
    hlsUrl?: string;
    /** If `true`, the video is a GIF */
    isGif?: boolean;
    /** The URL to the scrubber media file. E.g. "https://v.redd.it/abc123/DASH_96.mp4" */
    scrubberMediaUrl?: string;
    /** The status of the transcoding process. E.g. "completed" */
    transcodingStatus?: string;
    /** The width of the video in pixels. E.g. 1920 */
    width?: number;
};

declare interface RedditVideo_2 {
    bitrateKbps: number;
    fallbackUrl: string;
    height: number;
    width: number;
    scrubberMediaUrl: string;
    dashUrl: string;
    duration: number;
    hlsUrl: string;
    isGif: boolean;
    transcodingStatus: string;
}

declare const RedditVideo_2: {
    $type: "devvit.reddit.v2alpha.RedditVideo";
    encode(message: RedditVideo_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedditVideo_2;
    fromJSON(object: any): RedditVideo_2;
    toJSON(message: RedditVideo_2): unknown;
    create(base?: DeepPartial_78<RedditVideo_2>): RedditVideo_2;
    fromPartial(object: DeepPartial_78<RedditVideo_2>): RedditVideo_2;
};

/**
 * This should match as closely as reasonable to redis's names, arguments, etc.
 *
 * DO NOT CHANGE Redis names.  It's DEL, not DELETE, no matter your preferences.
 *
 * One catch here is that this interface mediates transactions, without exposing
 * the details of connection management.  Therefore, if you're doing an operation
 * in a transaction, two things are different:
 *
 *    1. You should provide a transaction id in your request.
 *    2. You should ignore the response (as it should be a zero value)
 *
 * The Typescript Redis client wrapper is smart enough to handle transactions
 * with a nice chaining API on your behalf.
 */
declare interface RedisAPI {
    /** Simple Key-Value operations */
    Get(request: KeyRequest, metadata?: Metadata): Promise<StringValue>;
    Set(request: SetRequest, metadata?: Metadata): Promise<StringValue>;
    Del(request: KeysRequest, metadata?: Metadata): Promise<Int64Value>;
    Type(request: KeyRequest, metadata?: Metadata): Promise<StringValue>;
    /** Number operations */
    IncrBy(request: IncrByRequest, metadata?: Metadata): Promise<Int64Value>;
    /** Redis Hash operations */
    HSet(request: HSetRequest, metadata?: Metadata): Promise<Int64Value>;
    HGet(request: HGetRequest, metadata?: Metadata): Promise<StringValue>;
    HGetAll(request: KeyRequest, metadata?: Metadata): Promise<RedisFieldValues>;
    HDel(request: HDelRequest, metadata?: Metadata): Promise<Int64Value>;
    HScan(request: HScanRequest, metadata?: Metadata): Promise<HScanResponse>;
    HKeys(request: KeyRequest, metadata?: Metadata): Promise<KeysResponse>;
    HIncrBy(request: HIncrByRequest, metadata?: Metadata): Promise<Int64Value>;
    HLen(request: KeyRequest, metadata?: Metadata): Promise<Int64Value>;
    /** Transactions */
    Multi(request: TransactionId, metadata?: Metadata): Promise<Empty>;
    Exec(request: TransactionId, metadata?: Metadata): Promise<TransactionResponses>;
    Discard(request: TransactionId, metadata?: Metadata): Promise<Empty>;
    Watch(request: WatchRequest, metadata?: Metadata): Promise<TransactionId>;
    Unwatch(request: TransactionId, metadata?: Metadata): Promise<Empty>;
    /** String operations */
    GetRange(request: KeyRangeRequest, metadata?: Metadata): Promise<StringValue>;
    SetRange(request: SetRangeRequest, metadata?: Metadata): Promise<Int64Value>;
    Strlen(request: KeyRequest, metadata?: Metadata): Promise<Int64Value>;
    /** Batch Key-Value operations */
    MGet(request: KeysRequest, metadata?: Metadata): Promise<RedisValues>;
    MSet(request: KeyValuesRequest, metadata?: Metadata): Promise<Empty>;
    /** Key expiration */
    Expire(request: ExpireRequest, metadata?: Metadata): Promise<Empty>;
    ExpireTime(request: KeyRequest, metadata?: Metadata): Promise<Int64Value>;
    /** Sorted sets */
    ZAdd(request: ZAddRequest, metadata?: Metadata): Promise<Int64Value>;
    ZCard(request: KeyRequest, metadata?: Metadata): Promise<Int64Value>;
    ZRange(request: ZRangeRequest, metadata?: Metadata): Promise<ZMembers>;
    ZRem(request: ZRemRequest, metadata?: Metadata): Promise<Int64Value>;
    ZRemRangeByLex(request: ZRemRangeByLexRequest, metadata?: Metadata): Promise<Int64Value>;
    ZRemRangeByRank(request: ZRemRangeByRankRequest, metadata?: Metadata): Promise<Int64Value>;
    ZRemRangeByScore(request: ZRemRangeByScoreRequest, metadata?: Metadata): Promise<Int64Value>;
    ZScore(request: ZScoreRequest, metadata?: Metadata): Promise<DoubleValue>;
    ZRank(request: ZRankRequest, metadata?: Metadata): Promise<Int64Value>;
    ZIncrBy(request: ZIncrByRequest, metadata?: Metadata): Promise<DoubleValue>;
    ZScan(request: ZScanRequest, metadata?: Metadata): Promise<ZScanResponse>;
}

declare class RedisAPIClientImpl implements RedisAPI {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_15, opts?: {
        service?: string;
    });
    Get(request: KeyRequest, metadata?: Metadata): Promise<StringValue>;
    Set(request: SetRequest, metadata?: Metadata): Promise<StringValue>;
    Del(request: KeysRequest, metadata?: Metadata): Promise<Int64Value>;
    Type(request: KeyRequest, metadata?: Metadata): Promise<StringValue>;
    IncrBy(request: IncrByRequest, metadata?: Metadata): Promise<Int64Value>;
    HSet(request: HSetRequest, metadata?: Metadata): Promise<Int64Value>;
    HGet(request: HGetRequest, metadata?: Metadata): Promise<StringValue>;
    HGetAll(request: KeyRequest, metadata?: Metadata): Promise<RedisFieldValues>;
    HDel(request: HDelRequest, metadata?: Metadata): Promise<Int64Value>;
    HScan(request: HScanRequest, metadata?: Metadata): Promise<HScanResponse>;
    HKeys(request: KeyRequest, metadata?: Metadata): Promise<KeysResponse>;
    HIncrBy(request: HIncrByRequest, metadata?: Metadata): Promise<Int64Value>;
    HLen(request: KeyRequest, metadata?: Metadata): Promise<Int64Value>;
    Multi(request: TransactionId, metadata?: Metadata): Promise<Empty>;
    Exec(request: TransactionId, metadata?: Metadata): Promise<TransactionResponses>;
    Discard(request: TransactionId, metadata?: Metadata): Promise<Empty>;
    Watch(request: WatchRequest, metadata?: Metadata): Promise<TransactionId>;
    Unwatch(request: TransactionId, metadata?: Metadata): Promise<Empty>;
    GetRange(request: KeyRangeRequest, metadata?: Metadata): Promise<StringValue>;
    SetRange(request: SetRangeRequest, metadata?: Metadata): Promise<Int64Value>;
    Strlen(request: KeyRequest, metadata?: Metadata): Promise<Int64Value>;
    MGet(request: KeysRequest, metadata?: Metadata): Promise<RedisValues>;
    MSet(request: KeyValuesRequest, metadata?: Metadata): Promise<Empty>;
    Expire(request: ExpireRequest, metadata?: Metadata): Promise<Empty>;
    ExpireTime(request: KeyRequest, metadata?: Metadata): Promise<Int64Value>;
    ZAdd(request: ZAddRequest, metadata?: Metadata): Promise<Int64Value>;
    ZCard(request: KeyRequest, metadata?: Metadata): Promise<Int64Value>;
    ZRange(request: ZRangeRequest, metadata?: Metadata): Promise<ZMembers>;
    ZRem(request: ZRemRequest, metadata?: Metadata): Promise<Int64Value>;
    ZRemRangeByLex(request: ZRemRangeByLexRequest, metadata?: Metadata): Promise<Int64Value>;
    ZRemRangeByRank(request: ZRemRangeByRankRequest, metadata?: Metadata): Promise<Int64Value>;
    ZRemRangeByScore(request: ZRemRangeByScoreRequest, metadata?: Metadata): Promise<Int64Value>;
    ZScore(request: ZScoreRequest, metadata?: Metadata): Promise<DoubleValue>;
    ZRank(request: ZRankRequest, metadata?: Metadata): Promise<Int64Value>;
    ZIncrBy(request: ZIncrByRequest, metadata?: Metadata): Promise<DoubleValue>;
    ZScan(request: ZScanRequest, metadata?: Metadata): Promise<ZScanResponse>;
}

/**
 * This should match as closely as reasonable to redis's names, arguments, etc.
 *
 * DO NOT CHANGE Redis names.  It's DEL, not DELETE, no matter your preferences.
 *
 * One catch here is that this interface mediates transactions, without exposing
 * the details of connection management.  Therefore, if you're doing an operation
 * in a transaction, two things are different:
 *
 *    1. You should provide a transaction id in your request.
 *    2. You should ignore the response (as it should be a zero value)
 *
 * The Typescript Redis client wrapper is smart enough to handle transactions
 * with a nice chaining API on your behalf.
 */
declare type RedisAPIDefinition = typeof RedisAPIDefinition;

declare const RedisAPIDefinition: {
    readonly name: "RedisAPI";
    readonly fullName: "devvit.plugin.redis.RedisAPI";
    readonly methods: {
        /** Simple Key-Value operations */
        readonly get: {
            readonly name: "Get";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyRequest";
                encode(message: KeyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyRequest;
                fromJSON(object: any): KeyRequest;
                toJSON(message: KeyRequest): unknown;
                create(base?: DeepPartial_86<KeyRequest>): KeyRequest;
                fromPartial(object: DeepPartial_86<KeyRequest>): KeyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.StringValue";
                encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StringValue;
                fromJSON(object: any): StringValue;
                toJSON(message: StringValue): unknown;
                create(base?: {
                    value?: string;
                } | undefined): StringValue;
                fromPartial(object: {
                    value?: string;
                }): StringValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly set: {
            readonly name: "Set";
            readonly requestType: {
                $type: "devvit.plugin.redis.SetRequest";
                encode(message: SetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): SetRequest;
                fromJSON(object: any): SetRequest;
                toJSON(message: SetRequest): unknown;
                create(base?: DeepPartial_86<SetRequest>): SetRequest;
                fromPartial(object: DeepPartial_86<SetRequest>): SetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.StringValue";
                encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StringValue;
                fromJSON(object: any): StringValue;
                toJSON(message: StringValue): unknown;
                create(base?: {
                    value?: string;
                } | undefined): StringValue;
                fromPartial(object: {
                    value?: string;
                }): StringValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly del: {
            readonly name: "Del";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeysRequest";
                encode(message: KeysRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeysRequest;
                fromJSON(object: any): KeysRequest;
                toJSON(message: KeysRequest): unknown;
                create(base?: DeepPartial_86<KeysRequest>): KeysRequest;
                fromPartial(object: DeepPartial_86<KeysRequest>): KeysRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly type: {
            readonly name: "Type";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyRequest";
                encode(message: KeyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyRequest;
                fromJSON(object: any): KeyRequest;
                toJSON(message: KeyRequest): unknown;
                create(base?: DeepPartial_86<KeyRequest>): KeyRequest;
                fromPartial(object: DeepPartial_86<KeyRequest>): KeyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.StringValue";
                encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StringValue;
                fromJSON(object: any): StringValue;
                toJSON(message: StringValue): unknown;
                create(base?: {
                    value?: string;
                } | undefined): StringValue;
                fromPartial(object: {
                    value?: string;
                }): StringValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Number operations */
        readonly incrBy: {
            readonly name: "IncrBy";
            readonly requestType: {
                $type: "devvit.plugin.redis.IncrByRequest";
                encode(message: IncrByRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): IncrByRequest;
                fromJSON(object: any): IncrByRequest;
                toJSON(message: IncrByRequest): unknown;
                create(base?: DeepPartial_86<IncrByRequest>): IncrByRequest;
                fromPartial(object: DeepPartial_86<IncrByRequest>): IncrByRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Redis Hash operations */
        readonly hSet: {
            readonly name: "HSet";
            readonly requestType: {
                $type: "devvit.plugin.redis.HSetRequest";
                encode(message: HSetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HSetRequest;
                fromJSON(object: any): HSetRequest;
                toJSON(message: HSetRequest): unknown;
                create(base?: DeepPartial_86<HSetRequest>): HSetRequest;
                fromPartial(object: DeepPartial_86<HSetRequest>): HSetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly hGet: {
            readonly name: "HGet";
            readonly requestType: {
                $type: "devvit.plugin.redis.HGetRequest";
                encode(message: HGetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HGetRequest;
                fromJSON(object: any): HGetRequest;
                toJSON(message: HGetRequest): unknown;
                create(base?: DeepPartial_86<HGetRequest>): HGetRequest;
                fromPartial(object: DeepPartial_86<HGetRequest>): HGetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.StringValue";
                encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StringValue;
                fromJSON(object: any): StringValue;
                toJSON(message: StringValue): unknown;
                create(base?: {
                    value?: string;
                } | undefined): StringValue;
                fromPartial(object: {
                    value?: string;
                }): StringValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly hGetAll: {
            readonly name: "HGetAll";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyRequest";
                encode(message: KeyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyRequest;
                fromJSON(object: any): KeyRequest;
                toJSON(message: KeyRequest): unknown;
                create(base?: DeepPartial_86<KeyRequest>): KeyRequest;
                fromPartial(object: DeepPartial_86<KeyRequest>): KeyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redis.RedisFieldValues";
                encode(message: RedisFieldValues, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RedisFieldValues;
                fromJSON(object: any): RedisFieldValues;
                toJSON(message: RedisFieldValues): unknown;
                create(base?: DeepPartial_86<RedisFieldValues>): RedisFieldValues;
                fromPartial(object: DeepPartial_86<RedisFieldValues>): RedisFieldValues;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly hDel: {
            readonly name: "HDel";
            readonly requestType: {
                $type: "devvit.plugin.redis.HDelRequest";
                encode(message: HDelRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HDelRequest;
                fromJSON(object: any): HDelRequest;
                toJSON(message: HDelRequest): unknown;
                create(base?: DeepPartial_86<HDelRequest>): HDelRequest;
                fromPartial(object: DeepPartial_86<HDelRequest>): HDelRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly hScan: {
            readonly name: "HScan";
            readonly requestType: {
                $type: "devvit.plugin.redis.HScanRequest";
                encode(message: HScanRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HScanRequest;
                fromJSON(object: any): HScanRequest;
                toJSON(message: HScanRequest): unknown;
                create(base?: DeepPartial_86<HScanRequest>): HScanRequest;
                fromPartial(object: DeepPartial_86<HScanRequest>): HScanRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redis.HScanResponse";
                encode(message: HScanResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HScanResponse;
                fromJSON(object: any): HScanResponse;
                toJSON(message: HScanResponse): unknown;
                create(base?: DeepPartial_86<HScanResponse>): HScanResponse;
                fromPartial(object: DeepPartial_86<HScanResponse>): HScanResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly hKeys: {
            readonly name: "HKeys";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyRequest";
                encode(message: KeyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyRequest;
                fromJSON(object: any): KeyRequest;
                toJSON(message: KeyRequest): unknown;
                create(base?: DeepPartial_86<KeyRequest>): KeyRequest;
                fromPartial(object: DeepPartial_86<KeyRequest>): KeyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redis.KeysResponse";
                encode(message: KeysResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeysResponse;
                fromJSON(object: any): KeysResponse;
                toJSON(message: KeysResponse): unknown;
                create(base?: DeepPartial_86<KeysResponse>): KeysResponse;
                fromPartial(object: DeepPartial_86<KeysResponse>): KeysResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly hIncrBy: {
            readonly name: "HIncrBy";
            readonly requestType: {
                $type: "devvit.plugin.redis.HIncrByRequest";
                encode(message: HIncrByRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HIncrByRequest;
                fromJSON(object: any): HIncrByRequest;
                toJSON(message: HIncrByRequest): unknown;
                create(base?: DeepPartial_86<HIncrByRequest>): HIncrByRequest;
                fromPartial(object: DeepPartial_86<HIncrByRequest>): HIncrByRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly hLen: {
            readonly name: "HLen";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyRequest";
                encode(message: KeyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyRequest;
                fromJSON(object: any): KeyRequest;
                toJSON(message: KeyRequest): unknown;
                create(base?: DeepPartial_86<KeyRequest>): KeyRequest;
                fromPartial(object: DeepPartial_86<KeyRequest>): KeyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Transactions */
        readonly multi: {
            readonly name: "Multi";
            readonly requestType: {
                $type: "devvit.plugin.redis.TransactionId";
                encode(message: TransactionId, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TransactionId;
                fromJSON(object: any): TransactionId;
                toJSON(message: TransactionId): unknown;
                create(base?: DeepPartial_86<TransactionId>): TransactionId;
                fromPartial(object: DeepPartial_86<TransactionId>): TransactionId;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly exec: {
            readonly name: "Exec";
            readonly requestType: {
                $type: "devvit.plugin.redis.TransactionId";
                encode(message: TransactionId, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TransactionId;
                fromJSON(object: any): TransactionId;
                toJSON(message: TransactionId): unknown;
                create(base?: DeepPartial_86<TransactionId>): TransactionId;
                fromPartial(object: DeepPartial_86<TransactionId>): TransactionId;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redis.TransactionResponses";
                encode(message: TransactionResponses, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TransactionResponses;
                fromJSON(object: any): TransactionResponses;
                toJSON(message: TransactionResponses): unknown;
                create(base?: DeepPartial_86<TransactionResponses>): TransactionResponses;
                fromPartial(object: DeepPartial_86<TransactionResponses>): TransactionResponses;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly discard: {
            readonly name: "Discard";
            readonly requestType: {
                $type: "devvit.plugin.redis.TransactionId";
                encode(message: TransactionId, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TransactionId;
                fromJSON(object: any): TransactionId;
                toJSON(message: TransactionId): unknown;
                create(base?: DeepPartial_86<TransactionId>): TransactionId;
                fromPartial(object: DeepPartial_86<TransactionId>): TransactionId;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly watch: {
            readonly name: "Watch";
            readonly requestType: {
                $type: "devvit.plugin.redis.WatchRequest";
                encode(message: WatchRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): WatchRequest;
                fromJSON(object: any): WatchRequest;
                toJSON(message: WatchRequest): unknown;
                create(base?: DeepPartial_86<WatchRequest>): WatchRequest;
                fromPartial(object: DeepPartial_86<WatchRequest>): WatchRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redis.TransactionId";
                encode(message: TransactionId, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TransactionId;
                fromJSON(object: any): TransactionId;
                toJSON(message: TransactionId): unknown;
                create(base?: DeepPartial_86<TransactionId>): TransactionId;
                fromPartial(object: DeepPartial_86<TransactionId>): TransactionId;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly unwatch: {
            readonly name: "Unwatch";
            readonly requestType: {
                $type: "devvit.plugin.redis.TransactionId";
                encode(message: TransactionId, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TransactionId;
                fromJSON(object: any): TransactionId;
                toJSON(message: TransactionId): unknown;
                create(base?: DeepPartial_86<TransactionId>): TransactionId;
                fromPartial(object: DeepPartial_86<TransactionId>): TransactionId;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** String operations */
        readonly getRange: {
            readonly name: "GetRange";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyRangeRequest";
                encode(message: KeyRangeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyRangeRequest;
                fromJSON(object: any): KeyRangeRequest;
                toJSON(message: KeyRangeRequest): unknown;
                create(base?: DeepPartial_86<KeyRangeRequest>): KeyRangeRequest;
                fromPartial(object: DeepPartial_86<KeyRangeRequest>): KeyRangeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.StringValue";
                encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StringValue;
                fromJSON(object: any): StringValue;
                toJSON(message: StringValue): unknown;
                create(base?: {
                    value?: string;
                } | undefined): StringValue;
                fromPartial(object: {
                    value?: string;
                }): StringValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly setRange: {
            readonly name: "SetRange";
            readonly requestType: {
                $type: "devvit.plugin.redis.SetRangeRequest";
                encode(message: SetRangeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): SetRangeRequest;
                fromJSON(object: any): SetRangeRequest;
                toJSON(message: SetRangeRequest): unknown;
                create(base?: DeepPartial_86<SetRangeRequest>): SetRangeRequest;
                fromPartial(object: DeepPartial_86<SetRangeRequest>): SetRangeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly strlen: {
            readonly name: "Strlen";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyRequest";
                encode(message: KeyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyRequest;
                fromJSON(object: any): KeyRequest;
                toJSON(message: KeyRequest): unknown;
                create(base?: DeepPartial_86<KeyRequest>): KeyRequest;
                fromPartial(object: DeepPartial_86<KeyRequest>): KeyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Batch Key-Value operations */
        readonly mGet: {
            readonly name: "MGet";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeysRequest";
                encode(message: KeysRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeysRequest;
                fromJSON(object: any): KeysRequest;
                toJSON(message: KeysRequest): unknown;
                create(base?: DeepPartial_86<KeysRequest>): KeysRequest;
                fromPartial(object: DeepPartial_86<KeysRequest>): KeysRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redis.RedisValues";
                encode(message: RedisValues, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RedisValues;
                fromJSON(object: any): RedisValues;
                toJSON(message: RedisValues): unknown;
                create(base?: DeepPartial_86<RedisValues>): RedisValues;
                fromPartial(object: DeepPartial_86<RedisValues>): RedisValues;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly mSet: {
            readonly name: "MSet";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyValuesRequest";
                encode(message: KeyValuesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyValuesRequest;
                fromJSON(object: any): KeyValuesRequest;
                toJSON(message: KeyValuesRequest): unknown;
                create(base?: DeepPartial_86<KeyValuesRequest>): KeyValuesRequest;
                fromPartial(object: DeepPartial_86<KeyValuesRequest>): KeyValuesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Key expiration */
        readonly expire: {
            readonly name: "Expire";
            readonly requestType: {
                $type: "devvit.plugin.redis.ExpireRequest";
                encode(message: ExpireRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ExpireRequest;
                fromJSON(object: any): ExpireRequest;
                toJSON(message: ExpireRequest): unknown;
                create(base?: DeepPartial_86<ExpireRequest>): ExpireRequest;
                fromPartial(object: DeepPartial_86<ExpireRequest>): ExpireRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly expireTime: {
            readonly name: "ExpireTime";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyRequest";
                encode(message: KeyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyRequest;
                fromJSON(object: any): KeyRequest;
                toJSON(message: KeyRequest): unknown;
                create(base?: DeepPartial_86<KeyRequest>): KeyRequest;
                fromPartial(object: DeepPartial_86<KeyRequest>): KeyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Sorted sets */
        readonly zAdd: {
            readonly name: "ZAdd";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZAddRequest";
                encode(message: ZAddRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZAddRequest;
                fromJSON(object: any): ZAddRequest;
                toJSON(message: ZAddRequest): unknown;
                create(base?: DeepPartial_86<ZAddRequest>): ZAddRequest;
                fromPartial(object: DeepPartial_86<ZAddRequest>): ZAddRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zCard: {
            readonly name: "ZCard";
            readonly requestType: {
                $type: "devvit.plugin.redis.KeyRequest";
                encode(message: KeyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): KeyRequest;
                fromJSON(object: any): KeyRequest;
                toJSON(message: KeyRequest): unknown;
                create(base?: DeepPartial_86<KeyRequest>): KeyRequest;
                fromPartial(object: DeepPartial_86<KeyRequest>): KeyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zRange: {
            readonly name: "ZRange";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZRangeRequest";
                encode(message: ZRangeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZRangeRequest;
                fromJSON(object: any): ZRangeRequest;
                toJSON(message: ZRangeRequest): unknown;
                create(base?: DeepPartial_86<ZRangeRequest>): ZRangeRequest;
                fromPartial(object: DeepPartial_86<ZRangeRequest>): ZRangeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redis.ZMembers";
                encode(message: ZMembers, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZMembers;
                fromJSON(object: any): ZMembers;
                toJSON(message: ZMembers): unknown;
                create(base?: DeepPartial_86<ZMembers>): ZMembers;
                fromPartial(object: DeepPartial_86<ZMembers>): ZMembers;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zRem: {
            readonly name: "ZRem";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZRemRequest";
                encode(message: ZRemRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZRemRequest;
                fromJSON(object: any): ZRemRequest;
                toJSON(message: ZRemRequest): unknown;
                create(base?: DeepPartial_86<ZRemRequest>): ZRemRequest;
                fromPartial(object: DeepPartial_86<ZRemRequest>): ZRemRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zRemRangeByLex: {
            readonly name: "ZRemRangeByLex";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZRemRangeByLexRequest";
                encode(message: ZRemRangeByLexRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZRemRangeByLexRequest;
                fromJSON(object: any): ZRemRangeByLexRequest;
                toJSON(message: ZRemRangeByLexRequest): unknown;
                create(base?: DeepPartial_86<ZRemRangeByLexRequest>): ZRemRangeByLexRequest;
                fromPartial(object: DeepPartial_86<ZRemRangeByLexRequest>): ZRemRangeByLexRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zRemRangeByRank: {
            readonly name: "ZRemRangeByRank";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZRemRangeByRankRequest";
                encode(message: ZRemRangeByRankRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZRemRangeByRankRequest;
                fromJSON(object: any): ZRemRangeByRankRequest;
                toJSON(message: ZRemRangeByRankRequest): unknown;
                create(base?: DeepPartial_86<ZRemRangeByRankRequest>): ZRemRangeByRankRequest;
                fromPartial(object: DeepPartial_86<ZRemRangeByRankRequest>): ZRemRangeByRankRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zRemRangeByScore: {
            readonly name: "ZRemRangeByScore";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZRemRangeByScoreRequest";
                encode(message: ZRemRangeByScoreRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZRemRangeByScoreRequest;
                fromJSON(object: any): ZRemRangeByScoreRequest;
                toJSON(message: ZRemRangeByScoreRequest): unknown;
                create(base?: DeepPartial_86<ZRemRangeByScoreRequest>): ZRemRangeByScoreRequest;
                fromPartial(object: DeepPartial_86<ZRemRangeByScoreRequest>): ZRemRangeByScoreRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zScore: {
            readonly name: "ZScore";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZScoreRequest";
                encode(message: ZScoreRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZScoreRequest;
                fromJSON(object: any): ZScoreRequest;
                toJSON(message: ZScoreRequest): unknown;
                create(base?: DeepPartial_86<ZScoreRequest>): ZScoreRequest;
                fromPartial(object: DeepPartial_86<ZScoreRequest>): ZScoreRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.DoubleValue";
                encode(message: DoubleValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DoubleValue;
                fromJSON(object: any): DoubleValue;
                toJSON(message: DoubleValue): unknown;
                create(base?: {
                    value?: number;
                } | undefined): DoubleValue;
                fromPartial(object: {
                    value?: number;
                }): DoubleValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zRank: {
            readonly name: "ZRank";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZRankRequest";
                encode(message: ZRankRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZRankRequest;
                fromJSON(object: any): ZRankRequest;
                toJSON(message: ZRankRequest): unknown;
                create(base?: DeepPartial_86<ZRankRequest>): ZRankRequest;
                fromPartial(object: DeepPartial_86<ZRankRequest>): ZRankRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zIncrBy: {
            readonly name: "ZIncrBy";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZIncrByRequest";
                encode(message: ZIncrByRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZIncrByRequest;
                fromJSON(object: any): ZIncrByRequest;
                toJSON(message: ZIncrByRequest): unknown;
                create(base?: DeepPartial_86<ZIncrByRequest>): ZIncrByRequest;
                fromPartial(object: DeepPartial_86<ZIncrByRequest>): ZIncrByRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.DoubleValue";
                encode(message: DoubleValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DoubleValue;
                fromJSON(object: any): DoubleValue;
                toJSON(message: DoubleValue): unknown;
                create(base?: {
                    value?: number;
                } | undefined): DoubleValue;
                fromPartial(object: {
                    value?: number;
                }): DoubleValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly zScan: {
            readonly name: "ZScan";
            readonly requestType: {
                $type: "devvit.plugin.redis.ZScanRequest";
                encode(message: ZScanRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZScanRequest;
                fromJSON(object: any): ZScanRequest;
                toJSON(message: ZScanRequest): unknown;
                create(base?: DeepPartial_86<ZScanRequest>): ZScanRequest;
                fromPartial(object: DeepPartial_86<ZScanRequest>): ZScanRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redis.ZScanResponse";
                encode(message: ZScanResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ZScanResponse;
                fromJSON(object: any): ZScanResponse;
                toJSON(message: ZScanResponse): unknown;
                create(base?: DeepPartial_86<ZScanResponse>): ZScanResponse;
                fromPartial(object: DeepPartial_86<ZScanResponse>): ZScanResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const RedisAPIServiceName = "devvit.plugin.redis.RedisAPI";

export declare type RedisClient = {
    /**
     * Marks the given keys to be watched for conditional execution of a transaction.
     * https://redis.io/commands/watch/
     * @arg {} keys - given keys to be watched
     */
    watch(...keys: string[]): Promise<TxClientLike>;
    /**
     * Get the value of key. If the key does not exist the special value nil is returned.
     * https://redis.io/commands/get/
     * @arg {} key
     * @returns value of key or null when key does not exist.
     */
    get(key: string): Promise<string | undefined>;
    /**
     * Set key to hold the string value. If key already holds a value, it is overwritten
     * https://redis.io/commands/set/
     * @arg {} key
     * @arg {} value
     * @arg {} options
     */
    set(key: string, value: string, options?: SetOptions): Promise<string>;
    /**
     * Removes the specified keys. A key is ignored if it does not exist.
     * https://redis.io/commands/del/
     * @arg {} keys
     */
    del(...keys: string[]): Promise<void>;
    /**
     * Returns the string representation of the type of the value stored at key
     * https://redis.io/commands/type/
     * @arg {} key
     * @returns string representation of the type
     */
    type(key: string): Promise<string>;
    /**
     * Returns the substring of the string value stored at key, determined by
     * the offsets start and end (both are inclusive).
     * https://redis.io/commands/getrange/
     * @arg {} key
     * @arg {} start
     * @arg {} end
     * @returns substring determined by offsets [start, end]
     */
    getRange(key: string, start: number, end: number): Promise<string>;
    /**
     * Overwrites part of the string stored at key, starting at the
     * specified offset, for the entire length of value.
     * https://redis.io/commands/setrange/
     * @arg {} key
     * @arg {} offset
     * @returns length of the string after it was modified by the command
     */
    setRange(key: string, offset: number, value: string): Promise<number>;
    /**
     * Returns the length of the string value stored at key.
     * An error is returned when key holds a non-string value.
     * https://redis.io/commands/strlen/
     * @arg {} key
     * @returns length of the string stored at key
     */
    strlen(key: string): Promise<number>;
    /**
     * Increments the number stored at key by increment.
     * https://redis.io/commands/incrby/
     * @arg {} key
     * @arg {} value
     * @returns value of key after the increment
     */
    incrBy(key: string, value: number): Promise<number>;
    /**
     * Returns the values of all specified keys.
     * https://redis.io/commands/mget/
     * @arg {} keys
     * @returns list of values at the specified keys
     */
    mget(keys: string[]): Promise<(string | null)[]>;
    /**
     * Sets the given keys to their respective values.
     * https://redis.io/commands/mset/
     * @arg {} keyValues
     */
    mset(keyValues: {
        [key: string]: string;
    }): Promise<void>;
    /**
     * Set a timeout on key.
     * https://redis.io/commands/expire/
     * @arg {} key
     * @arg {} seconds
     */
    expire(key: string, seconds: number): Promise<void>;
    /**
     * Returns the absolute Unix timestamp in seconds at which the given key will expire
     * https://redis.io/commands/expiretime/
     * @arg {} key
     * @returns expiration Unix timestamp in seconds, or a negative value in order to signal an error
     */
    expireTime(key: string): Promise<number>;
    /**
     * Adds all the specified members with the specified scores to the sorted set stored at key.
     * https://redis.io/commands/zadd/
     * @arg {} key
     * @returns number of elements added to the sorted set
     */
    zAdd(key: string, ...members: ZMember[]): Promise<number>;
    /**
     * Returns the cardinality (number of elements) of the sorted set stored at key.
     * https://redis.io/commands/zcard/
     * @arg {} key
     * @returns cardinality of the sorted set
     */
    zCard(key: string): Promise<number>;
    /**
     * Returns the score of member in the sorted set at key.
     * https://redis.io/commands/zscore/
     * @arg {} key
     * @arg {} member
     * @returns the score of the member (a double-precision floating point number).
     */
    zScore(key: string, member: string): Promise<number>;
    /**
     * Returns the rank of member in the sorted set stored at key
     * https://redis.io/commands/zrank/
     * @arg {} key
     * @arg {} member
     * @returns rank of the member. The rank (or index) is 0-based
     * which means that the member with the lowest score has rank 0
     */
    zRank(key: string, member: string): Promise<number>;
    /**
     * Increments the score of member in the sorted set stored at key by value
     * https://redis.io/commands/zincrby/
     * @arg {} key
     * @arg {} member
     * @arg {} value
     * @returns the new score of member as a double precision floating point number
     */
    zIncrBy(key: string, member: string, value: number): Promise<number>;
    /**
     * Returns the specified range of elements in the sorted set stored at key.
     * https://redis.io/commands/zrange/
     * @arg {} key
     * @arg {} start
     * @arg {} stop
     * @arg {} options
     * @returns list of elements in the specified range
     */
    zRange(key: string, start: number | string, stop: number | string, options?: ZRangeOptions): Promise<{
        member: string;
        score: number;
    }[]>;
    /**
     * Removes the specified members from the sorted set stored at key.
     * https://redis.io/commands/zrem/
     * @arg {} key
     * @arg {} members
     * @returns number of members removed from the sorted set
     */
    zRem(key: string, members: string[]): Promise<number>;
    /**
     * removes all elements in the sorted set stored at key between the
     * lexicographical range specified by min and max
     * https://redis.io/commands/zremrangebylex/
     * @arg {} key
     * @arg {} min
     * @arg {} max
     * @returns number of members removed from the sorted set
     */
    zRemRangeByLex(key: string, min: string, max: string): Promise<number>;
    /**
     * Removes all elements in the sorted set stored at key with rank between start and stop.
     * https://redis.io/commands/zremrangebyrank/
     * @arg {} key
     * @arg {} start
     * @arg {} stop
     * @returns number of members removed from the sorted set
     */
    zRemRangeByRank(key: string, start: number, stop: number): Promise<number>;
    /**
     * Removes all elements in the sorted set stored at key with a score between min and max
     * https://redis.io/commands/zremrangebyscore/
     * @arg {} key
     * @arg {} min
     * @arg {} max
     * @returns number of members removed from the sorted set
     */
    zRemRangeByScore(key: string, min: number, max: number): Promise<number>;
    /**
     * Iterates elements of Sorted Set types and their associated scores.
     * @arg {} key
     * @arg {} cursor
     * @arg {} pattern
     * @arg {} count
     */
    zScan(key: string, cursor: number, pattern?: string | undefined, count?: number | undefined): Promise<ZScanResponse>;
    /**
     * Sets the specified fields to their respective values in the hash stored at key.
     * https://redis.io/commands/hset
     * @arg {} key
     * @arg {} fieldValues
     * @returns number of fields that were added
     */
    hset(key: string, fieldValues: {
        [field: string]: string;
    }): Promise<number>;
    /**
     * Returns the value associated with field in the hash stored at key.
     * https://redis.io/commands/hget
     * @arg {} key
     * @arg {} field
     * @returns value associated with field
     */
    hget(key: string, field: string): Promise<string | undefined>;
    /**
     * Returns all fields and values of the hash stored at key
     * https://redis.io/commands/hgetall
     * @arg {} key
     * @returns a map of fields and their values stored in the hash,
     */
    hgetall(key: string): Promise<Record<string, string> | undefined>;
    /**
     * Removes the specified fields from the hash stored at key.
     * https://redis.io/commands/hdel/
     * @arg {} key
     * @arg {} fields
     * @returns number of fields that were removed from the hash
     */
    hdel(key: string, fields: string[]): Promise<number>;
    /**
     * Iterates fields of Hash types and their associated values.
     * @arg {} key
     * @arg {} cursor
     * @arg {} pattern
     * @arg {} count
     */
    hscan(key: string, cursor: number, pattern?: string | undefined, count?: number | undefined): Promise<HScanResponse>;
    /**
     * Returns all field names in the hash stored at key.
     * @arg {} key
     */
    hkeys(key: string): Promise<string[]>;
    /**
     * Increments the number stored at field in the hash stored at key by increment.
     * https://redis.io/commands/hincrby/
     * @arg {} key
     * @arg {} field
     * @arg {} value
     * @returns value of key after the increment
     */
    hincrby(key: string, field: string, value: number): Promise<number>;
    /**
     * Returns the number of fields contained in the hash stored at key.
     * @arg {} key
     * @returns the number of fields in the hash, or 0 when the key does not exist.
     */
    hlen(key: string): Promise<number>;
    /**
     * Allows read/write operations to global keys in Redis
     * Global redis enables apps to persist and access state across subreddit installations
     */
    global: Omit<RedisClient, 'global'>;
};

declare interface RedisFieldValue {
    field: string;
    value: string;
}

declare const RedisFieldValue: {
    $type: "devvit.plugin.redis.RedisFieldValue";
    encode(message: RedisFieldValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedisFieldValue;
    fromJSON(object: any): RedisFieldValue;
    toJSON(message: RedisFieldValue): unknown;
    create(base?: DeepPartial_86<RedisFieldValue>): RedisFieldValue;
    fromPartial(object: DeepPartial_86<RedisFieldValue>): RedisFieldValue;
};

declare interface RedisFieldValues {
    fieldValues: {
        [key: string]: string;
    };
}

declare const RedisFieldValues: {
    $type: "devvit.plugin.redis.RedisFieldValues";
    encode(message: RedisFieldValues, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedisFieldValues;
    fromJSON(object: any): RedisFieldValues;
    toJSON(message: RedisFieldValues): unknown;
    create(base?: DeepPartial_86<RedisFieldValues>): RedisFieldValues;
    fromPartial(object: DeepPartial_86<RedisFieldValues>): RedisFieldValues;
};

declare interface RedisFieldValues_FieldValuesEntry {
    key: string;
    value: string;
}

declare const RedisFieldValues_FieldValuesEntry: {
    $type: "devvit.plugin.redis.RedisFieldValues.FieldValuesEntry";
    encode(message: RedisFieldValues_FieldValuesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedisFieldValues_FieldValuesEntry;
    fromJSON(object: any): RedisFieldValues_FieldValuesEntry;
    toJSON(message: RedisFieldValues_FieldValuesEntry): unknown;
    create(base?: DeepPartial_86<RedisFieldValues_FieldValuesEntry>): RedisFieldValues_FieldValuesEntry;
    fromPartial(object: DeepPartial_86<RedisFieldValues_FieldValuesEntry>): RedisFieldValues_FieldValuesEntry;
};

/**
 * This key scope determines the key namespacing in Redis storage
 * By default, all keys in Redis are namespaced to an installation
 * Global redis enables apps to persist and access state across subreddit installations
 * Default key format - installation:app:custom-key
 * Global redis key format - global:app:custom-key
 */
declare enum RedisKeyScope {
    INSTALLATION = 0,
    GLOBAL = 1,
    UNRECOGNIZED = -1
}

declare function redisKeyScopeFromJSON(object: any): RedisKeyScope;

declare function redisKeyScopeToJSON(object: RedisKeyScope): number;

declare interface RedisKeyValue {
    key: string;
    value: string;
}

declare const RedisKeyValue: {
    $type: "devvit.plugin.redis.RedisKeyValue";
    encode(message: RedisKeyValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedisKeyValue;
    fromJSON(object: any): RedisKeyValue;
    toJSON(message: RedisKeyValue): unknown;
    create(base?: DeepPartial_86<RedisKeyValue>): RedisKeyValue;
    fromPartial(object: DeepPartial_86<RedisKeyValue>): RedisKeyValue;
};

declare interface RedisValues {
    values: string[];
}

declare const RedisValues: {
    $type: "devvit.plugin.redis.RedisValues";
    encode(message: RedisValues, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RedisValues;
    fromJSON(object: any): RedisValues;
    toJSON(message: RedisValues): unknown;
    create(base?: DeepPartial_86<RedisValues>): RedisValues;
    fromPartial(object: DeepPartial_86<RedisValues>): RedisValues;
};

export declare type RelationshipType = 'moderator_invite' | 'contributor' | 'banned' | 'muted' | 'wikibanned' | 'wikicontributor';

/** Request the client to reload some or all of the content in a particular post */
declare interface ReloadPartEffect {
    subreddit?: ReloadPartEffect_Subreddit | undefined;
    post?: ReloadPartEffect_Post | undefined;
    comment?: ReloadPartEffect_Comment | undefined;
}

declare const ReloadPartEffect: {
    $type: "devvit.ui.effects.v1alpha.ReloadPartEffect";
    encode(message: ReloadPartEffect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReloadPartEffect;
    fromJSON(object: any): ReloadPartEffect;
    toJSON(message: ReloadPartEffect): unknown;
    create(base?: DeepPartial_33<ReloadPartEffect>): ReloadPartEffect;
    fromPartial(object: DeepPartial_33<ReloadPartEffect>): ReloadPartEffect;
};

/**
 * Reload a comment and/or comment tree
 * e.g.: an action has altered or replied to a comment
 */
declare interface ReloadPartEffect_Comment {
    /** Parent Post Thing ID (t3) */
    postId: string;
    /** Comment Thing ID (t1) */
    commentId: string;
    /** If true, reload the entire comment tree, not just the contents of the target comment */
    replies?: boolean | undefined;
}

declare const ReloadPartEffect_Comment: {
    $type: "devvit.ui.effects.v1alpha.ReloadPartEffect.Comment";
    encode(message: ReloadPartEffect_Comment, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReloadPartEffect_Comment;
    fromJSON(object: any): ReloadPartEffect_Comment;
    toJSON(message: ReloadPartEffect_Comment): unknown;
    create(base?: DeepPartial_33<ReloadPartEffect_Comment>): ReloadPartEffect_Comment;
    fromPartial(object: DeepPartial_33<ReloadPartEffect_Comment>): ReloadPartEffect_Comment;
};

/**
 * Reload post contents
 * e.g.: an action has altered the post contents or parts of the comment tree
 */
declare interface ReloadPartEffect_Post {
    /** Post Thing ID (t3) */
    postId: string;
    /** If true reload post body */
    body?: boolean | undefined;
    /** If true reload entire comment tree */
    comments?: boolean | undefined;
}

declare const ReloadPartEffect_Post: {
    $type: "devvit.ui.effects.v1alpha.ReloadPartEffect.Post";
    encode(message: ReloadPartEffect_Post, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReloadPartEffect_Post;
    fromJSON(object: any): ReloadPartEffect_Post;
    toJSON(message: ReloadPartEffect_Post): unknown;
    create(base?: DeepPartial_33<ReloadPartEffect_Post>): ReloadPartEffect_Post;
    fromPartial(object: DeepPartial_33<ReloadPartEffect_Post>): ReloadPartEffect_Post;
};

/**
 * Reload listing
 * e.g.: an action has added or removed a post
 */
declare interface ReloadPartEffect_Subreddit {
    /** Subreddit Thing ID (t5) */
    subredditId: string;
}

declare const ReloadPartEffect_Subreddit: {
    $type: "devvit.ui.effects.v1alpha.ReloadPartEffect.Subreddit";
    encode(message: ReloadPartEffect_Subreddit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReloadPartEffect_Subreddit;
    fromJSON(object: any): ReloadPartEffect_Subreddit;
    toJSON(message: ReloadPartEffect_Subreddit): unknown;
    create(base?: DeepPartial_33<ReloadPartEffect_Subreddit>): ReloadPartEffect_Subreddit;
    fromPartial(object: DeepPartial_33<ReloadPartEffect_Subreddit>): ReloadPartEffect_Subreddit;
};

declare interface RemoteLogConsumer {
    Tail(request: RemoteLogQuery, metadata?: Metadata): Observable<RemoteLogMessage>;
}

declare interface RemoteLogConsumerClient {
    Tail(request: RemoteLogQuery): Promise<RemoteLogMessage>;
}

declare class RemoteLogConsumerClientImpl implements RemoteLogConsumer {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_4, opts?: {
        service?: string;
    });
    Tail(request: RemoteLogQuery, metadata?: Metadata): Observable<RemoteLogMessage>;
}

declare class RemoteLogConsumerClientJSON implements RemoteLogConsumerClient {
    private readonly rpc;
    constructor(rpc: Rpc_3);
    Tail(request: RemoteLogQuery): Promise<RemoteLogMessage>;
}

declare class RemoteLogConsumerClientProtobuf implements RemoteLogConsumerClient {
    private readonly rpc;
    constructor(rpc: Rpc_3);
    Tail(request: RemoteLogQuery): Promise<RemoteLogMessage>;
}

declare type RemoteLogConsumerDefinition = typeof RemoteLogConsumerDefinition;

declare const RemoteLogConsumerDefinition: {
    readonly name: "RemoteLogConsumer";
    readonly fullName: "devvit.remote_logger.RemoteLogConsumer";
    readonly methods: {
        readonly tail: {
            readonly name: "Tail";
            readonly requestType: {
                $type: "devvit.remote_logger.RemoteLogQuery";
                encode(message: RemoteLogQuery, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogQuery;
                fromJSON(object: any): RemoteLogQuery;
                toJSON(message: RemoteLogQuery): unknown;
                create(base?: DeepPartial_87<RemoteLogQuery>): RemoteLogQuery;
                fromPartial(object: DeepPartial_87<RemoteLogQuery>): RemoteLogQuery;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.remote_logger.RemoteLogMessage";
                encode(message: RemoteLogMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogMessage;
                fromJSON(object: any): RemoteLogMessage;
                toJSON(message: RemoteLogMessage): unknown;
                create(base?: DeepPartial_87<RemoteLogMessage>): RemoteLogMessage;
                fromPartial(object: DeepPartial_87<RemoteLogMessage>): RemoteLogMessage;
            };
            readonly responseStream: true;
            readonly options: {};
        };
    };
};

declare const RemoteLogConsumerServiceName = "devvit.remote_logger.RemoteLogConsumer";

/** Filter on installation ID (encoded subreddit name AND app name). */
declare interface RemoteLogInstallationFilter {
    installationId: string;
}

declare const RemoteLogInstallationFilter: {
    $type: "devvit.remote_logger.RemoteLogInstallationFilter";
    encode(message: RemoteLogInstallationFilter, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogInstallationFilter;
    fromJSON(object: any): RemoteLogInstallationFilter;
    toJSON(message: RemoteLogInstallationFilter): unknown;
    create(base?: DeepPartial_87<RemoteLogInstallationFilter>): RemoteLogInstallationFilter;
    fromPartial(object: DeepPartial_87<RemoteLogInstallationFilter>): RemoteLogInstallationFilter;
};

declare interface RemoteLogMessage {
    log?: LogMessage | undefined;
    error?: LogErrorMessage | undefined;
    keepalive?: KeepAliveMessage | undefined;
    event?: LogEventMessage | undefined;
}

declare const RemoteLogMessage: {
    $type: "devvit.remote_logger.RemoteLogMessage";
    encode(message: RemoteLogMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogMessage;
    fromJSON(object: any): RemoteLogMessage;
    toJSON(message: RemoteLogMessage): unknown;
    create(base?: DeepPartial_87<RemoteLogMessage>): RemoteLogMessage;
    fromPartial(object: DeepPartial_87<RemoteLogMessage>): RemoteLogMessage;
};

declare interface RemoteLogMessages {
    messages: RemoteLogMessage[];
}

declare const RemoteLogMessages: {
    $type: "devvit.remote_logger.RemoteLogMessages";
    encode(message: RemoteLogMessages, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogMessages;
    fromJSON(object: any): RemoteLogMessages;
    toJSON(message: RemoteLogMessages): unknown;
    create(base?: DeepPartial_87<RemoteLogMessages>): RemoteLogMessages;
    fromPartial(object: DeepPartial_87<RemoteLogMessages>): RemoteLogMessages;
};

declare interface RemoteLogPublisher {
    Put(request: RemoteLogMessage, metadata?: Metadata): Promise<RemoteLogPutResponse>;
    PutAll(request: RemoteLogMessages, metadata?: Metadata): Promise<RemoteLogPutResponse>;
}

declare interface RemoteLogPublisherClient {
    Put(request: RemoteLogMessage): Promise<RemoteLogPutResponse>;
    PutAll(request: RemoteLogMessages): Promise<RemoteLogPutResponse>;
}

declare class RemoteLogPublisherClientImpl implements RemoteLogPublisher {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_4, opts?: {
        service?: string;
    });
    Put(request: RemoteLogMessage, metadata?: Metadata): Promise<RemoteLogPutResponse>;
    PutAll(request: RemoteLogMessages, metadata?: Metadata): Promise<RemoteLogPutResponse>;
}

declare class RemoteLogPublisherClientJSON implements RemoteLogPublisherClient {
    private readonly rpc;
    constructor(rpc: Rpc_3);
    Put(request: RemoteLogMessage): Promise<RemoteLogPutResponse>;
    PutAll(request: RemoteLogMessages): Promise<RemoteLogPutResponse>;
}

declare class RemoteLogPublisherClientProtobuf implements RemoteLogPublisherClient {
    private readonly rpc;
    constructor(rpc: Rpc_3);
    Put(request: RemoteLogMessage): Promise<RemoteLogPutResponse>;
    PutAll(request: RemoteLogMessages): Promise<RemoteLogPutResponse>;
}

declare type RemoteLogPublisherDefinition = typeof RemoteLogPublisherDefinition;

declare const RemoteLogPublisherDefinition: {
    readonly name: "RemoteLogPublisher";
    readonly fullName: "devvit.remote_logger.RemoteLogPublisher";
    readonly methods: {
        readonly put: {
            readonly name: "Put";
            readonly requestType: {
                $type: "devvit.remote_logger.RemoteLogMessage";
                encode(message: RemoteLogMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogMessage;
                fromJSON(object: any): RemoteLogMessage;
                toJSON(message: RemoteLogMessage): unknown;
                create(base?: DeepPartial_87<RemoteLogMessage>): RemoteLogMessage;
                fromPartial(object: DeepPartial_87<RemoteLogMessage>): RemoteLogMessage;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.remote_logger.RemoteLogPutResponse";
                encode(_: RemoteLogPutResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogPutResponse;
                fromJSON(_: any): RemoteLogPutResponse;
                toJSON(_: RemoteLogPutResponse): unknown;
                create(base?: DeepPartial_87<RemoteLogPutResponse>): RemoteLogPutResponse;
                fromPartial(_: DeepPartial_87<RemoteLogPutResponse>): RemoteLogPutResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly putAll: {
            readonly name: "PutAll";
            readonly requestType: {
                $type: "devvit.remote_logger.RemoteLogMessages";
                encode(message: RemoteLogMessages, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogMessages;
                fromJSON(object: any): RemoteLogMessages;
                toJSON(message: RemoteLogMessages): unknown;
                create(base?: DeepPartial_87<RemoteLogMessages>): RemoteLogMessages;
                fromPartial(object: DeepPartial_87<RemoteLogMessages>): RemoteLogMessages;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.remote_logger.RemoteLogPutResponse";
                encode(_: RemoteLogPutResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogPutResponse;
                fromJSON(_: any): RemoteLogPutResponse;
                toJSON(_: RemoteLogPutResponse): unknown;
                create(base?: DeepPartial_87<RemoteLogPutResponse>): RemoteLogPutResponse;
                fromPartial(_: DeepPartial_87<RemoteLogPutResponse>): RemoteLogPutResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const RemoteLogPublisherServiceName = "devvit.remote_logger.RemoteLogPublisher";

declare interface RemoteLogPutResponse {
}

declare const RemoteLogPutResponse: {
    $type: "devvit.remote_logger.RemoteLogPutResponse";
    encode(_: RemoteLogPutResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogPutResponse;
    fromJSON(_: any): RemoteLogPutResponse;
    toJSON(_: RemoteLogPutResponse): unknown;
    create(base?: DeepPartial_87<RemoteLogPutResponse>): RemoteLogPutResponse;
    fromPartial(_: DeepPartial_87<RemoteLogPutResponse>): RemoteLogPutResponse;
};

declare interface RemoteLogQuery {
    installation?: RemoteLogInstallationFilter | undefined;
    subredditAppName?: RemoteLogSubredditAppNameFilter | undefined;
    type: RemoteLogType;
    since?: Date | undefined;
}

declare const RemoteLogQuery: {
    $type: "devvit.remote_logger.RemoteLogQuery";
    encode(message: RemoteLogQuery, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogQuery;
    fromJSON(object: any): RemoteLogQuery;
    toJSON(message: RemoteLogQuery): unknown;
    create(base?: DeepPartial_87<RemoteLogQuery>): RemoteLogQuery;
    fromPartial(object: DeepPartial_87<RemoteLogQuery>): RemoteLogQuery;
};

/**
 * Filter on subreddit name and / or app name. Not all combinations are
 * available on all streams.
 */
declare interface RemoteLogSubredditAppNameFilter {
    subreddit: string;
    appName: string;
}

declare const RemoteLogSubredditAppNameFilter: {
    $type: "devvit.remote_logger.RemoteLogSubredditAppNameFilter";
    encode(message: RemoteLogSubredditAppNameFilter, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RemoteLogSubredditAppNameFilter;
    fromJSON(object: any): RemoteLogSubredditAppNameFilter;
    toJSON(message: RemoteLogSubredditAppNameFilter): unknown;
    create(base?: DeepPartial_87<RemoteLogSubredditAppNameFilter>): RemoteLogSubredditAppNameFilter;
    fromPartial(object: DeepPartial_87<RemoteLogSubredditAppNameFilter>): RemoteLogSubredditAppNameFilter;
};

declare enum RemoteLogType {
    LOG = 0,
    ERROR = 1,
    EVENT = 2,
    UNRECOGNIZED = -1
}

declare function remoteLogTypeFromJSON(object: any): RemoteLogType;

declare function remoteLogTypeToJSON(object: RemoteLogType): number;

/**
 * An individual Removal Reason object.
 */
export declare type RemovalReason = {
    /**
     * The ID of the removal reason.
     */
    id: string;
    /**
     * The message associated with the removal reason.
     */
    message: string;
    /**
     * The title of the removal reason.
     */
    title: string;
};

declare interface RemovePostInCollectionRequest {
    /** The id of the collection. */
    collectionId?: string | undefined;
    /** The t3_ id of post which should be removed to the collection. */
    linkFullname?: string | undefined;
}

declare const RemovePostInCollectionRequest: {
    $type: "devvit.plugin.redditapi.postcollections.RemovePostInCollectionRequest";
    encode(message: RemovePostInCollectionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RemovePostInCollectionRequest;
    fromJSON(object: any): RemovePostInCollectionRequest;
    toJSON(message: RemovePostInCollectionRequest): unknown;
    create(base?: DeepPartial_81<RemovePostInCollectionRequest>): RemovePostInCollectionRequest;
    fromPartial(object: DeepPartial_81<RemovePostInCollectionRequest>): RemovePostInCollectionRequest;
};

export declare type RemoveRelationshipOptions = {
    subredditName: string;
    username: string;
    type: RelationshipType | 'moderator';
};

declare interface RemoveRequest {
    /** thing id (e.g t1_15bfi0) */
    id: string;
    /** is it spam? */
    spam: boolean;
}

declare const RemoveRequest: {
    $type: "devvit.plugin.redditapi.moderation.RemoveRequest";
    encode(message: RemoveRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RemoveRequest;
    fromJSON(object: any): RemoveRequest;
    toJSON(message: RemoveRequest): unknown;
    create(base?: DeepPartial_2<RemoveRequest>): RemoveRequest;
    fromPartial(object: DeepPartial_2<RemoveRequest>): RemoveRequest;
};

/**
 * **DO NOT EDIT**
 *
 * This message is deprecated and should be fixed in time to maintain backwards compatability.
 *
 * @deprecated
 */
declare interface RenderPostRequest {
    /** Stateful data received from a previous response */
    state?: {
        [key: string]: any;
    } | undefined;
    /** Render the post with Blocks */
    blocks?: BlockRenderRequest | undefined;
    /** Dimensions provides a way for the entry point to provide layout information to the proto. */
    dimensions?: Dimensions | undefined;
}

declare const RenderPostRequest: {
    $type: "devvit.reddit.custom_post.v1alpha.RenderPostRequest";
    encode(message: RenderPostRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RenderPostRequest;
    fromJSON(object: any): RenderPostRequest;
    toJSON(message: RenderPostRequest): unknown;
    create(base?: DeepPartial_43<RenderPostRequest>): RenderPostRequest;
    fromPartial(object: DeepPartial_43<RenderPostRequest>): RenderPostRequest;
};

/**
 * **DO NOT EDIT**
 *
 * This message is deprecated and should be fixed in time to maintain backwards compatability.
 *
 * @deprecated
 */
declare interface RenderPostResponse {
    /** Stateful data to send back to your app with events */
    state?: {
        [key: string]: any;
    } | undefined;
    /** Optional list of Effects to execute on the client */
    effects: Effect[];
    /** Blocks UI rendering of the post */
    blocks?: BlockRenderResponse | undefined;
}

declare const RenderPostResponse: {
    $type: "devvit.reddit.custom_post.v1alpha.RenderPostResponse";
    encode(message: RenderPostResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RenderPostResponse;
    fromJSON(object: any): RenderPostResponse;
    toJSON(message: RenderPostResponse): unknown;
    create(base?: DeepPartial_43<RenderPostResponse>): RenderPostResponse;
    fromPartial(object: DeepPartial_43<RenderPostResponse>): RenderPostResponse;
};

declare interface ReorderCollectionRequest {
    /** The id of the collection. */
    collectionId?: string | undefined;
    /** A comma separated list of post ids e.g. "t3_abc,t3_def", which will determine the order of posts in the collection. */
    linkIds?: string | undefined;
}

declare const ReorderCollectionRequest: {
    $type: "devvit.plugin.redditapi.postcollections.ReorderCollectionRequest";
    encode(message: ReorderCollectionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReorderCollectionRequest;
    fromJSON(object: any): ReorderCollectionRequest;
    toJSON(message: ReorderCollectionRequest): unknown;
    create(base?: DeepPartial_81<ReorderCollectionRequest>): ReorderCollectionRequest;
    fromPartial(object: DeepPartial_81<ReorderCollectionRequest>): ReorderCollectionRequest;
};

export declare type ReplyToCommentOptions = CommentSubmissionOptions;

declare interface ReportAwardRequest {
    /**
     * Award ID from a Post or Comment
     * @example "award_813b473a-4d74-4933-ba79-a7f1b8b285ef"
     */
    awardId: string;
    /** Reason for this report */
    reason?: string | undefined;
}

declare const ReportAwardRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.ReportAwardRequest";
    encode(message: ReportAwardRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReportAwardRequest;
    fromJSON(object: any): ReportAwardRequest;
    toJSON(message: ReportAwardRequest): unknown;
    create(base?: DeepPartial_64<ReportAwardRequest>): ReportAwardRequest;
    fromPartial(object: DeepPartial_64<ReportAwardRequest>): ReportAwardRequest;
};

declare interface ReportRequest {
    /** Additional information attached to the report */
    additionalInfo?: string | undefined;
    /** Additional information attached to the report */
    customText?: string | undefined;
    /** Modmail conversation ID to attach to the report for context */
    modmailConvId?: string | undefined;
    /**
     * Free-form reason explaining this report
     * Note: If reporting Subreddit content the subreddit must have
     *       "allow free-form reports by users" enabled
     * @see {@link Subreddits.SubredditAboutRules}
     */
    otherReason?: string | undefined;
    /** One of: "rule", "site_reason_selected", "other" */
    reason: string;
    /** The Subreddit rule this thing is violating */
    ruleReason?: string | undefined;
    /** The Reddit rule this thing is violating */
    siteReason?: string | undefined;
    /**
     * Subreddit name; set if reporting a Post or Comment
     * @example "AskReddit"
     */
    srName?: string | undefined;
    /**
     * The thing ID being reported. Must be a Post (t3), Comment (t1), or Private Message (t4)
     * @example "t3_abc123"
     */
    thingId: string;
    /**
     * List of comma-separated usernames to associate with this report
     * @example "user1,user2,user3"
     */
    usernames?: string | undefined;
}

declare const ReportRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.ReportRequest";
    encode(message: ReportRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReportRequest;
    fromJSON(object: any): ReportRequest;
    toJSON(message: ReportRequest): unknown;
    create(base?: DeepPartial_64<ReportRequest>): ReportRequest;
    fromPartial(object: DeepPartial_64<ReportRequest>): ReportRequest;
};

declare interface ReportUserRequest {
    /** JSON data */
    details: string;
    /** a string no longer than 100 characters */
    reason: string;
    /** a valid, existing reddit username */
    user: string;
}

declare const ReportUserRequest: {
    $type: "devvit.plugin.redditapi.users.ReportUserRequest";
    encode(message: ReportUserRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReportUserRequest;
    fromJSON(object: any): ReportUserRequest;
    toJSON(message: ReportUserRequest): unknown;
    create(base?: DeepPartial_100<ReportUserRequest>): ReportUserRequest;
    fromPartial(object: DeepPartial_100<ReportUserRequest>): ReportUserRequest;
};

declare interface RequestData {
    method: string;
    headers: {
        [key: string]: string;
    };
    body: Uint8Array;
}

declare const RequestData: {
    $type: "devvit.plugin.http.RequestData";
    encode(message: RequestData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RequestData;
    fromJSON(object: any): RequestData;
    toJSON(message: RequestData): unknown;
    create(base?: DeepPartial_58<RequestData>): RequestData;
    fromPartial(object: DeepPartial_58<RequestData>): RequestData;
};

declare interface RequestData_HeadersEntry {
    key: string;
    value: string;
}

declare const RequestData_HeadersEntry: {
    $type: "devvit.plugin.http.RequestData.HeadersEntry";
    encode(message: RequestData_HeadersEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RequestData_HeadersEntry;
    fromJSON(object: any): RequestData_HeadersEntry;
    toJSON(message: RequestData_HeadersEntry): unknown;
    create(base?: DeepPartial_58<RequestData_HeadersEntry>): RequestData_HeadersEntry;
    fromPartial(object: DeepPartial_58<RequestData_HeadersEntry>): RequestData_HeadersEntry;
};

/** Automatically re-render UI */
declare interface RerenderEffect {
    /** Value greater than zero to wait before calling Render again */
    delaySeconds?: number | undefined;
}

declare const RerenderEffect: {
    $type: "devvit.ui.effects.v1alpha.RerenderEffect";
    encode(message: RerenderEffect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RerenderEffect;
    fromJSON(object: any): RerenderEffect;
    toJSON(message: RerenderEffect): unknown;
    create(base?: DeepPartial_32<RerenderEffect>): RerenderEffect;
    fromPartial(object: DeepPartial_32<RerenderEffect>): RerenderEffect;
};

/** Signals to the server of device/client-side surface size changes */
declare interface ResizeEvent {
}

declare const ResizeEvent: {
    $type: "devvit.ui.events.v1alpha.ResizeEvent";
    encode(_: ResizeEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResizeEvent;
    fromJSON(_: any): ResizeEvent;
    toJSON(_: ResizeEvent): unknown;
    create(base?: DeepPartial_49<ResizeEvent>): ResizeEvent;
    fromPartial(_: DeepPartial_49<ResizeEvent>): ResizeEvent;
};

/** A PackageQuery resolves to a package backed by a Bundle or a plugin. */
declare interface Resolution {
    bundle?: Bundle | undefined;
    error?: ResolutionError | undefined;
    plugin?: InspectorDescription | undefined;
}

declare const Resolution: {
    $type: "devvit.plugin.linker.Resolution";
    encode(message: Resolution, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Resolution;
    fromJSON(object: any): Resolution;
    toJSON(message: Resolution): unknown;
    create(base?: DeepPartial_62<Resolution>): Resolution;
    fromPartial(object: DeepPartial_62<Resolution>): Resolution;
};

declare interface ResolutionError {
    /** Failing query. */
    query?: PackageQuery | undefined;
    /** Human readable error message. */
    text: string;
}

declare const ResolutionError: {
    $type: "devvit.plugin.linker.ResolutionError";
    encode(message: ResolutionError, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolutionError;
    fromJSON(object: any): ResolutionError;
    toJSON(message: ResolutionError): unknown;
    create(base?: DeepPartial_62<ResolutionError>): ResolutionError;
    fromPartial(object: DeepPartial_62<ResolutionError>): ResolutionError;
};

/**
 * A Resolver tells the Linker what bundles exist, and helps the Linker know
 * which bundle is the best bundle to match a given request or PackageQuery.
 */
declare interface Resolver {
    /** What plugins are available to the Resolver? */
    RegisterPlugins(request: InspectorDescriptions, metadata?: Metadata): Promise<Empty>;
    /** What Bundle is best to satisfy the given request? */
    Resolve(request: PackageQuery, metadata?: Metadata): Promise<Resolution>;
    /** Notify the resolver that a bundle exists. Newer Bundles can overwrite older bundles. */
    RegisterBundle(request: Bundle, metadata?: Metadata): Promise<Empty>;
}

declare class ResolverClientImpl implements Resolver {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_21, opts?: {
        service?: string;
    });
    RegisterPlugins(request: InspectorDescriptions, metadata?: Metadata): Promise<Empty>;
    Resolve(request: PackageQuery, metadata?: Metadata): Promise<Resolution>;
    RegisterBundle(request: Bundle, metadata?: Metadata): Promise<Empty>;
}

/**
 * A Resolver tells the Linker what bundles exist, and helps the Linker know
 * which bundle is the best bundle to match a given request or PackageQuery.
 */
declare type ResolverDefinition = typeof ResolverDefinition;

declare const ResolverDefinition: {
    readonly name: "Resolver";
    readonly fullName: "devvit.plugin.linker.Resolver";
    readonly methods: {
        /** What plugins are available to the Resolver? */
        readonly registerPlugins: {
            readonly name: "RegisterPlugins";
            readonly requestType: {
                $type: "devvit.plugin.inspector.InspectorDescriptions";
                encode(message: InspectorDescriptions, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): InspectorDescriptions;
                fromJSON(object: any): InspectorDescriptions;
                toJSON(message: InspectorDescriptions): unknown;
                create(base?: {
                    descriptions?: {
                        provides?: {
                            fullName?: string;
                            methods?: {
                                fullName?: string;
                                name?: string;
                                requestStream?: boolean;
                                responseStream?: boolean;
                                requestType?: string;
                                responseType?: string;
                            }[];
                            name?: string;
                            version?: string;
                        }[];
                        hostname?: string;
                    }[];
                } | undefined): InspectorDescriptions;
                fromPartial(object: {
                    descriptions?: {
                        provides?: {
                            fullName?: string;
                            methods?: {
                                fullName?: string;
                                name?: string;
                                requestStream?: boolean;
                                responseStream?: boolean;
                                requestType?: string;
                                responseType?: string;
                            }[];
                            name?: string;
                            version?: string;
                        }[];
                        hostname?: string;
                    }[];
                }): InspectorDescriptions;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** What Bundle is best to satisfy the given request? */
        readonly resolve: {
            readonly name: "Resolve";
            readonly requestType: {
                $type: "devvit.runtime.PackageQuery";
                encode(message: PackageQuery, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PackageQuery;
                fromJSON(object: any): PackageQuery;
                toJSON(message: PackageQuery): unknown;
                create(base?: {
                    name?: string | undefined;
                    owner?: string | undefined;
                    typeName?: string;
                    versions?: string | undefined;
                } | undefined): PackageQuery;
                fromPartial(object: {
                    name?: string | undefined;
                    owner?: string | undefined;
                    typeName?: string;
                    versions?: string | undefined;
                }): PackageQuery;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.linker.Resolution";
                encode(message: Resolution, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): Resolution;
                fromJSON(object: any): Resolution;
                toJSON(message: Resolution): unknown;
                create(base?: DeepPartial_62<Resolution>): Resolution;
                fromPartial(object: DeepPartial_62<Resolution>): Resolution;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Notify the resolver that a bundle exists. Newer Bundles can overwrite older bundles. */
        readonly registerBundle: {
            readonly name: "RegisterBundle";
            readonly requestType: {
                $type: "devvit.plugin.buildpack.Bundle";
                encode(message: Bundle, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Bundle;
                fromJSON(object: any): Bundle;
                toJSON(message: Bundle): unknown;
                create(base?: {
                    code?: string;
                    dependencies?: {
                        actor?: {
                            name?: string;
                            owner?: string;
                            version?: string;
                        } | undefined;
                        hostname?: string;
                        provides?: {
                            actor?: {
                                name?: string;
                                owner?: string;
                                version?: string;
                            } | undefined;
                            definition?: {
                                fullName?: string;
                                methods?: {
                                    fullName?: string;
                                    name?: string;
                                    requestStream?: boolean;
                                    responseStream?: boolean;
                                    requestType?: string;
                                    responseType?: string;
                                }[];
                                name?: string;
                                version?: string;
                            } | undefined;
                            locations?: {
                                allow?: string[];
                                deny?: string[];
                            } | undefined;
                            partitionsBy?: string[];
                        }[];
                        uses?: {
                            name?: string | undefined;
                            owner?: string | undefined;
                            typeName?: string;
                            versions?: string | undefined;
                        }[];
                    } | undefined;
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assets?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    assetIds?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): Bundle;
                fromPartial(object: {
                    code?: string;
                    dependencies?: {
                        actor?: {
                            name?: string;
                            owner?: string;
                            version?: string;
                        } | undefined;
                        hostname?: string;
                        provides?: {
                            actor?: {
                                name?: string;
                                owner?: string;
                                version?: string;
                            } | undefined;
                            definition?: {
                                fullName?: string;
                                methods?: {
                                    fullName?: string;
                                    name?: string;
                                    requestStream?: boolean;
                                    responseStream?: boolean;
                                    requestType?: string;
                                    responseType?: string;
                                }[];
                                name?: string;
                                version?: string;
                            } | undefined;
                            locations?: {
                                allow?: string[];
                                deny?: string[];
                            } | undefined;
                            partitionsBy?: string[];
                        }[];
                        uses?: {
                            name?: string | undefined;
                            owner?: string | undefined;
                            typeName?: string;
                            versions?: string | undefined;
                        }[];
                    } | undefined;
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assets?: {
                        files?: {
                            path?: string;
                            content?: string;
                            isDirectory?: boolean;
                            isBase64?: boolean;
                        }[];
                    } | undefined;
                    assetIds?: {
                        [x: string]: string | undefined;
                    };
                }): Bundle;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const ResolverServiceName = "devvit.plugin.linker.Resolver";

declare interface Response_2 {
    accepted: boolean;
}

declare const Response_2: {
    $type: "devvit.actor.reddit.Response";
    encode(message: Response_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Response_2;
    fromJSON(object: any): Response_2;
    toJSON(message: Response_2): unknown;
    create(base?: DeepPartial_83<Response_2>): Response_2;
    fromPartial(object: DeepPartial_83<Response_2>): Response_2;
};

declare interface RevertWikiPageRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
    /** The name of the wiki page. */
    page: string;
    /** The revision ID to revert to. */
    revision: string;
}

declare const RevertWikiPageRequest: {
    $type: "devvit.plugin.redditapi.wiki.RevertWikiPageRequest";
    encode(message: RevertWikiPageRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RevertWikiPageRequest;
    fromJSON(object: any): RevertWikiPageRequest;
    toJSON(message: RevertWikiPageRequest): unknown;
    create(base?: DeepPartial_9<RevertWikiPageRequest>): RevertWikiPageRequest;
    fromPartial(object: DeepPartial_9<RevertWikiPageRequest>): RevertWikiPageRequest;
};

/**
 * @mixes ParagraphContainer
 * @mixes HeadingContainer
 * @mixes HorizontalRuleContainer
 * @mixes BlockQuoteContainer
 * @mixes CodeBlockContainer
 * @mixes EmbedContainer
 * @mixes ListContainer
 * @mixes TableContainer
 * @mixes ImageContainer
 * @mixes VideoContainer
 */
export declare class RichTextBuilder implements ParagraphContainer<RichTextBuilder>, HeadingContainer<RichTextBuilder>, HorizontalRuleContainer<RichTextBuilder>, BlockQuoteContainer<RichTextBuilder>, CodeBlockContainer<RichTextBuilder>, EmbedContainer<RichTextBuilder>, ListContainer<RichTextBuilder>, TableContainer<RichTextBuilder>, ImageContainer<RichTextBuilder>, VideoContainer<RichTextBuilder> {
    #private;
    constructor();
    /**
     * Serializes the document to a JSON string
     */
    build(): string;
    paragraph(cb: (paragraph: ParagraphContext) => void): RichTextBuilder;
    heading(opts: HeadingOptions, cb: (heading: HeadingContext) => void): RichTextBuilder;
    horizontalRule(): RichTextBuilder;
    blockQuote(opts: BlockQuoteOptions, cb: (blockQuote: BlockQuoteContext) => void): RichTextBuilder;
    codeBlock(opts: CodeBlockOptions, cb: (codeBlock: CodeBlockContext) => void): RichTextBuilder;
    embed(_opts: EmbedOptions): RichTextBuilder;
    list(opts: ListOptions, cb: (list: ListContext) => void): RichTextBuilder;
    table(cb: (table: TableContext) => void): RichTextBuilder;
    image(opts: ImageOptions): RichTextBuilder;
    animatedImage(opts: ImageOptions): RichTextBuilder;
    video(opts: VideoOptions): RichTextBuilder;
}

declare interface Rpc {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_10 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_11 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_12 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_13 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Promise<Uint8Array>;
    serverStreamingRequest(service: string, method: string, data: Uint8Array, metadata?: Metadata): Observable<Uint8Array>;
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Observable<Uint8Array>;
}

declare interface Rpc_14 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_15 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_16 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_17 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_18 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_19 {
    request(service: string, method: string, contentType: 'application/json' | 'application/protobuf', data: object | Uint8Array): Promise<object | Uint8Array>;
}

declare interface Rpc_2 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_20 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_21 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_22 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_23 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_24 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Promise<Uint8Array>;
    serverStreamingRequest(service: string, method: string, data: Uint8Array, metadata?: Metadata): Observable<Uint8Array>;
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Observable<Uint8Array>;
}

declare interface Rpc_25 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_26 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_27 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Promise<Uint8Array>;
    serverStreamingRequest(service: string, method: string, data: Uint8Array, metadata?: Metadata): Observable<Uint8Array>;
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Observable<Uint8Array>;
}

declare interface Rpc_28 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Promise<Uint8Array>;
    serverStreamingRequest(service: string, method: string, data: Uint8Array, metadata?: Metadata): Observable<Uint8Array>;
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Observable<Uint8Array>;
}

declare interface Rpc_29 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_3 {
    request(service: string, method: string, contentType: 'application/json' | 'application/protobuf', data: object | Uint8Array): Promise<object | Uint8Array>;
}

declare interface Rpc_3 {
    request(service: string, method: string, contentType: 'application/json' | 'application/protobuf', data: object | Uint8Array): Promise<object | Uint8Array>;
}

declare interface Rpc_30 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_31 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Promise<Uint8Array>;
    serverStreamingRequest(service: string, method: string, data: Uint8Array, metadata?: Metadata): Observable<Uint8Array>;
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Observable<Uint8Array>;
}

declare interface Rpc_32 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_33 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_34 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_35 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Promise<Uint8Array>;
    serverStreamingRequest(service: string, method: string, data: Uint8Array, metadata?: Metadata): Observable<Uint8Array>;
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Observable<Uint8Array>;
}

declare interface Rpc_36 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_37 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_38 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_39 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Promise<Uint8Array>;
    serverStreamingRequest(service: string, method: string, data: Uint8Array, metadata?: Metadata): Observable<Uint8Array>;
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Observable<Uint8Array>;
}

declare interface Rpc_4 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Promise<Uint8Array>;
    serverStreamingRequest(service: string, method: string, data: Uint8Array, metadata?: Metadata): Observable<Uint8Array>;
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>, metadata?: Metadata): Observable<Uint8Array>;
}

declare interface Rpc_40 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_41 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_42 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_43 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_44 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_45 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_46 {
    request(service: string, method: string, contentType: 'application/json' | 'application/protobuf', data: object | Uint8Array): Promise<object | Uint8Array>;
}

declare interface Rpc_47 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_48 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_49 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_5 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_50 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_51 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_52 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_53 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_54 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_55 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_56 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_57 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_58 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_59 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_6 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_60 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_61 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_62 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_63 {
    request(service: string, method: string, contentType: 'application/json' | 'application/protobuf', data: object | Uint8Array): Promise<object | Uint8Array>;
}

declare interface Rpc_64 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_65 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_66 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_67 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_68 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

/**
 * Common denominator remote procedure call interface. Some services only
 * require a partial implementation.
 */
declare type Rpc_69 = {
    /** Make a unary request */
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
    /** Make a request that returns a server stream */
    serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
    /** Make a request where the client will stream the request */
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
    /** Make a request where both the request and the response is streaming */
    bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
};

declare interface Rpc_7 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_8 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

declare interface Rpc_9 {
    request(service: string, method: string, data: Uint8Array, metadata?: Metadata): Promise<Uint8Array>;
}

/**
 * Schedule a new job to run at a specific time or on a cron schedule
 * @param job The job to schedule
 * @returns {} The id of the scheduled job
 */
export declare type RunJob = (job: ScheduledJobOptions | ScheduledCronJobOptions) => Promise<string>;

/** Native implementation, spawns/terminates Workers. */
declare interface RuntimeActor {
    NewWorker(request: LinkedBundle, metadata?: Metadata): Promise<Empty>;
    TerminateWorker(request: WorkerQuery, metadata?: Metadata): Promise<Empty>;
}

declare class RuntimeActorClientImpl implements RuntimeActor {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_8, opts?: {
        service?: string;
    });
    NewWorker(request: LinkedBundle, metadata?: Metadata): Promise<Empty>;
    TerminateWorker(request: WorkerQuery, metadata?: Metadata): Promise<Empty>;
}

/** Native implementation, spawns/terminates Workers. */
declare type RuntimeActorDefinition = typeof RuntimeActorDefinition;

declare const RuntimeActorDefinition: {
    readonly name: "RuntimeActor";
    readonly fullName: "devvit.runtime.actor.RuntimeActor";
    readonly methods: {
        readonly newWorker: {
            readonly name: "NewWorker";
            readonly requestType: {
                $type: "devvit.runtime.LinkedBundle";
                encode(message: LinkedBundle, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): LinkedBundle;
                fromJSON(object: any): LinkedBundle;
                toJSON(message: LinkedBundle): unknown;
                create(base?: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): LinkedBundle;
                fromPartial(object: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                }): LinkedBundle;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly terminateWorker: {
            readonly name: "TerminateWorker";
            readonly requestType: {
                $type: "devvit.runtime.actor.WorkerQuery";
                encode(message: WorkerQuery, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): WorkerQuery;
                fromJSON(object: any): WorkerQuery;
                toJSON(message: WorkerQuery): unknown;
                create(base?: DeepPartial_108<WorkerQuery>): WorkerQuery;
                fromPartial(object: DeepPartial_108<WorkerQuery>): WorkerQuery;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const RuntimeActorServiceName = "devvit.runtime.actor.RuntimeActor";

declare interface SaveRequest {
    /**
     * Post or Comment thing ID
     * @example "t1_abc123"
     */
    id: string;
}

declare const SaveRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.SaveRequest";
    encode(message: SaveRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SaveRequest;
    fromJSON(object: any): SaveRequest;
    toJSON(message: SaveRequest): unknown;
    create(base?: DeepPartial_64<SaveRequest>): SaveRequest;
    fromPartial(object: DeepPartial_64<SaveRequest>): SaveRequest;
};

declare interface ScheduledAction {
    /** Arbitrary string for an Actor's internal use */
    type: string;
    /** Arbitrary string for an Actor's internal use (i.e.: JSON serialized data) */
    data?: {
        [key: string]: any;
    } | undefined;
}

declare const ScheduledAction: {
    $type: "devvit.actor.scheduler.ScheduledAction";
    encode(message: ScheduledAction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ScheduledAction;
    fromJSON(object: any): ScheduledAction;
    toJSON(message: ScheduledAction): unknown;
    create(base?: DeepPartial_88<ScheduledAction>): ScheduledAction;
    fromPartial(object: DeepPartial_88<ScheduledAction>): ScheduledAction;
};

declare interface ScheduledActionRequest {
    /** A time in the future to execute the action */
    when?: Date | undefined;
    /** A crontab parseable string */
    cron?: string | undefined;
    /** Action data to send back to the Actor */
    action?: ScheduledAction | undefined;
}

declare const ScheduledActionRequest: {
    $type: "devvit.plugin.scheduler.ScheduledActionRequest";
    encode(message: ScheduledActionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ScheduledActionRequest;
    fromJSON(object: any): ScheduledActionRequest;
    toJSON(message: ScheduledActionRequest): unknown;
    create(base?: DeepPartial_89<ScheduledActionRequest>): ScheduledActionRequest;
    fromPartial(object: DeepPartial_89<ScheduledActionRequest>): ScheduledActionRequest;
};

declare interface ScheduledActionResponse {
    /** Opaque ID for the scheduled action */
    id: string;
}

declare const ScheduledActionResponse: {
    $type: "devvit.plugin.scheduler.ScheduledActionResponse";
    encode(message: ScheduledActionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ScheduledActionResponse;
    fromJSON(object: any): ScheduledActionResponse;
    toJSON(message: ScheduledActionResponse): unknown;
    create(base?: DeepPartial_89<ScheduledActionResponse>): ScheduledActionResponse;
    fromPartial(object: DeepPartial_89<ScheduledActionResponse>): ScheduledActionResponse;
};

export declare type ScheduledCronJob = {
    /** ID of the scheduled job. Use this with scheduler.cancelJob to cancel the job. */
    id: string;
    /** The name of the scheduled job type */
    name: string;
    /** Additional data passed in by the scheduler client */
    data: Data | undefined;
    /** The cron string of when this job should run */
    cron: string;
};

export declare type ScheduledCronJobOptions = {
    /** The name of the scheduled job type */
    name: string;
    /** Additional data passed in by the scheduler client */
    data?: Data | undefined;
    /** The cron string of when this job should run */
    cron: string;
};

export declare type ScheduledJob = {
    /** ID of the scheduled job. Use this with scheduler.cancelJob to cancel the job. */
    id: string;
    /** The name of the scheduled job type */
    name: string;
    /** Additional data passed in by the scheduler client */
    data: Data | undefined;
    /** The Date of when this job should run */
    runAt: Date;
};

export declare type ScheduledJobEvent = {
    /** The name of the scheduled job */
    name: string;
    /** Additional data passed in by the scheduler client */
    data?: Data | undefined;
};

export declare type ScheduledJobHandler = (event: ScheduledJobEvent, context: Omit<Devvit.Context, 'ui' | 'dimensions' | 'modLog' | 'uiEnvironment'>) => void | Promise<void>;

export declare type ScheduledJobOptions = {
    /** The name of the scheduled job type */
    name: string;
    /** Additional data passed in by the scheduler client */
    data?: Data | undefined;
    /** The Date of when this job should run */
    runAt: Date;
};

export declare type ScheduledJobType = {
    /** The name of the scheduled job type */
    name: string;
    /** The function that will be called when the job is scheduled to run */
    onRun: ScheduledJobHandler;
};

/**
 * The Scheduler client lets you schedule new jobs or cancel existing jobs.
 * You must have the `scheduler` enabled in `Devvit.configure` to use this client.
 */
export declare type Scheduler = {
    /**
     * Schedule a new job to run at a specific time or on a cron schedule
     * @param job The job to schedule
     * @returns {} The id of the scheduled job
     */
    runJob: RunJob;
    /**
     * Cancel a scheduled job
     * @param jobId The id of the job to cancel
     */
    cancelJob: CancelJob;
    /**
     * Gets the list of all scheduled jobs.
     */
    listJobs: () => Promise<(ScheduledJob | ScheduledCronJob)[]>;
};

/**
 * Provides an API for Actors to execute an action sometime in the future.
 *
 * Actors will need to implement the SchedulerHandler interface which the Scheduler will call with
 * the provided ScheduledAction as an argument.
 *
 * The Scheduler will fail with an error if the time provided is in the past.
 */
declare interface Scheduler_2 {
    /** This schedules an action */
    Schedule(request: ScheduledActionRequest, metadata?: Metadata): Promise<ScheduledActionResponse>;
    /** This cancels any scheduled action */
    Cancel(request: CancelActionRequest, metadata?: Metadata): Promise<Empty>;
    /** This lists all scheduled actions for this installation. */
    List(request: ListActionRequest, metadata?: Metadata): Promise<ListActionResponse>;
}

declare class SchedulerClientImpl implements Scheduler_2 {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_14, opts?: {
        service?: string;
    });
    Schedule(request: ScheduledActionRequest, metadata?: Metadata): Promise<ScheduledActionResponse>;
    Cancel(request: CancelActionRequest, metadata?: Metadata): Promise<Empty>;
    List(request: ListActionRequest, metadata?: Metadata): Promise<ListActionResponse>;
}

/**
 * Provides an API for Actors to execute an action sometime in the future.
 *
 * Actors will need to implement the SchedulerHandler interface which the Scheduler will call with
 * the provided ScheduledAction as an argument.
 *
 * The Scheduler will fail with an error if the time provided is in the past.
 */
declare type SchedulerDefinition = typeof SchedulerDefinition;

declare const SchedulerDefinition: {
    readonly name: "Scheduler";
    readonly fullName: "devvit.plugin.scheduler.Scheduler";
    readonly methods: {
        /** This schedules an action */
        readonly schedule: {
            readonly name: "Schedule";
            readonly requestType: {
                $type: "devvit.plugin.scheduler.ScheduledActionRequest";
                encode(message: ScheduledActionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ScheduledActionRequest;
                fromJSON(object: any): ScheduledActionRequest;
                toJSON(message: ScheduledActionRequest): unknown;
                create(base?: DeepPartial_89<ScheduledActionRequest>): ScheduledActionRequest;
                fromPartial(object: DeepPartial_89<ScheduledActionRequest>): ScheduledActionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.scheduler.ScheduledActionResponse";
                encode(message: ScheduledActionResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ScheduledActionResponse;
                fromJSON(object: any): ScheduledActionResponse;
                toJSON(message: ScheduledActionResponse): unknown;
                create(base?: DeepPartial_89<ScheduledActionResponse>): ScheduledActionResponse;
                fromPartial(object: DeepPartial_89<ScheduledActionResponse>): ScheduledActionResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** This cancels any scheduled action */
        readonly cancel: {
            readonly name: "Cancel";
            readonly requestType: {
                $type: "devvit.plugin.scheduler.CancelActionRequest";
                encode(message: CancelActionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): CancelActionRequest;
                fromJSON(object: any): CancelActionRequest;
                toJSON(message: CancelActionRequest): unknown;
                create(base?: DeepPartial_89<CancelActionRequest>): CancelActionRequest;
                fromPartial(object: DeepPartial_89<CancelActionRequest>): CancelActionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** This lists all scheduled actions for this installation. */
        readonly list: {
            readonly name: "List";
            readonly requestType: {
                $type: "devvit.plugin.scheduler.ListActionRequest";
                encode(message: ListActionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ListActionRequest;
                fromJSON(object: any): ListActionRequest;
                toJSON(message: ListActionRequest): unknown;
                create(base?: DeepPartial_89<ListActionRequest>): ListActionRequest;
                fromPartial(object: DeepPartial_89<ListActionRequest>): ListActionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.scheduler.ListActionResponse";
                encode(message: ListActionResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ListActionResponse;
                fromJSON(object: any): ListActionResponse;
                toJSON(message: ListActionResponse): unknown;
                create(base?: DeepPartial_89<ListActionResponse>): ListActionResponse;
                fromPartial(object: DeepPartial_89<ListActionResponse>): ListActionResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

/**
 * Actors must implement this interface to use the Scheduler.
 * HandleScheduledAction will be called by the Scheduler at the specified time.
 */
declare interface SchedulerHandler {
    HandleScheduledAction(request: ScheduledAction, metadata?: Metadata): Promise<Empty>;
}

declare class SchedulerHandlerClientImpl implements SchedulerHandler {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_36, opts?: {
        service?: string;
    });
    HandleScheduledAction(request: ScheduledAction, metadata?: Metadata): Promise<Empty>;
}

/**
 * Actors must implement this interface to use the Scheduler.
 * HandleScheduledAction will be called by the Scheduler at the specified time.
 */
declare type SchedulerHandlerDefinition = typeof SchedulerHandlerDefinition;

declare const SchedulerHandlerDefinition: {
    readonly name: "SchedulerHandler";
    readonly fullName: "devvit.actor.scheduler.SchedulerHandler";
    readonly methods: {
        readonly handleScheduledAction: {
            readonly name: "HandleScheduledAction";
            readonly requestType: {
                $type: "devvit.actor.scheduler.ScheduledAction";
                encode(message: ScheduledAction, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ScheduledAction;
                fromJSON(object: any): ScheduledAction;
                toJSON(message: ScheduledAction): unknown;
                create(base?: {
                    type?: string;
                    data?: {
                        [x: string]: any;
                    } | undefined;
                } | undefined): ScheduledAction;
                fromPartial(object: {
                    type?: string;
                    data?: {
                        [x: string]: any;
                    } | undefined;
                }): ScheduledAction;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const SchedulerHandlerServiceName = "devvit.actor.scheduler.SchedulerHandler";

declare const SchedulerServiceName = "devvit.plugin.scheduler.Scheduler";

/** responses */
declare interface SearchRedditNamesResponse {
    names: string[];
}

declare const SearchRedditNamesResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SearchRedditNamesResponse";
    encode(message: SearchRedditNamesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SearchRedditNamesResponse;
    fromJSON(object: any): SearchRedditNamesResponse;
    toJSON(message: SearchRedditNamesResponse): unknown;
    create(base?: DeepPartial_11<SearchRedditNamesResponse>): SearchRedditNamesResponse;
    fromPartial(object: DeepPartial_11<SearchRedditNamesResponse>): SearchRedditNamesResponse;
};

declare interface SearchSubredditsResponse {
    subreddits: SearchSubredditsResponse_SubredditData[];
}

declare const SearchSubredditsResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SearchSubredditsResponse";
    encode(message: SearchSubredditsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SearchSubredditsResponse;
    fromJSON(object: any): SearchSubredditsResponse;
    toJSON(message: SearchSubredditsResponse): unknown;
    create(base?: DeepPartial_11<SearchSubredditsResponse>): SearchSubredditsResponse;
    fromPartial(object: DeepPartial_11<SearchSubredditsResponse>): SearchSubredditsResponse;
};

declare interface SearchSubredditsResponse_SubredditData {
    activeUserCount?: number | undefined;
    iconImg?: string | undefined;
    keyColor?: string | undefined;
    name?: string | undefined;
    subscriberCount?: number | undefined;
    isChatPostFeatureEnabled?: boolean | undefined;
    allowChatPostCreation?: boolean | undefined;
    allowImages?: boolean | undefined;
}

declare const SearchSubredditsResponse_SubredditData: {
    $type: "devvit.plugin.redditapi.subreddits.SearchSubredditsResponse.SubredditData";
    encode(message: SearchSubredditsResponse_SubredditData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SearchSubredditsResponse_SubredditData;
    fromJSON(object: any): SearchSubredditsResponse_SubredditData;
    toJSON(message: SearchSubredditsResponse_SubredditData): unknown;
    create(base?: DeepPartial_11<SearchSubredditsResponse_SubredditData>): SearchSubredditsResponse_SubredditData;
    fromPartial(object: DeepPartial_11<SearchSubredditsResponse_SubredditData>): SearchSubredditsResponse_SubredditData;
};

export declare type SecureMedia = {
    /** The type of the OEmbed media, if present (e.g. "youtube.com") */
    type?: string;
    oembed?: OEmbed;
    redditVideo?: RedditVideo;
};

/** A dropdown field that allows users to pick from a list of options */
export declare type SelectField = Prettify<BaseField<string[]> & Omit<FieldConfig_Selection, 'choices' | 'renderAsList' | 'minSelections' | 'maxSelections'> & {
    type: 'select';
    options: FieldConfig_Selection_Item[];
}>;

declare interface SelectFlairRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** a 6-digit rgb hex color, e.g. #AABBCC */
    backgroundColor: string;
    /** a valid subreddit image name */
    cssClass: string;
    /** no-op */
    flairTemplateId: string;
    /** the thing id of a link e.g. t3_15bfi0 */
    link: string;
    /** a user by name */
    name: string;
    /** "all" saves attributes and returns rtjson; "only" only returns rtjson; "none" only saves attributes e.g. [all|only|none] */
    returnRtjson: string;
    /** a string no longer than 64 characters */
    text: string;
    /** one of (light, dark) */
    textColor: string;
}

declare const SelectFlairRequest: {
    $type: "devvit.plugin.redditapi.flair.SelectFlairRequest";
    encode(message: SelectFlairRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SelectFlairRequest;
    fromJSON(object: any): SelectFlairRequest;
    toJSON(message: SelectFlairRequest): unknown;
    create(base?: DeepPartial_56<SelectFlairRequest>): SelectFlairRequest;
    fromPartial(object: DeepPartial_56<SelectFlairRequest>): SelectFlairRequest;
};

declare enum Selector {
    /** @deprecated */
    DEFAULT = 0,
    /** @deprecated */
    TARGET_USER = 1,
    /**
     * MOD_ACTION_TYPE - TODO(logan.hanks): Replace this with a field path string
     *
     * @deprecated
     */
    MOD_ACTION_TYPE = 2,
    UNRECOGNIZED = -1
}

declare function selectorFromJSON(object: any): Selector;

declare function selectorToJSON(object: Selector): number;

export declare type SendPrivateMessageAsSubredditOptions = SendPrivateMessageOptions & {
    /** The name of the subreddit the message is being sent from (without the leading r/) */
    fromSubredditName: string;
};

export declare type SendPrivateMessageOptions = {
    /** Recipient username (without the leading u/), or /r/name for that subreddit's moderators. */
    to: string;
    /** The subject of the message. */
    subject: string;
    /** The body of the message in markdown text format. */
    text: string;
};

declare interface SendRepliesRequest {
    /**
     * Post or Comment thing ID
     * @example "t1_abc123"
     */
    id: string;
    /** Boolean to enable reply notifications */
    state: boolean;
}

declare const SendRepliesRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.SendRepliesRequest";
    encode(message: SendRepliesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SendRepliesRequest;
    fromJSON(object: any): SendRepliesRequest;
    toJSON(message: SendRepliesRequest): unknown;
    create(base?: DeepPartial_64<SendRepliesRequest>): SendRepliesRequest;
    fromPartial(object: DeepPartial_64<SendRepliesRequest>): SendRepliesRequest;
};

/** A MethodDefinition subset representable as JSON. */
declare interface SerializableMethodDefinition {
    /** Leading slash. Eg, "/devvit.plugin.logger.Logger/Log". */
    fullName: string;
    /** Eg, "Log". */
    name: string;
    requestStream: boolean;
    responseStream: boolean;
    requestType: string;
    responseType: string;
}

declare const SerializableMethodDefinition: {
    $type: "devvit.runtime.SerializableMethodDefinition";
    encode(message: SerializableMethodDefinition, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SerializableMethodDefinition;
    fromJSON(object: any): SerializableMethodDefinition;
    toJSON(message: SerializableMethodDefinition): unknown;
    create(base?: DeepPartial_12<SerializableMethodDefinition>): SerializableMethodDefinition;
    fromPartial(object: DeepPartial_12<SerializableMethodDefinition>): SerializableMethodDefinition;
};

/** A Definition subset representable as JSON. */
declare interface SerializableServiceDefinition {
    /** No slashes. Eg, "devvit.plugin.logger.Logger". */
    fullName: string;
    methods: SerializableMethodDefinition[];
    /** Eg, "Logger". */
    name: string;
    version: string;
}

declare const SerializableServiceDefinition: {
    $type: "devvit.runtime.SerializableServiceDefinition";
    encode(message: SerializableServiceDefinition, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SerializableServiceDefinition;
    fromJSON(object: any): SerializableServiceDefinition;
    toJSON(message: SerializableServiceDefinition): unknown;
    create(base?: DeepPartial_12<SerializableServiceDefinition>): SerializableServiceDefinition;
    fromPartial(object: DeepPartial_12<SerializableServiceDefinition>): SerializableServiceDefinition;
};

/** Describes a service. */
declare interface ServiceDescriptorProto {
    name?: string | undefined;
    method: MethodDescriptorProto[];
    options?: ServiceOptions | undefined;
}

declare const ServiceDescriptorProto: {
    $type: "google.protobuf.ServiceDescriptorProto";
    encode(message: ServiceDescriptorProto, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ServiceDescriptorProto;
    fromJSON(object: any): ServiceDescriptorProto;
    toJSON(message: ServiceDescriptorProto): unknown;
    create(base?: DeepPartial_104<ServiceDescriptorProto>): ServiceDescriptorProto;
    fromPartial(object: DeepPartial_104<ServiceDescriptorProto>): ServiceDescriptorProto;
};

declare interface ServiceOptions {
    /** Any features defined in the specific edition. */
    features?: FeatureSet | undefined;
    /**
     * Is this service deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the service, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating services.
     */
    deprecated?: boolean | undefined;
    /** The parser stores options it doesn't recognize here. See above. */
    uninterpretedOption: UninterpretedOption[];
}

declare const ServiceOptions: {
    $type: "google.protobuf.ServiceOptions";
    encode(message: ServiceOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ServiceOptions;
    fromJSON(object: any): ServiceOptions;
    toJSON(message: ServiceOptions): unknown;
    create(base?: DeepPartial_104<ServiceOptions>): ServiceOptions;
    fromPartial(object: DeepPartial_104<ServiceOptions>): ServiceOptions;
};

declare interface SetContestModeRequest {
    /**
     * Post thing ID
     * @example "t3_abc123"
     */
    id: string;
    /** Boolean to enable Contest Mode */
    state: boolean;
}

declare const SetContestModeRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.SetContestModeRequest";
    encode(message: SetContestModeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SetContestModeRequest;
    fromJSON(object: any): SetContestModeRequest;
    toJSON(message: SetContestModeRequest): unknown;
    create(base?: DeepPartial_64<SetContestModeRequest>): SetContestModeRequest;
    fromPartial(object: DeepPartial_64<SetContestModeRequest>): SetContestModeRequest;
};

declare interface SetFlairEnabledRequest {
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    /** is flair enabled? e.g. true/false */
    flairEnabled: boolean;
}

declare const SetFlairEnabledRequest: {
    $type: "devvit.plugin.redditapi.flair.SetFlairEnabledRequest";
    encode(message: SetFlairEnabledRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SetFlairEnabledRequest;
    fromJSON(object: any): SetFlairEnabledRequest;
    toJSON(message: SetFlairEnabledRequest): unknown;
    create(base?: DeepPartial_56<SetFlairEnabledRequest>): SetFlairEnabledRequest;
    fromPartial(object: DeepPartial_56<SetFlairEnabledRequest>): SetFlairEnabledRequest;
};

export declare type SetFlairOptions = {
    /** The name of the subreddit of the item to set the flair on */
    subredditName: string;
    /** The flair template's ID */
    flairTemplateId?: string;
    /** The flair text */
    text?: string;
    /** The flair CSS class */
    cssClass?: string;
    /** The flair text color. Either 'dark' or 'light'. */
    textColor?: FlairTextColor;
    /** The flair background color. Either 'transparent' or a hex color code. e.g. #FFC0CB */
    backgroundColor?: string;
};

/**
 * This is the list of active timers.  We could choose to have an effect per timer, but
 * following realtime's lead, we send the whole list.
 *
 * This implies that if the timer disappears from the map, you should cancel it.
 */
declare interface SetIntervalsEffect {
    /** hook_id => interval map */
    intervals: {
        [key: string]: IntervalDetails;
    };
}

declare const SetIntervalsEffect: {
    $type: "devvit.ui.effects.v1alpha.SetIntervalsEffect";
    encode(message: SetIntervalsEffect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SetIntervalsEffect;
    fromJSON(object: any): SetIntervalsEffect;
    toJSON(message: SetIntervalsEffect): unknown;
    create(base?: DeepPartial_39<SetIntervalsEffect>): SetIntervalsEffect;
    fromPartial(object: DeepPartial_39<SetIntervalsEffect>): SetIntervalsEffect;
};

declare interface SetIntervalsEffect_IntervalsEntry {
    key: string;
    value?: IntervalDetails | undefined;
}

declare const SetIntervalsEffect_IntervalsEntry: {
    $type: "devvit.ui.effects.v1alpha.SetIntervalsEffect.IntervalsEntry";
    encode(message: SetIntervalsEffect_IntervalsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SetIntervalsEffect_IntervalsEntry;
    fromJSON(object: any): SetIntervalsEffect_IntervalsEntry;
    toJSON(message: SetIntervalsEffect_IntervalsEntry): unknown;
    create(base?: DeepPartial_39<SetIntervalsEffect_IntervalsEntry>): SetIntervalsEffect_IntervalsEntry;
    fromPartial(object: DeepPartial_39<SetIntervalsEffect_IntervalsEntry>): SetIntervalsEffect_IntervalsEntry;
};

export declare type SetOptions = {
    /** Only set the key if it does not already exist. */
    nx?: boolean;
    /** Only set the key if it already exists. */
    xx?: boolean;
    expiration?: Date;
};

declare interface SetPermissionsRequest {
    /** the name of an existing user */
    name: string;
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit: string;
    permissions: string;
    type: string;
}

declare const SetPermissionsRequest: {
    $type: "devvit.plugin.redditapi.users.SetPermissionsRequest";
    encode(message: SetPermissionsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SetPermissionsRequest;
    fromJSON(object: any): SetPermissionsRequest;
    toJSON(message: SetPermissionsRequest): unknown;
    create(base?: DeepPartial_100<SetPermissionsRequest>): SetPermissionsRequest;
    fromPartial(object: DeepPartial_100<SetPermissionsRequest>): SetPermissionsRequest;
};

export declare type SetPostFlairOptions = SetFlairOptions & {
    /** The ID of the post to set the flair on */
    postId: string;
};

declare interface SetRangeRequest {
    key: string;
    offset: number;
    value: string;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const SetRangeRequest: {
    $type: "devvit.plugin.redis.SetRangeRequest";
    encode(message: SetRangeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SetRangeRequest;
    fromJSON(object: any): SetRangeRequest;
    toJSON(message: SetRangeRequest): unknown;
    create(base?: DeepPartial_86<SetRangeRequest>): SetRangeRequest;
    fromPartial(object: DeepPartial_86<SetRangeRequest>): SetRangeRequest;
};

declare interface SetRequest {
    key: string;
    value: string;
    /** Expiration time in seconds */
    expiration: number;
    /** Set only if key does not exist */
    nx: boolean;
    /** Set only if key already exists */
    xx: boolean;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const SetRequest: {
    $type: "devvit.plugin.redis.SetRequest";
    encode(message: SetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SetRequest;
    fromJSON(object: any): SetRequest;
    toJSON(message: SetRequest): unknown;
    create(base?: DeepPartial_86<SetRequest>): SetRequest;
    fromPartial(object: DeepPartial_86<SetRequest>): SetRequest;
};

export declare type SetStateAction<S> = S | ((prevState: S) => S);

declare interface SetSubredditStickyRequest {
    /**
     * Post thing ID
     * @example "t3_abc123"
     */
    id: string;
    /**
     * Which sticky "slot" this Post should take
     * If the slot is empty or `num` is not set the bottom-most slot will be used
     * Valid range for subreddits: 1 - 2
     * Valid range for user profiles: 1 - 4
     */
    num?: number | undefined;
    /** Boolean to set the Post as sticky/pinned */
    state: boolean;
    /**
     * If the Post is owned by the current user set to `true` to pin
     * it to their profile instead of the subreddit it was posted in
     */
    toProfile?: boolean | undefined;
}

declare const SetSubredditStickyRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.SetSubredditStickyRequest";
    encode(message: SetSubredditStickyRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SetSubredditStickyRequest;
    fromJSON(object: any): SetSubredditStickyRequest;
    toJSON(message: SetSubredditStickyRequest): unknown;
    create(base?: DeepPartial_64<SetSubredditStickyRequest>): SetSubredditStickyRequest;
    fromPartial(object: DeepPartial_64<SetSubredditStickyRequest>): SetSubredditStickyRequest;
};

declare interface SetSuggestedSortRequest {
    /**
     * Post thing ID
     * @example "t3_abc123"
     */
    id: string;
    /**
     * One of: "confidence", "top", "new", "controversial", "old", "random", "qa", "live", ""
     * Note: If left blank the suggested sort order is cleared
     */
    sort: string;
}

declare const SetSuggestedSortRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.SetSuggestedSortRequest";
    encode(message: SetSuggestedSortRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SetSuggestedSortRequest;
    fromJSON(object: any): SetSuggestedSortRequest;
    toJSON(message: SetSuggestedSortRequest): unknown;
    create(base?: DeepPartial_64<SetSuggestedSortRequest>): SetSuggestedSortRequest;
    fromPartial(object: DeepPartial_64<SetSuggestedSortRequest>): SetSuggestedSortRequest;
};

declare interface Settings {
    /** Returns the installation and instance settings */
    GetSettings(request: SettingsRequest, metadata?: Metadata): Promise<SettingsResponse>;
}

/**
 * The Settings API Client lets you retrieve the settings values for your app set by the installer.
 * Use this in conjunction with `Devvit.addSettings`.
 */
export declare type SettingsClient = {
    /**
     * Get a single setting value by name.
     * @param name The name of the setting to retrieve.
     * @returns A promise that resolves to the setting value, or undefined if the setting doesn't exist.
     */
    get<T = string | string[] | boolean | number>(name: string): Promise<T | undefined>;
    /**
     * Get all settings values.
     * @returns A promise that resolves to an object containing all settings values.
     */
    getAll<T extends object = SettingsValues>(): Promise<T>;
};

declare interface SettingsClient_2 {
    GetSettings(request: SettingsRequest): Promise<SettingsResponse>;
}

declare class SettingsClientImpl implements Settings {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_47, opts?: {
        service?: string;
    });
    GetSettings(request: SettingsRequest, metadata?: Metadata): Promise<SettingsResponse>;
}

declare class SettingsClientJSON implements SettingsClient_2 {
    private readonly rpc;
    constructor(rpc: Rpc_46);
    GetSettings(request: SettingsRequest): Promise<SettingsResponse>;
}

declare class SettingsClientProtobuf implements SettingsClient_2 {
    private readonly rpc;
    constructor(rpc: Rpc_46);
    GetSettings(request: SettingsRequest): Promise<SettingsResponse>;
}

export declare enum SettingScope {
    Installation = "installation",
    App = "app"
}

export declare type SettingScopeType = 'installation' | 'app';

declare type SettingsDefinition = typeof SettingsDefinition;

declare const SettingsDefinition: {
    readonly name: "Settings";
    readonly fullName: "devvit.plugin.settings.v1alpha.Settings";
    readonly methods: {
        /** Returns the installation and instance settings */
        readonly getSettings: {
            readonly name: "GetSettings";
            readonly requestType: {
                $type: "devvit.plugin.settings.v1alpha.SettingsRequest";
                encode(_: SettingsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): SettingsRequest;
                fromJSON(_: any): SettingsRequest;
                toJSON(_: SettingsRequest): unknown;
                create(base?: DeepPartial_90<SettingsRequest>): SettingsRequest;
                fromPartial(_: DeepPartial_90<SettingsRequest>): SettingsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.settings.v1alpha.SettingsResponse";
                encode(message: SettingsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): SettingsResponse;
                fromJSON(object: any): SettingsResponse;
                toJSON(message: SettingsResponse): unknown;
                create(base?: DeepPartial_90<SettingsResponse>): SettingsResponse;
                fromPartial(object: DeepPartial_90<SettingsResponse>): SettingsResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

export declare type SettingsFormField = ValidatedStringField | ValidatedParagraphField | ValidatedNumberField | ValidatedBooleanField | ValidatedSelectField | SettingsFormFieldGroup;

export declare type SettingsFormFieldGroup = Prettify<Omit<FormFieldGroup, 'fields'> & {
    fields: SettingsFormField[];
}>;

export declare type SettingsFormFieldValidatorEvent<ValueType> = {
    value: ValueType | undefined;
    isEditing: boolean;
};

declare interface SettingsRequest {
}

declare const SettingsRequest: {
    $type: "devvit.plugin.settings.v1alpha.SettingsRequest";
    encode(_: SettingsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SettingsRequest;
    fromJSON(_: any): SettingsRequest;
    toJSON(_: SettingsRequest): unknown;
    create(base?: DeepPartial_90<SettingsRequest>): SettingsRequest;
    fromPartial(_: DeepPartial_90<SettingsRequest>): SettingsRequest;
};

declare interface SettingsResponse {
    /** Defined via InstallationSettings interface; the values of the settings */
    installationSettings?: SettingsValues_2 | undefined;
    /** Defined via InstanceSettings interface; the values of the settings */
    instanceSettings?: SettingsValues_2 | undefined;
    /** Defined via AppSettings interface; the values of the settings */
    appSettings?: SettingsValues_2 | undefined;
}

declare const SettingsResponse: {
    $type: "devvit.plugin.settings.v1alpha.SettingsResponse";
    encode(message: SettingsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SettingsResponse;
    fromJSON(object: any): SettingsResponse;
    toJSON(message: SettingsResponse): unknown;
    create(base?: DeepPartial_90<SettingsResponse>): SettingsResponse;
    fromPartial(object: DeepPartial_90<SettingsResponse>): SettingsResponse;
};

declare const SettingsServiceName = "devvit.plugin.settings.v1alpha.Settings";

export declare type SettingsValues = {
    [key: string]: string | string[] | boolean | number | undefined;
};

declare interface SettingsValues_2 {
    /** a unique identifier for this version of the settings */
    version: string;
    /** A map of the settings values, field_id:value */
    settings: {
        [key: string]: FormFieldValue;
    };
    /** timestamp of when settings were modified */
    timestamp?: Date | undefined;
}

declare const SettingsValues_2: {
    $type: "devvit.plugin.settings.v1alpha.SettingsValues";
    encode(message: SettingsValues_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SettingsValues_2;
    fromJSON(object: any): SettingsValues_2;
    toJSON(message: SettingsValues_2): unknown;
    create(base?: DeepPartial_90<SettingsValues_2>): SettingsValues_2;
    fromPartial(object: DeepPartial_90<SettingsValues_2>): SettingsValues_2;
};

declare interface SettingsValues_SettingsEntry {
    key: string;
    value?: FormFieldValue | undefined;
}

declare const SettingsValues_SettingsEntry: {
    $type: "devvit.plugin.settings.v1alpha.SettingsValues.SettingsEntry";
    encode(message: SettingsValues_SettingsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SettingsValues_SettingsEntry;
    fromJSON(object: any): SettingsValues_SettingsEntry;
    toJSON(message: SettingsValues_SettingsEntry): unknown;
    create(base?: DeepPartial_90<SettingsValues_SettingsEntry>): SettingsValues_SettingsEntry;
    fromPartial(object: DeepPartial_90<SettingsValues_SettingsEntry>): SettingsValues_SettingsEntry;
};

export declare type SetUserFlairOptions = SetFlairOptions & {
    /** The username of the user to set the flair on */
    username: string;
};

declare enum Severity {
    /**
     * DEBUG - Debug logs should never be committed.
     *
     * These logs are always enabled in development builds but disabled in
     * production.
     */
    DEBUG = 0,
    /**
     * INFO - Informational logs should be used to mark significant non-erroneous events.
     * Little information is significant.
     *
     * These logs are enabled by default in development builds but may be
     * disabled in production.
     */
    INFO = 1,
    /**
     * WARN - Warnings should be reported as long as they do not contain sensitive data.
     *
     * These logs are always enabled.
     */
    WARN = 2,
    /**
     * ERROR - Errors should always be reported as long as they do not contain sensitive
     * data.
     */
    ERROR = 3,
    /**
     * VERBOSE - Verbose logs are useful for tracing but usually a hindrance for others not
     * working where the log is placed. Keep our logs clean and add with care.
     *
     * These logs are disabled by default in all environments but can be enabled.
     */
    VERBOSE = 4,
    UNRECOGNIZED = -1
}

declare function severityFromJSON(object: any): Severity;

declare function severityToJSON(object: Severity): number;

/** Display a user input form */
declare interface ShowFormEffect {
    form?: Form_2 | undefined;
}

declare const ShowFormEffect: {
    $type: "devvit.ui.effects.v1alpha.ShowFormEffect";
    encode(message: ShowFormEffect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ShowFormEffect;
    fromJSON(object: any): ShowFormEffect;
    toJSON(message: ShowFormEffect): unknown;
    create(base?: DeepPartial_34<ShowFormEffect>): ShowFormEffect;
    fromPartial(object: DeepPartial_34<ShowFormEffect>): ShowFormEffect;
};

/** Display a popup toast */
declare interface ShowToastEffect {
    toast?: Toast_2 | undefined;
}

declare const ShowToastEffect: {
    $type: "devvit.ui.effects.v1alpha.ShowToastEffect";
    encode(message: ShowToastEffect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ShowToastEffect;
    fromJSON(object: any): ShowToastEffect;
    toJSON(message: ShowToastEffect): unknown;
    create(base?: DeepPartial_36<ShowToastEffect>): ShowToastEffect;
    fromPartial(object: DeepPartial_36<ShowToastEffect>): ShowToastEffect;
};

declare interface SiteAdminRequest {
    /** boolean value */
    acceptFollowers: boolean;
    /** boolean value */
    adminOverrideSpamComments: boolean;
    /** boolean value */
    adminOverrideSpamLinks: boolean;
    /** boolean value */
    adminOverrideSpamSelfposts: boolean;
    /** boolean value */
    allOriginalContent: boolean;
    /** boolean value */
    allowChatPostCreation: boolean;
    /** boolean value */
    allowDiscovery: boolean;
    /** boolean value */
    allowGalleries: boolean;
    /** boolean value */
    allowImages: boolean;
    /** boolean value */
    allowPolls: boolean;
    /** boolean value */
    allowPostCrossposts: boolean;
    /** boolean value */
    allowPredictionContributors: boolean;
    /** boolean value */
    allowPredictions: boolean;
    /** boolean value */
    allowPredictionsTournament: boolean;
    /** boolean value */
    allowTalks: boolean;
    /** boolean value */
    allowTop: boolean;
    /** boolean value */
    allowVideos: boolean;
    /** an integer between 0 and 3 */
    banEvasionThreshold: number;
    /** boolean value */
    collapseDeletedComments: boolean;
    /**
     * json data:
     * \{
     *   "allowed_media_types": [
     *     one of (`giphy`, `unknown`, `animated`, `static`),
     *     ...
     *   ],
     * \}
     */
    commentContributionSettings?: CommentContributionSettings | undefined;
    /** an integer between 0 and 1440 (default: 0) */
    commentScoreHideMins: number;
    /** boolean value */
    crowdControlFilter: boolean;
    /** an integer between 0 and 3 */
    crowdControlLevel: number;
    /** boolean value */
    crowdControlMode: boolean;
    /** an integer between 0 and 3 */
    crowdControlPostLevel: number;
    /** raw markdown text */
    description: string;
    /** boolean value */
    disableContributorRequests: boolean;
    /** boolean value */
    excludeBannedModqueue: boolean;
    /** boolean value */
    freeFormReports: boolean;
    gRecaptchaResponse: string;
    /** an integer between 0 and 3 */
    hatefulContentThresholdAbuse: number;
    /** an integer between 0 and 3 */
    hatefulContentThresholdIdentity: number;
    /** a string no longer than 500 characters */
    headerTitle: string;
    /** a 6-digit rgb hex color, e.g. #AABBCC */
    keyColor: string;
    /** one of (any, link, self) */
    linkType: string;
    /** subreddit name */
    name: string;
    /** boolean value */
    newPinnedPostPnsEnabled: boolean;
    /** boolean value */
    originalContentTagEnabled: boolean;
    /** boolean value */
    over18: boolean;
    /** an integer between 0 and 2 */
    predictionLeaderboardEntryType: number;
    /** raw markdown text */
    publicDescription: string;
    /** boolean value */
    restrictCommenting: boolean;
    /** boolean value */
    restrictPosting: boolean;
    /** boolean value */
    shouldArchivePosts: boolean;
    /** boolean value */
    showMedia: boolean;
    /** boolean value */
    showMediaPreview: boolean;
    /** one of (low, high, all) */
    spamComments: string;
    /** one of (low, high, all) */
    spamLinks: string;
    /** one of (low, high, all) */
    spamSelfposts: string;
    /** boolean value */
    spoilersEnabled: boolean;
    /** fullname of a thing */
    sr: string;
    /** a string no longer than 60 characters */
    submitLinkLabel: string;
    /** raw markdown text */
    submitText: string;
    /** a string no longer than 60 characters */
    submitTextLabel: string;
    /** one of (confidence, top, new, controversial, old, random, qa, live) */
    suggestedCommentSort: string;
    /** a string no longer than 100 characters */
    title: string;
    /** an integer between 0 and 1 */
    toxicityThresholdChatLevel: number;
    /** one of (gold_restricted, archived, restricted, private, employees_only, gold_only, public, user) */
    type: string;
    /** boolean value */
    userFlairPnsEnabled: boolean;
    /** boolean value */
    welcomeMessageEnabled: boolean;
    /** raw markdown text */
    welcomeMessageText: string;
    /** an integer between 0 and 36600 (default: 0) */
    wikiEditAge: number;
    /** an integer between 0 and 1000000000 (default: 0) */
    wikiEditKarma: number;
    /** one of (disabled, modonly, anyone) */
    wikimode: string;
    /** an integer between 0 and 3 */
    crowdControlChatLevel: number;
    /** boolean value */
    hideAds: boolean;
    /** boolean value */
    modmailHarassmentFilterEnabled: boolean;
}

declare const SiteAdminRequest: {
    $type: "devvit.plugin.redditapi.subreddits.SiteAdminRequest";
    encode(message: SiteAdminRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SiteAdminRequest;
    fromJSON(object: any): SiteAdminRequest;
    toJSON(message: SiteAdminRequest): unknown;
    create(base?: DeepPartial_11<SiteAdminRequest>): SiteAdminRequest;
    fromPartial(object: DeepPartial_11<SiteAdminRequest>): SiteAdminRequest;
};

declare interface SnoozeReportsRequest {
    /** thing id (e.g t1_15bfi0) */
    id: string;
    /** report reason */
    reason: string;
}

declare const SnoozeReportsRequest: {
    $type: "devvit.plugin.redditapi.moderation.SnoozeReportsRequest";
    encode(message: SnoozeReportsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SnoozeReportsRequest;
    fromJSON(object: any): SnoozeReportsRequest;
    toJSON(message: SnoozeReportsRequest): unknown;
    create(base?: DeepPartial_2<SnoozeReportsRequest>): SnoozeReportsRequest;
    fromPartial(object: DeepPartial_2<SnoozeReportsRequest>): SnoozeReportsRequest;
};

/**
 * Encapsulates information about the original source file from which a
 * FileDescriptorProto was generated.
 */
declare interface SourceCodeInfo {
    /**
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     *
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     *
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     */
    location: SourceCodeInfo_Location[];
}

declare const SourceCodeInfo: {
    $type: "google.protobuf.SourceCodeInfo";
    encode(message: SourceCodeInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SourceCodeInfo;
    fromJSON(object: any): SourceCodeInfo;
    toJSON(message: SourceCodeInfo): unknown;
    create(base?: DeepPartial_104<SourceCodeInfo>): SourceCodeInfo;
    fromPartial(object: DeepPartial_104<SourceCodeInfo>): SourceCodeInfo;
};

declare interface SourceCodeInfo_Location {
    /**
     * Identifies which part of the FileDescriptorProto was defined at this
     * location.
     *
     * Each element is a field number or an index.  They form a path from
     * the root FileDescriptorProto to the place where the definition appears.
     * For example, this path:
     *   [ 4, 3, 2, 7, 1 ]
     * refers to:
     *   file.message_type(3)  // 4, 3
     *       .field(7)         // 2, 7
     *       .name()           // 1
     * This is because FileDescriptorProto.message_type has field number 4:
     *   repeated DescriptorProto message_type = 4;
     * and DescriptorProto.field has field number 2:
     *   repeated FieldDescriptorProto field = 2;
     * and FieldDescriptorProto.name has field number 1:
     *   optional string name = 1;
     *
     * Thus, the above path gives the location of a field name.  If we removed
     * the last element:
     *   [ 4, 3, 2, 7 ]
     * this path refers to the whole field declaration (from the beginning
     * of the label to the terminating semicolon).
     */
    path: number[];
    /**
     * Always has exactly three or four elements: start line, start column,
     * end line (optional, otherwise assumed same as start line), end column.
     * These are packed into a single field for efficiency.  Note that line
     * and column numbers are zero-based -- typically you will want to add
     * 1 to each before displaying to a user.
     */
    span: number[];
    /**
     * If this SourceCodeInfo represents a complete declaration, these are any
     * comments appearing before and after the declaration which appear to be
     * attached to the declaration.
     *
     * A series of line comments appearing on consecutive lines, with no other
     * tokens appearing on those lines, will be treated as a single comment.
     *
     * leading_detached_comments will keep paragraphs of comments that appear
     * before (but not connected to) the current element. Each paragraph,
     * separated by empty lines, will be one comment element in the repeated
     * field.
     *
     * Only the comment content is provided; comment markers (e.g. //) are
     * stripped out.  For block comments, leading whitespace and an asterisk
     * will be stripped from the beginning of each line other than the first.
     * Newlines are included in the output.
     *
     * Examples:
     *
     *   optional int32 foo = 1;  // Comment attached to foo.
     *   // Comment attached to bar.
     *   optional int32 bar = 2;
     *
     *   optional string baz = 3;
     *   // Comment attached to baz.
     *   // Another line attached to baz.
     *
     *   // Comment attached to moo.
     *   //
     *   // Another line attached to moo.
     *   optional double moo = 4;
     *
     *   // Detached comment for corge. This is not leading or trailing comments
     *   // to moo or corge because there are blank lines separating it from
     *   // both.
     *
     *   // Detached comment for corge paragraph 2.
     *
     *   optional string corge = 5;
     *   /* Block comment attached
     *    * to corge.  Leading asterisks
     *    * will be removed. * /
     *   /* Block comment attached to
     *    * grault. * /
     *   optional int32 grault = 6;
     *
     *   // ignored detached comments.
     */
    leadingComments?: string | undefined;
    trailingComments?: string | undefined;
    leadingDetachedComments: string[];
}

declare const SourceCodeInfo_Location: {
    $type: "google.protobuf.SourceCodeInfo.Location";
    encode(message: SourceCodeInfo_Location, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SourceCodeInfo_Location;
    fromJSON(object: any): SourceCodeInfo_Location;
    toJSON(message: SourceCodeInfo_Location): unknown;
    create(base?: DeepPartial_104<SourceCodeInfo_Location>): SourceCodeInfo_Location;
    fromPartial(object: DeepPartial_104<SourceCodeInfo_Location>): SourceCodeInfo_Location;
};

declare const SPOILER_TEXT_ELEMENT = "spoilertext";

declare type SpoilerText = {
    e: typeof SPOILER_TEXT_ELEMENT;
    c: PlainText[];
};

export declare type StateSetter<S> = Dispatch<SetStateAction<S>>;

declare interface StickyRequest {
    /** an integer between 1 and 2 (default: 1) */
    num: number;
    /** the name of the subreddit */
    subreddit: string;
}

declare const StickyRequest: {
    $type: "devvit.plugin.redditapi.subreddits.StickyRequest";
    encode(message: StickyRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StickyRequest;
    fromJSON(object: any): StickyRequest;
    toJSON(message: StickyRequest): unknown;
    create(base?: DeepPartial_11<StickyRequest>): StickyRequest;
    fromPartial(object: DeepPartial_11<StickyRequest>): StickyRequest;
};

declare interface StickyResponse {
    kind?: string | undefined;
    data?: StickyResponse_StickyResponseData | undefined;
}

declare const StickyResponse: {
    $type: "devvit.plugin.redditapi.subreddits.StickyResponse";
    encode(message: StickyResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StickyResponse;
    fromJSON(object: any): StickyResponse;
    toJSON(message: StickyResponse): unknown;
    create(base?: DeepPartial_11<StickyResponse>): StickyResponse;
    fromPartial(object: DeepPartial_11<StickyResponse>): StickyResponse;
};

declare interface StickyResponse_LinkData {
    authorFlairBackgroundColor?: string | undefined;
    approvedAtUtc?: number | undefined;
    subreddit?: string | undefined;
    selftext?: string | undefined;
    userReports: string[];
    saved?: boolean | undefined;
    modReasonTitle?: string | undefined;
    gilded?: number | undefined;
    clicked?: boolean | undefined;
    title?: string | undefined;
    linkFlairRichtext: string[];
    subredditNamePrefixed?: string | undefined;
    hidden?: boolean | undefined;
    pwls?: string | undefined;
    linkFlairCssClass?: string | undefined;
    downs?: number | undefined;
    thumbnailHeight?: number | undefined;
    topAwardedType?: string | undefined;
    parentWhitelistStatus?: boolean | undefined;
    hideScore?: boolean | undefined;
    name?: string | undefined;
    quarantine?: boolean | undefined;
    linkFlairTextColor?: string | undefined;
    upvoteRatio?: number | undefined;
    ignoreReports?: boolean | undefined;
    ups?: number | undefined;
    domain?: string | undefined;
    mediaEmbed?: MediaEmbed | undefined;
    thumbnailWidth?: number | undefined;
    authorFlairTemplateId?: string | undefined;
    isOriginalContent?: boolean | undefined;
    authorFullname?: string | undefined;
    secureMedia?: boolean | undefined;
    isRedditMediaDomain?: boolean | undefined;
    isMeta?: boolean | undefined;
    category?: string | undefined;
    secureMediaEmbed?: MediaEmbed | undefined;
    linkFlairText?: string | undefined;
    canModPost?: boolean | undefined;
    score?: number | undefined;
    approvedBy?: string | undefined;
    isCreatedFromAdsUi?: boolean | undefined;
    authorPremium?: boolean | undefined;
    thumbnail?: string | undefined;
    edited?: boolean | undefined;
    authorFlairCssClass?: string | undefined;
    previousVisits: number[];
    authorFlairRichtext: string[];
    gildings?: Any | undefined;
    contentCategories?: string | undefined;
    isSelf?: boolean | undefined;
    subredditType?: string | undefined;
    created?: number | undefined;
    linkFlairType?: string | undefined;
    wls?: string | undefined;
    removedByCategory?: string | undefined;
    bannedBy?: string | undefined;
    authorFlairType?: string | undefined;
    totalAwardsReceived?: number | undefined;
    allowLiveComments?: boolean | undefined;
    selftextHtml?: string | undefined;
    likes?: boolean | undefined;
    suggestedSort?: string | undefined;
    bannedAtUtc?: number | undefined;
    viewCount?: number | undefined;
    archived?: boolean | undefined;
    noFollow?: boolean | undefined;
    spam?: boolean | undefined;
    isCrosspostable?: boolean | undefined;
    pinned?: boolean | undefined;
    over18?: boolean | undefined;
    allAwardings: Any[];
    awarders: string[];
    mediaOnly?: boolean | undefined;
    canGild?: boolean | undefined;
    removed?: boolean | undefined;
    spoiler?: boolean | undefined;
    locked?: boolean | undefined;
    authorFlairText?: string | undefined;
    treatmentTags: Any[];
    rteMode?: string | undefined;
    visited?: boolean | undefined;
    removedBy?: string | undefined;
    modNote?: string | undefined;
    distinguished?: string | undefined;
    subredditId?: string | undefined;
    authorIsBlocked?: boolean | undefined;
    modReasonBy?: string | undefined;
    numReports?: number | undefined;
    removalReason?: string | undefined;
    linkFlairBackgroundColor?: string | undefined;
    id?: string | undefined;
    isRobotIndexable?: boolean | undefined;
    numDuplicates?: number | undefined;
    reportReasons: Any[];
    author?: string | undefined;
    discussionType?: string | undefined;
    numComments?: number | undefined;
    sendReplies?: boolean | undefined;
    media?: string | undefined;
    contestMode?: boolean | undefined;
    authorPatreonFlair?: boolean | undefined;
    approved?: boolean | undefined;
    authorFlairTextColor?: string | undefined;
    permalink?: string | undefined;
    whitelistStatus?: boolean | undefined;
    stickied?: boolean | undefined;
    url?: string | undefined;
    subredditSubscribers?: number | undefined;
    createdUtc?: number | undefined;
    numCrossposts?: number | undefined;
    modReports: Any[];
    isVideo?: boolean | undefined;
}

declare const StickyResponse_LinkData: {
    $type: "devvit.plugin.redditapi.subreddits.StickyResponse.LinkData";
    encode(message: StickyResponse_LinkData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StickyResponse_LinkData;
    fromJSON(object: any): StickyResponse_LinkData;
    toJSON(message: StickyResponse_LinkData): unknown;
    create(base?: DeepPartial_11<StickyResponse_LinkData>): StickyResponse_LinkData;
    fromPartial(object: DeepPartial_11<StickyResponse_LinkData>): StickyResponse_LinkData;
};

declare interface StickyResponse_StickyResponseData {
    after?: string | undefined;
    before?: string | undefined;
    dist?: number | undefined;
    modhash?: string | undefined;
    geoFilter?: string | undefined;
    children: StickyResponse_WrappedStickyListing[];
}

declare const StickyResponse_StickyResponseData: {
    $type: "devvit.plugin.redditapi.subreddits.StickyResponse.StickyResponseData";
    encode(message: StickyResponse_StickyResponseData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StickyResponse_StickyResponseData;
    fromJSON(object: any): StickyResponse_StickyResponseData;
    toJSON(message: StickyResponse_StickyResponseData): unknown;
    create(base?: DeepPartial_11<StickyResponse_StickyResponseData>): StickyResponse_StickyResponseData;
    fromPartial(object: DeepPartial_11<StickyResponse_StickyResponseData>): StickyResponse_StickyResponseData;
};

declare interface StickyResponse_WrappedStickyListing {
    kind?: string | undefined;
    data?: StickyResponse_LinkData | undefined;
}

declare const StickyResponse_WrappedStickyListing: {
    $type: "devvit.plugin.redditapi.subreddits.StickyResponse.WrappedStickyListing";
    encode(message: StickyResponse_WrappedStickyListing, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StickyResponse_WrappedStickyListing;
    fromJSON(object: any): StickyResponse_WrappedStickyListing;
    toJSON(message: StickyResponse_WrappedStickyListing): unknown;
    create(base?: DeepPartial_11<StickyResponse_WrappedStickyListing>): StickyResponse_WrappedStickyListing;
    fromPartial(object: DeepPartial_11<StickyResponse_WrappedStickyListing>): StickyResponse_WrappedStickyListing;
};

declare interface StorableAction {
    id: string;
    actorHostname: string;
    request?: ScheduledActionRequest | undefined;
    metadata: {
        [key: string]: Strings;
    };
    state?: StorableAction_State | undefined;
}

declare const StorableAction: {
    $type: "devvit.plugin.scheduler.StorableAction";
    encode(message: StorableAction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StorableAction;
    fromJSON(object: any): StorableAction;
    toJSON(message: StorableAction): unknown;
    create(base?: DeepPartial_89<StorableAction>): StorableAction;
    fromPartial(object: DeepPartial_89<StorableAction>): StorableAction;
};

declare interface StorableAction_MetadataEntry {
    key: string;
    value?: Strings | undefined;
}

declare const StorableAction_MetadataEntry: {
    $type: "devvit.plugin.scheduler.StorableAction.MetadataEntry";
    encode(message: StorableAction_MetadataEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StorableAction_MetadataEntry;
    fromJSON(object: any): StorableAction_MetadataEntry;
    toJSON(message: StorableAction_MetadataEntry): unknown;
    create(base?: DeepPartial_89<StorableAction_MetadataEntry>): StorableAction_MetadataEntry;
    fromPartial(object: DeepPartial_89<StorableAction_MetadataEntry>): StorableAction_MetadataEntry;
};

declare enum StorableAction_State {
    WAITING = 0,
    CANCELED = 1,
    FAILED = 2,
    DELIVERED = 3,
    UNRECOGNIZED = -1
}

declare function storableAction_StateFromJSON(object: any): StorableAction_State;

declare function storableAction_StateToJSON(object: StorableAction_State): number;

/**
 * to-do: replace with StringValue. See
 * https://github.com/stephenh/ts-proto/issues/69.
 */
declare interface Str {
    value: string;
}

declare const Str: {
    $type: "devvit.runtime.Str";
    encode(message: Str, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Str;
    fromJSON(object: any): Str;
    toJSON(message: Str): unknown;
    create(base?: DeepPartial<Str>): Str;
    fromPartial(object: DeepPartial<Str>): Str;
};

declare interface StreamBroker {
    Put(request: Message, metadata?: Metadata): Promise<Empty>;
    Get(request: Cursor, metadata?: Metadata): Observable<Message>;
}

declare class StreamBrokerClientImpl implements StreamBroker {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_13, opts?: {
        service?: string;
    });
    Put(request: Message, metadata?: Metadata): Promise<Empty>;
    Get(request: Cursor, metadata?: Metadata): Observable<Message>;
}

declare type StreamBrokerDefinition = typeof StreamBrokerDefinition;

declare const StreamBrokerDefinition: {
    readonly name: "StreamBroker";
    readonly fullName: "devvit.plugin.streambroker.StreamBroker";
    readonly methods: {
        readonly put: {
            readonly name: "Put";
            readonly requestType: {
                $type: "devvit.plugin.streambroker.Message";
                encode(message: Message, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): Message;
                fromJSON(object: any): Message;
                toJSON(message: Message): unknown;
                create(base?: DeepPartial_91<Message>): Message;
                fromPartial(object: DeepPartial_91<Message>): Message;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly get: {
            readonly name: "Get";
            readonly requestType: {
                $type: "devvit.plugin.streambroker.Cursor";
                encode(message: Cursor, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): Cursor;
                fromJSON(object: any): Cursor;
                toJSON(message: Cursor): unknown;
                create(base?: DeepPartial_91<Cursor>): Cursor;
                fromPartial(object: DeepPartial_91<Cursor>): Cursor;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.streambroker.Message";
                encode(message: Message, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): Message;
                fromJSON(object: any): Message;
                toJSON(message: Message): unknown;
                create(base?: DeepPartial_91<Message>): Message;
                fromPartial(object: DeepPartial_91<Message>): Message;
            };
            readonly responseStream: true;
            readonly options: {};
        };
    };
};

declare const StreamBrokerServiceName = "devvit.plugin.streambroker.StreamBroker";

/** This is a test definition useful to figure out that streams are working well. */
declare interface Streams {
    /**
     * this copies messages from the request stream to the response stream.
     * It could also represent a filtering process (i.e. every odd number)
     */
    Transform(request: Observable<TestMessage>, metadata?: Metadata): Observable<TestMessage>;
    /**
     * This takes a stream of messages and returns a single response.
     * A canonical implementation would be a sum() function.
     */
    Aggregate(request: Observable<TestMessage>, metadata?: Metadata): Promise<TestMessage>;
    /**
     * This takes a single message and returns a stream of messages.  Think
     * range()
     */
    Enumerate(request: TestMessage, metadata?: Metadata): Observable<TestMessage>;
}

declare class StreamsClientImpl implements Streams {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_35, opts?: {
        service?: string;
    });
    Transform(request: Observable<TestMessage>, metadata?: Metadata): Observable<TestMessage>;
    Aggregate(request: Observable<TestMessage>, metadata?: Metadata): Promise<TestMessage>;
    Enumerate(request: TestMessage, metadata?: Metadata): Observable<TestMessage>;
}

/** This is a test definition useful to figure out that streams are working well. */
declare type StreamsDefinition = typeof StreamsDefinition;

declare const StreamsDefinition: {
    readonly name: "Streams";
    readonly fullName: "devvit.actor.test.Streams";
    readonly methods: {
        /**
         * this copies messages from the request stream to the response stream.
         * It could also represent a filtering process (i.e. every odd number)
         */
        readonly transform: {
            readonly name: "Transform";
            readonly requestType: {
                $type: "devvit.actor.test.TestMessage";
                encode(message: TestMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TestMessage;
                fromJSON(object: any): TestMessage;
                toJSON(message: TestMessage): unknown;
                create(base?: DeepPartial_92<TestMessage>): TestMessage;
                fromPartial(object: DeepPartial_92<TestMessage>): TestMessage;
            };
            readonly requestStream: true;
            readonly responseType: {
                $type: "devvit.actor.test.TestMessage";
                encode(message: TestMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TestMessage;
                fromJSON(object: any): TestMessage;
                toJSON(message: TestMessage): unknown;
                create(base?: DeepPartial_92<TestMessage>): TestMessage;
                fromPartial(object: DeepPartial_92<TestMessage>): TestMessage;
            };
            readonly responseStream: true;
            readonly options: {};
        };
        /**
         * This takes a stream of messages and returns a single response.
         * A canonical implementation would be a sum() function.
         */
        readonly aggregate: {
            readonly name: "Aggregate";
            readonly requestType: {
                $type: "devvit.actor.test.TestMessage";
                encode(message: TestMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TestMessage;
                fromJSON(object: any): TestMessage;
                toJSON(message: TestMessage): unknown;
                create(base?: DeepPartial_92<TestMessage>): TestMessage;
                fromPartial(object: DeepPartial_92<TestMessage>): TestMessage;
            };
            readonly requestStream: true;
            readonly responseType: {
                $type: "devvit.actor.test.TestMessage";
                encode(message: TestMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TestMessage;
                fromJSON(object: any): TestMessage;
                toJSON(message: TestMessage): unknown;
                create(base?: DeepPartial_92<TestMessage>): TestMessage;
                fromPartial(object: DeepPartial_92<TestMessage>): TestMessage;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /**
         * This takes a single message and returns a stream of messages.  Think
         * range()
         */
        readonly enumerate: {
            readonly name: "Enumerate";
            readonly requestType: {
                $type: "devvit.actor.test.TestMessage";
                encode(message: TestMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TestMessage;
                fromJSON(object: any): TestMessage;
                toJSON(message: TestMessage): unknown;
                create(base?: DeepPartial_92<TestMessage>): TestMessage;
                fromPartial(object: DeepPartial_92<TestMessage>): TestMessage;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.test.TestMessage";
                encode(message: TestMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TestMessage;
                fromJSON(object: any): TestMessage;
                toJSON(message: TestMessage): unknown;
                create(base?: DeepPartial_92<TestMessage>): TestMessage;
                fromPartial(object: DeepPartial_92<TestMessage>): TestMessage;
            };
            readonly responseStream: true;
            readonly options: {};
        };
    };
};

declare const StreamsServiceName = "devvit.actor.test.Streams";

/** A text field */
export declare type StringField = Prettify<BaseField<string> & Omit<FieldConfig_String, 'minLength' | 'maxLength'> & {
    type: 'string';
    isSecret?: boolean;
}>;

declare interface Strings {
    values: string[];
}

declare const Strings: {
    $type: "devvit.runtime.Strings";
    encode(message: Strings, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Strings;
    fromJSON(object: any): Strings;
    toJSON(message: Strings): unknown;
    create(base?: DeepPartial<Strings>): Strings;
    fromPartial(object: DeepPartial<Strings>): Strings;
};

/**
 * Wrapper message for `string`.
 *
 * The JSON representation for `StringValue` is JSON string.
 */
declare interface StringValue {
    /** The string value. */
    value: string;
}

declare const StringValue: {
    $type: "google.protobuf.StringValue";
    encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StringValue;
    fromJSON(object: any): StringValue;
    toJSON(message: StringValue): unknown;
    create(base?: DeepPartial_69<StringValue>): StringValue;
    fromPartial(object: DeepPartial_69<StringValue>): StringValue;
};

/**
 * `Struct` represents a structured data value, consisting of fields
 * which map to dynamically typed values. In some languages, `Struct`
 * might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an
 * object. The details of that representation are described together
 * with the proto support for the language.
 *
 * The JSON representation for `Struct` is JSON object.
 */
declare interface Struct {
    /** Unordered map of dynamically typed values. */
    fields: {
        [key: string]: any | undefined;
    };
}

declare const Struct: {
    $type: "google.protobuf.Struct";
    encode(message: Struct, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Struct;
    fromJSON(object: any): Struct;
    toJSON(message: Struct): unknown;
    create(base?: DeepPartial_103<Struct>): Struct;
    fromPartial(object: DeepPartial_103<Struct>): Struct;
    wrap(object: {
        [key: string]: any;
    } | undefined): Struct;
    unwrap(message: Struct): {
        [key: string]: any;
    };
};

declare interface Struct_FieldsEntry {
    key: string;
    value?: any | undefined;
}

declare const Struct_FieldsEntry: {
    $type: "google.protobuf.Struct.FieldsEntry";
    encode(message: Struct_FieldsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Struct_FieldsEntry;
    fromJSON(object: any): Struct_FieldsEntry;
    toJSON(message: Struct_FieldsEntry): unknown;
    create(base?: DeepPartial_103<Struct_FieldsEntry>): Struct_FieldsEntry;
    fromPartial(object: DeepPartial_103<Struct_FieldsEntry>): Struct_FieldsEntry;
};

declare interface StylesheetRequest {
    /** subreddit name without the r/ */
    subreddit: string;
}

declare const StylesheetRequest: {
    $type: "devvit.plugin.redditapi.moderation.StylesheetRequest";
    encode(message: StylesheetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StylesheetRequest;
    fromJSON(object: any): StylesheetRequest;
    toJSON(message: StylesheetRequest): unknown;
    create(base?: DeepPartial_2<StylesheetRequest>): StylesheetRequest;
    fromPartial(object: DeepPartial_2<StylesheetRequest>): StylesheetRequest;
};

export declare type SubmitCustomPostOptions = CommonSubmitPostOptions & {
    preview: JSX.Element;
};

export declare type SubmitLinkOptions = CommonSubmitPostOptions & {
    url: string;
    /**
     * @deprecated Unsupported. This property is for backwards compatibility and
     * has no effect. It will removed in a future version. New code should not
     * use it.
     */
    resubmit?: boolean;
};

export declare type SubmitMediaOptions = CommonSubmitPostOptions & {
    kind: 'image' | 'video' | 'videogif';
    videoPosterUrl: string;
};

export declare type SubmitPostOptions = (SubmitLinkOptions | SubmitSelfPostOptions | SubmitCustomPostOptions | SubmitMediaOptions) & {
    subredditName: string;
};

declare interface SubmitRequest {
    /**
     * UUID of the collection to add this Post to
     * @example "813b473a-4d74-4933-ba79-a7f1b8b285ef"
     */
    collectionId?: string | undefined;
    /**
     * Flair template ID to use for this Post
     * @example "813b473a-4d74-4933-ba79-a7f1b8b285ef"
     */
    flairId?: string | undefined;
    /**
     * Custom text to use in the selected flair template if the template
     * has `text_editable` enabled
     */
    flairText?: string | undefined;
    /**
     * What kind of Post is being created
     * One of: "link", "self", "image", "video", "videogif", "crosspost"
     */
    kind: string;
    /** Boolean to set the Not-Safe-For-Work tag */
    nsfw?: boolean | undefined;
    /**
     * Rich-text body of the Post. Serialized RTJSON string.
     * Note: Only used if `kind` is set to "self"
     * Note: `text` and `richtext_json` cannot both be set
     * @example '{"document":[{"e":"par","c":[{"e":"text","t":"Hello, world!","f":[[2, 0, 13]]}]}]}'
     */
    richtextJson?: string | undefined;
    /** Boolean to enable notifications when a comment is added */
    sendreplies?: boolean | undefined;
    /** Boolean to set the Spoiler tag */
    spoiler?: boolean | undefined;
    /**
     * Subreddit name
     * @example "AskReddit"
     */
    sr: string;
    /**
     * Markdown body of the Post
     * Note: Only used if `kind` is set to "self"
     * Note: `text` and `richtext_json` cannot both be set
     * @example "_Hello, world!_"
     */
    text?: string | undefined;
    /** Post title */
    title: string;
    /**
     * The URL this Post refers to if this is a Link Post
     * Note: If `kind` is "video", "videogif", or "image" this must be set to
     *       the media URL created when the media was uploaded
     * Note: If `kind` is "self" this is ignored
     */
    url?: string | undefined;
    /** If `kind` is "video" or "videogif" this must be set to the thumbnail URL */
    videoPosterUrl?: string | undefined;
    /** If `kind` is "crosspost" this must be set to the ID of the post being crossposted */
    crosspostFullname?: string | undefined;
}

declare const SubmitRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.SubmitRequest";
    encode(message: SubmitRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubmitRequest;
    fromJSON(object: any): SubmitRequest;
    toJSON(message: SubmitRequest): unknown;
    create(base?: DeepPartial_64<SubmitRequest>): SubmitRequest;
    fromPartial(object: DeepPartial_64<SubmitRequest>): SubmitRequest;
};

declare interface SubmitResponse {
    json?: SubmitResponse_JsonType | undefined;
}

declare const SubmitResponse: {
    $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse";
    encode(message: SubmitResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubmitResponse;
    fromJSON(object: any): SubmitResponse;
    toJSON(message: SubmitResponse): unknown;
    create(base?: DeepPartial_64<SubmitResponse>): SubmitResponse;
    fromPartial(object: DeepPartial_64<SubmitResponse>): SubmitResponse;
};

declare interface SubmitResponse_JsonType {
    errors: Any[];
    data?: SubmitResponse_JsonType_JsonData | undefined;
}

declare const SubmitResponse_JsonType: {
    $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType";
    encode(message: SubmitResponse_JsonType, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubmitResponse_JsonType;
    fromJSON(object: any): SubmitResponse_JsonType;
    toJSON(message: SubmitResponse_JsonType): unknown;
    create(base?: DeepPartial_64<SubmitResponse_JsonType>): SubmitResponse_JsonType;
    fromPartial(object: DeepPartial_64<SubmitResponse_JsonType>): SubmitResponse_JsonType;
};

declare interface SubmitResponse_JsonType_JsonData {
    url?: string | undefined;
    draftsCount?: number | undefined;
    id?: string | undefined;
    name?: string | undefined;
}

declare const SubmitResponse_JsonType_JsonData: {
    $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType.JsonData";
    encode(message: SubmitResponse_JsonType_JsonData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubmitResponse_JsonType_JsonData;
    fromJSON(object: any): SubmitResponse_JsonType_JsonData;
    toJSON(message: SubmitResponse_JsonType_JsonData): unknown;
    create(base?: DeepPartial_64<SubmitResponse_JsonType_JsonData>): SubmitResponse_JsonType_JsonData;
    fromPartial(object: DeepPartial_64<SubmitResponse_JsonType_JsonData>): SubmitResponse_JsonType_JsonData;
};

export declare type SubmitSelfPostOptions = PostTextOptions & CommonSubmitPostOptions;

declare interface SubmitTextResponse {
    submitText?: string | undefined;
    submitTextHtml?: string | undefined;
}

declare const SubmitTextResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubmitTextResponse";
    encode(message: SubmitTextResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubmitTextResponse;
    fromJSON(object: any): SubmitTextResponse;
    toJSON(message: SubmitTextResponse): unknown;
    create(base?: DeepPartial_11<SubmitTextResponse>): SubmitTextResponse;
    fromPartial(object: DeepPartial_11<SubmitTextResponse>): SubmitTextResponse;
};

/**
 * A class representing a subreddit.
 */
export declare class Subreddit {
    #private;
    /**
     * The ID (starting with t5_) of the subreddit to retrieve. e.g. t5_2qjpg
     */
    get id(): T5ID;
    /**
     * The name of a subreddit omitting the r/.
     */
    get name(): string;
    /**
     * The creation date of the subreddit.
     */
    get createdAt(): Date;
    /**
     * The type of subreddit (public, private, etc.).
     */
    get type(): SubredditType;
    /**
     * The title of the subreddit.
     */
    get title(): string | undefined;
    /**
     * The description of the subreddit.
     */
    get description(): string | undefined;
    /**
     * The language of the subreddit.
     */
    get language(): string;
    /**
     * The number of subscribers of the subreddit.
     */
    get numberOfSubscribers(): number;
    /**
     * The number of active users of the subreddit.
     */
    get numberOfActiveUsers(): number;
    /**
     * Whether the subreddit is marked as NSFW (Not Safe For Work).
     */
    get nsfw(): boolean;
    /**
     * The settings of the subreddit.
     */
    get settings(): SubredditSettings;
    /**
     * Whether the user flairs are enabled for this subreddit.
     */
    get userFlairsEnabled(): boolean;
    /**
     * Whether the post flairs are enabled for this subreddit.
     */
    get postFlairsEnabled(): boolean;
    /**
     * Whether the user can assign user flairs.
     * This is only true if the user flairs are enabled.
     */
    get usersCanAssignUserFlairs(): boolean;
    /**
     * Whether the user can assign post flairs.
     * This is only true if the post flairs are enabled.
     */
    get usersCanAssignPostFlairs(): boolean;
    /**
     * Returns the HTTP URL for the subreddit.
     * (R2 bug: subreddit.url is a permalink path and does not return a fully qualified URL in subreddit.url)
     */
    get url(): string;
    /**
     * Returns a permalink path
     * (R2 bug: subreddit.url is a permalink, and does not have a subreddit.permalink field)
     */
    get permalink(): string;
    toJSON(): Pick<Subreddit, 'id' | 'name' | 'createdAt' | 'type' | 'title' | 'description' | 'language' | 'nsfw' | 'numberOfSubscribers' | 'numberOfActiveUsers' | 'settings'>;
    submitPost(options: SubmitLinkOptions | SubmitSelfPostOptions): Promise<Post>;
    getControversialPosts(options?: Omit<GetPostsOptionsWithTimeframe, 'subredditName'>): Listing<Post>;
    getTopPosts(options?: Omit<GetPostsOptionsWithTimeframe, 'subredditName'>): Listing<Post>;
    getApprovedUsers(options?: GetUsersOptions): Listing<User>;
    approveUser(username: string): Promise<void>;
    removeUser(username: string): Promise<void>;
    getWikiContributors(options?: GetUsersOptions): Listing<User>;
    addWikiContributor(username: string): Promise<void>;
    removeWikiContributor(username: string): Promise<void>;
    getBannedUsers(options?: GetUsersOptions): Listing<User>;
    banUser(options: Omit<BanUserOptions, 'subredditName'>): Promise<void>;
    unbanUser(username: string): Promise<void>;
    getBannedWikiContributors(options?: GetUsersOptions): Listing<User>;
    banWikiContributor(options: Omit<BanWikiContributorOptions, 'subredditName'>): Promise<void>;
    unbanWikiContributor(username: string): Promise<void>;
    getModerators(options?: GetUsersOptions): Listing<User>;
    inviteModerator(username: string, permissions?: ModeratorPermission[]): Promise<void>;
    revokeModeratorInvite(username: string): Promise<void>;
    removeModerator(username: string): Promise<void>;
    setModeratorPermissions(username: string, permissions: ModeratorPermission[]): Promise<void>;
    getMutedUsers(options?: GetUsersOptions): Listing<User>;
    muteUser(username: string, note?: string): Promise<void>;
    unmuteUser(username: string): Promise<void>;
    getModerationLog(options: GetModerationLogOptions_2): Listing<ModAction>;
    getUserFlairTemplates(): Promise<FlairTemplate[]>;
    getPostFlairTemplates(): Promise<FlairTemplate[]>;
    createPostFlairTemplate(options: Omit<CreateFlairTemplateOptions, 'subredditName'>): Promise<FlairTemplate>;
    createUserFlairTemplate(options: Omit<CreateFlairTemplateOptions, 'subredditName'>): Promise<FlairTemplate>;
    /**
     * Get the user flair for the given subreddit. If `usernames` is provided then it will return only the
     * flair for the specified users. If retrieving the list of flair for a given subreddit and the list is long
     * then this method will return a `next` field which can be passed into the `after` field on the next call to
     * retrieve the next slice of data. To retrieve the previous slice of data pass the `prev` field into the `before` field
     * during the subsequent call.
     *
     * @param options See interface
     * @param metadata See interface
     *
     * @example
     * ```ts
     * const subredditName = "mysubreddit"
     * const subreddit = await reddit.getSubredditByName(subredditName)
     * const response = await subreddit.getUserFlair();
     * const userFlairList = response.users
     * ```
     * @example
     * ```ts
     * const response = await subreddit.getUserFlair({ after: "t2_awefae"});
     * const userFlairList = response.users
     * ```
     *
     * @example
     * ```ts
     * const response = await subreddit.getUserFlair({ usernames: ['toxictoad', 'badapple']});
     * const userFlairList = response.users
     * ```
     */
    getUserFlair(options?: GetUserFlairOptions): Promise<GetUserFlairBySubredditResponse>;
    /**
     * Return a listing of things requiring moderator review, such as reported things and items.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getModQueue();
     * console.log("Posts and Comments: ",  await listing.all())
     * listing = await subreddit.getModQueue({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getModQueue(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getModQueue(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getModQueue(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been reported.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getReports();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getReports({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getReports(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getReports(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getReports(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been marked as spam or otherwise removed.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getSpam();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getSpam({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getSpam(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getSpam(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getSpam(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have yet to be approved/removed by a mod.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getUnmoderated();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getUnmoderated({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getUnmoderated(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getUnmoderated(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getUnmoderated(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been edited recently.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getEdited();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getEdited({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getEdited(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getEdited(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getEdited(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things specified by their fullnames.
     *
     * @param ids Array of thing full ids (e.g. t3_abc123)
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName('askReddit');
     * const listing = subreddit.getCommentsAndPostsByIds(['t3_abc123', 't1_xyz123']);
     * const items = await listing.all();
     * console.log(items) // [Post, Comment]
     * ```
     */
    getCommentsAndPostsByIds(ids: string[]): Listing<Post | Comment>;
}

declare interface Subreddit_2 {
    acceptFollowers?: boolean | undefined;
    accountsActiveIsFuzzed?: boolean | undefined;
    accountsActive?: number | undefined;
    activeUserCount?: number | undefined;
    advertiserCategory?: string | undefined;
    allOriginalContent?: boolean | undefined;
    allowChatPostCreation?: boolean | undefined;
    allowDiscovery?: boolean | undefined;
    allowGalleries?: boolean | undefined;
    allowImages?: boolean | undefined;
    allowPolls?: boolean | undefined;
    allowPredictionContributors?: boolean | undefined;
    allowPredictionsTournament?: boolean | undefined;
    allowPredictions?: boolean | undefined;
    allowTalks?: boolean | undefined;
    allowVideogifs?: boolean | undefined;
    allowVideos?: boolean | undefined;
    allowedMediaInComments: string[];
    bannerBackgroundColor?: string | undefined;
    bannerBackgroundImage?: string | undefined;
    bannerImg?: string | undefined;
    bannerSize: number[];
    canAssignLinkFlair?: boolean | undefined;
    canAssignUserFlair?: boolean | undefined;
    coins?: number | undefined;
    collapseDeletedComments?: boolean | undefined;
    commentContributionSettings?: CommentContributionSettings | undefined;
    commentScoreHideMins?: number | undefined;
    communityIcon?: string | undefined;
    communityReviewed?: boolean | undefined;
    contentCategory?: string | undefined;
    createdUtc?: number | undefined;
    created?: number | undefined;
    defaultSet?: boolean | undefined;
    description?: string | undefined;
    descriptionHtml?: string | undefined;
    disableContributorRequests?: boolean | undefined;
    displayName?: string | undefined;
    displayNamePrefixed?: string | undefined;
    emojisCustomSize: number[];
    emojisEnabled?: boolean | undefined;
    freeFormReports?: boolean | undefined;
    hasMenuWidget?: boolean | undefined;
    headerImg?: string | undefined;
    headerSize: number[];
    headerTitle?: string | undefined;
    hideAds?: boolean | undefined;
    iconColor?: string | undefined;
    iconImg?: string | undefined;
    iconSize: number[];
    id?: string | undefined;
    isChatPostFeatureEnabled?: boolean | undefined;
    isCrosspostableSubreddit?: boolean | undefined;
    isDefaultBanner?: boolean | undefined;
    isDefaultIcon?: boolean | undefined;
    isEnrolledInNewModmail?: boolean | undefined;
    keyColor?: string | undefined;
    lang?: string | undefined;
    linkFlairEnabled?: boolean | undefined;
    linkFlairPosition?: string | undefined;
    mobileBannerImage?: string | undefined;
    name?: string | undefined;
    notificationLevel?: string | undefined;
    originalContentTagEnabled?: string | undefined;
    over18?: boolean | undefined;
    predictionLeaderboardEntryType?: string | undefined;
    previousNames: string[];
    primaryColor?: string | undefined;
    publicDescription?: string | undefined;
    publicDescriptionHtml?: string | undefined;
    publicTraffic?: boolean | undefined;
    quarantine?: boolean | undefined;
    restrictCommenting?: boolean | undefined;
    restrictPosting?: boolean | undefined;
    shouldArchivePosts?: boolean | undefined;
    shouldShowMediaInCommentsSetting?: boolean | undefined;
    showMedia?: boolean | undefined;
    showMediaPreview?: boolean | undefined;
    spoilersEnabled?: boolean | undefined;
    submissionType?: string | undefined;
    submitLinkLabel?: string | undefined;
    submitText?: string | undefined;
    submitTextHtml?: string | undefined;
    submitTextLabel?: string | undefined;
    subredditType?: string | undefined;
    subscribers?: number | undefined;
    suggestedCommentSort?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;
    userCanFlairInSr?: boolean | undefined;
    userFlairBackgroundColor?: string | undefined;
    userFlairCssClass?: string | undefined;
    userFlairEnabledInSr?: boolean | undefined;
    userFlairPosition?: string | undefined;
    userFlairRichtext: UserFlairRichtext[];
    userFlairTemplateId?: string | undefined;
    userFlairText?: string | undefined;
    userFlairTextColor?: string | undefined;
    userFlairType?: string | undefined;
    userHasFavorited?: boolean | undefined;
    userIsBanned?: boolean | undefined;
    userIsContributor?: boolean | undefined;
    userIsModerator?: boolean | undefined;
    userIsSubscriber?: boolean | undefined;
    userSrFlairEnabled?: boolean | undefined;
    userSrThemeEnabled?: boolean | undefined;
    videostreamLinksCount?: number | undefined;
    whitelistStatus?: string | undefined;
    wikiEnabled?: boolean | undefined;
    wls?: number | undefined;
    /** PRIVATE - DO NOT SET FOR PUBLIC USE */
    markedSpam?: boolean | undefined;
    /**
     * previously used for post guidance
     *
     * @deprecated
     */
    postRequirements?: Subreddit_PostRequirements | undefined;
    /** If `true`, the current user may not send messages to moderators */
    userIsMuted: boolean;
}

declare const Subreddit_2: {
    $type: "devvit.reddit.Subreddit";
    encode(message: Subreddit_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Subreddit_2;
    fromJSON(object: any): Subreddit_2;
    toJSON(message: Subreddit_2): unknown;
    create(base?: DeepPartial_7<Subreddit_2>): Subreddit_2;
    fromPartial(object: DeepPartial_7<Subreddit_2>): Subreddit_2;
};

declare const SUBREDDIT_LINK_ELEMENT = "r/";

declare interface Subreddit_PostRequirements {
    bodyRestrictionPolicy?: string | undefined;
}

declare const Subreddit_PostRequirements: {
    $type: "devvit.reddit.Subreddit.PostRequirements";
    encode(message: Subreddit_PostRequirements, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Subreddit_PostRequirements;
    fromJSON(object: any): Subreddit_PostRequirements;
    toJSON(message: Subreddit_PostRequirements): unknown;
    create(base?: DeepPartial_7<Subreddit_PostRequirements>): Subreddit_PostRequirements;
    fromPartial(object: DeepPartial_7<Subreddit_PostRequirements>): Subreddit_PostRequirements;
};

declare interface SubredditAboutEditRequest {
    /** one of (true, false) */
    created: string;
    location: string;
    /** the name of the subreddit */
    subreddit: string;
}

declare const SubredditAboutEditRequest: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditRequest";
    encode(message: SubredditAboutEditRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutEditRequest;
    fromJSON(object: any): SubredditAboutEditRequest;
    toJSON(message: SubredditAboutEditRequest): unknown;
    create(base?: DeepPartial_11<SubredditAboutEditRequest>): SubredditAboutEditRequest;
    fromPartial(object: DeepPartial_11<SubredditAboutEditRequest>): SubredditAboutEditRequest;
};

declare interface SubredditAboutEditResponse {
    kind?: string | undefined;
    data?: SubredditAboutEditResponse_SubredditSettings | undefined;
}

declare const SubredditAboutEditResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse";
    encode(message: SubredditAboutEditResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutEditResponse;
    fromJSON(object: any): SubredditAboutEditResponse;
    toJSON(message: SubredditAboutEditResponse): unknown;
    create(base?: DeepPartial_11<SubredditAboutEditResponse>): SubredditAboutEditResponse;
    fromPartial(object: DeepPartial_11<SubredditAboutEditResponse>): SubredditAboutEditResponse;
};

declare interface SubredditAboutEditResponse_SubredditSettings {
    defaultSet?: boolean | undefined;
    toxicityThresholdChatLevel?: number | undefined;
    crowdControlChatLevel?: number | undefined;
    restrictPosting?: boolean | undefined;
    publicDescription?: string | undefined;
    subredditId?: string | undefined;
    allowImages?: boolean | undefined;
    freeFormReports?: boolean | undefined;
    domain?: string | undefined;
    originalContentTagEnabled?: boolean | undefined;
    showMedia?: boolean | undefined;
    excludeBannedModqueue?: boolean | undefined;
    shouldArchivePosts?: boolean | undefined;
    submitText?: string | undefined;
    spamLinks?: string | undefined;
    title?: string | undefined;
    collapseDeletedComments?: boolean | undefined;
    wikimode?: string | undefined;
    over18?: boolean | undefined;
    allowVideos?: boolean | undefined;
    allowGalleries?: boolean | undefined;
    crowdControlLevel?: number | undefined;
    banEvasionThreshold?: number | undefined;
    crowdControlMode?: boolean | undefined;
    welcomeMessageEnabled?: boolean | undefined;
    welcomeMessageText?: string | undefined;
    suggestedCommentSort?: boolean | undefined;
    disableContributorRequests?: boolean | undefined;
    allowTalks?: boolean | undefined;
    description?: string | undefined;
    submitLinkLabel?: string | undefined;
    spoilersEnabled?: boolean | undefined;
    allowPostCrossposts?: boolean | undefined;
    spamComments?: string | undefined;
    publicTraffic?: boolean | undefined;
    restrictCommenting?: boolean | undefined;
    allowPolls?: boolean | undefined;
    commentContributionSettings?: CommentContributionSettings | undefined;
    submitTextLabel?: string | undefined;
    commentScoreHideMins?: number | undefined;
    allOriginalContent?: boolean | undefined;
    spamSelfposts?: string | undefined;
    keyColor?: string | undefined;
    language?: string | undefined;
    newPinnedPostPnsEnabled?: boolean | undefined;
    hideAds?: boolean | undefined;
    predictionLeaderboardEntryType?: number | undefined;
    headerHoverText?: string | undefined;
    wikiEditAge?: number | undefined;
    allowChatPostCreation?: boolean | undefined;
    allowPredictionContributors?: boolean | undefined;
    allowDiscovery?: boolean | undefined;
    acceptFollowers?: boolean | undefined;
    crowdControlPostLevel?: number | undefined;
    allowPredictionsTournament?: boolean | undefined;
    wikiEditKarma?: number | undefined;
    showMediaPreview?: boolean | undefined;
    crowdControlFilter?: boolean | undefined;
    subredditType?: string | undefined;
    allowPredictions?: boolean | undefined;
    userFlairPnsEnabled?: boolean | undefined;
    contentOptions?: string | undefined;
}

declare const SubredditAboutEditResponse_SubredditSettings: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse.SubredditSettings";
    encode(message: SubredditAboutEditResponse_SubredditSettings, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutEditResponse_SubredditSettings;
    fromJSON(object: any): SubredditAboutEditResponse_SubredditSettings;
    toJSON(message: SubredditAboutEditResponse_SubredditSettings): unknown;
    create(base?: DeepPartial_11<SubredditAboutEditResponse_SubredditSettings>): SubredditAboutEditResponse_SubredditSettings;
    fromPartial(object: DeepPartial_11<SubredditAboutEditResponse_SubredditSettings>): SubredditAboutEditResponse_SubredditSettings;
};

declare interface SubredditAboutResponse {
    kind?: string | undefined;
    data?: SubredditAboutResponse_AboutData | undefined;
}

declare const SubredditAboutResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutResponse";
    encode(message: SubredditAboutResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutResponse;
    fromJSON(object: any): SubredditAboutResponse;
    toJSON(message: SubredditAboutResponse): unknown;
    create(base?: DeepPartial_11<SubredditAboutResponse>): SubredditAboutResponse;
    fromPartial(object: DeepPartial_11<SubredditAboutResponse>): SubredditAboutResponse;
};

declare interface SubredditAboutResponse_AboutData {
    userFlairBackgroundColor?: string | undefined;
    submitTextHtml?: string | undefined;
    restrictPosting?: boolean | undefined;
    userIsBanned?: boolean | undefined;
    freeFormReports?: boolean | undefined;
    wikiEnabled?: boolean | undefined;
    userIsMuted?: boolean | undefined;
    userCanFlairInSr?: boolean | undefined;
    displayName?: string | undefined;
    headerImg?: string | undefined;
    title?: string | undefined;
    allowGalleries?: boolean | undefined;
    primaryColor?: string | undefined;
    activeUserCount?: number | undefined;
    iconImg?: string | undefined;
    displayNamePrefixed?: string | undefined;
    accountsActive?: number | undefined;
    publicTraffic?: boolean | undefined;
    subscribers?: number | undefined;
    userFlairRichtext: UserFlairRichtext[];
    name?: string | undefined;
    quarantine?: boolean | undefined;
    hideAds?: boolean | undefined;
    emojisEnabled?: boolean | undefined;
    advertiserCategory?: string | undefined;
    publicDescription?: string | undefined;
    commentScoreHideMins?: number | undefined;
    allowPredictions?: boolean | undefined;
    userHasFavorited?: boolean | undefined;
    userFlairTemplateId?: string | undefined;
    communityIcon?: string | undefined;
    bannerBackgroundImage?: string | undefined;
    originalContentTagEnabled?: boolean | undefined;
    communityReviewed?: boolean | undefined;
    submitText?: string | undefined;
    descriptionHtml?: string | undefined;
    spoilersEnabled?: boolean | undefined;
    commentContributionSettings?: CommentContributionSettings | undefined;
    allowTalks?: boolean | undefined;
    userFlairPosition?: string | undefined;
    allOriginalContent?: boolean | undefined;
    collectionsEnabled?: boolean | undefined;
    isEnrolledInNewModmail?: boolean | undefined;
    keyColor?: string | undefined;
    eventPostsEnabled?: boolean | undefined;
    canAssignUserFlair?: boolean | undefined;
    created?: number | undefined;
    showMediaPreview?: boolean | undefined;
    submissionType?: string | undefined;
    userIsSubscriber?: boolean | undefined;
    allowedMediaInComments: string[];
    allowVideogifs?: boolean | undefined;
    shouldArchivePosts?: boolean | undefined;
    userFlairType?: string | undefined;
    allowPolls?: boolean | undefined;
    collapseDeletedComments?: boolean | undefined;
    coins?: number | undefined;
    publicDescriptionHtml?: string | undefined;
    allowVideos?: boolean | undefined;
    isCrosspostableSubreddit?: boolean | undefined;
    notificationLevel?: string | undefined;
    shouldShowMediaInCommentsSetting?: boolean | undefined;
    canAssignLinkFlair?: boolean | undefined;
    hasMenuWidget?: boolean | undefined;
    accountsActiveIsFuzzed?: boolean | undefined;
    allowPredictionContributors?: boolean | undefined;
    submitTextLabel?: string | undefined;
    linkFlairPosition?: string | undefined;
    userSrFlairEnabled?: boolean | undefined;
    userFlairEnabledInSr?: boolean | undefined;
    allowChatPostCreation?: boolean | undefined;
    allowDiscovery?: boolean | undefined;
    acceptFollowers?: boolean | undefined;
    userSrThemeEnabled?: boolean | undefined;
    linkFlairEnabled?: boolean | undefined;
    disableContributorRequests?: boolean | undefined;
    subredditType?: string | undefined;
    suggestedCommentSort?: string | undefined;
    bannerImg?: string | undefined;
    userFlairText?: string | undefined;
    bannerBackgroundColor?: string | undefined;
    showMedia?: boolean | undefined;
    id?: string | undefined;
    userIsModerator?: boolean | undefined;
    over18?: boolean | undefined;
    headerTitle?: string | undefined;
    description?: string | undefined;
    isChatPostFeatureEnabled?: boolean | undefined;
    submitLinkLabel?: string | undefined;
    userFlairTextColor?: string | undefined;
    restrictCommenting?: boolean | undefined;
    userFlairCssClass?: string | undefined;
    allowImages?: boolean | undefined;
    lang?: string | undefined;
    url?: string | undefined;
    createdUtc?: number | undefined;
    bannerSize: number[];
    mobileBannerImage?: string | undefined;
    userIsContributor?: boolean | undefined;
    allowPredictionsTournament?: boolean | undefined;
    iconSize: number[];
    headerSize: number[];
    wls?: number | undefined;
    whitelistStatus?: string | undefined;
    emojisCustomSize: number[];
}

declare const SubredditAboutResponse_AboutData: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutResponse.AboutData";
    encode(message: SubredditAboutResponse_AboutData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutResponse_AboutData;
    fromJSON(object: any): SubredditAboutResponse_AboutData;
    toJSON(message: SubredditAboutResponse_AboutData): unknown;
    create(base?: DeepPartial_11<SubredditAboutResponse_AboutData>): SubredditAboutResponse_AboutData;
    fromPartial(object: DeepPartial_11<SubredditAboutResponse_AboutData>): SubredditAboutResponse_AboutData;
};

declare interface SubredditAboutRulesResponse {
    rules: SubredditAboutRulesResponse_SubredditRule[];
    siteRules: string[];
    siteRulesFlow: SubredditAboutRulesResponse_RuleFlow[];
}

declare const SubredditAboutRulesResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse";
    encode(message: SubredditAboutRulesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutRulesResponse;
    fromJSON(object: any): SubredditAboutRulesResponse;
    toJSON(message: SubredditAboutRulesResponse): unknown;
    create(base?: DeepPartial_11<SubredditAboutRulesResponse>): SubredditAboutRulesResponse;
    fromPartial(object: DeepPartial_11<SubredditAboutRulesResponse>): SubredditAboutRulesResponse;
};

declare interface SubredditAboutRulesResponse_RuleFlow {
    reasonTextToShow?: string | undefined;
    reasonText?: string | undefined;
    nextStepHeader?: string | undefined;
    nextStepReasons: SubredditAboutRulesResponse_RuleFlow[];
    complaintButtonText?: string | undefined;
    complaintUrl?: string | undefined;
    complaintPageTitle?: string | undefined;
    fileComplaint?: boolean | undefined;
    complaintPrompt?: string | undefined;
    canWriteNotes?: boolean | undefined;
    isAbuseOfReportButton?: boolean | undefined;
    notesInputTitle?: string | undefined;
    usernamesInputTitle?: string | undefined;
    canSpecifyUsernames?: boolean | undefined;
    requestCrisisSupport?: boolean | undefined;
    oneUsername?: boolean | undefined;
}

declare const SubredditAboutRulesResponse_RuleFlow: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.RuleFlow";
    encode(message: SubredditAboutRulesResponse_RuleFlow, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutRulesResponse_RuleFlow;
    fromJSON(object: any): SubredditAboutRulesResponse_RuleFlow;
    toJSON(message: SubredditAboutRulesResponse_RuleFlow): unknown;
    create(base?: DeepPartial_11<SubredditAboutRulesResponse_RuleFlow>): SubredditAboutRulesResponse_RuleFlow;
    fromPartial(object: DeepPartial_11<SubredditAboutRulesResponse_RuleFlow>): SubredditAboutRulesResponse_RuleFlow;
};

declare interface SubredditAboutRulesResponse_SubredditRule {
    kind?: string | undefined;
    description?: string | undefined;
    shortName?: string | undefined;
    violationReason?: string | undefined;
    createdUtc?: number | undefined;
    priority?: number | undefined;
    descriptionHtml?: string | undefined;
}

declare const SubredditAboutRulesResponse_SubredditRule: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.SubredditRule";
    encode(message: SubredditAboutRulesResponse_SubredditRule, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutRulesResponse_SubredditRule;
    fromJSON(object: any): SubredditAboutRulesResponse_SubredditRule;
    toJSON(message: SubredditAboutRulesResponse_SubredditRule): unknown;
    create(base?: DeepPartial_11<SubredditAboutRulesResponse_SubredditRule>): SubredditAboutRulesResponse_SubredditRule;
    fromPartial(object: DeepPartial_11<SubredditAboutRulesResponse_SubredditRule>): SubredditAboutRulesResponse_SubredditRule;
};

declare interface SubredditAboutTrafficResponse {
    day: SubredditAboutTrafficResponse_Data[];
    hour: SubredditAboutTrafficResponse_Data[];
    month: SubredditAboutTrafficResponse_Data[];
}

declare const SubredditAboutTrafficResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse";
    encode(message: SubredditAboutTrafficResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutTrafficResponse;
    fromJSON(object: any): SubredditAboutTrafficResponse;
    toJSON(message: SubredditAboutTrafficResponse): unknown;
    create(base?: DeepPartial_11<SubredditAboutTrafficResponse>): SubredditAboutTrafficResponse;
    fromPartial(object: DeepPartial_11<SubredditAboutTrafficResponse>): SubredditAboutTrafficResponse;
};

declare interface SubredditAboutTrafficResponse_Data {
    values: number[];
}

declare const SubredditAboutTrafficResponse_Data: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse.Data";
    encode(message: SubredditAboutTrafficResponse_Data, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAboutTrafficResponse_Data;
    fromJSON(object: any): SubredditAboutTrafficResponse_Data;
    toJSON(message: SubredditAboutTrafficResponse_Data): unknown;
    create(base?: DeepPartial_11<SubredditAboutTrafficResponse_Data>): SubredditAboutTrafficResponse_Data;
    fromPartial(object: DeepPartial_11<SubredditAboutTrafficResponse_Data>): SubredditAboutTrafficResponse_Data;
};

declare interface SubredditAddRemovalReasonRequest {
    /** The name of the subreddit without `r/` */
    subreddit: string;
    /** A message that will communicate to the user why their post was removed */
    message: string;
    /** Removal Reason title */
    title: string;
}

declare const SubredditAddRemovalReasonRequest: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonRequest";
    encode(message: SubredditAddRemovalReasonRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAddRemovalReasonRequest;
    fromJSON(object: any): SubredditAddRemovalReasonRequest;
    toJSON(message: SubredditAddRemovalReasonRequest): unknown;
    create(base?: DeepPartial_11<SubredditAddRemovalReasonRequest>): SubredditAddRemovalReasonRequest;
    fromPartial(object: DeepPartial_11<SubredditAddRemovalReasonRequest>): SubredditAddRemovalReasonRequest;
};

declare interface SubredditAddRemovalReasonResponse {
    /** Removal Reason ID */
    id: string;
}

declare const SubredditAddRemovalReasonResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonResponse";
    encode(message: SubredditAddRemovalReasonResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAddRemovalReasonResponse;
    fromJSON(object: any): SubredditAddRemovalReasonResponse;
    toJSON(message: SubredditAddRemovalReasonResponse): unknown;
    create(base?: DeepPartial_11<SubredditAddRemovalReasonResponse>): SubredditAddRemovalReasonResponse;
    fromPartial(object: DeepPartial_11<SubredditAddRemovalReasonResponse>): SubredditAddRemovalReasonResponse;
};

declare interface SubredditAutocompleteRequest {
    /** boolean value */
    includeOver18?: boolean | undefined;
    /** boolean value */
    includeProfiles?: boolean | undefined;
    /** an integer between 1 and 10 (default: 5) */
    limit?: number | undefined;
    /** a string up to 25 characters long, consisting of printable characters */
    query: string;
    /** a uuid */
    searchQueryId?: string | undefined;
    /** (optional) boolean value */
    typeaheadActive?: boolean | undefined;
}

declare const SubredditAutocompleteRequest: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteRequest";
    encode(message: SubredditAutocompleteRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAutocompleteRequest;
    fromJSON(object: any): SubredditAutocompleteRequest;
    toJSON(message: SubredditAutocompleteRequest): unknown;
    create(base?: DeepPartial_11<SubredditAutocompleteRequest>): SubredditAutocompleteRequest;
    fromPartial(object: DeepPartial_11<SubredditAutocompleteRequest>): SubredditAutocompleteRequest;
};

declare interface SubredditAutocompleteResponse {
    kind?: string | undefined;
    data?: SubredditAutocompleteResponse_AutocompleteResponse | undefined;
}

declare const SubredditAutocompleteResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse";
    encode(message: SubredditAutocompleteResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAutocompleteResponse;
    fromJSON(object: any): SubredditAutocompleteResponse;
    toJSON(message: SubredditAutocompleteResponse): unknown;
    create(base?: DeepPartial_11<SubredditAutocompleteResponse>): SubredditAutocompleteResponse;
    fromPartial(object: DeepPartial_11<SubredditAutocompleteResponse>): SubredditAutocompleteResponse;
};

declare interface SubredditAutocompleteResponse_AutocompleteAccount {
    isEmployee?: boolean | undefined;
    isFriend?: boolean | undefined;
    snoovatarSize?: number | undefined;
    id?: string | undefined;
    verified?: boolean | undefined;
    isGold?: boolean | undefined;
    isMod?: boolean | undefined;
    hasVerifiedEmail?: boolean | undefined;
    iconImg?: string | undefined;
    hideFromRobots?: boolean | undefined;
    linkKarma?: number | undefined;
    acceptChats?: boolean | undefined;
    isBlocked?: boolean | undefined;
    prefShowSnoovatar?: boolean | undefined;
    name?: string | undefined;
    created?: number | undefined;
    createdUtc?: number | undefined;
    snoovatarImg?: string | undefined;
    commentKarma?: number | undefined;
    acceptFollowers?: boolean | undefined;
    hasSubscribed?: boolean | undefined;
    acceptPms?: boolean | undefined;
}

declare const SubredditAutocompleteResponse_AutocompleteAccount: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount";
    encode(message: SubredditAutocompleteResponse_AutocompleteAccount, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAutocompleteResponse_AutocompleteAccount;
    fromJSON(object: any): SubredditAutocompleteResponse_AutocompleteAccount;
    toJSON(message: SubredditAutocompleteResponse_AutocompleteAccount): unknown;
    create(base?: DeepPartial_11<SubredditAutocompleteResponse_AutocompleteAccount>): SubredditAutocompleteResponse_AutocompleteAccount;
    fromPartial(object: DeepPartial_11<SubredditAutocompleteResponse_AutocompleteAccount>): SubredditAutocompleteResponse_AutocompleteAccount;
};

declare interface SubredditAutocompleteResponse_AutocompleteAccount_Subreddit {
    defaultSet?: boolean | undefined;
    userIsContributor?: boolean | undefined;
    bannerImg?: string | undefined;
    allowedMediaInComments: string[];
    userIsBanned?: boolean | undefined;
    freeFormReports?: boolean | undefined;
    communityIcon?: string | undefined;
    showMedia?: boolean | undefined;
    iconColor?: string | undefined;
    userIsMuted?: boolean | undefined;
    displayName?: string | undefined;
    headerImg?: string | undefined;
    title?: string | undefined;
    previousNames: string[];
    over18?: boolean | undefined;
    iconSize: number[];
    primaryColor?: string | undefined;
    iconImg?: string | undefined;
    description?: string | undefined;
    submitLinkLabel?: string | undefined;
    headerSize?: number | undefined;
    restrictPosting?: boolean | undefined;
    restrictCommenting?: boolean | undefined;
    subscribers?: number | undefined;
    submitTextLabel?: string | undefined;
    isDefaultIcon?: boolean | undefined;
    inkFlairPosition?: string | undefined;
    displayNamePrefixed?: string | undefined;
    keyColor?: string | undefined;
    name?: string | undefined;
    isDefaultBanner?: boolean | undefined;
    url?: string | undefined;
    quarantine?: boolean | undefined;
    bannerSize?: number | undefined;
    userIsModerator?: boolean | undefined;
    acceptFollowers?: boolean | undefined;
    publicDescription?: string | undefined;
    linkFlairEnabled?: boolean | undefined;
    disableContributorRequests?: boolean | undefined;
    subredditType?: string | undefined;
    userIsSubscriber?: boolean | undefined;
}

declare const SubredditAutocompleteResponse_AutocompleteAccount_Subreddit: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount.Subreddit";
    encode(message: SubredditAutocompleteResponse_AutocompleteAccount_Subreddit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAutocompleteResponse_AutocompleteAccount_Subreddit;
    fromJSON(object: any): SubredditAutocompleteResponse_AutocompleteAccount_Subreddit;
    toJSON(message: SubredditAutocompleteResponse_AutocompleteAccount_Subreddit): unknown;
    create(base?: DeepPartial_11<SubredditAutocompleteResponse_AutocompleteAccount_Subreddit>): SubredditAutocompleteResponse_AutocompleteAccount_Subreddit;
    fromPartial(object: DeepPartial_11<SubredditAutocompleteResponse_AutocompleteAccount_Subreddit>): SubredditAutocompleteResponse_AutocompleteAccount_Subreddit;
};

declare interface SubredditAutocompleteResponse_AutocompleteResponse {
    after?: string | undefined;
    before?: string | undefined;
    dist?: number | undefined;
    childrenSubreddits: SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit[];
    childrenAccounts: SubredditAutocompleteResponse_WrappedAutoCompleteAccount[];
}

declare const SubredditAutocompleteResponse_AutocompleteResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteResponse";
    encode(message: SubredditAutocompleteResponse_AutocompleteResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAutocompleteResponse_AutocompleteResponse;
    fromJSON(object: any): SubredditAutocompleteResponse_AutocompleteResponse;
    toJSON(message: SubredditAutocompleteResponse_AutocompleteResponse): unknown;
    create(base?: DeepPartial_11<SubredditAutocompleteResponse_AutocompleteResponse>): SubredditAutocompleteResponse_AutocompleteResponse;
    fromPartial(object: DeepPartial_11<SubredditAutocompleteResponse_AutocompleteResponse>): SubredditAutocompleteResponse_AutocompleteResponse;
};

declare interface SubredditAutocompleteResponse_WrappedAutoCompleteAccount {
    kind: string;
    data?: SubredditAutocompleteResponse_AutocompleteAccount | undefined;
}

declare const SubredditAutocompleteResponse_WrappedAutoCompleteAccount: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteAccount";
    encode(message: SubredditAutocompleteResponse_WrappedAutoCompleteAccount, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAutocompleteResponse_WrappedAutoCompleteAccount;
    fromJSON(object: any): SubredditAutocompleteResponse_WrappedAutoCompleteAccount;
    toJSON(message: SubredditAutocompleteResponse_WrappedAutoCompleteAccount): unknown;
    create(base?: DeepPartial_11<SubredditAutocompleteResponse_WrappedAutoCompleteAccount>): SubredditAutocompleteResponse_WrappedAutoCompleteAccount;
    fromPartial(object: DeepPartial_11<SubredditAutocompleteResponse_WrappedAutoCompleteAccount>): SubredditAutocompleteResponse_WrappedAutoCompleteAccount;
};

declare interface SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit {
    kind: string;
    data?: FullSubredditObject | undefined;
}

declare const SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteSubreddit";
    encode(message: SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit;
    fromJSON(object: any): SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit;
    toJSON(message: SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit): unknown;
    create(base?: DeepPartial_11<SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit>): SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit;
    fromPartial(object: DeepPartial_11<SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit>): SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit;
};

export declare type SubredditCollectionsInput = {
    /** The t5_ id of the subreddit that contains the collections to be retrieved. */
    subredditId?: string;
};

declare interface SubredditCollectionsRequest {
    /** The subreddit id of the subreddit for which to fetch a list of the collections */
    srFullname?: string | undefined;
}

declare const SubredditCollectionsRequest: {
    $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsRequest";
    encode(message: SubredditCollectionsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditCollectionsRequest;
    fromJSON(object: any): SubredditCollectionsRequest;
    toJSON(message: SubredditCollectionsRequest): unknown;
    create(base?: DeepPartial_81<SubredditCollectionsRequest>): SubredditCollectionsRequest;
    fromPartial(object: DeepPartial_81<SubredditCollectionsRequest>): SubredditCollectionsRequest;
};

declare interface SubredditCollectionsResponse {
    /** A list of collections. */
    collections: CollectionResponse[];
}

declare const SubredditCollectionsResponse: {
    $type: "devvit.plugin.redditapi.postcollections.SubredditCollectionsResponse";
    encode(message: SubredditCollectionsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditCollectionsResponse;
    fromJSON(object: any): SubredditCollectionsResponse;
    toJSON(message: SubredditCollectionsResponse): unknown;
    create(base?: DeepPartial_81<SubredditCollectionsResponse>): SubredditCollectionsResponse;
    fromPartial(object: DeepPartial_81<SubredditCollectionsResponse>): SubredditCollectionsResponse;
};

declare interface SubredditContextActions {
    /** LinkedBundle.hostname */
    actorHostname: string;
    /** Return value from ContextAction.GetActions() */
    actions?: ContextActionList | undefined;
}

declare const SubredditContextActions: {
    $type: "devvit.gql.SubredditContextActions";
    encode(message: SubredditContextActions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditContextActions;
    fromJSON(object: any): SubredditContextActions;
    toJSON(message: SubredditContextActions): unknown;
    create(base?: DeepPartial_94<SubredditContextActions>): SubredditContextActions;
    fromPartial(object: DeepPartial_94<SubredditContextActions>): SubredditContextActions;
};

export declare type SubredditData = {
    id?: string;
    name?: string;
    displayName?: string;
    communityIcon?: string;
    keyColor?: string;
    subscribers?: number;
    primaryColor?: string;
    lastUpdated?: string;
    icon?: string;
};

declare interface SubredditGetRemovalReasonsRequest {
    /** The name of the subreddit without `r/` */
    subreddit: string;
}

declare const SubredditGetRemovalReasonsRequest: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsRequest";
    encode(message: SubredditGetRemovalReasonsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditGetRemovalReasonsRequest;
    fromJSON(object: any): SubredditGetRemovalReasonsRequest;
    toJSON(message: SubredditGetRemovalReasonsRequest): unknown;
    create(base?: DeepPartial_11<SubredditGetRemovalReasonsRequest>): SubredditGetRemovalReasonsRequest;
    fromPartial(object: DeepPartial_11<SubredditGetRemovalReasonsRequest>): SubredditGetRemovalReasonsRequest;
};

declare interface SubredditGetRemovalReasonsResponse {
    data: {
        [key: string]: SubredditGetRemovalReasonsResponse_SubredditRemovalReason;
    };
    /** Ordered list of Removal Reason IDs */
    order: string[];
}

declare const SubredditGetRemovalReasonsResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse";
    encode(message: SubredditGetRemovalReasonsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditGetRemovalReasonsResponse;
    fromJSON(object: any): SubredditGetRemovalReasonsResponse;
    toJSON(message: SubredditGetRemovalReasonsResponse): unknown;
    create(base?: DeepPartial_11<SubredditGetRemovalReasonsResponse>): SubredditGetRemovalReasonsResponse;
    fromPartial(object: DeepPartial_11<SubredditGetRemovalReasonsResponse>): SubredditGetRemovalReasonsResponse;
};

declare interface SubredditGetRemovalReasonsResponse_DataEntry {
    key: string;
    value?: SubredditGetRemovalReasonsResponse_SubredditRemovalReason | undefined;
}

declare const SubredditGetRemovalReasonsResponse_DataEntry: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse.DataEntry";
    encode(message: SubredditGetRemovalReasonsResponse_DataEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditGetRemovalReasonsResponse_DataEntry;
    fromJSON(object: any): SubredditGetRemovalReasonsResponse_DataEntry;
    toJSON(message: SubredditGetRemovalReasonsResponse_DataEntry): unknown;
    create(base?: DeepPartial_11<SubredditGetRemovalReasonsResponse_DataEntry>): SubredditGetRemovalReasonsResponse_DataEntry;
    fromPartial(object: DeepPartial_11<SubredditGetRemovalReasonsResponse_DataEntry>): SubredditGetRemovalReasonsResponse_DataEntry;
};

declare interface SubredditGetRemovalReasonsResponse_SubredditRemovalReason {
    /** Removal Reason ID */
    id: string;
    /** A message that will communicate to the user why their post was removed */
    message: string;
    /** Removal Reason title */
    title: string;
}

declare const SubredditGetRemovalReasonsResponse_SubredditRemovalReason: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse.SubredditRemovalReason";
    encode(message: SubredditGetRemovalReasonsResponse_SubredditRemovalReason, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditGetRemovalReasonsResponse_SubredditRemovalReason;
    fromJSON(object: any): SubredditGetRemovalReasonsResponse_SubredditRemovalReason;
    toJSON(message: SubredditGetRemovalReasonsResponse_SubredditRemovalReason): unknown;
    create(base?: DeepPartial_11<SubredditGetRemovalReasonsResponse_SubredditRemovalReason>): SubredditGetRemovalReasonsResponse_SubredditRemovalReason;
    fromPartial(object: DeepPartial_11<SubredditGetRemovalReasonsResponse_SubredditRemovalReason>): SubredditGetRemovalReasonsResponse_SubredditRemovalReason;
};

declare type SubredditLink = {
    e: typeof SUBREDDIT_LINK_ELEMENT;
    t: string;
    l: boolean;
};

/**
 * @borrows PrefixedRedditLinkOptions
 */
declare type SubredditLinkOptions = PrefixedRedditLinkOptions & {
    /**
     * Subreddit name without the "r/" prefix
     * @example { subredditName: "aww", showPrefix: true }
     */
    subredditName: string;
};

declare interface SubredditMetadataRequest {
    /** t5_ subreddit id */
    subreddit: string;
}

declare const SubredditMetadataRequest: {
    $type: "devvit.gateway.SubredditMetadataRequest";
    encode(message: SubredditMetadataRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditMetadataRequest;
    fromJSON(object: any): SubredditMetadataRequest;
    toJSON(message: SubredditMetadataRequest): unknown;
    create(base?: DeepPartial_93<SubredditMetadataRequest>): SubredditMetadataRequest;
    fromPartial(object: DeepPartial_93<SubredditMetadataRequest>): SubredditMetadataRequest;
};

declare interface SubredditMetadataResolver {
    GetSubredditMetadata(request: SubredditMetadataRequest, metadata?: Metadata): Promise<DevvitSubredditMetadata>;
}

declare class SubredditMetadataResolverClientImpl implements SubredditMetadataResolver {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_5, opts?: {
        service?: string;
    });
    GetSubredditMetadata(request: SubredditMetadataRequest, metadata?: Metadata): Promise<DevvitSubredditMetadata>;
}

declare type SubredditMetadataResolverDefinition = typeof SubredditMetadataResolverDefinition;

declare const SubredditMetadataResolverDefinition: {
    readonly name: "SubredditMetadataResolver";
    readonly fullName: "devvit.gateway.SubredditMetadataResolver";
    readonly methods: {
        readonly getSubredditMetadata: {
            readonly name: "GetSubredditMetadata";
            readonly requestType: {
                $type: "devvit.gateway.SubredditMetadataRequest";
                encode(message: SubredditMetadataRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): SubredditMetadataRequest;
                fromJSON(object: any): SubredditMetadataRequest;
                toJSON(message: SubredditMetadataRequest): unknown;
                create(base?: DeepPartial_93<SubredditMetadataRequest>): SubredditMetadataRequest;
                fromPartial(object: DeepPartial_93<SubredditMetadataRequest>): SubredditMetadataRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gql.DevvitSubredditMetadata";
                encode(message: DevvitSubredditMetadata, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DevvitSubredditMetadata;
                fromJSON(object: any): DevvitSubredditMetadata;
                toJSON(message: DevvitSubredditMetadata): unknown;
                create(base?: {
                    installedRemoteApps?: {
                        actor?: {
                            name?: string;
                            owner?: string;
                            version?: string;
                        } | undefined;
                        code?: string;
                        hostname?: string;
                        provides?: {
                            fullName?: string;
                            methods?: {
                                fullName?: string;
                                name?: string;
                                requestStream?: boolean;
                                responseStream?: boolean;
                                requestType?: string;
                                responseType?: string;
                            }[];
                            name?: string;
                            version?: string;
                        }[];
                        uses?: any[];
                        buildInfo?: {
                            created?: Date | undefined;
                            dependencies?: {
                                [x: string]: string | undefined;
                            };
                        } | undefined;
                        assetsUrl?: string | undefined;
                        assets?: {
                            [x: string]: string | undefined;
                        };
                    }[];
                    contextActions?: {
                        actorHostname?: string;
                        actions?: {
                            actions?: {
                                actionId?: string;
                                name?: string;
                                description?: string;
                                contexts?: {
                                    post?: boolean;
                                    comment?: boolean;
                                    subreddit?: boolean;
                                } | undefined;
                                users?: {
                                    moderator?: boolean;
                                    member?: boolean;
                                    loggedOut?: boolean;
                                } | undefined;
                                userInput?: {
                                    fields?: {
                                        fieldType?: ConfigFieldType_2;
                                        key?: string;
                                        prompt?: string;
                                        response?: string;
                                    }[];
                                } | undefined;
                                postFilters?: {
                                    currentApp?: boolean | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    }[];
                    errors?: {
                        message?: string;
                    }[];
                    installedAppsInfo?: {
                        slug?: string;
                        name?: string;
                    }[];
                } | undefined): DevvitSubredditMetadata;
                fromPartial(object: {
                    installedRemoteApps?: {
                        actor?: {
                            name?: string;
                            owner?: string;
                            version?: string;
                        } | undefined;
                        code?: string;
                        hostname?: string;
                        provides?: {
                            fullName?: string;
                            methods?: {
                                fullName?: string;
                                name?: string;
                                requestStream?: boolean;
                                responseStream?: boolean;
                                requestType?: string;
                                responseType?: string;
                            }[];
                            name?: string;
                            version?: string;
                        }[];
                        uses?: any[];
                        buildInfo?: {
                            created?: Date | undefined;
                            dependencies?: {
                                [x: string]: string | undefined;
                            };
                        } | undefined;
                        assetsUrl?: string | undefined;
                        assets?: {
                            [x: string]: string | undefined;
                        };
                    }[];
                    contextActions?: {
                        actorHostname?: string;
                        actions?: {
                            actions?: {
                                actionId?: string;
                                name?: string;
                                description?: string;
                                contexts?: {
                                    post?: boolean;
                                    comment?: boolean;
                                    subreddit?: boolean;
                                } | undefined;
                                users?: {
                                    moderator?: boolean;
                                    member?: boolean;
                                    loggedOut?: boolean;
                                } | undefined;
                                userInput?: {
                                    fields?: {
                                        fieldType?: ConfigFieldType_2;
                                        key?: string;
                                        prompt?: string;
                                        response?: string;
                                    }[];
                                } | undefined;
                                postFilters?: {
                                    currentApp?: boolean | undefined;
                                } | undefined;
                            }[];
                        } | undefined;
                    }[];
                    errors?: {
                        message?: string;
                    }[];
                    installedAppsInfo?: {
                        slug?: string;
                        name?: string;
                    }[];
                }): DevvitSubredditMetadata;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const SubredditMetadataResolverServiceName = "devvit.gateway.SubredditMetadataResolver";

/**
 * @privateRemarks
 * TODO: remove in favor of Subreddit
 * A SubredditObject represents a Subreddit (t5)
 */
declare interface SubredditObject {
    /**
     * @deprecated
     *
     * @deprecated
     */
    defaultSet?: boolean | undefined;
    /** If `true`, the current user has posted */
    userIsContributor?: boolean | undefined;
    /**
     * Banner image for old.reddit.com
     * @deprecated
     *
     * @deprecated
     */
    bannerImg?: string | undefined;
    /** If `true`, crowd control is enabled */
    restrictPosting?: boolean | undefined;
    /** If `true`, the current user is banned */
    userIsBanned?: boolean | undefined;
    /** If `true`, users are given the option to write a custom explanation when reporting content */
    freeFormReports?: boolean | undefined;
    /** URL to the custom icon as configured from www.reddit.com */
    communityIcon?: string | undefined;
    /**
     * If `true`, show thumbnail images of content is enabled on old.reddit.com
     * @deprecated
     *
     * @deprecated
     */
    showMedia?: boolean | undefined;
    /**
     * @deprecated
     *
     * @deprecated
     */
    iconColor?: string | undefined;
    /**
     * Permanent identifier
     * @example "AskReddit"
     */
    displayName?: string | undefined;
    /**
     * URL to the custom header icon as configured from old.reddit.com
     * @deprecated
     *
     * @deprecated
     */
    headerImg?: string | undefined;
    /**
     * Current, editable name
     * @example "Ask Reddit Something"
     */
    title?: string | undefined;
    /** Community coin balance */
    coins?: number | undefined;
    /**
     * @deprecated
     *
     * @deprecated
     */
    previousNames: string[];
    /** If `true`, this community contains content deemed not-safe-for-work (NSFW) */
    over18?: boolean | undefined;
    /**
     * Resolution of icon_img
     * Format: [width, height]
     * @deprecated
     *
     * @deprecated
     */
    iconSize: number[];
    /**
     * Theme base color as a # prefixed hex color, configured on www.reddit.com
     * @example "#FF4500"
     */
    primaryColor?: string | undefined;
    /**
     * URL to the custom community icon as configured from old.reddit.com as the mobile icon image
     * Note: used as a fallback if community_icon_img is not set
     * @deprecated
     *
     * @deprecated
     */
    iconImg?: string | undefined;
    /**
     * Sidebar description displayed on old.reddit.com
     * @deprecated
     *
     * @deprecated
     */
    description?: string | undefined;
    /**
     * Custom label for the Submit Link button when viewed on old.reddit.com
     * @deprecated
     *
     * @deprecated
     */
    submitLinkLabel?: string | undefined;
    /**
     * Resolution of header_img
     * Note: Incorrectly typed and unusable.
     * @deprecated
     *
     * @deprecated
     */
    headerSize?: string | undefined;
    /** If `true`, crowd control is currently enabled */
    restrictCommenting?: boolean | undefined;
    /** Current count of subscribed users */
    subscribers?: number | undefined;
    /**
     * Custom label for the Submit Text Post button when viewed on old.reddit.com
     * @deprecated
     */
    submitTextLabel?: string | undefined;
    /**
     * If `true`, this Subreddit is using the default icon
     * @deprecated
     *
     * @deprecated
     */
    isDefaultIcon?: boolean | undefined;
    /**
     * Where flair should be shown relative to the Post title on old.reddit.com
     * One of: "left", "right", ""
     * @deprecated
     *
     * @deprecated
     */
    linkFlairPosition?: string | undefined;
    /**
     * Permanent identifier with the leading "r/" prefix
     * @example "r/AskReddit"
     */
    displayNamePrefixed?: string | undefined;
    /**
     * Mobile theme color as configured on old.reddit.com
     * @deprecated
     *
     * @deprecated
     */
    keyColor?: string | undefined;
    /**
     * Thing ID for this object
     * @example "t5_abc123"
     */
    name?: string | undefined;
    /**
     * If `true`, this Subreddit is using the default banner without customizing it
     *
     * @deprecated
     */
    isDefaultBanner?: boolean | undefined;
    /**
     * The path of this object relative to www.reddit.com
     * @example "/r/AskReddit/"
     */
    url?: string | undefined;
    /** If `true`, this Subreddit has been put in quarantine for breaking site rules */
    quarantine?: boolean | undefined;
    /**
     * Resolution of banner_img
     * Format: [width, height]
     * @deprecated
     *
     * @deprecated
     */
    bannerSize: number[];
    /** If `true`, the current user is a moderator */
    userIsModerator?: boolean | undefined;
    /** If `true`, users can join */
    acceptFollowers?: boolean | undefined;
    /** Plain text description */
    publicDescription?: string | undefined;
    /** If `true`, Post Flair is enabled */
    linkFlairEnabled?: boolean | undefined;
    /** If `true`, users may not request access to join */
    disableContributorRequests?: boolean | undefined;
    /**
     * One of: "public", "private", "restricted", "gold_only", "gold_restricted",
     *         "archived", "user", "employees_only"
     */
    subredditType?: string | undefined;
    /** If `true`, the current user has joined */
    userIsSubscriber?: boolean | undefined;
    /** Pre-rendered HTML representing public_description */
    publicDescriptionHtml?: string | undefined;
    /**
     * Thing ID without leading thing ID prefix
     * @example "abc123" // for: t5_abc123
     */
    id?: string | undefined;
    /** If `true`, the current user may not send messages to moderators */
    userIsMuted: boolean;
}

declare const SubredditObject: {
    $type: "devvit.plugin.redditapi.common.SubredditObject";
    encode(message: SubredditObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditObject;
    fromJSON(object: any): SubredditObject;
    toJSON(message: SubredditObject): unknown;
    create(base?: DeepPartial_8<SubredditObject>): SubredditObject;
    fromPartial(object: DeepPartial_8<SubredditObject>): SubredditObject;
};

declare interface SubredditPostRequirementsResponse {
    titleRegexes: string[];
    bodyBlacklistedStrings: string[];
    titleBlacklistedStrings: string[];
    bodyTextMaxLength?: number | undefined;
    titleRequiredStrings: string[];
    guidelinesText?: string | undefined;
    galleryMinItems?: number | undefined;
    domainBlacklist: string[];
    domainWhitelist: string[];
    titleTextMaxLength?: number | undefined;
    bodyRestrictionPolicy?: string | undefined;
    linkRestrictionPolicy?: string | undefined;
    guidelinesDisplayPolicy?: string | undefined;
    bodyRequiredStrings: string[];
    titleTextMinLength?: number | undefined;
    galleryCaptionsRequirement?: string | undefined;
    isFlairRequired?: boolean | undefined;
    galleryMaxItems?: number | undefined;
    galleryUrlsRequirement?: string | undefined;
    bodyRegexes: string[];
    linkRepostAge?: number | undefined;
    bodyTextMinLength?: number | undefined;
}

declare const SubredditPostRequirementsResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditPostRequirementsResponse";
    encode(message: SubredditPostRequirementsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditPostRequirementsResponse;
    fromJSON(object: any): SubredditPostRequirementsResponse;
    toJSON(message: SubredditPostRequirementsResponse): unknown;
    create(base?: DeepPartial_11<SubredditPostRequirementsResponse>): SubredditPostRequirementsResponse;
    fromPartial(object: DeepPartial_11<SubredditPostRequirementsResponse>): SubredditPostRequirementsResponse;
};

/** used with data-api */
declare enum SubredditRating {
    UNKNOWN_SUBREDDIT_RATING = 0,
    /** E - everyone */
    E = 1,
    /** M1 - mature 1 */
    M1 = 2,
    /** M2 - mature 2 */
    M2 = 3,
    /** D - high-risk drug use */
    D = 4,
    /** V - violence & gore */
    V = 5,
    /** X - sexually explicit */
    X = 6,
    UNRECOGNIZED = -1
}

declare function subredditRatingFromJSON(object: any): SubredditRating;

declare function subredditRatingToJSON(object: SubredditRating): number;

declare type SubredditRule = {
    description: string;
    priority: number;
    shortName: string;
    violationReason: string;
};

export declare class SubredditRulesWidget extends Widget {
    #private;
    constructor(subredditAboutRulesRsp: SubredditAboutRulesResponse, widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get rules(): SubredditRule[];
    toJSON(): ReturnType<Widget['toJSON']> & Pick<SubredditRulesWidget, 'rules'>;
}

/** SUBREDDITS - https://www.reddit.com/dev/api#section_subreddits */
declare interface Subreddits {
    /** https://www.reddit.com/dev/api#GET_about_\{where\} */
    AboutWhere(request: AboutWhereRequest, metadata?: Metadata): Promise<Listing_2>;
    /** https://www.reddit.com/dev/api#POST_api_delete_sr_banner */
    DeleteSrBanner(request: BasicSubredditRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_delete_sr_header */
    DeleteSrHeader(request: BasicSubredditRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_delete_sr_icon */
    DeleteSrIcon(request: BasicSubredditRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_delete_sr_img */
    DeleteSrImg(request: DeleteSrImgRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_search_reddit_names */
    SearchRedditNames(request: BasicSearchRequest, metadata?: Metadata): Promise<SearchRedditNamesResponse>;
    /** https://www.reddit.com/dev/api#POST_api_search_subreddits */
    SearchSubreddits(request: BasicSearchRequest, metadata?: Metadata): Promise<SearchSubredditsResponse>;
    /** https://www.reddit.com/dev/api#POST_api_site_admin */
    SiteAdmin(request: SiteAdminRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#GET_api_submit_text */
    SubmitText(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubmitTextResponse>;
    /**
     * TODO: this seems to return a Listing, not a SubredditAutocompleteResponse.
     * https://www.reddit.com/dev/api#GET_api_subreddit_autocomplete_v2
     */
    SubredditAutocomplete(request: SubredditAutocompleteRequest, metadata?: Metadata): Promise<SubredditAutocompleteResponse>;
    /** https://www.reddit.com/dev/api#POST_api_subreddit_stylesheet */
    SubredditStylesheet(request: SubredditStylesheetRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_subscribe */
    Subscribe(request: SubscribeRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_upload_sr_img */
    UploadSrImg(request: UploadSrImgRequest, metadata?: Metadata): Promise<UploadSrImgResponse>;
    /** https://www.reddit.com/dev/api#GET_api_v1_\{subreddit\}_post_requirements */
    SubredditPostRequirements(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubredditPostRequirementsResponse>;
    /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about */
    SubredditAbout(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubredditAboutResponse>;
    /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about_edit */
    SubredditAboutEdit(request: SubredditAboutEditRequest, metadata?: Metadata): Promise<SubredditAboutEditResponse>;
    /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about_rules */
    SubredditAboutRules(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubredditAboutRulesResponse>;
    /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about_traffic */
    SubredditAboutTraffic(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubredditAboutTrafficResponse>;
    /** https://www.reddit.com/dev/api#GET_sidebar */
    Sidebar(request: BasicSubredditRequest, metadata?: Metadata): Promise<StringValue>;
    /** https://www.reddit.com/dev/api#GET_sticky */
    Sticky(request: StickyRequest, metadata?: Metadata): Promise<StickyResponse>;
    /** https://www.reddit.com/dev/api#GET_subreddits_mine_\{where\} */
    SubredditsMineWhere(request: BasicWhereRequest, metadata?: Metadata): Promise<Listing_2>;
    /**
     * https://www.reddit.com/dev/api#GET_subreddits_search
     * Make Wrapped
     */
    SubredditsSearch(request: SubredditsSearchRequest, metadata?: Metadata): Promise<SubredditsSearchResponse>;
    /** https://www.reddit.com/dev/api#GET_subreddits_\{where\} */
    SubredditsWhere(request: BasicWhereRequest, metadata?: Metadata): Promise<SubredditsSearchResponse>;
    /** https://www.reddit.com/dev/api#GET_users_search */
    UsersSearch(request: UsersSearchRequest, metadata?: Metadata): Promise<UserSearchResponse>;
    /** https://www.reddit.com/dev/api#GET_users_\{where\} */
    UsersWhere(request: BasicWhereRequest, metadata?: Metadata): Promise<SubredditsSearchResponse>;
    /**
     * Add a removal reason to a subreddit.
     *
     * POST /api/v1/{subreddit}/removal_reasons
     */
    SubredditAddRemovalReason(request: SubredditAddRemovalReasonRequest, metadata?: Metadata): Promise<SubredditAddRemovalReasonResponse>;
    /**
     * Get the list of subreddit's removal reasons.
     *
     * GET /api/v1/{subreddit}/removal_reasons
     */
    SubredditGetRemovalReasons(request: SubredditGetRemovalReasonsRequest, metadata?: Metadata): Promise<SubredditGetRemovalReasonsResponse>;
}

declare class SubredditsClientImpl implements Subreddits {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_51, opts?: {
        service?: string;
    });
    AboutWhere(request: AboutWhereRequest, metadata?: Metadata): Promise<Listing_2>;
    DeleteSrBanner(request: BasicSubredditRequest, metadata?: Metadata): Promise<JsonStatus>;
    DeleteSrHeader(request: BasicSubredditRequest, metadata?: Metadata): Promise<JsonStatus>;
    DeleteSrIcon(request: BasicSubredditRequest, metadata?: Metadata): Promise<JsonStatus>;
    DeleteSrImg(request: DeleteSrImgRequest, metadata?: Metadata): Promise<JsonStatus>;
    SearchRedditNames(request: BasicSearchRequest, metadata?: Metadata): Promise<SearchRedditNamesResponse>;
    SearchSubreddits(request: BasicSearchRequest, metadata?: Metadata): Promise<SearchSubredditsResponse>;
    SiteAdmin(request: SiteAdminRequest, metadata?: Metadata): Promise<JsonStatus>;
    SubmitText(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubmitTextResponse>;
    SubredditAutocomplete(request: SubredditAutocompleteRequest, metadata?: Metadata): Promise<SubredditAutocompleteResponse>;
    SubredditStylesheet(request: SubredditStylesheetRequest, metadata?: Metadata): Promise<JsonStatus>;
    Subscribe(request: SubscribeRequest, metadata?: Metadata): Promise<Empty>;
    UploadSrImg(request: UploadSrImgRequest, metadata?: Metadata): Promise<UploadSrImgResponse>;
    SubredditPostRequirements(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubredditPostRequirementsResponse>;
    SubredditAbout(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubredditAboutResponse>;
    SubredditAboutEdit(request: SubredditAboutEditRequest, metadata?: Metadata): Promise<SubredditAboutEditResponse>;
    SubredditAboutRules(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubredditAboutRulesResponse>;
    SubredditAboutTraffic(request: BasicSubredditRequest, metadata?: Metadata): Promise<SubredditAboutTrafficResponse>;
    Sidebar(request: BasicSubredditRequest, metadata?: Metadata): Promise<StringValue>;
    Sticky(request: StickyRequest, metadata?: Metadata): Promise<StickyResponse>;
    SubredditsMineWhere(request: BasicWhereRequest, metadata?: Metadata): Promise<Listing_2>;
    SubredditsSearch(request: SubredditsSearchRequest, metadata?: Metadata): Promise<SubredditsSearchResponse>;
    SubredditsWhere(request: BasicWhereRequest, metadata?: Metadata): Promise<SubredditsSearchResponse>;
    UsersSearch(request: UsersSearchRequest, metadata?: Metadata): Promise<UserSearchResponse>;
    UsersWhere(request: BasicWhereRequest, metadata?: Metadata): Promise<SubredditsSearchResponse>;
    SubredditAddRemovalReason(request: SubredditAddRemovalReasonRequest, metadata?: Metadata): Promise<SubredditAddRemovalReasonResponse>;
    SubredditGetRemovalReasons(request: SubredditGetRemovalReasonsRequest, metadata?: Metadata): Promise<SubredditGetRemovalReasonsResponse>;
}

/** SUBREDDITS - https://www.reddit.com/dev/api#section_subreddits */
declare type SubredditsDefinition = typeof SubredditsDefinition;

declare const SubredditsDefinition: {
    readonly name: "Subreddits";
    readonly fullName: "devvit.plugin.redditapi.subreddits.Subreddits";
    readonly methods: {
        /** https://www.reddit.com/dev/api#GET_about_\{where\} */
        readonly aboutWhere: {
            readonly name: "AboutWhere";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.AboutWhereRequest";
                encode(message: AboutWhereRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AboutWhereRequest;
                fromJSON(object: any): AboutWhereRequest;
                toJSON(message: AboutWhereRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    user?: string | undefined;
                    subreddit?: string | undefined;
                    where?: string;
                } | undefined): AboutWhereRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    user?: string | undefined;
                    subreddit?: string | undefined;
                    where?: string;
                }): AboutWhereRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api#POST_api_delete_sr_banner */
        readonly deleteSrBanner: {
            readonly name: "DeleteSrBanner";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
                encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSubredditRequest;
                fromJSON(object: any): BasicSubredditRequest;
                toJSON(message: BasicSubredditRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): BasicSubredditRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): BasicSubredditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_delete_sr_header */
        readonly deleteSrHeader: {
            readonly name: "DeleteSrHeader";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
                encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSubredditRequest;
                fromJSON(object: any): BasicSubredditRequest;
                toJSON(message: BasicSubredditRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): BasicSubredditRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): BasicSubredditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_delete_sr_icon */
        readonly deleteSrIcon: {
            readonly name: "DeleteSrIcon";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
                encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSubredditRequest;
                fromJSON(object: any): BasicSubredditRequest;
                toJSON(message: BasicSubredditRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): BasicSubredditRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): BasicSubredditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_delete_sr_img */
        readonly deleteSrImg: {
            readonly name: "DeleteSrImg";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.DeleteSrImgRequest";
                encode(message: DeleteSrImgRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DeleteSrImgRequest;
                fromJSON(object: any): DeleteSrImgRequest;
                toJSON(message: DeleteSrImgRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    imgName?: string;
                } | undefined): DeleteSrImgRequest;
                fromPartial(object: {
                    subreddit?: string;
                    imgName?: string;
                }): DeleteSrImgRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_search_reddit_names */
        readonly searchRedditNames: {
            readonly name: "SearchRedditNames";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSearchRequest";
                encode(message: BasicSearchRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSearchRequest;
                fromJSON(object: any): BasicSearchRequest;
                toJSON(message: BasicSearchRequest): unknown;
                create(base?: {
                    exact?: boolean | undefined;
                    includeOver18?: boolean | undefined;
                    includeUnadvertisable?: boolean | undefined;
                    query?: string;
                    searchQueryId?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                } | undefined): BasicSearchRequest;
                fromPartial(object: {
                    exact?: boolean | undefined;
                    includeOver18?: boolean | undefined;
                    includeUnadvertisable?: boolean | undefined;
                    query?: string;
                    searchQueryId?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                }): BasicSearchRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SearchRedditNamesResponse";
                encode(message: SearchRedditNamesResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SearchRedditNamesResponse;
                fromJSON(object: any): SearchRedditNamesResponse;
                toJSON(message: SearchRedditNamesResponse): unknown;
                create(base?: {
                    names?: string[];
                } | undefined): SearchRedditNamesResponse;
                fromPartial(object: {
                    names?: string[];
                }): SearchRedditNamesResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_search_subreddits */
        readonly searchSubreddits: {
            readonly name: "SearchSubreddits";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSearchRequest";
                encode(message: BasicSearchRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSearchRequest;
                fromJSON(object: any): BasicSearchRequest;
                toJSON(message: BasicSearchRequest): unknown;
                create(base?: {
                    exact?: boolean | undefined;
                    includeOver18?: boolean | undefined;
                    includeUnadvertisable?: boolean | undefined;
                    query?: string;
                    searchQueryId?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                } | undefined): BasicSearchRequest;
                fromPartial(object: {
                    exact?: boolean | undefined;
                    includeOver18?: boolean | undefined;
                    includeUnadvertisable?: boolean | undefined;
                    query?: string;
                    searchQueryId?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                }): BasicSearchRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SearchSubredditsResponse";
                encode(message: SearchSubredditsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SearchSubredditsResponse;
                fromJSON(object: any): SearchSubredditsResponse;
                toJSON(message: SearchSubredditsResponse): unknown;
                create(base?: {
                    subreddits?: {
                        activeUserCount?: number | undefined;
                        iconImg?: string | undefined;
                        keyColor?: string | undefined;
                        name?: string | undefined;
                        subscriberCount?: number | undefined;
                        isChatPostFeatureEnabled?: boolean | undefined;
                        allowChatPostCreation?: boolean | undefined;
                        allowImages?: boolean | undefined;
                    }[];
                } | undefined): SearchSubredditsResponse;
                fromPartial(object: {
                    subreddits?: {
                        activeUserCount?: number | undefined;
                        iconImg?: string | undefined;
                        keyColor?: string | undefined;
                        name?: string | undefined;
                        subscriberCount?: number | undefined;
                        isChatPostFeatureEnabled?: boolean | undefined;
                        allowChatPostCreation?: boolean | undefined;
                        allowImages?: boolean | undefined;
                    }[];
                }): SearchSubredditsResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_site_admin */
        readonly siteAdmin: {
            readonly name: "SiteAdmin";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.SiteAdminRequest";
                encode(message: SiteAdminRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SiteAdminRequest;
                fromJSON(object: any): SiteAdminRequest;
                toJSON(message: SiteAdminRequest): unknown;
                create(base?: {
                    acceptFollowers?: boolean;
                    adminOverrideSpamComments?: boolean;
                    adminOverrideSpamLinks?: boolean;
                    adminOverrideSpamSelfposts?: boolean;
                    allOriginalContent?: boolean;
                    allowChatPostCreation?: boolean;
                    allowDiscovery?: boolean;
                    allowGalleries?: boolean;
                    allowImages?: boolean;
                    allowPolls?: boolean;
                    allowPostCrossposts?: boolean;
                    allowPredictionContributors?: boolean;
                    allowPredictions?: boolean;
                    allowPredictionsTournament?: boolean;
                    allowTalks?: boolean;
                    allowTop?: boolean;
                    allowVideos?: boolean;
                    banEvasionThreshold?: number;
                    collapseDeletedComments?: boolean;
                    commentContributionSettings?: {
                        allowedMediaTypes?: string[];
                    } | undefined;
                    commentScoreHideMins?: number;
                    crowdControlFilter?: boolean;
                    crowdControlLevel?: number;
                    crowdControlMode?: boolean;
                    crowdControlPostLevel?: number;
                    description?: string;
                    disableContributorRequests?: boolean;
                    excludeBannedModqueue?: boolean;
                    freeFormReports?: boolean;
                    gRecaptchaResponse?: string;
                    hatefulContentThresholdAbuse?: number;
                    hatefulContentThresholdIdentity?: number;
                    headerTitle?: string;
                    keyColor?: string;
                    linkType?: string;
                    name?: string;
                    newPinnedPostPnsEnabled?: boolean;
                    originalContentTagEnabled?: boolean;
                    over18?: boolean;
                    predictionLeaderboardEntryType?: number;
                    publicDescription?: string;
                    restrictCommenting?: boolean;
                    restrictPosting?: boolean;
                    shouldArchivePosts?: boolean;
                    showMedia?: boolean;
                    showMediaPreview?: boolean;
                    spamComments?: string;
                    spamLinks?: string;
                    spamSelfposts?: string;
                    spoilersEnabled?: boolean;
                    sr?: string;
                    submitLinkLabel?: string;
                    submitText?: string;
                    submitTextLabel?: string;
                    suggestedCommentSort?: string;
                    title?: string;
                    toxicityThresholdChatLevel?: number;
                    type?: string;
                    userFlairPnsEnabled?: boolean;
                    welcomeMessageEnabled?: boolean;
                    welcomeMessageText?: string;
                    wikiEditAge?: number;
                    wikiEditKarma?: number;
                    wikimode?: string;
                    crowdControlChatLevel?: number;
                    hideAds?: boolean;
                    modmailHarassmentFilterEnabled?: boolean;
                } | undefined): SiteAdminRequest;
                fromPartial(object: {
                    acceptFollowers?: boolean;
                    adminOverrideSpamComments?: boolean;
                    adminOverrideSpamLinks?: boolean;
                    adminOverrideSpamSelfposts?: boolean;
                    allOriginalContent?: boolean;
                    allowChatPostCreation?: boolean;
                    allowDiscovery?: boolean;
                    allowGalleries?: boolean;
                    allowImages?: boolean;
                    allowPolls?: boolean;
                    allowPostCrossposts?: boolean;
                    allowPredictionContributors?: boolean;
                    allowPredictions?: boolean;
                    allowPredictionsTournament?: boolean;
                    allowTalks?: boolean;
                    allowTop?: boolean;
                    allowVideos?: boolean;
                    banEvasionThreshold?: number;
                    collapseDeletedComments?: boolean;
                    commentContributionSettings?: {
                        allowedMediaTypes?: string[];
                    } | undefined;
                    commentScoreHideMins?: number;
                    crowdControlFilter?: boolean;
                    crowdControlLevel?: number;
                    crowdControlMode?: boolean;
                    crowdControlPostLevel?: number;
                    description?: string;
                    disableContributorRequests?: boolean;
                    excludeBannedModqueue?: boolean;
                    freeFormReports?: boolean;
                    gRecaptchaResponse?: string;
                    hatefulContentThresholdAbuse?: number;
                    hatefulContentThresholdIdentity?: number;
                    headerTitle?: string;
                    keyColor?: string;
                    linkType?: string;
                    name?: string;
                    newPinnedPostPnsEnabled?: boolean;
                    originalContentTagEnabled?: boolean;
                    over18?: boolean;
                    predictionLeaderboardEntryType?: number;
                    publicDescription?: string;
                    restrictCommenting?: boolean;
                    restrictPosting?: boolean;
                    shouldArchivePosts?: boolean;
                    showMedia?: boolean;
                    showMediaPreview?: boolean;
                    spamComments?: string;
                    spamLinks?: string;
                    spamSelfposts?: string;
                    spoilersEnabled?: boolean;
                    sr?: string;
                    submitLinkLabel?: string;
                    submitText?: string;
                    submitTextLabel?: string;
                    suggestedCommentSort?: string;
                    title?: string;
                    toxicityThresholdChatLevel?: number;
                    type?: string;
                    userFlairPnsEnabled?: boolean;
                    welcomeMessageEnabled?: boolean;
                    welcomeMessageText?: string;
                    wikiEditAge?: number;
                    wikiEditKarma?: number;
                    wikimode?: string;
                    crowdControlChatLevel?: number;
                    hideAds?: boolean;
                    modmailHarassmentFilterEnabled?: boolean;
                }): SiteAdminRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_submit_text */
        readonly submitText: {
            readonly name: "SubmitText";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
                encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSubredditRequest;
                fromJSON(object: any): BasicSubredditRequest;
                toJSON(message: BasicSubredditRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): BasicSubredditRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): BasicSubredditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubmitTextResponse";
                encode(message: SubmitTextResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubmitTextResponse;
                fromJSON(object: any): SubmitTextResponse;
                toJSON(message: SubmitTextResponse): unknown;
                create(base?: {
                    submitText?: string | undefined;
                    submitTextHtml?: string | undefined;
                } | undefined): SubmitTextResponse;
                fromPartial(object: {
                    submitText?: string | undefined;
                    submitTextHtml?: string | undefined;
                }): SubmitTextResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * TODO: this seems to return a Listing, not a SubredditAutocompleteResponse.
         * https://www.reddit.com/dev/api#GET_api_subreddit_autocomplete_v2
         */
        readonly subredditAutocomplete: {
            readonly name: "SubredditAutocomplete";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteRequest";
                encode(message: SubredditAutocompleteRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditAutocompleteRequest;
                fromJSON(object: any): SubredditAutocompleteRequest;
                toJSON(message: SubredditAutocompleteRequest): unknown;
                create(base?: {
                    includeOver18?: boolean | undefined;
                    includeProfiles?: boolean | undefined;
                    limit?: number | undefined;
                    query?: string;
                    searchQueryId?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                } | undefined): SubredditAutocompleteRequest;
                fromPartial(object: {
                    includeOver18?: boolean | undefined;
                    includeProfiles?: boolean | undefined;
                    limit?: number | undefined;
                    query?: string;
                    searchQueryId?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                }): SubredditAutocompleteRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse";
                encode(message: SubredditAutocompleteResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditAutocompleteResponse;
                fromJSON(object: any): SubredditAutocompleteResponse;
                toJSON(message: SubredditAutocompleteResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        childrenSubreddits?: {
                            kind?: string;
                            data?: {
                                userFlairBackgroundColor?: string | undefined;
                                submitTextHtml?: string | undefined;
                                restrictPosting?: boolean | undefined;
                                userIsBanned?: boolean | undefined;
                                freeFormReports?: boolean | undefined;
                                wikiEnabled?: boolean | undefined;
                                userIsMuted?: boolean | undefined;
                                userCanFlairInSr?: boolean | undefined;
                                displayName?: string | undefined;
                                headerImg?: string | undefined;
                                title?: string | undefined;
                                allowGalleries?: boolean | undefined;
                                iconSize?: number[];
                                primaryColor?: string | undefined;
                                activeUserCount?: number | undefined;
                                iconImg?: string | undefined;
                                displayNamePrefixed?: string | undefined;
                                accountsActive?: number | undefined;
                                publicTraffic?: boolean | undefined;
                                subscribers?: number | undefined;
                                userFlairRichtext?: string[];
                                videostreamLinksCount?: number | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                hideAds?: boolean | undefined;
                                emojisEnabled?: boolean | undefined;
                                advertiserCategory?: string | undefined;
                                publicDescription?: string | undefined;
                                commentScoreHideMins?: number | undefined;
                                allowPredictions?: boolean | undefined;
                                userHasFavorited?: boolean | undefined;
                                userFlairTemplateId?: string | undefined;
                                communityIcon?: string | undefined;
                                bannerBackgroundImage?: string | undefined;
                                originalContentTagEnabled?: boolean | undefined;
                                communityReviewed?: boolean | undefined;
                                submitText?: string | undefined;
                                descriptionHtml?: string | undefined;
                                spoilersEnabled?: boolean | undefined;
                                commentContributionSettings?: {
                                    allowedMediaTypes?: string[];
                                } | undefined;
                                allowTalks?: boolean | undefined;
                                headerSize?: number[];
                                userFlairPosition?: string | undefined;
                                allOriginalContent?: boolean | undefined;
                                hasMenuWidget?: boolean | undefined;
                                isEnrolledInNewModmail?: boolean | undefined;
                                keyColor?: string | undefined;
                                canAssignUserFlair?: boolean | undefined;
                                created?: number | undefined;
                                wls?: number | undefined;
                                showMediaPreview?: boolean | undefined;
                                submissionType?: string | undefined;
                                userIsSubscriber?: boolean | undefined;
                                allowedMediaInComments?: string[];
                                allowVideogifs?: boolean | undefined;
                                shouldArchivePosts?: boolean | undefined;
                                userFlairType?: string | undefined;
                                allowPolls?: boolean | undefined;
                                collapseDeletedComments?: boolean | undefined;
                                emojisCustomSize?: number[];
                                publicDescriptionHtml?: string | undefined;
                                allowVideos?: boolean | undefined;
                                isCrosspostableSubreddit?: boolean | undefined;
                                notificationLevel?: string | undefined;
                                shouldShowMediaInCommentsSetting?: boolean | undefined;
                                canAssignLinkFlair?: boolean | undefined;
                                accountsActiveIsFuzzed?: boolean | undefined;
                                allowPredictionContributors?: boolean | undefined;
                                submitTextLabel?: string | undefined;
                                linkFlairPosition?: string | undefined;
                                userSrFlairEnabled?: boolean | undefined;
                                userFlairEnabledInSr?: boolean | undefined;
                                allowChatPostCreation?: boolean | undefined;
                                allowDiscovery?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                userSrThemeEnabled?: boolean | undefined;
                                linkFlairEnabled?: boolean | undefined;
                                disableContributorRequests?: boolean | undefined;
                                subredditType?: string | undefined;
                                suggestedCommentSort?: string | undefined;
                                bannerImg?: string | undefined;
                                userFlairText?: string | undefined;
                                contentCategory?: string | undefined;
                                bannerBackgroundColor?: string | undefined;
                                showMedia?: boolean | undefined;
                                id?: string | undefined;
                                userIsModerator?: boolean | undefined;
                                over18?: boolean | undefined;
                                headerTitle?: string | undefined;
                                description?: string | undefined;
                                isChatPostFeatureEnabled?: boolean | undefined;
                                submitLinkLabel?: string | undefined;
                                userFlairTextColor?: string | undefined;
                                restrictCommenting?: boolean | undefined;
                                userFlairCssClass?: string | undefined;
                                allowImages?: boolean | undefined;
                                lang?: string | undefined;
                                whitelistStatus?: string | undefined;
                                url?: string | undefined;
                                createdUtc?: number | undefined;
                                bannerSize?: number[];
                                mobileBannerImage?: string | undefined;
                                userIsContributor?: boolean | undefined;
                                allowPredictionsTournament?: boolean | undefined;
                            } | undefined;
                        }[];
                        childrenAccounts?: {
                            kind?: string;
                            data?: {
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                snoovatarSize?: number | undefined;
                                id?: string | undefined;
                                verified?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                iconImg?: string | undefined;
                                hideFromRobots?: boolean | undefined;
                                linkKarma?: number | undefined;
                                acceptChats?: boolean | undefined;
                                isBlocked?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                name?: string | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                snoovatarImg?: string | undefined;
                                commentKarma?: number | undefined;
                                acceptFollowers?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                } | undefined): SubredditAutocompleteResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        childrenSubreddits?: {
                            kind?: string;
                            data?: {
                                userFlairBackgroundColor?: string | undefined;
                                submitTextHtml?: string | undefined;
                                restrictPosting?: boolean | undefined;
                                userIsBanned?: boolean | undefined;
                                freeFormReports?: boolean | undefined;
                                wikiEnabled?: boolean | undefined;
                                userIsMuted?: boolean | undefined;
                                userCanFlairInSr?: boolean | undefined;
                                displayName?: string | undefined;
                                headerImg?: string | undefined;
                                title?: string | undefined;
                                allowGalleries?: boolean | undefined;
                                iconSize?: number[];
                                primaryColor?: string | undefined;
                                activeUserCount?: number | undefined;
                                iconImg?: string | undefined;
                                displayNamePrefixed?: string | undefined;
                                accountsActive?: number | undefined;
                                publicTraffic?: boolean | undefined;
                                subscribers?: number | undefined;
                                userFlairRichtext?: string[];
                                videostreamLinksCount?: number | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                hideAds?: boolean | undefined;
                                emojisEnabled?: boolean | undefined;
                                advertiserCategory?: string | undefined;
                                publicDescription?: string | undefined;
                                commentScoreHideMins?: number | undefined;
                                allowPredictions?: boolean | undefined;
                                userHasFavorited?: boolean | undefined;
                                userFlairTemplateId?: string | undefined;
                                communityIcon?: string | undefined;
                                bannerBackgroundImage?: string | undefined;
                                originalContentTagEnabled?: boolean | undefined;
                                communityReviewed?: boolean | undefined;
                                submitText?: string | undefined;
                                descriptionHtml?: string | undefined;
                                spoilersEnabled?: boolean | undefined;
                                commentContributionSettings?: {
                                    allowedMediaTypes?: string[];
                                } | undefined;
                                allowTalks?: boolean | undefined;
                                headerSize?: number[];
                                userFlairPosition?: string | undefined;
                                allOriginalContent?: boolean | undefined;
                                hasMenuWidget?: boolean | undefined;
                                isEnrolledInNewModmail?: boolean | undefined;
                                keyColor?: string | undefined;
                                canAssignUserFlair?: boolean | undefined;
                                created?: number | undefined;
                                wls?: number | undefined;
                                showMediaPreview?: boolean | undefined;
                                submissionType?: string | undefined;
                                userIsSubscriber?: boolean | undefined;
                                allowedMediaInComments?: string[];
                                allowVideogifs?: boolean | undefined;
                                shouldArchivePosts?: boolean | undefined;
                                userFlairType?: string | undefined;
                                allowPolls?: boolean | undefined;
                                collapseDeletedComments?: boolean | undefined;
                                emojisCustomSize?: number[];
                                publicDescriptionHtml?: string | undefined;
                                allowVideos?: boolean | undefined;
                                isCrosspostableSubreddit?: boolean | undefined;
                                notificationLevel?: string | undefined;
                                shouldShowMediaInCommentsSetting?: boolean | undefined;
                                canAssignLinkFlair?: boolean | undefined;
                                accountsActiveIsFuzzed?: boolean | undefined;
                                allowPredictionContributors?: boolean | undefined;
                                submitTextLabel?: string | undefined;
                                linkFlairPosition?: string | undefined;
                                userSrFlairEnabled?: boolean | undefined;
                                userFlairEnabledInSr?: boolean | undefined;
                                allowChatPostCreation?: boolean | undefined;
                                allowDiscovery?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                userSrThemeEnabled?: boolean | undefined;
                                linkFlairEnabled?: boolean | undefined;
                                disableContributorRequests?: boolean | undefined;
                                subredditType?: string | undefined;
                                suggestedCommentSort?: string | undefined;
                                bannerImg?: string | undefined;
                                userFlairText?: string | undefined;
                                contentCategory?: string | undefined;
                                bannerBackgroundColor?: string | undefined;
                                showMedia?: boolean | undefined;
                                id?: string | undefined;
                                userIsModerator?: boolean | undefined;
                                over18?: boolean | undefined;
                                headerTitle?: string | undefined;
                                description?: string | undefined;
                                isChatPostFeatureEnabled?: boolean | undefined;
                                submitLinkLabel?: string | undefined;
                                userFlairTextColor?: string | undefined;
                                restrictCommenting?: boolean | undefined;
                                userFlairCssClass?: string | undefined;
                                allowImages?: boolean | undefined;
                                lang?: string | undefined;
                                whitelistStatus?: string | undefined;
                                url?: string | undefined;
                                createdUtc?: number | undefined;
                                bannerSize?: number[];
                                mobileBannerImage?: string | undefined;
                                userIsContributor?: boolean | undefined;
                                allowPredictionsTournament?: boolean | undefined;
                            } | undefined;
                        }[];
                        childrenAccounts?: {
                            kind?: string;
                            data?: {
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                snoovatarSize?: number | undefined;
                                id?: string | undefined;
                                verified?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                iconImg?: string | undefined;
                                hideFromRobots?: boolean | undefined;
                                linkKarma?: number | undefined;
                                acceptChats?: boolean | undefined;
                                isBlocked?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                name?: string | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                snoovatarImg?: string | undefined;
                                commentKarma?: number | undefined;
                                acceptFollowers?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                }): SubredditAutocompleteResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_subreddit_stylesheet */
        readonly subredditStylesheet: {
            readonly name: "SubredditStylesheet";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditStylesheetRequest";
                encode(message: SubredditStylesheetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditStylesheetRequest;
                fromJSON(object: any): SubredditStylesheetRequest;
                toJSON(message: SubredditStylesheetRequest): unknown;
                create(base?: {
                    op?: string;
                    reason?: string;
                    stylesheetContents?: string;
                    subreddit?: string;
                } | undefined): SubredditStylesheetRequest;
                fromPartial(object: {
                    op?: string;
                    reason?: string;
                    stylesheetContents?: string;
                    subreddit?: string;
                }): SubredditStylesheetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_subscribe */
        readonly subscribe: {
            readonly name: "Subscribe";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.SubscribeRequest";
                encode(message: SubscribeRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubscribeRequest;
                fromJSON(object: any): SubscribeRequest;
                toJSON(message: SubscribeRequest): unknown;
                create(base?: {
                    action?: string;
                    actionSource?: string;
                    skipInitialDefaults?: boolean;
                    sr?: string;
                    srName?: string;
                } | undefined): SubscribeRequest;
                fromPartial(object: {
                    action?: string;
                    actionSource?: string;
                    skipInitialDefaults?: boolean;
                    sr?: string;
                    srName?: string;
                }): SubscribeRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_upload_sr_img */
        readonly uploadSrImg: {
            readonly name: "UploadSrImg";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.UploadSrImgRequest";
                encode(message: UploadSrImgRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UploadSrImgRequest;
                fromJSON(object: any): UploadSrImgRequest;
                toJSON(message: UploadSrImgRequest): unknown;
                create(base?: {
                    file?: string;
                    header?: number;
                    imgType?: string;
                    name?: string;
                    uploadType?: string;
                    subreddit?: string;
                } | undefined): UploadSrImgRequest;
                fromPartial(object: {
                    file?: string;
                    header?: number;
                    imgType?: string;
                    name?: string;
                    uploadType?: string;
                    subreddit?: string;
                }): UploadSrImgRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.UploadSrImgResponse";
                encode(message: UploadSrImgResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UploadSrImgResponse;
                fromJSON(object: any): UploadSrImgResponse;
                toJSON(message: UploadSrImgResponse): unknown;
                create(base?: {
                    errors?: string[];
                    imgSrc?: string | undefined;
                    errorsValues?: string[];
                } | undefined): UploadSrImgResponse;
                fromPartial(object: {
                    errors?: string[];
                    imgSrc?: string | undefined;
                    errorsValues?: string[];
                }): UploadSrImgResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_v1_\{subreddit\}_post_requirements */
        readonly subredditPostRequirements: {
            readonly name: "SubredditPostRequirements";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
                encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSubredditRequest;
                fromJSON(object: any): BasicSubredditRequest;
                toJSON(message: BasicSubredditRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): BasicSubredditRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): BasicSubredditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditPostRequirementsResponse";
                encode(message: SubredditPostRequirementsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditPostRequirementsResponse;
                fromJSON(object: any): SubredditPostRequirementsResponse;
                toJSON(message: SubredditPostRequirementsResponse): unknown;
                create(base?: {
                    titleRegexes?: string[];
                    bodyBlacklistedStrings?: string[];
                    titleBlacklistedStrings?: string[];
                    bodyTextMaxLength?: number | undefined;
                    titleRequiredStrings?: string[];
                    guidelinesText?: string | undefined;
                    galleryMinItems?: number | undefined;
                    domainBlacklist?: string[];
                    domainWhitelist?: string[];
                    titleTextMaxLength?: number | undefined;
                    bodyRestrictionPolicy?: string | undefined;
                    linkRestrictionPolicy?: string | undefined;
                    guidelinesDisplayPolicy?: string | undefined;
                    bodyRequiredStrings?: string[];
                    titleTextMinLength?: number | undefined;
                    galleryCaptionsRequirement?: string | undefined;
                    isFlairRequired?: boolean | undefined;
                    galleryMaxItems?: number | undefined;
                    galleryUrlsRequirement?: string | undefined;
                    bodyRegexes?: string[];
                    linkRepostAge?: number | undefined;
                    bodyTextMinLength?: number | undefined;
                } | undefined): SubredditPostRequirementsResponse;
                fromPartial(object: {
                    titleRegexes?: string[];
                    bodyBlacklistedStrings?: string[];
                    titleBlacklistedStrings?: string[];
                    bodyTextMaxLength?: number | undefined;
                    titleRequiredStrings?: string[];
                    guidelinesText?: string | undefined;
                    galleryMinItems?: number | undefined;
                    domainBlacklist?: string[];
                    domainWhitelist?: string[];
                    titleTextMaxLength?: number | undefined;
                    bodyRestrictionPolicy?: string | undefined;
                    linkRestrictionPolicy?: string | undefined;
                    guidelinesDisplayPolicy?: string | undefined;
                    bodyRequiredStrings?: string[];
                    titleTextMinLength?: number | undefined;
                    galleryCaptionsRequirement?: string | undefined;
                    isFlairRequired?: boolean | undefined;
                    galleryMaxItems?: number | undefined;
                    galleryUrlsRequirement?: string | undefined;
                    bodyRegexes?: string[];
                    linkRepostAge?: number | undefined;
                    bodyTextMinLength?: number | undefined;
                }): SubredditPostRequirementsResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about */
        readonly subredditAbout: {
            readonly name: "SubredditAbout";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
                encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSubredditRequest;
                fromJSON(object: any): BasicSubredditRequest;
                toJSON(message: BasicSubredditRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): BasicSubredditRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): BasicSubredditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditAboutResponse";
                encode(message: SubredditAboutResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditAboutResponse;
                fromJSON(object: any): SubredditAboutResponse;
                toJSON(message: SubredditAboutResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        userFlairBackgroundColor?: string | undefined;
                        submitTextHtml?: string | undefined;
                        restrictPosting?: boolean | undefined;
                        userIsBanned?: boolean | undefined;
                        freeFormReports?: boolean | undefined;
                        wikiEnabled?: boolean | undefined;
                        userIsMuted?: boolean | undefined;
                        userCanFlairInSr?: boolean | undefined;
                        displayName?: string | undefined;
                        headerImg?: string | undefined;
                        title?: string | undefined;
                        allowGalleries?: boolean | undefined;
                        primaryColor?: string | undefined;
                        activeUserCount?: number | undefined;
                        iconImg?: string | undefined;
                        displayNamePrefixed?: string | undefined;
                        accountsActive?: number | undefined;
                        publicTraffic?: boolean | undefined;
                        subscribers?: number | undefined;
                        userFlairRichtext?: {
                            e?: string | undefined;
                            t?: string | undefined;
                        }[];
                        name?: string | undefined;
                        quarantine?: boolean | undefined;
                        hideAds?: boolean | undefined;
                        emojisEnabled?: boolean | undefined;
                        advertiserCategory?: string | undefined;
                        publicDescription?: string | undefined;
                        commentScoreHideMins?: number | undefined;
                        allowPredictions?: boolean | undefined;
                        userHasFavorited?: boolean | undefined;
                        userFlairTemplateId?: string | undefined;
                        communityIcon?: string | undefined;
                        bannerBackgroundImage?: string | undefined;
                        originalContentTagEnabled?: boolean | undefined;
                        communityReviewed?: boolean | undefined;
                        submitText?: string | undefined;
                        descriptionHtml?: string | undefined;
                        spoilersEnabled?: boolean | undefined;
                        commentContributionSettings?: {
                            allowedMediaTypes?: string[];
                        } | undefined;
                        allowTalks?: boolean | undefined;
                        userFlairPosition?: string | undefined;
                        allOriginalContent?: boolean | undefined;
                        collectionsEnabled?: boolean | undefined;
                        isEnrolledInNewModmail?: boolean | undefined;
                        keyColor?: string | undefined;
                        eventPostsEnabled?: boolean | undefined;
                        canAssignUserFlair?: boolean | undefined;
                        created?: number | undefined;
                        showMediaPreview?: boolean | undefined;
                        submissionType?: string | undefined;
                        userIsSubscriber?: boolean | undefined;
                        allowedMediaInComments?: string[];
                        allowVideogifs?: boolean | undefined;
                        shouldArchivePosts?: boolean | undefined;
                        userFlairType?: string | undefined;
                        allowPolls?: boolean | undefined;
                        collapseDeletedComments?: boolean | undefined;
                        coins?: number | undefined;
                        publicDescriptionHtml?: string | undefined;
                        allowVideos?: boolean | undefined;
                        isCrosspostableSubreddit?: boolean | undefined;
                        notificationLevel?: string | undefined;
                        shouldShowMediaInCommentsSetting?: boolean | undefined;
                        canAssignLinkFlair?: boolean | undefined;
                        hasMenuWidget?: boolean | undefined;
                        accountsActiveIsFuzzed?: boolean | undefined;
                        allowPredictionContributors?: boolean | undefined;
                        submitTextLabel?: string | undefined;
                        linkFlairPosition?: string | undefined;
                        userSrFlairEnabled?: boolean | undefined;
                        userFlairEnabledInSr?: boolean | undefined;
                        allowChatPostCreation?: boolean | undefined;
                        allowDiscovery?: boolean | undefined;
                        acceptFollowers?: boolean | undefined;
                        userSrThemeEnabled?: boolean | undefined;
                        linkFlairEnabled?: boolean | undefined;
                        disableContributorRequests?: boolean | undefined;
                        subredditType?: string | undefined;
                        suggestedCommentSort?: string | undefined;
                        bannerImg?: string | undefined;
                        userFlairText?: string | undefined;
                        bannerBackgroundColor?: string | undefined;
                        showMedia?: boolean | undefined;
                        id?: string | undefined;
                        userIsModerator?: boolean | undefined;
                        over18?: boolean | undefined;
                        headerTitle?: string | undefined;
                        description?: string | undefined;
                        isChatPostFeatureEnabled?: boolean | undefined;
                        submitLinkLabel?: string | undefined;
                        userFlairTextColor?: string | undefined;
                        restrictCommenting?: boolean | undefined;
                        userFlairCssClass?: string | undefined;
                        allowImages?: boolean | undefined;
                        lang?: string | undefined;
                        url?: string | undefined;
                        createdUtc?: number | undefined;
                        bannerSize?: number[];
                        mobileBannerImage?: string | undefined;
                        userIsContributor?: boolean | undefined;
                        allowPredictionsTournament?: boolean | undefined;
                        iconSize?: number[];
                        headerSize?: number[];
                        wls?: number | undefined;
                        whitelistStatus?: string | undefined;
                        emojisCustomSize?: number[];
                    } | undefined;
                } | undefined): SubredditAboutResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        userFlairBackgroundColor?: string | undefined;
                        submitTextHtml?: string | undefined;
                        restrictPosting?: boolean | undefined;
                        userIsBanned?: boolean | undefined;
                        freeFormReports?: boolean | undefined;
                        wikiEnabled?: boolean | undefined;
                        userIsMuted?: boolean | undefined;
                        userCanFlairInSr?: boolean | undefined;
                        displayName?: string | undefined;
                        headerImg?: string | undefined;
                        title?: string | undefined;
                        allowGalleries?: boolean | undefined;
                        primaryColor?: string | undefined;
                        activeUserCount?: number | undefined;
                        iconImg?: string | undefined;
                        displayNamePrefixed?: string | undefined;
                        accountsActive?: number | undefined;
                        publicTraffic?: boolean | undefined;
                        subscribers?: number | undefined;
                        userFlairRichtext?: {
                            e?: string | undefined;
                            t?: string | undefined;
                        }[];
                        name?: string | undefined;
                        quarantine?: boolean | undefined;
                        hideAds?: boolean | undefined;
                        emojisEnabled?: boolean | undefined;
                        advertiserCategory?: string | undefined;
                        publicDescription?: string | undefined;
                        commentScoreHideMins?: number | undefined;
                        allowPredictions?: boolean | undefined;
                        userHasFavorited?: boolean | undefined;
                        userFlairTemplateId?: string | undefined;
                        communityIcon?: string | undefined;
                        bannerBackgroundImage?: string | undefined;
                        originalContentTagEnabled?: boolean | undefined;
                        communityReviewed?: boolean | undefined;
                        submitText?: string | undefined;
                        descriptionHtml?: string | undefined;
                        spoilersEnabled?: boolean | undefined;
                        commentContributionSettings?: {
                            allowedMediaTypes?: string[];
                        } | undefined;
                        allowTalks?: boolean | undefined;
                        userFlairPosition?: string | undefined;
                        allOriginalContent?: boolean | undefined;
                        collectionsEnabled?: boolean | undefined;
                        isEnrolledInNewModmail?: boolean | undefined;
                        keyColor?: string | undefined;
                        eventPostsEnabled?: boolean | undefined;
                        canAssignUserFlair?: boolean | undefined;
                        created?: number | undefined;
                        showMediaPreview?: boolean | undefined;
                        submissionType?: string | undefined;
                        userIsSubscriber?: boolean | undefined;
                        allowedMediaInComments?: string[];
                        allowVideogifs?: boolean | undefined;
                        shouldArchivePosts?: boolean | undefined;
                        userFlairType?: string | undefined;
                        allowPolls?: boolean | undefined;
                        collapseDeletedComments?: boolean | undefined;
                        coins?: number | undefined;
                        publicDescriptionHtml?: string | undefined;
                        allowVideos?: boolean | undefined;
                        isCrosspostableSubreddit?: boolean | undefined;
                        notificationLevel?: string | undefined;
                        shouldShowMediaInCommentsSetting?: boolean | undefined;
                        canAssignLinkFlair?: boolean | undefined;
                        hasMenuWidget?: boolean | undefined;
                        accountsActiveIsFuzzed?: boolean | undefined;
                        allowPredictionContributors?: boolean | undefined;
                        submitTextLabel?: string | undefined;
                        linkFlairPosition?: string | undefined;
                        userSrFlairEnabled?: boolean | undefined;
                        userFlairEnabledInSr?: boolean | undefined;
                        allowChatPostCreation?: boolean | undefined;
                        allowDiscovery?: boolean | undefined;
                        acceptFollowers?: boolean | undefined;
                        userSrThemeEnabled?: boolean | undefined;
                        linkFlairEnabled?: boolean | undefined;
                        disableContributorRequests?: boolean | undefined;
                        subredditType?: string | undefined;
                        suggestedCommentSort?: string | undefined;
                        bannerImg?: string | undefined;
                        userFlairText?: string | undefined;
                        bannerBackgroundColor?: string | undefined;
                        showMedia?: boolean | undefined;
                        id?: string | undefined;
                        userIsModerator?: boolean | undefined;
                        over18?: boolean | undefined;
                        headerTitle?: string | undefined;
                        description?: string | undefined;
                        isChatPostFeatureEnabled?: boolean | undefined;
                        submitLinkLabel?: string | undefined;
                        userFlairTextColor?: string | undefined;
                        restrictCommenting?: boolean | undefined;
                        userFlairCssClass?: string | undefined;
                        allowImages?: boolean | undefined;
                        lang?: string | undefined;
                        url?: string | undefined;
                        createdUtc?: number | undefined;
                        bannerSize?: number[];
                        mobileBannerImage?: string | undefined;
                        userIsContributor?: boolean | undefined;
                        allowPredictionsTournament?: boolean | undefined;
                        iconSize?: number[];
                        headerSize?: number[];
                        wls?: number | undefined;
                        whitelistStatus?: string | undefined;
                        emojisCustomSize?: number[];
                    } | undefined;
                }): SubredditAboutResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about_edit */
        readonly subredditAboutEdit: {
            readonly name: "SubredditAboutEdit";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditRequest";
                encode(message: SubredditAboutEditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditAboutEditRequest;
                fromJSON(object: any): SubredditAboutEditRequest;
                toJSON(message: SubredditAboutEditRequest): unknown;
                create(base?: {
                    created?: string;
                    location?: string;
                    subreddit?: string;
                } | undefined): SubredditAboutEditRequest;
                fromPartial(object: {
                    created?: string;
                    location?: string;
                    subreddit?: string;
                }): SubredditAboutEditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse";
                encode(message: SubredditAboutEditResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditAboutEditResponse;
                fromJSON(object: any): SubredditAboutEditResponse;
                toJSON(message: SubredditAboutEditResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        defaultSet?: boolean | undefined;
                        toxicityThresholdChatLevel?: number | undefined;
                        crowdControlChatLevel?: number | undefined;
                        restrictPosting?: boolean | undefined;
                        publicDescription?: string | undefined;
                        subredditId?: string | undefined;
                        allowImages?: boolean | undefined;
                        freeFormReports?: boolean | undefined;
                        domain?: string | undefined;
                        originalContentTagEnabled?: boolean | undefined;
                        showMedia?: boolean | undefined;
                        excludeBannedModqueue?: boolean | undefined;
                        shouldArchivePosts?: boolean | undefined;
                        submitText?: string | undefined;
                        spamLinks?: string | undefined;
                        title?: string | undefined;
                        collapseDeletedComments?: boolean | undefined;
                        wikimode?: string | undefined;
                        over18?: boolean | undefined;
                        allowVideos?: boolean | undefined;
                        allowGalleries?: boolean | undefined;
                        crowdControlLevel?: number | undefined;
                        banEvasionThreshold?: number | undefined;
                        crowdControlMode?: boolean | undefined;
                        welcomeMessageEnabled?: boolean | undefined;
                        welcomeMessageText?: string | undefined;
                        suggestedCommentSort?: boolean | undefined;
                        disableContributorRequests?: boolean | undefined;
                        allowTalks?: boolean | undefined;
                        description?: string | undefined;
                        submitLinkLabel?: string | undefined;
                        spoilersEnabled?: boolean | undefined;
                        allowPostCrossposts?: boolean | undefined;
                        spamComments?: string | undefined;
                        publicTraffic?: boolean | undefined;
                        restrictCommenting?: boolean | undefined;
                        allowPolls?: boolean | undefined;
                        commentContributionSettings?: {
                            allowedMediaTypes?: string[];
                        } | undefined;
                        submitTextLabel?: string | undefined;
                        commentScoreHideMins?: number | undefined;
                        allOriginalContent?: boolean | undefined;
                        spamSelfposts?: string | undefined;
                        keyColor?: string | undefined;
                        language?: string | undefined;
                        newPinnedPostPnsEnabled?: boolean | undefined;
                        hideAds?: boolean | undefined;
                        predictionLeaderboardEntryType?: number | undefined;
                        headerHoverText?: string | undefined;
                        wikiEditAge?: number | undefined;
                        allowChatPostCreation?: boolean | undefined;
                        allowPredictionContributors?: boolean | undefined;
                        allowDiscovery?: boolean | undefined;
                        acceptFollowers?: boolean | undefined;
                        crowdControlPostLevel?: number | undefined;
                        allowPredictionsTournament?: boolean | undefined;
                        wikiEditKarma?: number | undefined;
                        showMediaPreview?: boolean | undefined;
                        crowdControlFilter?: boolean | undefined;
                        subredditType?: string | undefined;
                        allowPredictions?: boolean | undefined;
                        userFlairPnsEnabled?: boolean | undefined;
                        contentOptions?: string | undefined;
                    } | undefined;
                } | undefined): SubredditAboutEditResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        defaultSet?: boolean | undefined;
                        toxicityThresholdChatLevel?: number | undefined;
                        crowdControlChatLevel?: number | undefined;
                        restrictPosting?: boolean | undefined;
                        publicDescription?: string | undefined;
                        subredditId?: string | undefined;
                        allowImages?: boolean | undefined;
                        freeFormReports?: boolean | undefined;
                        domain?: string | undefined;
                        originalContentTagEnabled?: boolean | undefined;
                        showMedia?: boolean | undefined;
                        excludeBannedModqueue?: boolean | undefined;
                        shouldArchivePosts?: boolean | undefined;
                        submitText?: string | undefined;
                        spamLinks?: string | undefined;
                        title?: string | undefined;
                        collapseDeletedComments?: boolean | undefined;
                        wikimode?: string | undefined;
                        over18?: boolean | undefined;
                        allowVideos?: boolean | undefined;
                        allowGalleries?: boolean | undefined;
                        crowdControlLevel?: number | undefined;
                        banEvasionThreshold?: number | undefined;
                        crowdControlMode?: boolean | undefined;
                        welcomeMessageEnabled?: boolean | undefined;
                        welcomeMessageText?: string | undefined;
                        suggestedCommentSort?: boolean | undefined;
                        disableContributorRequests?: boolean | undefined;
                        allowTalks?: boolean | undefined;
                        description?: string | undefined;
                        submitLinkLabel?: string | undefined;
                        spoilersEnabled?: boolean | undefined;
                        allowPostCrossposts?: boolean | undefined;
                        spamComments?: string | undefined;
                        publicTraffic?: boolean | undefined;
                        restrictCommenting?: boolean | undefined;
                        allowPolls?: boolean | undefined;
                        commentContributionSettings?: {
                            allowedMediaTypes?: string[];
                        } | undefined;
                        submitTextLabel?: string | undefined;
                        commentScoreHideMins?: number | undefined;
                        allOriginalContent?: boolean | undefined;
                        spamSelfposts?: string | undefined;
                        keyColor?: string | undefined;
                        language?: string | undefined;
                        newPinnedPostPnsEnabled?: boolean | undefined;
                        hideAds?: boolean | undefined;
                        predictionLeaderboardEntryType?: number | undefined;
                        headerHoverText?: string | undefined;
                        wikiEditAge?: number | undefined;
                        allowChatPostCreation?: boolean | undefined;
                        allowPredictionContributors?: boolean | undefined;
                        allowDiscovery?: boolean | undefined;
                        acceptFollowers?: boolean | undefined;
                        crowdControlPostLevel?: number | undefined;
                        allowPredictionsTournament?: boolean | undefined;
                        wikiEditKarma?: number | undefined;
                        showMediaPreview?: boolean | undefined;
                        crowdControlFilter?: boolean | undefined;
                        subredditType?: string | undefined;
                        allowPredictions?: boolean | undefined;
                        userFlairPnsEnabled?: boolean | undefined;
                        contentOptions?: string | undefined;
                    } | undefined;
                }): SubredditAboutEditResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about_rules */
        readonly subredditAboutRules: {
            readonly name: "SubredditAboutRules";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
                encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSubredditRequest;
                fromJSON(object: any): BasicSubredditRequest;
                toJSON(message: BasicSubredditRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): BasicSubredditRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): BasicSubredditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse";
                encode(message: SubredditAboutRulesResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditAboutRulesResponse;
                fromJSON(object: any): SubredditAboutRulesResponse;
                toJSON(message: SubredditAboutRulesResponse): unknown;
                create(base?: {
                    rules?: {
                        kind?: string | undefined;
                        description?: string | undefined;
                        shortName?: string | undefined;
                        violationReason?: string | undefined;
                        createdUtc?: number | undefined;
                        priority?: number | undefined;
                        descriptionHtml?: string | undefined;
                    }[];
                    siteRules?: string[];
                    siteRulesFlow?: {
                        reasonTextToShow?: string | undefined;
                        reasonText?: string | undefined;
                        nextStepHeader?: string | undefined;
                        nextStepReasons?: any[];
                        complaintButtonText?: string | undefined;
                        complaintUrl?: string | undefined;
                        complaintPageTitle?: string | undefined;
                        fileComplaint?: boolean | undefined;
                        complaintPrompt?: string | undefined;
                        canWriteNotes?: boolean | undefined;
                        isAbuseOfReportButton?: boolean | undefined;
                        notesInputTitle?: string | undefined;
                        usernamesInputTitle?: string | undefined;
                        canSpecifyUsernames?: boolean | undefined;
                        requestCrisisSupport?: boolean | undefined;
                        oneUsername?: boolean | undefined;
                    }[];
                } | undefined): SubredditAboutRulesResponse;
                fromPartial(object: {
                    rules?: {
                        kind?: string | undefined;
                        description?: string | undefined;
                        shortName?: string | undefined;
                        violationReason?: string | undefined;
                        createdUtc?: number | undefined;
                        priority?: number | undefined;
                        descriptionHtml?: string | undefined;
                    }[];
                    siteRules?: string[];
                    siteRulesFlow?: {
                        reasonTextToShow?: string | undefined;
                        reasonText?: string | undefined;
                        nextStepHeader?: string | undefined;
                        nextStepReasons?: any[];
                        complaintButtonText?: string | undefined;
                        complaintUrl?: string | undefined;
                        complaintPageTitle?: string | undefined;
                        fileComplaint?: boolean | undefined;
                        complaintPrompt?: string | undefined;
                        canWriteNotes?: boolean | undefined;
                        isAbuseOfReportButton?: boolean | undefined;
                        notesInputTitle?: string | undefined;
                        usernamesInputTitle?: string | undefined;
                        canSpecifyUsernames?: boolean | undefined;
                        requestCrisisSupport?: boolean | undefined;
                        oneUsername?: boolean | undefined;
                    }[];
                }): SubredditAboutRulesResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about_traffic */
        readonly subredditAboutTraffic: {
            readonly name: "SubredditAboutTraffic";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
                encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSubredditRequest;
                fromJSON(object: any): BasicSubredditRequest;
                toJSON(message: BasicSubredditRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): BasicSubredditRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): BasicSubredditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse";
                encode(message: SubredditAboutTrafficResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditAboutTrafficResponse;
                fromJSON(object: any): SubredditAboutTrafficResponse;
                toJSON(message: SubredditAboutTrafficResponse): unknown;
                create(base?: {
                    day?: {
                        values?: number[];
                    }[];
                    hour?: {
                        values?: number[];
                    }[];
                    month?: {
                        values?: number[];
                    }[];
                } | undefined): SubredditAboutTrafficResponse;
                fromPartial(object: {
                    day?: {
                        values?: number[];
                    }[];
                    hour?: {
                        values?: number[];
                    }[];
                    month?: {
                        values?: number[];
                    }[];
                }): SubredditAboutTrafficResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_sidebar */
        readonly sidebar: {
            readonly name: "Sidebar";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest";
                encode(message: BasicSubredditRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicSubredditRequest;
                fromJSON(object: any): BasicSubredditRequest;
                toJSON(message: BasicSubredditRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): BasicSubredditRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): BasicSubredditRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.StringValue";
                encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StringValue;
                fromJSON(object: any): StringValue;
                toJSON(message: StringValue): unknown;
                create(base?: {
                    value?: string;
                } | undefined): StringValue;
                fromPartial(object: {
                    value?: string;
                }): StringValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api#GET_sticky */
        readonly sticky: {
            readonly name: "Sticky";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.StickyRequest";
                encode(message: StickyRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StickyRequest;
                fromJSON(object: any): StickyRequest;
                toJSON(message: StickyRequest): unknown;
                create(base?: {
                    num?: number;
                    subreddit?: string;
                } | undefined): StickyRequest;
                fromPartial(object: {
                    num?: number;
                    subreddit?: string;
                }): StickyRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.StickyResponse";
                encode(message: StickyResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StickyResponse;
                fromJSON(object: any): StickyResponse;
                toJSON(message: StickyResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        modhash?: string | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                authorFlairBackgroundColor?: string | undefined;
                                approvedAtUtc?: number | undefined;
                                subreddit?: string | undefined;
                                selftext?: string | undefined;
                                userReports?: string[];
                                saved?: boolean | undefined;
                                modReasonTitle?: string | undefined;
                                gilded?: number | undefined;
                                clicked?: boolean | undefined;
                                title?: string | undefined;
                                linkFlairRichtext?: string[];
                                subredditNamePrefixed?: string | undefined;
                                hidden?: boolean | undefined;
                                pwls?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                downs?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                topAwardedType?: string | undefined;
                                parentWhitelistStatus?: boolean | undefined;
                                hideScore?: boolean | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkFlairTextColor?: string | undefined;
                                upvoteRatio?: number | undefined;
                                ignoreReports?: boolean | undefined;
                                ups?: number | undefined;
                                domain?: string | undefined;
                                mediaEmbed?: {
                                    content?: string | undefined;
                                    width?: number | undefined;
                                    height?: number | undefined;
                                    sandbox?: boolean | undefined;
                                    scrolling?: boolean | undefined;
                                    publicThumbnailUrl?: string | undefined;
                                } | undefined;
                                thumbnailWidth?: number | undefined;
                                authorFlairTemplateId?: string | undefined;
                                isOriginalContent?: boolean | undefined;
                                authorFullname?: string | undefined;
                                secureMedia?: boolean | undefined;
                                isRedditMediaDomain?: boolean | undefined;
                                isMeta?: boolean | undefined;
                                category?: string | undefined;
                                secureMediaEmbed?: {
                                    content?: string | undefined;
                                    width?: number | undefined;
                                    height?: number | undefined;
                                    sandbox?: boolean | undefined;
                                    scrolling?: boolean | undefined;
                                    publicThumbnailUrl?: string | undefined;
                                } | undefined;
                                linkFlairText?: string | undefined;
                                canModPost?: boolean | undefined;
                                score?: number | undefined;
                                approvedBy?: string | undefined;
                                isCreatedFromAdsUi?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                thumbnail?: string | undefined;
                                edited?: boolean | undefined;
                                authorFlairCssClass?: string | undefined;
                                previousVisits?: number[];
                                authorFlairRichtext?: string[];
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                contentCategories?: string | undefined;
                                isSelf?: boolean | undefined;
                                subredditType?: string | undefined;
                                created?: number | undefined;
                                linkFlairType?: string | undefined;
                                wls?: string | undefined;
                                removedByCategory?: string | undefined;
                                bannedBy?: string | undefined;
                                authorFlairType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                allowLiveComments?: boolean | undefined;
                                selftextHtml?: string | undefined;
                                likes?: boolean | undefined;
                                suggestedSort?: string | undefined;
                                bannedAtUtc?: number | undefined;
                                viewCount?: number | undefined;
                                archived?: boolean | undefined;
                                noFollow?: boolean | undefined;
                                spam?: boolean | undefined;
                                isCrosspostable?: boolean | undefined;
                                pinned?: boolean | undefined;
                                over18?: boolean | undefined;
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                awarders?: string[];
                                mediaOnly?: boolean | undefined;
                                canGild?: boolean | undefined;
                                removed?: boolean | undefined;
                                spoiler?: boolean | undefined;
                                locked?: boolean | undefined;
                                authorFlairText?: string | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                rteMode?: string | undefined;
                                visited?: boolean | undefined;
                                removedBy?: string | undefined;
                                modNote?: string | undefined;
                                distinguished?: string | undefined;
                                subredditId?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                modReasonBy?: string | undefined;
                                numReports?: number | undefined;
                                removalReason?: string | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                id?: string | undefined;
                                isRobotIndexable?: boolean | undefined;
                                numDuplicates?: number | undefined;
                                reportReasons?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                author?: string | undefined;
                                discussionType?: string | undefined;
                                numComments?: number | undefined;
                                sendReplies?: boolean | undefined;
                                media?: string | undefined;
                                contestMode?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                approved?: boolean | undefined;
                                authorFlairTextColor?: string | undefined;
                                permalink?: string | undefined;
                                whitelistStatus?: boolean | undefined;
                                stickied?: boolean | undefined;
                                url?: string | undefined;
                                subredditSubscribers?: number | undefined;
                                createdUtc?: number | undefined;
                                numCrossposts?: number | undefined;
                                modReports?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                isVideo?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                } | undefined): StickyResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        modhash?: string | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                authorFlairBackgroundColor?: string | undefined;
                                approvedAtUtc?: number | undefined;
                                subreddit?: string | undefined;
                                selftext?: string | undefined;
                                userReports?: string[];
                                saved?: boolean | undefined;
                                modReasonTitle?: string | undefined;
                                gilded?: number | undefined;
                                clicked?: boolean | undefined;
                                title?: string | undefined;
                                linkFlairRichtext?: string[];
                                subredditNamePrefixed?: string | undefined;
                                hidden?: boolean | undefined;
                                pwls?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                downs?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                topAwardedType?: string | undefined;
                                parentWhitelistStatus?: boolean | undefined;
                                hideScore?: boolean | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkFlairTextColor?: string | undefined;
                                upvoteRatio?: number | undefined;
                                ignoreReports?: boolean | undefined;
                                ups?: number | undefined;
                                domain?: string | undefined;
                                mediaEmbed?: {
                                    content?: string | undefined;
                                    width?: number | undefined;
                                    height?: number | undefined;
                                    sandbox?: boolean | undefined;
                                    scrolling?: boolean | undefined;
                                    publicThumbnailUrl?: string | undefined;
                                } | undefined;
                                thumbnailWidth?: number | undefined;
                                authorFlairTemplateId?: string | undefined;
                                isOriginalContent?: boolean | undefined;
                                authorFullname?: string | undefined;
                                secureMedia?: boolean | undefined;
                                isRedditMediaDomain?: boolean | undefined;
                                isMeta?: boolean | undefined;
                                category?: string | undefined;
                                secureMediaEmbed?: {
                                    content?: string | undefined;
                                    width?: number | undefined;
                                    height?: number | undefined;
                                    sandbox?: boolean | undefined;
                                    scrolling?: boolean | undefined;
                                    publicThumbnailUrl?: string | undefined;
                                } | undefined;
                                linkFlairText?: string | undefined;
                                canModPost?: boolean | undefined;
                                score?: number | undefined;
                                approvedBy?: string | undefined;
                                isCreatedFromAdsUi?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                thumbnail?: string | undefined;
                                edited?: boolean | undefined;
                                authorFlairCssClass?: string | undefined;
                                previousVisits?: number[];
                                authorFlairRichtext?: string[];
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                contentCategories?: string | undefined;
                                isSelf?: boolean | undefined;
                                subredditType?: string | undefined;
                                created?: number | undefined;
                                linkFlairType?: string | undefined;
                                wls?: string | undefined;
                                removedByCategory?: string | undefined;
                                bannedBy?: string | undefined;
                                authorFlairType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                allowLiveComments?: boolean | undefined;
                                selftextHtml?: string | undefined;
                                likes?: boolean | undefined;
                                suggestedSort?: string | undefined;
                                bannedAtUtc?: number | undefined;
                                viewCount?: number | undefined;
                                archived?: boolean | undefined;
                                noFollow?: boolean | undefined;
                                spam?: boolean | undefined;
                                isCrosspostable?: boolean | undefined;
                                pinned?: boolean | undefined;
                                over18?: boolean | undefined;
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                awarders?: string[];
                                mediaOnly?: boolean | undefined;
                                canGild?: boolean | undefined;
                                removed?: boolean | undefined;
                                spoiler?: boolean | undefined;
                                locked?: boolean | undefined;
                                authorFlairText?: string | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                rteMode?: string | undefined;
                                visited?: boolean | undefined;
                                removedBy?: string | undefined;
                                modNote?: string | undefined;
                                distinguished?: string | undefined;
                                subredditId?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                modReasonBy?: string | undefined;
                                numReports?: number | undefined;
                                removalReason?: string | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                id?: string | undefined;
                                isRobotIndexable?: boolean | undefined;
                                numDuplicates?: number | undefined;
                                reportReasons?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                author?: string | undefined;
                                discussionType?: string | undefined;
                                numComments?: number | undefined;
                                sendReplies?: boolean | undefined;
                                media?: string | undefined;
                                contestMode?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                approved?: boolean | undefined;
                                authorFlairTextColor?: string | undefined;
                                permalink?: string | undefined;
                                whitelistStatus?: boolean | undefined;
                                stickied?: boolean | undefined;
                                url?: string | undefined;
                                subredditSubscribers?: number | undefined;
                                createdUtc?: number | undefined;
                                numCrossposts?: number | undefined;
                                modReports?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                isVideo?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                }): StickyResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_subreddits_mine_\{where\} */
        readonly subredditsMineWhere: {
            readonly name: "SubredditsMineWhere";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicWhereRequest";
                encode(message: BasicWhereRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicWhereRequest;
                fromJSON(object: any): BasicWhereRequest;
                toJSON(message: BasicWhereRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    where?: string;
                } | undefined): BasicWhereRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    where?: string;
                }): BasicWhereRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * https://www.reddit.com/dev/api#GET_subreddits_search
         * Make Wrapped
         */
        readonly subredditsSearch: {
            readonly name: "SubredditsSearch";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchRequest";
                encode(message: SubredditsSearchRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditsSearchRequest;
                fromJSON(object: any): SubredditsSearchRequest;
                toJSON(message: SubredditsSearchRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    q?: string;
                    searchQueryId?: string | undefined;
                    show?: string | undefined;
                    showUsers?: boolean | undefined;
                    sort?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                } | undefined): SubredditsSearchRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    q?: string;
                    searchQueryId?: string | undefined;
                    show?: string | undefined;
                    showUsers?: boolean | undefined;
                    sort?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                }): SubredditsSearchRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse";
                encode(message: SubredditsSearchResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditsSearchResponse;
                fromJSON(object: any): SubredditsSearchResponse;
                toJSON(message: SubredditsSearchResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                userFlairBackgroundColor?: string | undefined;
                                submitTextHtml?: string | undefined;
                                restrictPosting?: boolean | undefined;
                                userIsBanned?: boolean | undefined;
                                freeFormReports?: boolean | undefined;
                                wikiEnabled?: boolean | undefined;
                                userIsMuted?: boolean | undefined;
                                userCanFlairInSr?: boolean | undefined;
                                displayName?: string | undefined;
                                headerImg?: string | undefined;
                                title?: string | undefined;
                                allowGalleries?: boolean | undefined;
                                iconSize?: number[];
                                primaryColor?: string | undefined;
                                activeUserCount?: number | undefined;
                                iconImg?: string | undefined;
                                displayNamePrefixed?: string | undefined;
                                accountsActive?: number | undefined;
                                publicTraffic?: boolean | undefined;
                                subscribers?: number | undefined;
                                userFlairRichtext?: string[];
                                videostreamLinksCount?: number | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                hideAds?: boolean | undefined;
                                emojisEnabled?: boolean | undefined;
                                advertiserCategory?: string | undefined;
                                publicDescription?: string | undefined;
                                commentScoreHideMins?: number | undefined;
                                allowPredictions?: boolean | undefined;
                                userHasFavorited?: boolean | undefined;
                                userFlairTemplateId?: string | undefined;
                                communityIcon?: string | undefined;
                                bannerBackgroundImage?: string | undefined;
                                originalContentTagEnabled?: boolean | undefined;
                                communityReviewed?: boolean | undefined;
                                submitText?: string | undefined;
                                descriptionHtml?: string | undefined;
                                spoilersEnabled?: boolean | undefined;
                                commentContributionSettings?: {
                                    allowedMediaTypes?: string[];
                                } | undefined;
                                allowTalks?: boolean | undefined;
                                headerSize?: number[];
                                userFlairPosition?: string | undefined;
                                allOriginalContent?: boolean | undefined;
                                hasMenuWidget?: boolean | undefined;
                                isEnrolledInNewModmail?: boolean | undefined;
                                keyColor?: string | undefined;
                                canAssignUserFlair?: boolean | undefined;
                                created?: number | undefined;
                                wls?: number | undefined;
                                showMediaPreview?: boolean | undefined;
                                submissionType?: string | undefined;
                                userIsSubscriber?: boolean | undefined;
                                allowedMediaInComments?: string[];
                                allowVideogifs?: boolean | undefined;
                                shouldArchivePosts?: boolean | undefined;
                                userFlairType?: string | undefined;
                                allowPolls?: boolean | undefined;
                                collapseDeletedComments?: boolean | undefined;
                                emojisCustomSize?: number[];
                                publicDescriptionHtml?: string | undefined;
                                allowVideos?: boolean | undefined;
                                isCrosspostableSubreddit?: boolean | undefined;
                                notificationLevel?: string | undefined;
                                shouldShowMediaInCommentsSetting?: boolean | undefined;
                                canAssignLinkFlair?: boolean | undefined;
                                accountsActiveIsFuzzed?: boolean | undefined;
                                allowPredictionContributors?: boolean | undefined;
                                submitTextLabel?: string | undefined;
                                linkFlairPosition?: string | undefined;
                                userSrFlairEnabled?: boolean | undefined;
                                userFlairEnabledInSr?: boolean | undefined;
                                allowChatPostCreation?: boolean | undefined;
                                allowDiscovery?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                userSrThemeEnabled?: boolean | undefined;
                                linkFlairEnabled?: boolean | undefined;
                                disableContributorRequests?: boolean | undefined;
                                subredditType?: string | undefined;
                                suggestedCommentSort?: string | undefined;
                                bannerImg?: string | undefined;
                                userFlairText?: string | undefined;
                                contentCategory?: string | undefined;
                                bannerBackgroundColor?: string | undefined;
                                showMedia?: boolean | undefined;
                                id?: string | undefined;
                                userIsModerator?: boolean | undefined;
                                over18?: boolean | undefined;
                                headerTitle?: string | undefined;
                                description?: string | undefined;
                                isChatPostFeatureEnabled?: boolean | undefined;
                                submitLinkLabel?: string | undefined;
                                userFlairTextColor?: string | undefined;
                                restrictCommenting?: boolean | undefined;
                                userFlairCssClass?: string | undefined;
                                allowImages?: boolean | undefined;
                                lang?: string | undefined;
                                whitelistStatus?: string | undefined;
                                url?: string | undefined;
                                createdUtc?: number | undefined;
                                bannerSize?: number[];
                                mobileBannerImage?: string | undefined;
                                userIsContributor?: boolean | undefined;
                                allowPredictionsTournament?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                } | undefined): SubredditsSearchResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                userFlairBackgroundColor?: string | undefined;
                                submitTextHtml?: string | undefined;
                                restrictPosting?: boolean | undefined;
                                userIsBanned?: boolean | undefined;
                                freeFormReports?: boolean | undefined;
                                wikiEnabled?: boolean | undefined;
                                userIsMuted?: boolean | undefined;
                                userCanFlairInSr?: boolean | undefined;
                                displayName?: string | undefined;
                                headerImg?: string | undefined;
                                title?: string | undefined;
                                allowGalleries?: boolean | undefined;
                                iconSize?: number[];
                                primaryColor?: string | undefined;
                                activeUserCount?: number | undefined;
                                iconImg?: string | undefined;
                                displayNamePrefixed?: string | undefined;
                                accountsActive?: number | undefined;
                                publicTraffic?: boolean | undefined;
                                subscribers?: number | undefined;
                                userFlairRichtext?: string[];
                                videostreamLinksCount?: number | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                hideAds?: boolean | undefined;
                                emojisEnabled?: boolean | undefined;
                                advertiserCategory?: string | undefined;
                                publicDescription?: string | undefined;
                                commentScoreHideMins?: number | undefined;
                                allowPredictions?: boolean | undefined;
                                userHasFavorited?: boolean | undefined;
                                userFlairTemplateId?: string | undefined;
                                communityIcon?: string | undefined;
                                bannerBackgroundImage?: string | undefined;
                                originalContentTagEnabled?: boolean | undefined;
                                communityReviewed?: boolean | undefined;
                                submitText?: string | undefined;
                                descriptionHtml?: string | undefined;
                                spoilersEnabled?: boolean | undefined;
                                commentContributionSettings?: {
                                    allowedMediaTypes?: string[];
                                } | undefined;
                                allowTalks?: boolean | undefined;
                                headerSize?: number[];
                                userFlairPosition?: string | undefined;
                                allOriginalContent?: boolean | undefined;
                                hasMenuWidget?: boolean | undefined;
                                isEnrolledInNewModmail?: boolean | undefined;
                                keyColor?: string | undefined;
                                canAssignUserFlair?: boolean | undefined;
                                created?: number | undefined;
                                wls?: number | undefined;
                                showMediaPreview?: boolean | undefined;
                                submissionType?: string | undefined;
                                userIsSubscriber?: boolean | undefined;
                                allowedMediaInComments?: string[];
                                allowVideogifs?: boolean | undefined;
                                shouldArchivePosts?: boolean | undefined;
                                userFlairType?: string | undefined;
                                allowPolls?: boolean | undefined;
                                collapseDeletedComments?: boolean | undefined;
                                emojisCustomSize?: number[];
                                publicDescriptionHtml?: string | undefined;
                                allowVideos?: boolean | undefined;
                                isCrosspostableSubreddit?: boolean | undefined;
                                notificationLevel?: string | undefined;
                                shouldShowMediaInCommentsSetting?: boolean | undefined;
                                canAssignLinkFlair?: boolean | undefined;
                                accountsActiveIsFuzzed?: boolean | undefined;
                                allowPredictionContributors?: boolean | undefined;
                                submitTextLabel?: string | undefined;
                                linkFlairPosition?: string | undefined;
                                userSrFlairEnabled?: boolean | undefined;
                                userFlairEnabledInSr?: boolean | undefined;
                                allowChatPostCreation?: boolean | undefined;
                                allowDiscovery?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                userSrThemeEnabled?: boolean | undefined;
                                linkFlairEnabled?: boolean | undefined;
                                disableContributorRequests?: boolean | undefined;
                                subredditType?: string | undefined;
                                suggestedCommentSort?: string | undefined;
                                bannerImg?: string | undefined;
                                userFlairText?: string | undefined;
                                contentCategory?: string | undefined;
                                bannerBackgroundColor?: string | undefined;
                                showMedia?: boolean | undefined;
                                id?: string | undefined;
                                userIsModerator?: boolean | undefined;
                                over18?: boolean | undefined;
                                headerTitle?: string | undefined;
                                description?: string | undefined;
                                isChatPostFeatureEnabled?: boolean | undefined;
                                submitLinkLabel?: string | undefined;
                                userFlairTextColor?: string | undefined;
                                restrictCommenting?: boolean | undefined;
                                userFlairCssClass?: string | undefined;
                                allowImages?: boolean | undefined;
                                lang?: string | undefined;
                                whitelistStatus?: string | undefined;
                                url?: string | undefined;
                                createdUtc?: number | undefined;
                                bannerSize?: number[];
                                mobileBannerImage?: string | undefined;
                                userIsContributor?: boolean | undefined;
                                allowPredictionsTournament?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                }): SubredditsSearchResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_subreddits_\{where\} */
        readonly subredditsWhere: {
            readonly name: "SubredditsWhere";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicWhereRequest";
                encode(message: BasicWhereRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicWhereRequest;
                fromJSON(object: any): BasicWhereRequest;
                toJSON(message: BasicWhereRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    where?: string;
                } | undefined): BasicWhereRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    where?: string;
                }): BasicWhereRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse";
                encode(message: SubredditsSearchResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditsSearchResponse;
                fromJSON(object: any): SubredditsSearchResponse;
                toJSON(message: SubredditsSearchResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                userFlairBackgroundColor?: string | undefined;
                                submitTextHtml?: string | undefined;
                                restrictPosting?: boolean | undefined;
                                userIsBanned?: boolean | undefined;
                                freeFormReports?: boolean | undefined;
                                wikiEnabled?: boolean | undefined;
                                userIsMuted?: boolean | undefined;
                                userCanFlairInSr?: boolean | undefined;
                                displayName?: string | undefined;
                                headerImg?: string | undefined;
                                title?: string | undefined;
                                allowGalleries?: boolean | undefined;
                                iconSize?: number[];
                                primaryColor?: string | undefined;
                                activeUserCount?: number | undefined;
                                iconImg?: string | undefined;
                                displayNamePrefixed?: string | undefined;
                                accountsActive?: number | undefined;
                                publicTraffic?: boolean | undefined;
                                subscribers?: number | undefined;
                                userFlairRichtext?: string[];
                                videostreamLinksCount?: number | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                hideAds?: boolean | undefined;
                                emojisEnabled?: boolean | undefined;
                                advertiserCategory?: string | undefined;
                                publicDescription?: string | undefined;
                                commentScoreHideMins?: number | undefined;
                                allowPredictions?: boolean | undefined;
                                userHasFavorited?: boolean | undefined;
                                userFlairTemplateId?: string | undefined;
                                communityIcon?: string | undefined;
                                bannerBackgroundImage?: string | undefined;
                                originalContentTagEnabled?: boolean | undefined;
                                communityReviewed?: boolean | undefined;
                                submitText?: string | undefined;
                                descriptionHtml?: string | undefined;
                                spoilersEnabled?: boolean | undefined;
                                commentContributionSettings?: {
                                    allowedMediaTypes?: string[];
                                } | undefined;
                                allowTalks?: boolean | undefined;
                                headerSize?: number[];
                                userFlairPosition?: string | undefined;
                                allOriginalContent?: boolean | undefined;
                                hasMenuWidget?: boolean | undefined;
                                isEnrolledInNewModmail?: boolean | undefined;
                                keyColor?: string | undefined;
                                canAssignUserFlair?: boolean | undefined;
                                created?: number | undefined;
                                wls?: number | undefined;
                                showMediaPreview?: boolean | undefined;
                                submissionType?: string | undefined;
                                userIsSubscriber?: boolean | undefined;
                                allowedMediaInComments?: string[];
                                allowVideogifs?: boolean | undefined;
                                shouldArchivePosts?: boolean | undefined;
                                userFlairType?: string | undefined;
                                allowPolls?: boolean | undefined;
                                collapseDeletedComments?: boolean | undefined;
                                emojisCustomSize?: number[];
                                publicDescriptionHtml?: string | undefined;
                                allowVideos?: boolean | undefined;
                                isCrosspostableSubreddit?: boolean | undefined;
                                notificationLevel?: string | undefined;
                                shouldShowMediaInCommentsSetting?: boolean | undefined;
                                canAssignLinkFlair?: boolean | undefined;
                                accountsActiveIsFuzzed?: boolean | undefined;
                                allowPredictionContributors?: boolean | undefined;
                                submitTextLabel?: string | undefined;
                                linkFlairPosition?: string | undefined;
                                userSrFlairEnabled?: boolean | undefined;
                                userFlairEnabledInSr?: boolean | undefined;
                                allowChatPostCreation?: boolean | undefined;
                                allowDiscovery?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                userSrThemeEnabled?: boolean | undefined;
                                linkFlairEnabled?: boolean | undefined;
                                disableContributorRequests?: boolean | undefined;
                                subredditType?: string | undefined;
                                suggestedCommentSort?: string | undefined;
                                bannerImg?: string | undefined;
                                userFlairText?: string | undefined;
                                contentCategory?: string | undefined;
                                bannerBackgroundColor?: string | undefined;
                                showMedia?: boolean | undefined;
                                id?: string | undefined;
                                userIsModerator?: boolean | undefined;
                                over18?: boolean | undefined;
                                headerTitle?: string | undefined;
                                description?: string | undefined;
                                isChatPostFeatureEnabled?: boolean | undefined;
                                submitLinkLabel?: string | undefined;
                                userFlairTextColor?: string | undefined;
                                restrictCommenting?: boolean | undefined;
                                userFlairCssClass?: string | undefined;
                                allowImages?: boolean | undefined;
                                lang?: string | undefined;
                                whitelistStatus?: string | undefined;
                                url?: string | undefined;
                                createdUtc?: number | undefined;
                                bannerSize?: number[];
                                mobileBannerImage?: string | undefined;
                                userIsContributor?: boolean | undefined;
                                allowPredictionsTournament?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                } | undefined): SubredditsSearchResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                userFlairBackgroundColor?: string | undefined;
                                submitTextHtml?: string | undefined;
                                restrictPosting?: boolean | undefined;
                                userIsBanned?: boolean | undefined;
                                freeFormReports?: boolean | undefined;
                                wikiEnabled?: boolean | undefined;
                                userIsMuted?: boolean | undefined;
                                userCanFlairInSr?: boolean | undefined;
                                displayName?: string | undefined;
                                headerImg?: string | undefined;
                                title?: string | undefined;
                                allowGalleries?: boolean | undefined;
                                iconSize?: number[];
                                primaryColor?: string | undefined;
                                activeUserCount?: number | undefined;
                                iconImg?: string | undefined;
                                displayNamePrefixed?: string | undefined;
                                accountsActive?: number | undefined;
                                publicTraffic?: boolean | undefined;
                                subscribers?: number | undefined;
                                userFlairRichtext?: string[];
                                videostreamLinksCount?: number | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                hideAds?: boolean | undefined;
                                emojisEnabled?: boolean | undefined;
                                advertiserCategory?: string | undefined;
                                publicDescription?: string | undefined;
                                commentScoreHideMins?: number | undefined;
                                allowPredictions?: boolean | undefined;
                                userHasFavorited?: boolean | undefined;
                                userFlairTemplateId?: string | undefined;
                                communityIcon?: string | undefined;
                                bannerBackgroundImage?: string | undefined;
                                originalContentTagEnabled?: boolean | undefined;
                                communityReviewed?: boolean | undefined;
                                submitText?: string | undefined;
                                descriptionHtml?: string | undefined;
                                spoilersEnabled?: boolean | undefined;
                                commentContributionSettings?: {
                                    allowedMediaTypes?: string[];
                                } | undefined;
                                allowTalks?: boolean | undefined;
                                headerSize?: number[];
                                userFlairPosition?: string | undefined;
                                allOriginalContent?: boolean | undefined;
                                hasMenuWidget?: boolean | undefined;
                                isEnrolledInNewModmail?: boolean | undefined;
                                keyColor?: string | undefined;
                                canAssignUserFlair?: boolean | undefined;
                                created?: number | undefined;
                                wls?: number | undefined;
                                showMediaPreview?: boolean | undefined;
                                submissionType?: string | undefined;
                                userIsSubscriber?: boolean | undefined;
                                allowedMediaInComments?: string[];
                                allowVideogifs?: boolean | undefined;
                                shouldArchivePosts?: boolean | undefined;
                                userFlairType?: string | undefined;
                                allowPolls?: boolean | undefined;
                                collapseDeletedComments?: boolean | undefined;
                                emojisCustomSize?: number[];
                                publicDescriptionHtml?: string | undefined;
                                allowVideos?: boolean | undefined;
                                isCrosspostableSubreddit?: boolean | undefined;
                                notificationLevel?: string | undefined;
                                shouldShowMediaInCommentsSetting?: boolean | undefined;
                                canAssignLinkFlair?: boolean | undefined;
                                accountsActiveIsFuzzed?: boolean | undefined;
                                allowPredictionContributors?: boolean | undefined;
                                submitTextLabel?: string | undefined;
                                linkFlairPosition?: string | undefined;
                                userSrFlairEnabled?: boolean | undefined;
                                userFlairEnabledInSr?: boolean | undefined;
                                allowChatPostCreation?: boolean | undefined;
                                allowDiscovery?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                userSrThemeEnabled?: boolean | undefined;
                                linkFlairEnabled?: boolean | undefined;
                                disableContributorRequests?: boolean | undefined;
                                subredditType?: string | undefined;
                                suggestedCommentSort?: string | undefined;
                                bannerImg?: string | undefined;
                                userFlairText?: string | undefined;
                                contentCategory?: string | undefined;
                                bannerBackgroundColor?: string | undefined;
                                showMedia?: boolean | undefined;
                                id?: string | undefined;
                                userIsModerator?: boolean | undefined;
                                over18?: boolean | undefined;
                                headerTitle?: string | undefined;
                                description?: string | undefined;
                                isChatPostFeatureEnabled?: boolean | undefined;
                                submitLinkLabel?: string | undefined;
                                userFlairTextColor?: string | undefined;
                                restrictCommenting?: boolean | undefined;
                                userFlairCssClass?: string | undefined;
                                allowImages?: boolean | undefined;
                                lang?: string | undefined;
                                whitelistStatus?: string | undefined;
                                url?: string | undefined;
                                createdUtc?: number | undefined;
                                bannerSize?: number[];
                                mobileBannerImage?: string | undefined;
                                userIsContributor?: boolean | undefined;
                                allowPredictionsTournament?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                }): SubredditsSearchResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_users_search */
        readonly usersSearch: {
            readonly name: "UsersSearch";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.UsersSearchRequest";
                encode(message: UsersSearchRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UsersSearchRequest;
                fromJSON(object: any): UsersSearchRequest;
                toJSON(message: UsersSearchRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    q?: string;
                    searchQueryId?: string | undefined;
                    show?: string | undefined;
                    sort?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                } | undefined): UsersSearchRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    q?: string;
                    searchQueryId?: string | undefined;
                    show?: string | undefined;
                    sort?: string | undefined;
                    typeaheadActive?: boolean | undefined;
                }): UsersSearchRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse";
                encode(message: UserSearchResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UserSearchResponse;
                fromJSON(object: any): UserSearchResponse;
                toJSON(message: UserSearchResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        dist?: number | undefined;
                        modhash?: string | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                snoovatarSize?: number[];
                                id?: string | undefined;
                                verified?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                iconImg?: string | undefined;
                                hideFromRobots?: boolean | undefined;
                                linkKarma?: number | undefined;
                                acceptChats?: boolean | undefined;
                                isBlocked?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                name?: string | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                snoovatarImg?: string | undefined;
                                commentKarma?: number | undefined;
                                acceptFollowers?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                                isSuspended?: boolean | undefined;
                                subreddit?: {
                                    defaultSet?: boolean | undefined;
                                    userIsContributor?: boolean | undefined;
                                    bannerImg?: string | undefined;
                                    allowedMediaInComments?: string[];
                                    userIsBanned?: boolean | undefined;
                                    freeFormReports?: boolean | undefined;
                                    communityIcon?: string | undefined;
                                    showMedia?: boolean | undefined;
                                    iconColor?: string | undefined;
                                    userIsMuted?: boolean | undefined;
                                    displayName?: string | undefined;
                                    headerImg?: string | undefined;
                                    title?: string | undefined;
                                    previousNames?: string[];
                                    over18?: boolean | undefined;
                                    iconSize?: number[];
                                    primaryColor?: string | undefined;
                                    iconImg?: string | undefined;
                                    description?: string | undefined;
                                    submitLinkLabel?: string | undefined;
                                    headerSize?: number[];
                                    restrictPosting?: boolean | undefined;
                                    restrictCommenting?: boolean | undefined;
                                    subscribers?: number | undefined;
                                    submitTextLabel?: string | undefined;
                                    isDefaultIcon?: boolean | undefined;
                                    linkFlairPosition?: string | undefined;
                                    displayNamePrefixed?: string | undefined;
                                    keyColor?: string | undefined;
                                    name?: string | undefined;
                                    isDefaultBanner?: boolean | undefined;
                                    url?: string | undefined;
                                    quarantine?: boolean | undefined;
                                    bannerSize?: number[];
                                    userIsModerator?: boolean | undefined;
                                    acceptFollowers?: boolean | undefined;
                                    publicDescription?: string | undefined;
                                    linkFlairEnabled?: boolean | undefined;
                                    disableContributorRequests?: boolean | undefined;
                                    subredditType?: string | undefined;
                                    userIsSubscriber?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        }[];
                        before?: string | undefined;
                    } | undefined;
                } | undefined): UserSearchResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        dist?: number | undefined;
                        modhash?: string | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                snoovatarSize?: number[];
                                id?: string | undefined;
                                verified?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                iconImg?: string | undefined;
                                hideFromRobots?: boolean | undefined;
                                linkKarma?: number | undefined;
                                acceptChats?: boolean | undefined;
                                isBlocked?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                name?: string | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                snoovatarImg?: string | undefined;
                                commentKarma?: number | undefined;
                                acceptFollowers?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                                isSuspended?: boolean | undefined;
                                subreddit?: {
                                    defaultSet?: boolean | undefined;
                                    userIsContributor?: boolean | undefined;
                                    bannerImg?: string | undefined;
                                    allowedMediaInComments?: string[];
                                    userIsBanned?: boolean | undefined;
                                    freeFormReports?: boolean | undefined;
                                    communityIcon?: string | undefined;
                                    showMedia?: boolean | undefined;
                                    iconColor?: string | undefined;
                                    userIsMuted?: boolean | undefined;
                                    displayName?: string | undefined;
                                    headerImg?: string | undefined;
                                    title?: string | undefined;
                                    previousNames?: string[];
                                    over18?: boolean | undefined;
                                    iconSize?: number[];
                                    primaryColor?: string | undefined;
                                    iconImg?: string | undefined;
                                    description?: string | undefined;
                                    submitLinkLabel?: string | undefined;
                                    headerSize?: number[];
                                    restrictPosting?: boolean | undefined;
                                    restrictCommenting?: boolean | undefined;
                                    subscribers?: number | undefined;
                                    submitTextLabel?: string | undefined;
                                    isDefaultIcon?: boolean | undefined;
                                    linkFlairPosition?: string | undefined;
                                    displayNamePrefixed?: string | undefined;
                                    keyColor?: string | undefined;
                                    name?: string | undefined;
                                    isDefaultBanner?: boolean | undefined;
                                    url?: string | undefined;
                                    quarantine?: boolean | undefined;
                                    bannerSize?: number[];
                                    userIsModerator?: boolean | undefined;
                                    acceptFollowers?: boolean | undefined;
                                    publicDescription?: string | undefined;
                                    linkFlairEnabled?: boolean | undefined;
                                    disableContributorRequests?: boolean | undefined;
                                    subredditType?: string | undefined;
                                    userIsSubscriber?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        }[];
                        before?: string | undefined;
                    } | undefined;
                }): UserSearchResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_users_\{where\} */
        readonly usersWhere: {
            readonly name: "UsersWhere";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.BasicWhereRequest";
                encode(message: BasicWhereRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BasicWhereRequest;
                fromJSON(object: any): BasicWhereRequest;
                toJSON(message: BasicWhereRequest): unknown;
                create(base?: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    where?: string;
                } | undefined): BasicWhereRequest;
                fromPartial(object: {
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    show?: string | undefined;
                    where?: string;
                }): BasicWhereRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse";
                encode(message: SubredditsSearchResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditsSearchResponse;
                fromJSON(object: any): SubredditsSearchResponse;
                toJSON(message: SubredditsSearchResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                userFlairBackgroundColor?: string | undefined;
                                submitTextHtml?: string | undefined;
                                restrictPosting?: boolean | undefined;
                                userIsBanned?: boolean | undefined;
                                freeFormReports?: boolean | undefined;
                                wikiEnabled?: boolean | undefined;
                                userIsMuted?: boolean | undefined;
                                userCanFlairInSr?: boolean | undefined;
                                displayName?: string | undefined;
                                headerImg?: string | undefined;
                                title?: string | undefined;
                                allowGalleries?: boolean | undefined;
                                iconSize?: number[];
                                primaryColor?: string | undefined;
                                activeUserCount?: number | undefined;
                                iconImg?: string | undefined;
                                displayNamePrefixed?: string | undefined;
                                accountsActive?: number | undefined;
                                publicTraffic?: boolean | undefined;
                                subscribers?: number | undefined;
                                userFlairRichtext?: string[];
                                videostreamLinksCount?: number | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                hideAds?: boolean | undefined;
                                emojisEnabled?: boolean | undefined;
                                advertiserCategory?: string | undefined;
                                publicDescription?: string | undefined;
                                commentScoreHideMins?: number | undefined;
                                allowPredictions?: boolean | undefined;
                                userHasFavorited?: boolean | undefined;
                                userFlairTemplateId?: string | undefined;
                                communityIcon?: string | undefined;
                                bannerBackgroundImage?: string | undefined;
                                originalContentTagEnabled?: boolean | undefined;
                                communityReviewed?: boolean | undefined;
                                submitText?: string | undefined;
                                descriptionHtml?: string | undefined;
                                spoilersEnabled?: boolean | undefined;
                                commentContributionSettings?: {
                                    allowedMediaTypes?: string[];
                                } | undefined;
                                allowTalks?: boolean | undefined;
                                headerSize?: number[];
                                userFlairPosition?: string | undefined;
                                allOriginalContent?: boolean | undefined;
                                hasMenuWidget?: boolean | undefined;
                                isEnrolledInNewModmail?: boolean | undefined;
                                keyColor?: string | undefined;
                                canAssignUserFlair?: boolean | undefined;
                                created?: number | undefined;
                                wls?: number | undefined;
                                showMediaPreview?: boolean | undefined;
                                submissionType?: string | undefined;
                                userIsSubscriber?: boolean | undefined;
                                allowedMediaInComments?: string[];
                                allowVideogifs?: boolean | undefined;
                                shouldArchivePosts?: boolean | undefined;
                                userFlairType?: string | undefined;
                                allowPolls?: boolean | undefined;
                                collapseDeletedComments?: boolean | undefined;
                                emojisCustomSize?: number[];
                                publicDescriptionHtml?: string | undefined;
                                allowVideos?: boolean | undefined;
                                isCrosspostableSubreddit?: boolean | undefined;
                                notificationLevel?: string | undefined;
                                shouldShowMediaInCommentsSetting?: boolean | undefined;
                                canAssignLinkFlair?: boolean | undefined;
                                accountsActiveIsFuzzed?: boolean | undefined;
                                allowPredictionContributors?: boolean | undefined;
                                submitTextLabel?: string | undefined;
                                linkFlairPosition?: string | undefined;
                                userSrFlairEnabled?: boolean | undefined;
                                userFlairEnabledInSr?: boolean | undefined;
                                allowChatPostCreation?: boolean | undefined;
                                allowDiscovery?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                userSrThemeEnabled?: boolean | undefined;
                                linkFlairEnabled?: boolean | undefined;
                                disableContributorRequests?: boolean | undefined;
                                subredditType?: string | undefined;
                                suggestedCommentSort?: string | undefined;
                                bannerImg?: string | undefined;
                                userFlairText?: string | undefined;
                                contentCategory?: string | undefined;
                                bannerBackgroundColor?: string | undefined;
                                showMedia?: boolean | undefined;
                                id?: string | undefined;
                                userIsModerator?: boolean | undefined;
                                over18?: boolean | undefined;
                                headerTitle?: string | undefined;
                                description?: string | undefined;
                                isChatPostFeatureEnabled?: boolean | undefined;
                                submitLinkLabel?: string | undefined;
                                userFlairTextColor?: string | undefined;
                                restrictCommenting?: boolean | undefined;
                                userFlairCssClass?: string | undefined;
                                allowImages?: boolean | undefined;
                                lang?: string | undefined;
                                whitelistStatus?: string | undefined;
                                url?: string | undefined;
                                createdUtc?: number | undefined;
                                bannerSize?: number[];
                                mobileBannerImage?: string | undefined;
                                userIsContributor?: boolean | undefined;
                                allowPredictionsTournament?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                } | undefined): SubredditsSearchResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        dist?: number | undefined;
                        geoFilter?: string | undefined;
                        children?: {
                            kind?: string | undefined;
                            data?: {
                                userFlairBackgroundColor?: string | undefined;
                                submitTextHtml?: string | undefined;
                                restrictPosting?: boolean | undefined;
                                userIsBanned?: boolean | undefined;
                                freeFormReports?: boolean | undefined;
                                wikiEnabled?: boolean | undefined;
                                userIsMuted?: boolean | undefined;
                                userCanFlairInSr?: boolean | undefined;
                                displayName?: string | undefined;
                                headerImg?: string | undefined;
                                title?: string | undefined;
                                allowGalleries?: boolean | undefined;
                                iconSize?: number[];
                                primaryColor?: string | undefined;
                                activeUserCount?: number | undefined;
                                iconImg?: string | undefined;
                                displayNamePrefixed?: string | undefined;
                                accountsActive?: number | undefined;
                                publicTraffic?: boolean | undefined;
                                subscribers?: number | undefined;
                                userFlairRichtext?: string[];
                                videostreamLinksCount?: number | undefined;
                                name?: string | undefined;
                                quarantine?: boolean | undefined;
                                hideAds?: boolean | undefined;
                                emojisEnabled?: boolean | undefined;
                                advertiserCategory?: string | undefined;
                                publicDescription?: string | undefined;
                                commentScoreHideMins?: number | undefined;
                                allowPredictions?: boolean | undefined;
                                userHasFavorited?: boolean | undefined;
                                userFlairTemplateId?: string | undefined;
                                communityIcon?: string | undefined;
                                bannerBackgroundImage?: string | undefined;
                                originalContentTagEnabled?: boolean | undefined;
                                communityReviewed?: boolean | undefined;
                                submitText?: string | undefined;
                                descriptionHtml?: string | undefined;
                                spoilersEnabled?: boolean | undefined;
                                commentContributionSettings?: {
                                    allowedMediaTypes?: string[];
                                } | undefined;
                                allowTalks?: boolean | undefined;
                                headerSize?: number[];
                                userFlairPosition?: string | undefined;
                                allOriginalContent?: boolean | undefined;
                                hasMenuWidget?: boolean | undefined;
                                isEnrolledInNewModmail?: boolean | undefined;
                                keyColor?: string | undefined;
                                canAssignUserFlair?: boolean | undefined;
                                created?: number | undefined;
                                wls?: number | undefined;
                                showMediaPreview?: boolean | undefined;
                                submissionType?: string | undefined;
                                userIsSubscriber?: boolean | undefined;
                                allowedMediaInComments?: string[];
                                allowVideogifs?: boolean | undefined;
                                shouldArchivePosts?: boolean | undefined;
                                userFlairType?: string | undefined;
                                allowPolls?: boolean | undefined;
                                collapseDeletedComments?: boolean | undefined;
                                emojisCustomSize?: number[];
                                publicDescriptionHtml?: string | undefined;
                                allowVideos?: boolean | undefined;
                                isCrosspostableSubreddit?: boolean | undefined;
                                notificationLevel?: string | undefined;
                                shouldShowMediaInCommentsSetting?: boolean | undefined;
                                canAssignLinkFlair?: boolean | undefined;
                                accountsActiveIsFuzzed?: boolean | undefined;
                                allowPredictionContributors?: boolean | undefined;
                                submitTextLabel?: string | undefined;
                                linkFlairPosition?: string | undefined;
                                userSrFlairEnabled?: boolean | undefined;
                                userFlairEnabledInSr?: boolean | undefined;
                                allowChatPostCreation?: boolean | undefined;
                                allowDiscovery?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                userSrThemeEnabled?: boolean | undefined;
                                linkFlairEnabled?: boolean | undefined;
                                disableContributorRequests?: boolean | undefined;
                                subredditType?: string | undefined;
                                suggestedCommentSort?: string | undefined;
                                bannerImg?: string | undefined;
                                userFlairText?: string | undefined;
                                contentCategory?: string | undefined;
                                bannerBackgroundColor?: string | undefined;
                                showMedia?: boolean | undefined;
                                id?: string | undefined;
                                userIsModerator?: boolean | undefined;
                                over18?: boolean | undefined;
                                headerTitle?: string | undefined;
                                description?: string | undefined;
                                isChatPostFeatureEnabled?: boolean | undefined;
                                submitLinkLabel?: string | undefined;
                                userFlairTextColor?: string | undefined;
                                restrictCommenting?: boolean | undefined;
                                userFlairCssClass?: string | undefined;
                                allowImages?: boolean | undefined;
                                lang?: string | undefined;
                                whitelistStatus?: string | undefined;
                                url?: string | undefined;
                                createdUtc?: number | undefined;
                                bannerSize?: number[];
                                mobileBannerImage?: string | undefined;
                                userIsContributor?: boolean | undefined;
                                allowPredictionsTournament?: boolean | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                }): SubredditsSearchResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Add a removal reason to a subreddit.
         *
         * POST /api/v1/{subreddit}/removal_reasons
         */
        readonly subredditAddRemovalReason: {
            readonly name: "SubredditAddRemovalReason";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonRequest";
                encode(message: SubredditAddRemovalReasonRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditAddRemovalReasonRequest;
                fromJSON(object: any): SubredditAddRemovalReasonRequest;
                toJSON(message: SubredditAddRemovalReasonRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    message?: string;
                    title?: string;
                } | undefined): SubredditAddRemovalReasonRequest;
                fromPartial(object: {
                    subreddit?: string;
                    message?: string;
                    title?: string;
                }): SubredditAddRemovalReasonRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditAddRemovalReasonResponse";
                encode(message: SubredditAddRemovalReasonResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditAddRemovalReasonResponse;
                fromJSON(object: any): SubredditAddRemovalReasonResponse;
                toJSON(message: SubredditAddRemovalReasonResponse): unknown;
                create(base?: {
                    id?: string;
                } | undefined): SubredditAddRemovalReasonResponse;
                fromPartial(object: {
                    id?: string;
                }): SubredditAddRemovalReasonResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Get the list of subreddit's removal reasons.
         *
         * GET /api/v1/{subreddit}/removal_reasons
         */
        readonly subredditGetRemovalReasons: {
            readonly name: "SubredditGetRemovalReasons";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsRequest";
                encode(message: SubredditGetRemovalReasonsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditGetRemovalReasonsRequest;
                fromJSON(object: any): SubredditGetRemovalReasonsRequest;
                toJSON(message: SubredditGetRemovalReasonsRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): SubredditGetRemovalReasonsRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): SubredditGetRemovalReasonsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.subreddits.SubredditGetRemovalReasonsResponse";
                encode(message: SubredditGetRemovalReasonsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SubredditGetRemovalReasonsResponse;
                fromJSON(object: any): SubredditGetRemovalReasonsResponse;
                toJSON(message: SubredditGetRemovalReasonsResponse): unknown;
                create(base?: {
                    data?: {
                        [x: string]: {
                            id?: string;
                            message?: string;
                            title?: string;
                        } | undefined;
                    };
                    order?: string[];
                } | undefined): SubredditGetRemovalReasonsResponse;
                fromPartial(object: {
                    data?: {
                        [x: string]: {
                            id?: string;
                            message?: string;
                            title?: string;
                        } | undefined;
                    };
                    order?: string[];
                }): SubredditGetRemovalReasonsResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
    };
};

export declare type SubredditSettings = {
    /**
     * Whether the subreddit accepts followers or not.
     */
    acceptFollowers: boolean;
    /**
     * Whether all content posted on the subreddit is original.
     */
    allOriginalContent: boolean;
    /**
     * Whether users are allowed to create chat posts on the subreddit.
     */
    allowChatPostCreation: boolean;
    /**
     * Whether the subreddit can be discovered through search.
     */
    allowDiscovery: boolean;
    /**
     * Whether the subreddit allows galleries.
     */
    allowGalleries: boolean;
    /**
     * Whether the subreddit allows images.
     */
    allowImages: boolean;
    /**
     * Whether the subreddit allows polls.
     */
    allowPolls: boolean;
    /**
     * Whether contributors are allowed to make predictions on the subreddit.
     */
    allowPredictionContributors: boolean;
    /**
     * Whether predictions are allowed on the subreddit.
     */
    allowPredictions: boolean;
    /**
     * Whether prediction tournaments are allowed on the subreddit.
     */
    allowPredictionsTournament: boolean;
    /**
     * Whether talks are allowed on the subreddit.
     */
    allowTalks: boolean;
    /**
     * Whether video GIFs are allowed on the subreddit.
     */
    allowVideoGifs: boolean;
    /**
     * Whether videos are allowed on the subreddit.
     */
    allowVideos: boolean;
    /**
     * Whether chat posts are enabled on the subreddit.
     */
    chatPostEnabled: boolean;
    /**
     * Whether collections are enabled on the subreddit.
     */
    collectionsEnabled: boolean;
    /**
     * Whether crossposts can be made to this subreddit.
     */
    crosspostable: boolean;
    /**
     * Whether emojis are enabled on the subreddit.
     */
    emojisEnabled: boolean;
    /**
     * Whether event posts are enabled on the subreddit.
     */
    eventPostsEnabled: boolean;
    /**
     * Whether link flairs are enabled on the subreddit.
     */
    linkFlairEnabled: boolean;
    /**
     * Whether the Original Content tag is enabled.
     */
    originalContentTagEnabled: boolean;
    /**
     * Whether commenting is restricted in the subreddit.
     */
    restrictCommenting: boolean;
    /**
     * Whether posting is restricted in the subreddit.
     */
    restrictPosting: boolean;
    /**
     * Whether posts in the subreddit should be automatically archived after 6 months.
     */
    shouldArchivePosts: boolean;
    /**
     * Whether the Spoiler tag is enabled.
     */
    spoilersEnabled: boolean;
    /**
     * Whether the wiki is enabled for the subreddit.
     */
    wikiEnabled: boolean;
    /**
     * The types of post allowed in this subreddit. Either "any", "link", or "self".
     */
    allowedPostType: 'any' | 'link' | 'self';
    /**
     * List of allowed media types in the comments made in the subreddit.
     */
    allowedMediaInComments: CommentMediaTypes[];
    /**
     * a 6-digit rgb hex color of the banner e.g. `#AABBCC`,
     */
    bannerBackgroundColor?: string;
    /**
     * The background image of the banner.
     */
    bannerBackgroundImage?: string;
    /**
     * The URL of the banner image.
     */
    bannerImage?: string;
    /**
     * The URL of the community icon.
     */
    communityIcon?: string;
    /**
     * The header title.
     */
    headerTitle?: string;
    /**
     * Banner image used on mobile apps.
     */
    mobileBannerImage?: string;
    /**
     * The user flair settings for the subreddit.
     */
    userFlairs: FlairSettings;
    /**
     * The post flair settings for the subreddit.
     */
    postFlairs: FlairSettings;
    /**
     * HTTP URL to the subreddit
     */
    url: string;
};

declare interface SubredditsResponse {
    subreddits: {
        [key: string]: SubredditsResponse_SubredditData;
    };
}

declare const SubredditsResponse: {
    $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse";
    encode(message: SubredditsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditsResponse;
    fromJSON(object: any): SubredditsResponse;
    toJSON(message: SubredditsResponse): unknown;
    create(base?: DeepPartial_71<SubredditsResponse>): SubredditsResponse;
    fromPartial(object: DeepPartial_71<SubredditsResponse>): SubredditsResponse;
};

declare interface SubredditsResponse_SubredditData {
    communityIcon?: string | undefined;
    keyColor?: string | undefined;
    displayName?: string | undefined;
    name?: string | undefined;
    subscribers?: number | undefined;
    primaryColor?: string | undefined;
    id?: string | undefined;
    lastUpdated?: string | undefined;
    icon?: string | undefined;
}

declare const SubredditsResponse_SubredditData: {
    $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditData";
    encode(message: SubredditsResponse_SubredditData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditsResponse_SubredditData;
    fromJSON(object: any): SubredditsResponse_SubredditData;
    toJSON(message: SubredditsResponse_SubredditData): unknown;
    create(base?: DeepPartial_71<SubredditsResponse_SubredditData>): SubredditsResponse_SubredditData;
    fromPartial(object: DeepPartial_71<SubredditsResponse_SubredditData>): SubredditsResponse_SubredditData;
};

declare interface SubredditsResponse_SubredditsEntry {
    key: string;
    value?: SubredditsResponse_SubredditData | undefined;
}

declare const SubredditsResponse_SubredditsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditsEntry";
    encode(message: SubredditsResponse_SubredditsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditsResponse_SubredditsEntry;
    fromJSON(object: any): SubredditsResponse_SubredditsEntry;
    toJSON(message: SubredditsResponse_SubredditsEntry): unknown;
    create(base?: DeepPartial_71<SubredditsResponse_SubredditsEntry>): SubredditsResponse_SubredditsEntry;
    fromPartial(object: DeepPartial_71<SubredditsResponse_SubredditsEntry>): SubredditsResponse_SubredditsEntry;
};

declare interface SubredditsSearchRequest {
    /** fullname of a thing */
    after?: string | undefined;
    /** fullname of a thing */
    before?: string | undefined;
    /** a positive integer (default: 0) */
    count?: number | undefined;
    /** the maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    /** a search query */
    q: string;
    /** a uuid */
    searchQueryId?: string | undefined;
    /** (optional) the string all */
    show?: string | undefined;
    /** boolean value */
    showUsers?: boolean | undefined;
    /** one of (relevance, activity) */
    sort?: string | undefined;
    /** (optional) boolean value */
    typeaheadActive?: boolean | undefined;
}

declare const SubredditsSearchRequest: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchRequest";
    encode(message: SubredditsSearchRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditsSearchRequest;
    fromJSON(object: any): SubredditsSearchRequest;
    toJSON(message: SubredditsSearchRequest): unknown;
    create(base?: DeepPartial_11<SubredditsSearchRequest>): SubredditsSearchRequest;
    fromPartial(object: DeepPartial_11<SubredditsSearchRequest>): SubredditsSearchRequest;
};

declare interface SubredditsSearchResponse {
    kind?: string | undefined;
    data?: SubredditsSearchResponse_WrappedSubredditObject | undefined;
}

declare const SubredditsSearchResponse: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse";
    encode(message: SubredditsSearchResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditsSearchResponse;
    fromJSON(object: any): SubredditsSearchResponse;
    toJSON(message: SubredditsSearchResponse): unknown;
    create(base?: DeepPartial_11<SubredditsSearchResponse>): SubredditsSearchResponse;
    fromPartial(object: DeepPartial_11<SubredditsSearchResponse>): SubredditsSearchResponse;
};

declare interface SubredditsSearchResponse_WrappedSubredditObject {
    after?: string | undefined;
    before?: string | undefined;
    dist?: number | undefined;
    geoFilter?: string | undefined;
    children: SubredditsSearchResponse_WrappedSubredditObject_SubredditData[];
}

declare const SubredditsSearchResponse_WrappedSubredditObject: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject";
    encode(message: SubredditsSearchResponse_WrappedSubredditObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditsSearchResponse_WrappedSubredditObject;
    fromJSON(object: any): SubredditsSearchResponse_WrappedSubredditObject;
    toJSON(message: SubredditsSearchResponse_WrappedSubredditObject): unknown;
    create(base?: DeepPartial_11<SubredditsSearchResponse_WrappedSubredditObject>): SubredditsSearchResponse_WrappedSubredditObject;
    fromPartial(object: DeepPartial_11<SubredditsSearchResponse_WrappedSubredditObject>): SubredditsSearchResponse_WrappedSubredditObject;
};

declare interface SubredditsSearchResponse_WrappedSubredditObject_SubredditData {
    kind?: string | undefined;
    data?: FullSubredditObject | undefined;
}

declare const SubredditsSearchResponse_WrappedSubredditObject_SubredditData: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject.SubredditData";
    encode(message: SubredditsSearchResponse_WrappedSubredditObject_SubredditData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditsSearchResponse_WrappedSubredditObject_SubredditData;
    fromJSON(object: any): SubredditsSearchResponse_WrappedSubredditObject_SubredditData;
    toJSON(message: SubredditsSearchResponse_WrappedSubredditObject_SubredditData): unknown;
    create(base?: DeepPartial_11<SubredditsSearchResponse_WrappedSubredditObject_SubredditData>): SubredditsSearchResponse_WrappedSubredditObject_SubredditData;
    fromPartial(object: DeepPartial_11<SubredditsSearchResponse_WrappedSubredditObject_SubredditData>): SubredditsSearchResponse_WrappedSubredditObject_SubredditData;
};

declare const SubredditsServiceName = "devvit.plugin.redditapi.subreddits.Subreddits";

declare interface SubredditStylesheetRequest {
    /** one of (save, preview) */
    op: string;
    /** a string up to 256 characters long, consisting of printable characters. */
    reason: string;
    /** the new stylesheet content */
    stylesheetContents: string;
    /** the name of the subreddit */
    subreddit: string;
}

declare const SubredditStylesheetRequest: {
    $type: "devvit.plugin.redditapi.subreddits.SubredditStylesheetRequest";
    encode(message: SubredditStylesheetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditStylesheetRequest;
    fromJSON(object: any): SubredditStylesheetRequest;
    toJSON(message: SubredditStylesheetRequest): unknown;
    create(base?: DeepPartial_11<SubredditStylesheetRequest>): SubredditStylesheetRequest;
    fromPartial(object: DeepPartial_11<SubredditStylesheetRequest>): SubredditStylesheetRequest;
};

declare interface SubredditSubscribe {
    subreddit?: SubredditV2 | undefined;
    subscriber?: UserV2 | undefined;
}

declare const SubredditSubscribe: {
    $type: "devvit.events.v1alpha.SubredditSubscribe";
    encode(message: SubredditSubscribe, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditSubscribe;
    fromJSON(object: any): SubredditSubscribe;
    toJSON(message: SubredditSubscribe): unknown;
    create(base?: DeepPartial_74<SubredditSubscribe>): SubredditSubscribe;
    fromPartial(object: DeepPartial_74<SubredditSubscribe>): SubredditSubscribe;
};

export declare type SubredditType = 'public' | 'private' | 'restricted' | 'employees_only' | 'gold_restricted' | 'archived';

declare enum SubredditType_2 {
    ARCHIVED = 0,
    EMPLOYEES_ONLY = 1,
    GOLD_ONLY = 2,
    GOLD_RESTRICTED = 3,
    PRIVATE = 4,
    PUBLIC = 5,
    RESTRICTED = 6,
    USER = 7,
    UNRECOGNIZED = -1
}

declare function subredditTypeFromJSON(object: any): SubredditType_2;

declare function subredditTypeToJSON(object: SubredditType_2): number;

declare interface SubredditV2 {
    id: string;
    name: string;
    nsfw: boolean;
    type: SubredditType_2;
    spam: boolean;
    quarantined: boolean;
    topics: string[];
    rating: SubredditRating;
    subscribersCount: number;
    permalink: string;
}

declare const SubredditV2: {
    $type: "devvit.reddit.v2alpha.SubredditV2";
    encode(message: SubredditV2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubredditV2;
    fromJSON(object: any): SubredditV2;
    toJSON(message: SubredditV2): unknown;
    create(base?: DeepPartial_76<SubredditV2>): SubredditV2;
    fromPartial(object: DeepPartial_76<SubredditV2>): SubredditV2;
};

declare interface SubscribeRequest {
    /** one of (sub, unsub) */
    action: string;
    /** one of (o, n, b, o, a, r, d, i, n, g) */
    actionSource: string;
    /** boolean value */
    skipInitialDefaults: boolean;
    /** A comma-separated list of subreddit fullnames */
    sr: string;
    /** A comma-separated list of subreddit names */
    srName: string;
}

declare const SubscribeRequest: {
    $type: "devvit.plugin.redditapi.subreddits.SubscribeRequest";
    encode(message: SubscribeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeRequest;
    fromJSON(object: any): SubscribeRequest;
    toJSON(message: SubscribeRequest): unknown;
    create(base?: DeepPartial_11<SubscribeRequest>): SubscribeRequest;
    fromPartial(object: DeepPartial_11<SubscribeRequest>): SubscribeRequest;
};

/**
 * Root Worker, responsible for RPC and loading additional Workers
 * local://supervisor
 */
declare interface Supervisor {
    /**
     * Transform an incoming envelope.
     *
     * Because the input and outputs are Envelopes, they are actually Envelopes
     * wrapped in Envelopes. That is, Envelope.message is an Envelope. The outer
     * Envelope.success flag indicates filter status.
     */
    Filter(request: Envelope, metadata?: Metadata): Promise<Envelope>;
    /** Unpacks and loads each bundled Actor into their own Workers */
    Load(request: LinkedBundle, metadata?: Metadata): Promise<Empty>;
    /** Unloads the actor at the provided URI, and unloads dependencies if needed */
    Unload(request: UnloadRequest, metadata?: Metadata): Promise<Empty>;
}

declare class SupervisorClientImpl implements Supervisor {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_7, opts?: {
        service?: string;
    });
    Filter(request: Envelope, metadata?: Metadata): Promise<Envelope>;
    Load(request: LinkedBundle, metadata?: Metadata): Promise<Empty>;
    Unload(request: UnloadRequest, metadata?: Metadata): Promise<Empty>;
}

/**
 * Root Worker, responsible for RPC and loading additional Workers
 * local://supervisor
 */
declare type SupervisorDefinition = typeof SupervisorDefinition;

declare const SupervisorDefinition: {
    readonly name: "Supervisor";
    readonly fullName: "devvit.runtime.actor.Supervisor";
    readonly methods: {
        /**
         * Transform an incoming envelope.
         *
         * Because the input and outputs are Envelopes, they are actually Envelopes
         * wrapped in Envelopes. That is, Envelope.message is an Envelope. The outer
         * Envelope.success flag indicates filter status.
         */
        readonly filter: {
            readonly name: "Filter";
            readonly requestType: {
                $type: "devvit.runtime.Envelope";
                encode(message: Envelope, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Envelope;
                fromJSON(object: any): Envelope;
                toJSON(message: Envelope): unknown;
                create(base?: {
                    id?: string;
                    src?: string;
                    dst?: string;
                    method?: string;
                    streamId?: string;
                    traceId?: string;
                    success?: boolean;
                    message?: any;
                    request?: boolean;
                    complete?: boolean;
                    metadata?: {
                        [x: string]: {
                            values?: string[];
                        } | undefined;
                    };
                } | undefined): Envelope;
                fromPartial(object: {
                    id?: string;
                    src?: string;
                    dst?: string;
                    method?: string;
                    streamId?: string;
                    traceId?: string;
                    success?: boolean;
                    message?: any;
                    request?: boolean;
                    complete?: boolean;
                    metadata?: {
                        [x: string]: {
                            values?: string[];
                        } | undefined;
                    };
                }): Envelope;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.runtime.Envelope";
                encode(message: Envelope, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Envelope;
                fromJSON(object: any): Envelope;
                toJSON(message: Envelope): unknown;
                create(base?: {
                    id?: string;
                    src?: string;
                    dst?: string;
                    method?: string;
                    streamId?: string;
                    traceId?: string;
                    success?: boolean;
                    message?: any;
                    request?: boolean;
                    complete?: boolean;
                    metadata?: {
                        [x: string]: {
                            values?: string[];
                        } | undefined;
                    };
                } | undefined): Envelope;
                fromPartial(object: {
                    id?: string;
                    src?: string;
                    dst?: string;
                    method?: string;
                    streamId?: string;
                    traceId?: string;
                    success?: boolean;
                    message?: any;
                    request?: boolean;
                    complete?: boolean;
                    metadata?: {
                        [x: string]: {
                            values?: string[];
                        } | undefined;
                    };
                }): Envelope;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Unpacks and loads each bundled Actor into their own Workers */
        readonly load: {
            readonly name: "Load";
            readonly requestType: {
                $type: "devvit.runtime.LinkedBundle";
                encode(message: LinkedBundle, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): LinkedBundle;
                fromJSON(object: any): LinkedBundle;
                toJSON(message: LinkedBundle): unknown;
                create(base?: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                } | undefined): LinkedBundle;
                fromPartial(object: {
                    actor?: {
                        name?: string;
                        owner?: string;
                        version?: string;
                    } | undefined;
                    code?: string;
                    hostname?: string;
                    provides?: {
                        fullName?: string;
                        methods?: {
                            fullName?: string;
                            name?: string;
                            requestStream?: boolean;
                            responseStream?: boolean;
                            requestType?: string;
                            responseType?: string;
                        }[];
                        name?: string;
                        version?: string;
                    }[];
                    uses?: any[];
                    buildInfo?: {
                        created?: Date | undefined;
                        dependencies?: {
                            [x: string]: string | undefined;
                        };
                    } | undefined;
                    assetsUrl?: string | undefined;
                    assets?: {
                        [x: string]: string | undefined;
                    };
                }): LinkedBundle;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** Unloads the actor at the provided URI, and unloads dependencies if needed */
        readonly unload: {
            readonly name: "Unload";
            readonly requestType: {
                $type: "devvit.runtime.actor.UnloadRequest";
                encode(message: UnloadRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): UnloadRequest;
                fromJSON(object: any): UnloadRequest;
                toJSON(message: UnloadRequest): unknown;
                create(base?: DeepPartial_107<UnloadRequest>): UnloadRequest;
                fromPartial(object: DeepPartial_107<UnloadRequest>): UnloadRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const SupervisorServiceName = "devvit.runtime.actor.Supervisor";

/**
 * @experimental
 *
 * A helper to allow SVG functionality within image tags.
 *
 * @example
 * ```ts
 * import { Devvit, svg } from '@devvit/public-api';
 * const App = () => {
 *     const color = 'gold'
 *     return (
 *        <hstack>
 *          <image
 *            url={svg`<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
 *                      <circle fill="${color}" cx="5" cy="5" r="4" />
 *                    </svg>`}
 *            imageHeight={100}
 *            imageWidth={100}
 *          />
 *        </hstack>
 *     )
 * }
 * ```
 */
export declare function svg(strings: TemplateStringsArray, ...args: (string | number)[]): `data:image/svg+xml;charset=UTF-8,${string}` | '';

/** Commment thing ID. */
declare type T1ID = `${T_PREFIX.COMMENT}${string}`;

/** Account thing ID. */
declare type T2ID = `${T_PREFIX.ACCOUNT}${string}`;

/** Post (also called link) thing ID. */
declare type T3ID = `${T_PREFIX.LINK}${string}`;

/** Message thing ID. */
declare type T4ID = `${T_PREFIX.MESSAGE}${string}`;

/** Subreddit thing ID. */
declare type T5ID = `${T_PREFIX.SUBREDDIT}${string}`;

/** Award thing ID. */
declare type T6ID = `${T_PREFIX.AWARD}${string}`;

declare enum T_PREFIX {
    COMMENT = "t1_",
    ACCOUNT = "t2_",
    LINK = "t3_",// Same as POST
    MESSAGE = "t4_",
    SUBREDDIT = "t5_",
    AWARD = "t6_"
}

/**
 * @mixin
 */
declare type TableCellContainer<Context> = {
    /**
     * Append a Cell to a Table Row
     * @param cb scoped callback to add child elements to this Table Cell
     */
    cell(cb: (cell: TableCellContext) => void): Context;
};

/**
 * @borrows TextContainer
 * @borrows LinkContainer
 * @borrows ImageContainer
 */
declare interface TableCellContext extends TextContainer<TableCellContext>, LinkContainer<TableCellContext>, ImageContainer<TableCellContext> {
}

/**
 * @mixin
 */
declare type TableContainer<Context> = {
    /**
     * Append a Table
     * @param cb scoped callback to add child elements to this Table
     */
    table(cb: (table: TableContext) => void): Context;
};

/**
 * @mixin
 */
declare type TableContentContainer<Context> = {
    /**
     * Append a Table Cell to the Table Header
     * @param opts {@link TableHeaderCellOptions}
     * @param cb scoped callback to add child elements to this Table Header Cell
     */
    headerCell(opts: TableHeaderCellOptions, cb: (cell: TableHeaderCellContext) => void): Context;
    /**
     * Append a Table Row to the Table
     * @param cb scoped callback to add child elements to this Table Row
     */
    row(cb: (row: TableRowContext) => void): Context;
};

/**
 * @borrows TableContentContainer
 */
declare interface TableContext extends TableContentContainer<TableContext> {
}

/**
 * @borrows TableCellContext
 */
declare type TableHeaderCellContext = TableCellContext;

declare type TableHeaderCellOptions = {
    /** Text alignment for the entire column */
    columnAlignment?: 'left' | 'right' | 'center';
};

/**
 * @borrows TableCellContainer
 */
declare interface TableRowContext extends TableCellContainer<TableRowContext> {
}

declare interface TempBanRequest {
    /** id36 of a modmail conversation id */
    conversationId: string;
    /** duration in days, max 999 */
    duration: number;
}

declare const TempBanRequest: {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanRequest";
    encode(message: TempBanRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TempBanRequest;
    fromJSON(object: any): TempBanRequest;
    toJSON(message: TempBanRequest): unknown;
    create(base?: DeepPartial_71<TempBanRequest>): TempBanRequest;
    fromPartial(object: DeepPartial_71<TempBanRequest>): TempBanRequest;
};

declare interface TempBanResponse {
    conversations?: ConversationData_2 | undefined;
    messages: {
        [key: string]: MessageData_2;
    };
    user?: ConversationUserData_2 | undefined;
    modActions: {
        [key: string]: ModActionData_2;
    };
    /** error case */
    fields: string[];
    reason?: string | undefined;
    message?: string | undefined;
}

declare const TempBanResponse: {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse";
    encode(message: TempBanResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TempBanResponse;
    fromJSON(object: any): TempBanResponse;
    toJSON(message: TempBanResponse): unknown;
    create(base?: DeepPartial_71<TempBanResponse>): TempBanResponse;
    fromPartial(object: DeepPartial_71<TempBanResponse>): TempBanResponse;
};

declare interface TempBanResponse_MessagesEntry {
    key: string;
    value?: MessageData_2 | undefined;
}

declare const TempBanResponse_MessagesEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.MessagesEntry";
    encode(message: TempBanResponse_MessagesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TempBanResponse_MessagesEntry;
    fromJSON(object: any): TempBanResponse_MessagesEntry;
    toJSON(message: TempBanResponse_MessagesEntry): unknown;
    create(base?: DeepPartial_71<TempBanResponse_MessagesEntry>): TempBanResponse_MessagesEntry;
    fromPartial(object: DeepPartial_71<TempBanResponse_MessagesEntry>): TempBanResponse_MessagesEntry;
};

declare interface TempBanResponse_ModActionsEntry {
    key: string;
    value?: ModActionData_2 | undefined;
}

declare const TempBanResponse_ModActionsEntry: {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.ModActionsEntry";
    encode(message: TempBanResponse_ModActionsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TempBanResponse_ModActionsEntry;
    fromJSON(object: any): TempBanResponse_ModActionsEntry;
    toJSON(message: TempBanResponse_ModActionsEntry): unknown;
    create(base?: DeepPartial_71<TempBanResponse_ModActionsEntry>): TempBanResponse_ModActionsEntry;
    fromPartial(object: DeepPartial_71<TempBanResponse_ModActionsEntry>): TempBanResponse_ModActionsEntry;
};

declare interface TestMessage {
    number: number;
}

declare const TestMessage: {
    $type: "devvit.actor.test.TestMessage";
    encode(message: TestMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TestMessage;
    fromJSON(object: any): TestMessage;
    toJSON(message: TestMessage): unknown;
    create(base?: DeepPartial_92<TestMessage>): TestMessage;
    fromPartial(object: DeepPartial_92<TestMessage>): TestMessage;
};

declare type Text = {
    e: typeof TEXT_ELEMENT;
    t: string;
    f?: FormatRange[];
};

declare const TEXT_ELEMENT = "text";

export declare class TextAreaWidget extends Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get text(): string;
    get styles(): WidgetStyles;
    toJSON(): ReturnType<Widget['toJSON']> & Pick<TextAreaWidget, 'text' | 'styles'>;
}

declare interface TextAreaWidget_2 {
    id: string;
    kind: string;
    shortName: string;
    text: string;
    styles?: WidgetStyles | undefined;
}

declare const TextAreaWidget_2: {
    $type: "devvit.plugin.redditapi.widgets.TextAreaWidget";
    encode(message: TextAreaWidget_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TextAreaWidget_2;
    fromJSON(object: any): TextAreaWidget_2;
    toJSON(message: TextAreaWidget_2): unknown;
    create(base?: DeepPartial_4<TextAreaWidget_2>): TextAreaWidget_2;
    fromPartial(object: DeepPartial_4<TextAreaWidget_2>): TextAreaWidget_2;
};

/**
 * @mixin
 */
declare type TextContainer<Context> = {
    /**
     * Append Text with optional formatting
     * @param opts {@link TextOptions}
     */
    text(opts: TextOptions): Context;
};

declare type TextNode = PlainText | SpoilerText;

/**
 * @borrows RawTextOptions
 */
declare type TextOptions = RawTextOptions & {
    /**
     * A list of FormatRange specifications which defines text style for an
     * arbitrary substring within the text
     * @see {@link FormatRange}
     * @see {@link makeFormatting}
     * @example // Make the exclamation mark italic:
     * { text: 'Hello!', formatting: [makeFormatting({italic: true, startIndex: 5, length: 1})] }
     */
    formatting?: FormatRange[];
};

declare enum ThingType {
    UNKNOWN = 0,
    COMMENT = 1,
    ACCOUNT = 2,
    POST = 3,
    MESSAGE = 4,
    SUBREDDIT = 5,
    AWARD = 6,
    UNRECOGNIZED = -1
}

declare function thingTypeFromJSON(object: any): ThingType;

declare function thingTypeToJSON(object: ThingType): number;

declare type TID = T1ID | T2ID | T3ID | T4ID | T5ID | T6ID;

declare interface Timer {
    Wait(request: TimerMessage, metadata?: Metadata): Promise<Empty>;
}

declare class TimerClientImpl implements Timer {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_12, opts?: {
        service?: string;
    });
    Wait(request: TimerMessage, metadata?: Metadata): Promise<Empty>;
}

declare type TimerDefinition = typeof TimerDefinition;

declare const TimerDefinition: {
    readonly name: "Timer";
    readonly fullName: "devvit.plugin.timer.Timer";
    readonly methods: {
        readonly wait: {
            readonly name: "Wait";
            readonly requestType: {
                $type: "devvit.plugin.timer.TimerMessage";
                encode(message: TimerMessage, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TimerMessage;
                fromJSON(object: any): TimerMessage;
                toJSON(message: TimerMessage): unknown;
                create(base?: DeepPartial_95<TimerMessage>): TimerMessage;
                fromPartial(object: DeepPartial_95<TimerMessage>): TimerMessage;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

/**
 * There's no data sent with the timer (yet?).  Just knowing to fire it is
 * enough.
 */
declare interface TimerEvent {
}

declare const TimerEvent: {
    $type: "devvit.ui.events.v1alpha.TimerEvent";
    encode(_: TimerEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TimerEvent;
    fromJSON(_: any): TimerEvent;
    toJSON(_: TimerEvent): unknown;
    create(base?: DeepPartial_49<TimerEvent>): TimerEvent;
    fromPartial(_: DeepPartial_49<TimerEvent>): TimerEvent;
};

declare interface TimerMessage {
    durationMillis: number;
}

declare const TimerMessage: {
    $type: "devvit.plugin.timer.TimerMessage";
    encode(message: TimerMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TimerMessage;
    fromJSON(object: any): TimerMessage;
    toJSON(message: TimerMessage): unknown;
    create(base?: DeepPartial_95<TimerMessage>): TimerMessage;
    fromPartial(object: DeepPartial_95<TimerMessage>): TimerMessage;
};

declare const TimerServiceName = "devvit.plugin.timer.Timer";

/**
 * A Timestamp represents a point in time independent of any time zone or local
 * calendar, encoded as a count of seconds and fractions of seconds at
 * nanosecond resolution. The count is relative to an epoch at UTC midnight on
 * January 1, 1970, in the proleptic Gregorian calendar which extends the
 * Gregorian calendar backwards to year one.
 *
 * All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
 * second table is needed for interpretation, using a [24-hour linear
 * smear](https://developers.google.com/time/smear).
 *
 * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
 * restricting to that range, we ensure that we can convert to and from [RFC
 * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
 *
 * # Examples
 *
 * Example 1: Compute Timestamp from POSIX `time()`.
 *
 *     Timestamp timestamp;
 *     timestamp.set_seconds(time(NULL));
 *     timestamp.set_nanos(0);
 *
 * Example 2: Compute Timestamp from POSIX `gettimeofday()`.
 *
 *     struct timeval tv;
 *     gettimeofday(&tv, NULL);
 *
 *     Timestamp timestamp;
 *     timestamp.set_seconds(tv.tv_sec);
 *     timestamp.set_nanos(tv.tv_usec * 1000);
 *
 * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
 *
 *     FILETIME ft;
 *     GetSystemTimeAsFileTime(&ft);
 *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
 *
 *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
 *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
 *     Timestamp timestamp;
 *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
 *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
 *
 * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
 *
 *     long millis = System.currentTimeMillis();
 *
 *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
 *         .setNanos((int) ((millis % 1000) * 1000000)).build();
 *
 * Example 5: Compute Timestamp from Java `Instant.now()`.
 *
 *     Instant now = Instant.now();
 *
 *     Timestamp timestamp =
 *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
 *             .setNanos(now.getNano()).build();
 *
 * Example 6: Compute Timestamp from current time in Python.
 *
 *     timestamp = Timestamp()
 *     timestamp.GetCurrentTime()
 *
 * # JSON Mapping
 *
 * In JSON format, the Timestamp type is encoded as a string in the
 * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
 * format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
 * where {year} is always expressed using four digits while {month}, {day},
 * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
 * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
 * are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
 * is required. A proto3 JSON serializer should always use UTC (as indicated by
 * "Z") when printing the Timestamp type and a proto3 JSON parser should be
 * able to accept both UTC and other timezones (as indicated by an offset).
 *
 * For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
 * 01:30 UTC on January 15, 2017.
 *
 * In JavaScript, one can convert a Date object to this format using the
 * standard
 * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
 * method. In Python, a standard `datetime.datetime` object can be converted
 * to this format using
 * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
 * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
 * the Joda Time's [`ISODateTimeFormat.dateTime()`](
 * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
 * ) to obtain a formatter capable of generating timestamps in this format.
 */
declare interface Timestamp {
    /**
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     */
    seconds: number;
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive.
     */
    nanos: number;
}

declare const Timestamp: {
    $type: "google.protobuf.Timestamp";
    encode(message: Timestamp, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Timestamp;
    fromJSON(object: any): Timestamp;
    toJSON(message: Timestamp): unknown;
    create(base?: DeepPartial_27<Timestamp>): Timestamp;
    fromPartial(object: DeepPartial_27<Timestamp>): Timestamp;
};

export declare type Toast = {
    /** The message shown within the toast */
    text: string;
    /** The appearance of the toast */
    appearance?: 'neutral' | 'success';
};

declare interface Toast_2 {
    /** Text to display on the toast */
    text: string;
    /** Additional styling based on what this toast represents */
    appearance?: ToastAppearance | undefined;
    /** Content to display before the text */
    leadingElement?: ToastLeadingElement | undefined;
    /** Content to display after the text */
    trailingElement?: ToastTrailingElement | undefined;
}

declare const Toast_2: {
    $type: "devvit.ui.toast.Toast";
    encode(message: Toast_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Toast_2;
    fromJSON(object: any): Toast_2;
    toJSON(message: Toast_2): unknown;
    create(base?: DeepPartial_35<Toast_2>): Toast_2;
    fromPartial(object: DeepPartial_35<Toast_2>): Toast_2;
};

/** Only fired if the toast has an action button and the user tapped it */
declare interface ToastActionEvent {
}

declare const ToastActionEvent: {
    $type: "devvit.ui.effects.v1alpha.ToastActionEvent";
    encode(_: ToastActionEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ToastActionEvent;
    fromJSON(_: any): ToastActionEvent;
    toJSON(_: ToastActionEvent): unknown;
    create(base?: DeepPartial_36<ToastActionEvent>): ToastActionEvent;
    fromPartial(_: DeepPartial_36<ToastActionEvent>): ToastActionEvent;
};

declare enum ToastAppearance {
    NEUTRAL = 0,
    SUCCESS = 1,
    UNRECOGNIZED = -1
}

declare function toastAppearanceFromJSON(object: any): ToastAppearance;

declare function toastAppearanceToJSON(object: ToastAppearance): number;

declare interface ToastLeadingElement {
    /** Icon name */
    icon?: string | undefined;
    /** Emoji name */
    emoji?: string | undefined;
    /** Username */
    avatar?: string | undefined;
}

declare const ToastLeadingElement: {
    $type: "devvit.ui.toast.ToastLeadingElement";
    encode(message: ToastLeadingElement, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ToastLeadingElement;
    fromJSON(object: any): ToastLeadingElement;
    toJSON(message: ToastLeadingElement): unknown;
    create(base?: DeepPartial_35<ToastLeadingElement>): ToastLeadingElement;
    fromPartial(object: DeepPartial_35<ToastLeadingElement>): ToastLeadingElement;
};

declare interface ToastTrailingElement {
    /** Text button */
    label?: string | undefined;
    /** Icon button */
    icon?: string | undefined;
}

declare const ToastTrailingElement: {
    $type: "devvit.ui.toast.ToastTrailingElement";
    encode(message: ToastTrailingElement, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ToastTrailingElement;
    fromJSON(object: any): ToastTrailingElement;
    toJSON(message: ToastTrailingElement): unknown;
    create(base?: DeepPartial_35<ToastTrailingElement>): ToastTrailingElement;
    fromPartial(object: DeepPartial_35<ToastTrailingElement>): ToastTrailingElement;
};

declare interface TransactionId {
    id: string;
}

declare const TransactionId: {
    $type: "devvit.plugin.redis.TransactionId";
    encode(message: TransactionId, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TransactionId;
    fromJSON(object: any): TransactionId;
    toJSON(message: TransactionId): unknown;
    create(base?: DeepPartial_86<TransactionId>): TransactionId;
    fromPartial(object: DeepPartial_86<TransactionId>): TransactionId;
};

declare interface TransactionResponse {
    str?: string | undefined;
    nil?: Empty | undefined;
    num?: number | undefined;
    members?: ZMembers | undefined;
    values?: RedisValues | undefined;
}

declare const TransactionResponse: {
    $type: "devvit.plugin.redis.TransactionResponse";
    encode(message: TransactionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TransactionResponse;
    fromJSON(object: any): TransactionResponse;
    toJSON(message: TransactionResponse): unknown;
    create(base?: DeepPartial_86<TransactionResponse>): TransactionResponse;
    fromPartial(object: DeepPartial_86<TransactionResponse>): TransactionResponse;
};

declare interface TransactionResponses {
    response: TransactionResponse[];
}

declare const TransactionResponses: {
    $type: "devvit.plugin.redis.TransactionResponses";
    encode(message: TransactionResponses, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TransactionResponses;
    fromJSON(object: any): TransactionResponses;
    toJSON(message: TransactionResponses): unknown;
    create(base?: DeepPartial_86<TransactionResponses>): TransactionResponses;
    fromPartial(object: DeepPartial_86<TransactionResponses>): TransactionResponses;
};

export declare type TriggerContext = Omit<Devvit.Context, 'ui' | 'dimensions' | 'modLog' | 'uiEnvironment'>;

export declare type TriggerDefinition = PostSubmitDefinition | PostCreateDefinition | PostUpdateDefinition | PostFlairUpdateDefinition | PostReportDefinition | PostDeleteDefinition | CommentSubmitDefinition | CommentCreateDefinition | CommentUpdateDefinition | CommentReportDefinition | CommentDeleteDefinition | AppInstallDefinition | AppUpgradeDefinition | ModActionDefinition | ModMailDefinition;

export declare type TriggerEvent = PostSubmit | PostCreate | PostUpdate | PostReport | PostDelete | PostFlairUpdate | CommentSubmit | CommentCreate | CommentUpdate | CommentReport | CommentDelete | AppInstall | AppUpgrade | ModActionTrigger | ModMailTrigger;

declare interface TriggerEvent_2 {
    /** UUID for the event */
    id: string;
    /** Event timestamp */
    timestamp?: Date | undefined;
    subreddit: string;
    postSubmit?: PostSubmit_2 | undefined;
    postCreate?: PostCreate_2 | undefined;
    postUpdate?: PostUpdate_2 | undefined;
    postReport?: PostReport_2 | undefined;
    postFlairUpdate?: PostFlairUpdate_2 | undefined;
    postDelete?: PostDelete_2 | undefined;
    commentSubmit?: CommentSubmit_2 | undefined;
    commentCreate?: CommentCreate_2 | undefined;
    commentUpdate?: CommentUpdate_2 | undefined;
    commentReport?: CommentReport_2 | undefined;
    commentDelete?: CommentDelete_2 | undefined;
    subredditSubscribe?: SubredditSubscribe | undefined;
    appInstall?: AppInstall_2 | undefined;
    appUpgrade?: AppUpgrade_2 | undefined;
    modAction?: ModAction_2 | undefined;
    modMail?: ModMail | undefined;
    accountDelete?: AccountDelete | undefined;
    vote?: Vote | undefined;
    postApprove?: PostApprove | undefined;
    commentApprove?: CommentApprove | undefined;
}

declare const TriggerEvent_2: {
    $type: "devvit.data.triggers.v1alpha.TriggerEvent";
    encode(message: TriggerEvent_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TriggerEvent_2;
    fromJSON(object: any): TriggerEvent_2;
    toJSON(message: TriggerEvent_2): unknown;
    create(base?: DeepPartial_96<TriggerEvent_2>): TriggerEvent_2;
    fromPartial(object: DeepPartial_96<TriggerEvent_2>): TriggerEvent_2;
};

/** Maps a TriggerEvent to a Protobuf message and type. */
export declare type TriggerEventType = {
    PostSubmit: {
        type: 'PostSubmit';
    } & protos.PostSubmit;
    PostCreate: {
        type: 'PostCreate';
    } & protos.PostCreate;
    PostUpdate: {
        type: 'PostUpdate';
    } & protos.PostUpdate;
    PostReport: {
        type: 'PostReport';
    } & protos.PostReport;
    PostDelete: {
        type: 'PostDelete';
    } & protos.PostDelete;
    PostFlairUpdate: {
        type: 'PostFlairUpdate';
    } & protos.PostFlairUpdate;
    CommentSubmit: {
        type: 'CommentSubmit';
    } & protos.CommentSubmit;
    CommentCreate: {
        type: 'CommentCreate';
    } & protos.CommentCreate;
    CommentUpdate: {
        type: 'CommentUpdate';
    } & protos.CommentUpdate;
    CommentReport: {
        type: 'CommentReport';
    } & protos.CommentReport;
    CommentDelete: {
        type: 'CommentDelete';
    } & protos.CommentDelete;
    AppInstall: {
        type: 'AppInstall';
    } & protos.AppInstall;
    AppUpgrade: {
        type: 'AppUpgrade';
    } & protos.AppUpgrade;
    ModAction: {
        type: 'ModAction';
    } & protos.ModAction;
    ModMail: {
        type: 'ModMail';
    } & protos.ModMail;
};

declare interface TriggerFanOutResponse {
    /** installation id of apps to invoke */
    installationIds: string[];
}

declare const TriggerFanOutResponse: {
    $type: "devvit.gateway.v1alpha.TriggerFanOutResponse";
    encode(message: TriggerFanOutResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TriggerFanOutResponse;
    fromJSON(object: any): TriggerFanOutResponse;
    toJSON(message: TriggerFanOutResponse): unknown;
    create(base?: DeepPartial_97<TriggerFanOutResponse>): TriggerFanOutResponse;
    fromPartial(object: DeepPartial_97<TriggerFanOutResponse>): TriggerFanOutResponse;
};

declare interface TriggerInvocation {
    installationId: string;
    evt?: TriggerEvent_2 | undefined;
}

declare const TriggerInvocation: {
    $type: "devvit.gateway.v1alpha.TriggerInvocation";
    encode(message: TriggerInvocation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TriggerInvocation;
    fromJSON(object: any): TriggerInvocation;
    toJSON(message: TriggerInvocation): unknown;
    create(base?: DeepPartial_97<TriggerInvocation>): TriggerInvocation;
    fromPartial(object: DeepPartial_97<TriggerInvocation>): TriggerInvocation;
};

export declare type TriggerOnEventHandler<RequestType> = (event: RequestType, context: TriggerContext) => TriggerResult;

declare interface TriggerResponse {
    /** total number of apps invoked */
    total: number;
    /** successful installation ids */
    success: string[];
    /** map of installation ids to error message */
    errors: {
        [key: string]: string;
    };
}

declare const TriggerResponse: {
    $type: "devvit.gateway.v1alpha.TriggerResponse";
    encode(message: TriggerResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TriggerResponse;
    fromJSON(object: any): TriggerResponse;
    toJSON(message: TriggerResponse): unknown;
    create(base?: DeepPartial_97<TriggerResponse>): TriggerResponse;
    fromPartial(object: DeepPartial_97<TriggerResponse>): TriggerResponse;
};

declare interface TriggerResponse_ErrorsEntry {
    key: string;
    value: string;
}

declare const TriggerResponse_ErrorsEntry: {
    $type: "devvit.gateway.v1alpha.TriggerResponse.ErrorsEntry";
    encode(message: TriggerResponse_ErrorsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TriggerResponse_ErrorsEntry;
    fromJSON(object: any): TriggerResponse_ErrorsEntry;
    toJSON(message: TriggerResponse_ErrorsEntry): unknown;
    create(base?: DeepPartial_97<TriggerResponse_ErrorsEntry>): TriggerResponse_ErrorsEntry;
    fromPartial(object: DeepPartial_97<TriggerResponse_ErrorsEntry>): TriggerResponse_ErrorsEntry;
};

declare type TriggerResult = Promise<void> | void;

declare interface Triggers {
    OnTrigger(request: TriggerEvent_2, metadata?: Metadata): Promise<TriggerResponse>;
    OnFanOut(request: TriggerEvent_2, metadata?: Metadata): Promise<TriggerFanOutResponse>;
    OnInvoke(request: TriggerInvocation, metadata?: Metadata): Promise<Empty>;
    OnInstall(request: InstallationInfo, metadata?: Metadata): Promise<Empty>;
    OnUninstall(request: InstallationInfo, metadata?: Metadata): Promise<Empty>;
    OnInstallChanged(request: InstallationInfo, metadata?: Metadata): Promise<Empty>;
}

declare class TriggersClientImpl implements Triggers {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_30, opts?: {
        service?: string;
    });
    OnTrigger(request: TriggerEvent_2, metadata?: Metadata): Promise<TriggerResponse>;
    OnFanOut(request: TriggerEvent_2, metadata?: Metadata): Promise<TriggerFanOutResponse>;
    OnInvoke(request: TriggerInvocation, metadata?: Metadata): Promise<Empty>;
    OnInstall(request: InstallationInfo, metadata?: Metadata): Promise<Empty>;
    OnUninstall(request: InstallationInfo, metadata?: Metadata): Promise<Empty>;
    OnInstallChanged(request: InstallationInfo, metadata?: Metadata): Promise<Empty>;
}

declare type TriggersDefinition = typeof TriggersDefinition;

declare const TriggersDefinition: {
    readonly name: "Triggers";
    readonly fullName: "devvit.gateway.v1alpha.Triggers";
    readonly methods: {
        readonly onTrigger: {
            readonly name: "OnTrigger";
            readonly requestType: {
                $type: "devvit.data.triggers.v1alpha.TriggerEvent";
                encode(message: TriggerEvent_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): TriggerEvent_2;
                fromJSON(object: any): TriggerEvent_2;
                toJSON(message: TriggerEvent_2): unknown;
                create(base?: {
                    id?: string;
                    timestamp?: Date | undefined;
                    subreddit?: string;
                    postSubmit?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postCreate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postUpdate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        previousBody?: string;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postReport?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        reason?: string;
                    } | undefined;
                    postFlairUpdate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postDelete?: {
                        postId?: string;
                        deletedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        source?: EventSource_4;
                        reason?: DeletionReason_3;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentSubmit?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentCreate?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentUpdate?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        previousBody?: string;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentReport?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        reason?: string;
                    } | undefined;
                    commentDelete?: {
                        commentId?: string;
                        postId?: string;
                        parentId?: string;
                        deletedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        source?: EventSource_4;
                        reason?: DeletionReason_3;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    subredditSubscribe?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        subscriber?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    appInstall?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        installer?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    appUpgrade?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        installer?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    modAction?: {
                        action?: string | undefined;
                        actionedAt?: Date | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        moderator?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        targetUser?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        targetComment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        targetPost?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                    } | undefined;
                    modMail?: {
                        messageAuthor?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        messageAuthorType?: string;
                        conversationState?: string;
                        conversationType?: string;
                        isAutoGenerated?: boolean;
                        conversationSubreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        destinationSubreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        conversationId?: string;
                        messageId?: string;
                    } | undefined;
                    accountDelete?: {
                        userId?: string;
                        deletedAt?: Date | undefined;
                        user?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    vote?: {
                        updatedAt?: Date | undefined;
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        upvoteRatio?: number;
                        score?: number;
                    } | undefined;
                    postApprove?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        approvedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        source?: EventSource_4;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentApprove?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        approvedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        source?: EventSource_4;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                } | undefined): TriggerEvent_2;
                fromPartial(object: {
                    id?: string;
                    timestamp?: Date | undefined;
                    subreddit?: string;
                    postSubmit?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postCreate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postUpdate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        previousBody?: string;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postReport?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        reason?: string;
                    } | undefined;
                    postFlairUpdate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postDelete?: {
                        postId?: string;
                        deletedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        source?: EventSource_4;
                        reason?: DeletionReason_3;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentSubmit?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentCreate?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentUpdate?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        previousBody?: string;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentReport?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        reason?: string;
                    } | undefined;
                    commentDelete?: {
                        commentId?: string;
                        postId?: string;
                        parentId?: string;
                        deletedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        source?: EventSource_4;
                        reason?: DeletionReason_3;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    subredditSubscribe?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        subscriber?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    appInstall?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        installer?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    appUpgrade?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        installer?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    modAction?: {
                        action?: string | undefined;
                        actionedAt?: Date | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        moderator?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        targetUser?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        targetComment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        targetPost?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                    } | undefined;
                    modMail?: {
                        messageAuthor?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        messageAuthorType?: string;
                        conversationState?: string;
                        conversationType?: string;
                        isAutoGenerated?: boolean;
                        conversationSubreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        destinationSubreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        conversationId?: string;
                        messageId?: string;
                    } | undefined;
                    accountDelete?: {
                        userId?: string;
                        deletedAt?: Date | undefined;
                        user?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    vote?: {
                        updatedAt?: Date | undefined;
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        upvoteRatio?: number;
                        score?: number;
                    } | undefined;
                    postApprove?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        approvedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        source?: EventSource_4;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentApprove?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        approvedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        source?: EventSource_4;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                }): TriggerEvent_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gateway.v1alpha.TriggerResponse";
                encode(message: TriggerResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TriggerResponse;
                fromJSON(object: any): TriggerResponse;
                toJSON(message: TriggerResponse): unknown;
                create(base?: DeepPartial_97<TriggerResponse>): TriggerResponse;
                fromPartial(object: DeepPartial_97<TriggerResponse>): TriggerResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly onFanOut: {
            readonly name: "OnFanOut";
            readonly requestType: {
                $type: "devvit.data.triggers.v1alpha.TriggerEvent";
                encode(message: TriggerEvent_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): TriggerEvent_2;
                fromJSON(object: any): TriggerEvent_2;
                toJSON(message: TriggerEvent_2): unknown;
                create(base?: {
                    id?: string;
                    timestamp?: Date | undefined;
                    subreddit?: string;
                    postSubmit?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postCreate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postUpdate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        previousBody?: string;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postReport?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        reason?: string;
                    } | undefined;
                    postFlairUpdate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postDelete?: {
                        postId?: string;
                        deletedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        source?: EventSource_4;
                        reason?: DeletionReason_3;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentSubmit?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentCreate?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentUpdate?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        previousBody?: string;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentReport?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        reason?: string;
                    } | undefined;
                    commentDelete?: {
                        commentId?: string;
                        postId?: string;
                        parentId?: string;
                        deletedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        source?: EventSource_4;
                        reason?: DeletionReason_3;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    subredditSubscribe?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        subscriber?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    appInstall?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        installer?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    appUpgrade?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        installer?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    modAction?: {
                        action?: string | undefined;
                        actionedAt?: Date | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        moderator?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        targetUser?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        targetComment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        targetPost?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                    } | undefined;
                    modMail?: {
                        messageAuthor?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        messageAuthorType?: string;
                        conversationState?: string;
                        conversationType?: string;
                        isAutoGenerated?: boolean;
                        conversationSubreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        destinationSubreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        conversationId?: string;
                        messageId?: string;
                    } | undefined;
                    accountDelete?: {
                        userId?: string;
                        deletedAt?: Date | undefined;
                        user?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    vote?: {
                        updatedAt?: Date | undefined;
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        upvoteRatio?: number;
                        score?: number;
                    } | undefined;
                    postApprove?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        approvedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        source?: EventSource_4;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentApprove?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        approvedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        source?: EventSource_4;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                } | undefined): TriggerEvent_2;
                fromPartial(object: {
                    id?: string;
                    timestamp?: Date | undefined;
                    subreddit?: string;
                    postSubmit?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postCreate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postUpdate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        previousBody?: string;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postReport?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        reason?: string;
                    } | undefined;
                    postFlairUpdate?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    postDelete?: {
                        postId?: string;
                        deletedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        source?: EventSource_4;
                        reason?: DeletionReason_3;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentSubmit?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentCreate?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentUpdate?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        previousBody?: string;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentReport?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        reason?: string;
                    } | undefined;
                    commentDelete?: {
                        commentId?: string;
                        postId?: string;
                        parentId?: string;
                        deletedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        source?: EventSource_4;
                        reason?: DeletionReason_3;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    subredditSubscribe?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        subscriber?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    appInstall?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        installer?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    appUpgrade?: {
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        installer?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    modAction?: {
                        action?: string | undefined;
                        actionedAt?: Date | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        moderator?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        targetUser?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        targetComment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        targetPost?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                    } | undefined;
                    modMail?: {
                        messageAuthor?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        createdAt?: Date | undefined;
                        messageAuthorType?: string;
                        conversationState?: string;
                        conversationType?: string;
                        isAutoGenerated?: boolean;
                        conversationSubreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        destinationSubreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        conversationId?: string;
                        messageId?: string;
                    } | undefined;
                    accountDelete?: {
                        userId?: string;
                        deletedAt?: Date | undefined;
                        user?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                    } | undefined;
                    vote?: {
                        updatedAt?: Date | undefined;
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                        upvoteRatio?: number;
                        score?: number;
                    } | undefined;
                    postApprove?: {
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        approvedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        source?: EventSource_4;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                    commentApprove?: {
                        comment?: {
                            id?: string;
                            parentId?: string;
                            body?: string;
                            author?: string;
                            numReports?: number;
                            collapsedBecauseCrowdControl?: boolean;
                            spam?: boolean;
                            deleted?: boolean;
                            createdAt?: number;
                            upvotes?: number;
                            downvotes?: number;
                            languageCode?: string;
                            lastModifiedAt?: number;
                            gilded?: boolean;
                            score?: number;
                            permalink?: string;
                            hasMedia?: boolean;
                            postId?: string;
                            subredditId?: string;
                            elementTypes?: string[];
                        } | undefined;
                        post?: {
                            id?: string;
                            title?: string;
                            selftext?: string;
                            nsfw?: boolean;
                            authorId?: string;
                            crowdControlLevel?: CrowdControlLevel_3;
                            numReports?: number;
                            isGallery?: boolean;
                            isMeta?: boolean;
                            createdAt?: number;
                            isApproved?: boolean;
                            isArchived?: boolean;
                            distinguished?: DistinguishType_3;
                            ignoreReports?: boolean;
                            isSelf?: boolean;
                            isVideo?: boolean;
                            isLocked?: boolean;
                            isSpoiler?: boolean;
                            subredditId?: string;
                            upvotes?: number;
                            downvotes?: number;
                            url?: string;
                            isSticky?: boolean;
                            linkFlair?: {
                                text?: string;
                                cssClass?: string;
                                backgroundColor?: string;
                                templateId?: string;
                                textColor?: string;
                            } | undefined;
                            authorFlair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            spam?: boolean;
                            deleted?: boolean;
                            languageCode?: string;
                            updatedAt?: number;
                            gildings?: number;
                            score?: number;
                            numComments?: number;
                            thumbnail?: string;
                            media?: {
                                type?: string;
                                oembed?: {
                                    type?: string;
                                    version?: string;
                                    title?: string;
                                    description?: string;
                                    authorName?: string;
                                    authorUrl?: string;
                                    providerName?: string;
                                    providerUrl?: string;
                                    thumbnailUrl?: string;
                                    thumbnailWidth?: number;
                                    thumbnailHeight?: number;
                                    html?: string;
                                    width?: number;
                                    height?: number;
                                } | undefined;
                                redditVideo?: {
                                    bitrateKbps?: number;
                                    fallbackUrl?: string;
                                    height?: number;
                                    width?: number;
                                    scrubberMediaUrl?: string;
                                    dashUrl?: string;
                                    duration?: number;
                                    hlsUrl?: string;
                                    isGif?: boolean;
                                    transcodingStatus?: string;
                                } | undefined;
                            } | undefined;
                            crosspostParentId?: string;
                            permalink?: string;
                            isPoll?: boolean;
                            isPromoted?: boolean;
                            isMultiMedia?: boolean;
                            type?: string;
                            unlisted?: boolean;
                        } | undefined;
                        approvedAt?: Date | undefined;
                        author?: {
                            id?: string;
                            name?: string;
                            isGold?: boolean;
                            snoovatarImage?: string;
                            url?: string;
                            spam?: boolean;
                            banned?: boolean;
                            flair?: {
                                userId?: string;
                                subredditId?: string;
                                text?: string;
                                cssClass?: string;
                                templateId?: string;
                                textColor?: string;
                                backgroundColor?: string;
                                enabled?: boolean;
                            } | undefined;
                            karma?: number;
                            iconImage?: string;
                        } | undefined;
                        source?: EventSource_4;
                        subreddit?: {
                            id?: string;
                            name?: string;
                            nsfw?: boolean;
                            type?: SubredditType_4;
                            spam?: boolean;
                            quarantined?: boolean;
                            topics?: string[];
                            rating?: SubredditRating_3;
                            subscribersCount?: number;
                            permalink?: string;
                        } | undefined;
                    } | undefined;
                }): TriggerEvent_2;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.gateway.v1alpha.TriggerFanOutResponse";
                encode(message: TriggerFanOutResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TriggerFanOutResponse;
                fromJSON(object: any): TriggerFanOutResponse;
                toJSON(message: TriggerFanOutResponse): unknown;
                create(base?: DeepPartial_97<TriggerFanOutResponse>): TriggerFanOutResponse;
                fromPartial(object: DeepPartial_97<TriggerFanOutResponse>): TriggerFanOutResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly onInvoke: {
            readonly name: "OnInvoke";
            readonly requestType: {
                $type: "devvit.gateway.v1alpha.TriggerInvocation";
                encode(message: TriggerInvocation, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): TriggerInvocation;
                fromJSON(object: any): TriggerInvocation;
                toJSON(message: TriggerInvocation): unknown;
                create(base?: DeepPartial_97<TriggerInvocation>): TriggerInvocation;
                fromPartial(object: DeepPartial_97<TriggerInvocation>): TriggerInvocation;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly onInstall: {
            readonly name: "OnInstall";
            readonly requestType: {
                $type: "devvit.dev_portal.installation.InstallationInfo";
                encode(message: InstallationInfo, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): InstallationInfo;
                fromJSON(object: any): InstallationInfo;
                toJSON(message: InstallationInfo): unknown;
                create(base?: {
                    id?: string;
                    upgradeStrategy?: UpgradeStrategy_2;
                    upgradeStrategyConfig?: {
                        [x: string]: any;
                    } | undefined;
                    runAs?: string | undefined;
                    type?: InstallationType_2;
                    location?: {
                        id?: string;
                        name?: string;
                        type?: ThingType_2;
                        icon?: string | undefined;
                        isNsfw?: boolean;
                        isUnavailable?: boolean;
                    } | undefined;
                    isEnabled?: boolean;
                } | undefined): InstallationInfo;
                fromPartial(object: {
                    id?: string;
                    upgradeStrategy?: UpgradeStrategy_2;
                    upgradeStrategyConfig?: {
                        [x: string]: any;
                    } | undefined;
                    runAs?: string | undefined;
                    type?: InstallationType_2;
                    location?: {
                        id?: string;
                        name?: string;
                        type?: ThingType_2;
                        icon?: string | undefined;
                        isNsfw?: boolean;
                        isUnavailable?: boolean;
                    } | undefined;
                    isEnabled?: boolean;
                }): InstallationInfo;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly onUninstall: {
            readonly name: "OnUninstall";
            readonly requestType: {
                $type: "devvit.dev_portal.installation.InstallationInfo";
                encode(message: InstallationInfo, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): InstallationInfo;
                fromJSON(object: any): InstallationInfo;
                toJSON(message: InstallationInfo): unknown;
                create(base?: {
                    id?: string;
                    upgradeStrategy?: UpgradeStrategy_2;
                    upgradeStrategyConfig?: {
                        [x: string]: any;
                    } | undefined;
                    runAs?: string | undefined;
                    type?: InstallationType_2;
                    location?: {
                        id?: string;
                        name?: string;
                        type?: ThingType_2;
                        icon?: string | undefined;
                        isNsfw?: boolean;
                        isUnavailable?: boolean;
                    } | undefined;
                    isEnabled?: boolean;
                } | undefined): InstallationInfo;
                fromPartial(object: {
                    id?: string;
                    upgradeStrategy?: UpgradeStrategy_2;
                    upgradeStrategyConfig?: {
                        [x: string]: any;
                    } | undefined;
                    runAs?: string | undefined;
                    type?: InstallationType_2;
                    location?: {
                        id?: string;
                        name?: string;
                        type?: ThingType_2;
                        icon?: string | undefined;
                        isNsfw?: boolean;
                        isUnavailable?: boolean;
                    } | undefined;
                    isEnabled?: boolean;
                }): InstallationInfo;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly onInstallChanged: {
            readonly name: "OnInstallChanged";
            readonly requestType: {
                $type: "devvit.dev_portal.installation.InstallationInfo";
                encode(message: InstallationInfo, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): InstallationInfo;
                fromJSON(object: any): InstallationInfo;
                toJSON(message: InstallationInfo): unknown;
                create(base?: {
                    id?: string;
                    upgradeStrategy?: UpgradeStrategy_2;
                    upgradeStrategyConfig?: {
                        [x: string]: any;
                    } | undefined;
                    runAs?: string | undefined;
                    type?: InstallationType_2;
                    location?: {
                        id?: string;
                        name?: string;
                        type?: ThingType_2;
                        icon?: string | undefined;
                        isNsfw?: boolean;
                        isUnavailable?: boolean;
                    } | undefined;
                    isEnabled?: boolean;
                } | undefined): InstallationInfo;
                fromPartial(object: {
                    id?: string;
                    upgradeStrategy?: UpgradeStrategy_2;
                    upgradeStrategyConfig?: {
                        [x: string]: any;
                    } | undefined;
                    runAs?: string | undefined;
                    type?: InstallationType_2;
                    location?: {
                        id?: string;
                        name?: string;
                        type?: ThingType_2;
                        icon?: string | undefined;
                        isNsfw?: boolean;
                        isUnavailable?: boolean;
                    } | undefined;
                    isEnabled?: boolean;
                }): InstallationInfo;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const TriggersServiceName = "devvit.gateway.v1alpha.Triggers";

export declare type TxClientLike = {
    /**
     * Executes all previously queued commands in a transaction and
     * restores the connection state to normal. https://redis.io/commands/exec/
     * @returns array, each element being the reply to each of the commands in the atomic transaction.
     */
    exec(): Promise<any[]>;
    /**
     * Marks the start of a transaction block. Subsequent commands will be
     * queued for atomic execution using EXEC. https://redis.io/commands/multi/
     */
    multi(): Promise<void>;
    discard(): Promise<void>;
    /**
     * Marks the given keys to be watched for conditional execution of a transaction.
     * https://redis.io/commands/watch/
     * @arg {} keys - given keys to be watched
     */
    watch(...keys: string[]): Promise<TxClientLike>;
    unwatch(): Promise<TxClientLike>;
    /**
     * Get the value of key. If the key does not exist the special value nil is returned.
     * https://redis.io/commands/get/
     * @arg {} key
     * @returns value of key or null when key does not exist.
     */
    get(key: string): Promise<TxClientLike>;
    /**
     * Set key to hold the string value. If key already holds a value, it is overwritten
     * https://redis.io/commands/set/
     * @arg {} key
     * @arg {} value
     * @arg {} options
     */
    set(key: string, value: string, options?: SetOptions): Promise<TxClientLike>;
    /**
     * Removes the specified keys. A key is ignored if it does not exist.
     * https://redis.io/commands/del/
     * @arg {} keys
     */
    del(...keys: string[]): Promise<TxClientLike>;
    /**
     * Increments the number stored at key by increment.
     * https://redis.io/commands/incrby/
     * @arg {} key
     * @arg {} value
     */
    incrBy(key: string, value: number): Promise<TxClientLike>;
    /**
     * Returns the string representation of the type of the value stored at key
     * https://redis.io/commands/type/
     * @arg {} key
     * @returns string representation of the type
     */
    type(key: string): Promise<TxClientLike>;
    /**
     * Returns the substring of the string value stored at key, determined by
     * the offsets start and end (both are inclusive).
     * https://redis.io/commands/getrange/
     * @arg {} key
     * @arg {} start
     * @arg {} end
     * @returns substring determined by offsets [start, end]
     */
    getRange(key: string, start: number, end: number): Promise<TxClientLike>;
    /**
     * Overwrites part of the string stored at key, starting at the
     * specified offset, for the entire length of value.
     * https://redis.io/commands/setrange/
     * @arg {} key
     * @arg {} offset
     * @returns length of the string after it was modified by the command
     */
    setRange(key: string, offset: number, value: string): Promise<TxClientLike>;
    /**
     * Returns the length of the string value stored at key.
     * An error is returned when key holds a non-string value.
     * https://redis.io/commands/strlen/
     * @arg {} key
     * @returns length of the string stored at key
     */
    strlen(key: string): Promise<TxClientLike>;
    /**
     * Returns the values of all specified keys.
     * https://redis.io/commands/mget/
     * @arg {} keys
     * @returns list of values at the specified keys
     */
    mget(keys: string[]): Promise<TxClientLike>;
    /**
     * Sets the given keys to their respective values.
     * https://redis.io/commands/mset/
     * @arg {} keyValues
     */
    mset(keyValues: {
        [key: string]: string;
    }): Promise<TxClientLike>;
    /**
     * Set a timeout on key.
     * https://redis.io/commands/expire/
     * @arg {} key
     * @arg {} seconds
     */
    expire(key: string, seconds: number): Promise<TxClientLike>;
    /**
     * Returns the absolute Unix timestamp in seconds at which the given key will expire
     * https://redis.io/commands/expiretime/
     * @arg {} key
     * @returns expiration Unix timestamp in seconds, or a negative value in order to signal an error
     */
    expireTime(key: string): Promise<TxClientLike>;
    /**
     * Adds all the specified members with the specified scores to the sorted set stored at key.
     * https://redis.io/commands/zadd/
     * @arg {} key
     * @returns number of elements added to the sorted set
     */
    zAdd(key: string, ...members: ZMember[]): Promise<TxClientLike>;
    /**
     * Returns the cardinality (number of elements) of the sorted set stored at key.
     * https://redis.io/commands/zcard/
     * @arg {} key
     * @returns cardinality of the sorted set
     */
    zCard(key: string): Promise<TxClientLike>;
    /**
     * Increments the score of member in the sorted set stored at key by value
     * https://redis.io/commands/zincrby/
     * @arg {} key
     * @arg {} member
     * @arg {} value
     * @returns the new score of member as a double precision floating point number
     */
    zIncrBy(key: string, member: string, value: number): Promise<TxClientLike>;
    /**
     * Returns the rank of member in the sorted set stored at key
     * https://redis.io/commands/zrank/
     * @arg {} key
     * @arg {} member
     * @returns rank of the member. The rank (or index) is 0-based
     * which means that the member with the lowest score has rank 0
     */
    zRank(key: string, member: string): Promise<TxClientLike>;
    /**
     * Returns the score of member in the sorted set at key.
     * https://redis.io/commands/zscore/
     * @arg {} key
     * @arg {} member
     * @returns the score of the member (a double-precision floating point number).
     */
    zScore(key: string, member: string): Promise<TxClientLike>;
    /**
     * Iterates elements of Sorted Set types and their associated scores.
     * @arg {} key
     * @arg {} cursor
     * @arg {} pattern
     * @arg {} count
     */
    zScan(key: string, cursor: number, pattern?: string | undefined, count?: number | undefined): Promise<TxClientLike>;
    /**
     * Returns the specified range of elements in the sorted set stored at key.
     * https://redis.io/commands/zrange/
     * @arg {} key
     * @arg {} start
     * @arg {} stop
     * @arg {} options
     * @returns list of elements in the specified range
     */
    zRange(key: string, start: number | string, stop: number | string, options?: ZRangeOptions): Promise<TxClientLike>;
    /**
     * Removes the specified members from the sorted set stored at key.
     * https://redis.io/commands/zrem/
     * @arg {} key
     * @arg {} members
     * @returns number of members removed from the sorted set
     */
    zRem(key: string, members: string[]): Promise<TxClientLike>;
    /**
     * removes all elements in the sorted set stored at key between the
     * lexicographical range specified by min and max
     * https://redis.io/commands/zremrangebylex/
     * @arg {} key
     * @arg {} min
     * @arg {} max
     * @returns number of members removed from the sorted set
     */
    zRemRangeByLex(key: string, min: string, max: string): Promise<TxClientLike>;
    /**
     * Removes all elements in the sorted set stored at key with rank between start and stop.
     * https://redis.io/commands/zremrangebyrank/
     * @arg {} key
     * @arg {} start
     * @arg {} stop
     * @returns number of members removed from the sorted set
     */
    zRemRangeByRank(key: string, start: number, stop: number): Promise<TxClientLike>;
    /**
     * Removes all elements in the sorted set stored at key with a score between min and max
     * https://redis.io/commands/zremrangebyscore/
     * @arg {} key
     * @arg {} min
     * @arg {} max
     * @returns number of members removed from the sorted set
     */
    zRemRangeByScore(key: string, min: number, max: number): Promise<TxClientLike>;
    /**
     * Sets the specified fields to their respective values in the hash stored at key.
     * https://redis.io/commands/hset
     * @arg {} key
     * @arg {} fieldValues
     * @returns number of fields that were added
     */
    hset(key: string, fieldValues: {
        [field: string]: string;
    }): Promise<TxClientLike>;
    /**
     * Returns the value associated with field in the hash stored at key.
     * https://redis.io/commands/hget
     * @arg {} key
     * @arg {} field
     * @returns value associated with field
     */
    hget(key: string, field: string): Promise<TxClientLike>;
    /**
     * Returns all fields and values of the hash stored at key
     * https://redis.io/commands/hgetall
     * @arg {} key
     * @returns a map of fields and their values stored in the hash,
     */
    hgetall(key: string): Promise<TxClientLike>;
    /**
     * Removes the specified fields from the hash stored at key.
     * https://redis.io/commands/hdel/
     * @arg {} key
     * @arg {} fields
     * @returns number of fields that were removed from the hash
     */
    hdel(key: string, fields: string[]): Promise<TxClientLike>;
    /**
     * Iterates fields of Hash types and their associated values.
     * @arg {} key
     * @arg {} cursor
     * @arg {} pattern
     * @arg {} count
     */
    hscan(key: string, cursor: number, pattern?: string | undefined, count?: number | undefined): Promise<TxClientLike>;
    /**
     * Returns all field names in the hash stored at key.
     * @arg {} key
     */
    hkeys(key: string): Promise<TxClientLike>;
    /**
     * Increments the number stored at field in the hash stored at key by increment.
     * https://redis.io/commands/hincrby/
     * @arg {} key
     * @arg {} field
     * @arg {} value
     * @returns value of key after the increment
     */
    hincrby(key: string, field: string, value: number): Promise<TxClientLike>;
    /**
     * Returns the number of fields contained in the hash stored at key.
     * @arg {} key
     * @returns the number of fields in the hash, or 0 when the key does not exist.
     */
    hlen(key: string): Promise<TxClientLike>;
};

/**
 * The UI client lets your app interact with the Reddit frontend.
 * This client will only be available for capabilities that have
 * a frontend component, such as within the Custom Post component's
 * event handlers, a Form's `onSubmit` handler, and Menu items.
 */
export declare type UIClient = {
    /** Open a form in a modal */
    showForm(formKey: FormKey, data?: Data | undefined): void;
    /** Show a message in a toast. */
    showToast(text: string): void;
    showToast(toast: Toast): void;
    /** Navigate to a URL */
    navigateTo(url: string): void;
    navigateTo(subreddit: Subreddit): void;
    navigateTo(post: Post): void;
    navigateTo(comment: Comment): void;
    navigateTo(user: User): void;
    navigateTo(urlOrThing: string | Subreddit | Post | Comment | User): void;
};

/**
 * Dimensions describe the layout characteristics of a custom post within
 * Devvit. They are used to allow Devvitors to create responsive experiences
 * within their post. For example, they can use this API to conditionally render
 * an element on small viewports only.
 */
declare interface UIDimensions {
    /** Unitless pixels describing the content box height for the custom post. */
    height: number;
    /** Unitless pixels describing the content box width for the custom post. */
    width: number;
    /** Describes the device pixel ratio for a device. */
    scale: number;
}

declare const UIDimensions: {
    $type: "devvit.ui.common.v1alpha.UIDimensions";
    encode(message: UIDimensions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UIDimensions;
    fromJSON(object: any): UIDimensions;
    toJSON(message: UIDimensions): unknown;
    create(base?: DeepPartial_46<UIDimensions>): UIDimensions;
    fromPartial(object: DeepPartial_46<UIDimensions>): UIDimensions;
};

/**
 * This is universally available to all UIs.  It's a place to put environment-specific data.
 * Typical items are e.g. locale, dark mode, etc.  Please don't put surface-specific data here.
 * (i.e. *NOT* post_id, that should be in the props.  *NOT* user_id, that should be in the state.)
 */
declare interface UIEnvironment {
    /** The locale of the user.  This is a string like "en-US" or "fr-CA" */
    locale?: string | undefined;
    /** The user's preferred color scheme.  This is a string like "light" or "dark" */
    colorScheme?: string | undefined;
    /** The layout size of the post */
    dimensions?: UIDimensions | undefined;
    /** The timezone of the user */
    timezone?: string | undefined;
}

declare const UIEnvironment: {
    $type: "devvit.ui.block_kit.v1beta.UIEnvironment";
    encode(message: UIEnvironment, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UIEnvironment;
    fromJSON(object: any): UIEnvironment;
    toJSON(message: UIEnvironment): unknown;
    create(base?: DeepPartial_47<UIEnvironment>): UIEnvironment;
    fromPartial(object: DeepPartial_47<UIEnvironment>): UIEnvironment;
};

declare interface UIEvent {
    realtimeEvent?: RealtimeSubscriptionEvent | undefined;
    formSubmitted?: FormSubmittedEvent | undefined;
    toastAction?: ToastActionEvent | undefined;
    userAction?: UserAction | undefined;
    asyncRequest?: AsyncRequest | undefined;
    asyncResponse?: AsyncResponse | undefined;
    timer?: TimerEvent | undefined;
    blocking?: BlockingRenderEvent | undefined;
    resize?: ResizeEvent | undefined;
    /**
     * If an event is async, it can be fired in parallel with other events.  Async events
     * are not allowed to mutate state.  Any state mutations they attempt would be ignored.
     * If they want to communicate something back to the state, they need to pass a message via
     * effects.
     */
    async?: boolean | undefined;
    /**
     * This is set for circuit-broken or fetchy events that are known to only work on the
     * remote runtime.
     */
    remoteOnly?: boolean | undefined;
    /** The id of a the hook that should respond to this event */
    hook?: string | undefined;
    /** Signals if this event should be sent to the front (true) or back of the queue (false) */
    retry?: boolean | undefined;
}

declare const UIEvent: {
    $type: "devvit.ui.events.v1alpha.UIEvent";
    encode(message: UIEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UIEvent;
    fromJSON(object: any): UIEvent;
    toJSON(message: UIEvent): unknown;
    create(base?: DeepPartial_49<UIEvent>): UIEvent;
    fromPartial(object: DeepPartial_49<UIEvent>): UIEvent;
};

/** @deprecated */
declare interface UIEventHandler {
    HandleUIEvent(request: HandleUIEventRequest, metadata?: Metadata): Promise<HandleUIEventResponse>;
}

declare class UIEventHandlerClientImpl implements UIEventHandler {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_42, opts?: {
        service?: string;
    });
    HandleUIEvent(request: HandleUIEventRequest, metadata?: Metadata): Promise<HandleUIEventResponse>;
}

/** @deprecated */
declare type UIEventHandlerDefinition = typeof UIEventHandlerDefinition;

declare const UIEventHandlerDefinition: {
    readonly name: "UIEventHandler";
    readonly fullName: "devvit.ui.events.v1alpha.UIEventHandler";
    readonly methods: {
        readonly handleUIEvent: {
            readonly name: "HandleUIEvent";
            readonly requestType: {
                $type: "devvit.ui.events.v1alpha.HandleUIEventRequest";
                encode(message: HandleUIEventRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandleUIEventRequest;
                fromJSON(object: any): HandleUIEventRequest;
                toJSON(message: HandleUIEventRequest): unknown;
                create(base?: DeepPartial_99<HandleUIEventRequest>): HandleUIEventRequest;
                fromPartial(object: DeepPartial_99<HandleUIEventRequest>): HandleUIEventRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.ui.events.v1alpha.HandleUIEventResponse";
                encode(message: HandleUIEventResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): HandleUIEventResponse;
                fromJSON(object: any): HandleUIEventResponse;
                toJSON(message: HandleUIEventResponse): unknown;
                create(base?: DeepPartial_99<HandleUIEventResponse>): HandleUIEventResponse;
                fromPartial(object: DeepPartial_99<HandleUIEventResponse>): HandleUIEventResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const UIEventHandlerServiceName = "devvit.ui.events.v1alpha.UIEventHandler";

/**
 * Wrapper message for `uint32`.
 *
 * The JSON representation for `UInt32Value` is JSON number.
 */
declare interface UInt32Value {
    /** The uint32 value. */
    value: number;
}

declare const UInt32Value: {
    $type: "google.protobuf.UInt32Value";
    encode(message: UInt32Value, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UInt32Value;
    fromJSON(object: any): UInt32Value;
    toJSON(message: UInt32Value): unknown;
    create(base?: DeepPartial_69<UInt32Value>): UInt32Value;
    fromPartial(object: DeepPartial_69<UInt32Value>): UInt32Value;
};

/**
 * Wrapper message for `uint64`.
 *
 * The JSON representation for `UInt64Value` is JSON string.
 */
declare interface UInt64Value {
    /** The uint64 value. */
    value: number;
}

declare const UInt64Value: {
    $type: "google.protobuf.UInt64Value";
    encode(message: UInt64Value, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UInt64Value;
    fromJSON(object: any): UInt64Value;
    toJSON(message: UInt64Value): unknown;
    create(base?: DeepPartial_69<UInt64Value>): UInt64Value;
    fromPartial(object: DeepPartial_69<UInt64Value>): UInt64Value;
};

/**
 * This file encodes a generic protocol for rendering UIs.  If you want to embed a UI into Devvit, you should use this protocol.
 * This protobuf is for the second iteration of Blocks components.  It's an extraction of CustomPost to work with any UI surface.
 *
 * The idea is that if you want to add a new surface, you can add an rpc method that takes a RenderUIRequest and returns a RenderUIResponse.
 * This RPC method will encompass the full lifecycle of the UI.  It will be called when the UI is first rendered, and it will be called again
 * when the user or system interacts with the UI via UIEvents.
 *
 * Example:
 *
 *    service MyService {
 *      rpc MyNewSidebarUI(UIRequest) returns (UIResponse) {};
 *    }
 *
 * There are some optimizations encoded in the protocol.  For example, if you just want a pure render, you can send a UIRequest with no events.  This
 * will return a UIResponse with no effects and no new state.  Conversely, if you want to update state, but not render anything, you can send a UIRequest
 * with no_render set to true.  This will return a UIResponse with effects and state updates but no new UI.
 *
 * The common case, however, is to send a UIRequest with events and no_render set to false.  This will perform the state updates, do a render, then return
 * a UIResponse with a new UI, new state, and effects, and saving the multiple round-trips.
 */
declare interface UIRequest {
    /**
     * This is universally available to all UIs.  It's a place to put environment-specific data.
     * Typical items are e.g. locale, dark mode, etc.  Please don't put surface-specific data here.
     * (i.e. *NOT* post_id, that should be in the props.  *NOT* user_id, that should be in the state.)
     */
    env?: UIEnvironment | undefined;
    /** Props to the root component of this UI. */
    props?: {
        [key: string]: any;
    } | undefined;
    /** Stateful data received from a previous response */
    state?: {
        [key: string]: any;
    } | undefined;
    /**
     * This is a "repeated" so we can consider adding event batching (e.g. multiple key presses).  For
     * now, This is zero or one events. If you just want to render a UI, you can send an empty list.
     */
    events: UIEvent[];
}

declare const UIRequest: {
    $type: "devvit.ui.block_kit.v1beta.UIRequest";
    encode(message: UIRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UIRequest;
    fromJSON(object: any): UIRequest;
    toJSON(message: UIRequest): unknown;
    create(base?: DeepPartial_47<UIRequest>): UIRequest;
    fromPartial(object: DeepPartial_47<UIRequest>): UIRequest;
};

declare interface UIResponse {
    /**
     * Stateful data to be sent back. Event responses only contain state deltas to
     * allow the requester to aggregate and reconcile local and remote state. This
     * will be sent back to you in the next request.
     */
    state?: {
        [key: string]: any;
    } | undefined;
    /** Optional list of Effects to execute on the client */
    effects: Effect[];
    /** Optional list of Events that will re-enter the dispatcher queue */
    events: UIEvent[];
    /** Render the post with Blocks */
    blocks?: Block | undefined;
}

declare const UIResponse: {
    $type: "devvit.ui.block_kit.v1beta.UIResponse";
    encode(message: UIResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UIResponse;
    fromJSON(object: any): UIResponse;
    toJSON(message: UIResponse): unknown;
    create(base?: DeepPartial_47<UIResponse>): UIResponse;
    fromPartial(object: DeepPartial_47<UIResponse>): UIResponse;
};

declare interface UnfriendRequest {
    /** thing id e.g. 't3_15bfi0' */
    id?: string | undefined;
    /** the name of an existing */
    name?: string | undefined;
    /** one of (friend, enemy, moderator, moderator_invite, contributor, banned, muted, wikibanned, wikicontributor) */
    type: string;
    /** subreddit name without the r/ e.g. 'devvit_test' */
    subreddit?: string | undefined;
}

declare const UnfriendRequest: {
    $type: "devvit.plugin.redditapi.users.UnfriendRequest";
    encode(message: UnfriendRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UnfriendRequest;
    fromJSON(object: any): UnfriendRequest;
    toJSON(message: UnfriendRequest): unknown;
    create(base?: DeepPartial_100<UnfriendRequest>): UnfriendRequest;
    fromPartial(object: DeepPartial_100<UnfriendRequest>): UnfriendRequest;
};

/**
 * A message representing a option the parser does not recognize. This only
 * appears in options protos created by the compiler::Parser class.
 * DescriptorPool resolves these when building Descriptor objects. Therefore,
 * options protos in descriptor objects (e.g. returned by Descriptor::options(),
 * or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
 * in them.
 */
declare interface UninterpretedOption {
    name: UninterpretedOption_NamePart[];
    /**
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     */
    identifierValue?: string | undefined;
    positiveIntValue?: number | undefined;
    negativeIntValue?: number | undefined;
    doubleValue?: number | undefined;
    stringValue?: Uint8Array | undefined;
    aggregateValue?: string | undefined;
}

declare const UninterpretedOption: {
    $type: "google.protobuf.UninterpretedOption";
    encode(message: UninterpretedOption, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UninterpretedOption;
    fromJSON(object: any): UninterpretedOption;
    toJSON(message: UninterpretedOption): unknown;
    create(base?: DeepPartial_104<UninterpretedOption>): UninterpretedOption;
    fromPartial(object: DeepPartial_104<UninterpretedOption>): UninterpretedOption;
};

/**
 * The name of the uninterpreted option.  Each string represents a segment in
 * a dot-separated name.  is_extension is true iff a segment represents an
 * extension (denoted with parentheses in options specs in .proto files).
 * E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
 * "foo.(bar.baz).moo".
 */
declare interface UninterpretedOption_NamePart {
    namePart: string;
    isExtension: boolean;
}

declare const UninterpretedOption_NamePart: {
    $type: "google.protobuf.UninterpretedOption.NamePart";
    encode(message: UninterpretedOption_NamePart, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UninterpretedOption_NamePart;
    fromJSON(object: any): UninterpretedOption_NamePart;
    toJSON(message: UninterpretedOption_NamePart): unknown;
    create(base?: DeepPartial_104<UninterpretedOption_NamePart>): UninterpretedOption_NamePart;
    fromPartial(object: DeepPartial_104<UninterpretedOption_NamePart>): UninterpretedOption_NamePart;
};

declare type UnknownMessage = unknown;

declare interface UnloadRequest {
    force: boolean;
    hostname: string;
}

declare const UnloadRequest: {
    $type: "devvit.runtime.actor.UnloadRequest";
    encode(message: UnloadRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UnloadRequest;
    fromJSON(object: any): UnloadRequest;
    toJSON(message: UnloadRequest): unknown;
    create(base?: DeepPartial_107<UnloadRequest>): UnloadRequest;
    fromPartial(object: DeepPartial_107<UnloadRequest>): UnloadRequest;
};

export declare type UnreadCountResponse = {
    archived?: number;
    appeals?: number;
    highlighted?: number;
    notifications?: number;
    joinRequests?: number;
    filtered?: number;
    new?: number;
    inprogress?: number;
    mod?: number;
};

declare interface UnreadCountResponse_2 {
    archived?: number | undefined;
    appeals?: number | undefined;
    highlighted?: number | undefined;
    notifications?: number | undefined;
    joinRequests?: number | undefined;
    filtered?: number | undefined;
    new?: number | undefined;
    inprogress?: number | undefined;
    mod?: number | undefined;
}

declare const UnreadCountResponse_2: {
    $type: "devvit.plugin.redditapi.newmodmail.UnreadCountResponse";
    encode(message: UnreadCountResponse_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UnreadCountResponse_2;
    fromJSON(object: any): UnreadCountResponse_2;
    toJSON(message: UnreadCountResponse_2): unknown;
    create(base?: DeepPartial_71<UnreadCountResponse_2>): UnreadCountResponse_2;
    fromPartial(object: DeepPartial_71<UnreadCountResponse_2>): UnreadCountResponse_2;
};

declare interface UpdateButtonWidgetRequest {
    subreddit: string;
    id: string;
    shortName: string;
    description: string;
    buttons: WidgetButton[];
    styles?: WidgetStyles | undefined;
}

declare const UpdateButtonWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.UpdateButtonWidgetRequest";
    encode(message: UpdateButtonWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateButtonWidgetRequest;
    fromJSON(object: any): UpdateButtonWidgetRequest;
    toJSON(message: UpdateButtonWidgetRequest): unknown;
    create(base?: DeepPartial_4<UpdateButtonWidgetRequest>): UpdateButtonWidgetRequest;
    fromPartial(object: DeepPartial_4<UpdateButtonWidgetRequest>): UpdateButtonWidgetRequest;
};

declare interface UpdateCalendarWidgetRequest {
    subreddit: string;
    id: string;
    configuration?: CalendarWidgetConfiguration | undefined;
    googleCalendarId: string;
    requiresSync: boolean;
    shortName: string;
    styles?: WidgetStyles | undefined;
}

declare const UpdateCalendarWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.UpdateCalendarWidgetRequest";
    encode(message: UpdateCalendarWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCalendarWidgetRequest;
    fromJSON(object: any): UpdateCalendarWidgetRequest;
    toJSON(message: UpdateCalendarWidgetRequest): unknown;
    create(base?: DeepPartial_4<UpdateCalendarWidgetRequest>): UpdateCalendarWidgetRequest;
    fromPartial(object: DeepPartial_4<UpdateCalendarWidgetRequest>): UpdateCalendarWidgetRequest;
};

declare interface UpdateCollectionDescriptionRequest {
    /** The id of the collection to update. */
    collectionId?: string | undefined;
    /** The new description of the collection */
    description?: string | undefined;
}

declare const UpdateCollectionDescriptionRequest: {
    $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDescriptionRequest";
    encode(message: UpdateCollectionDescriptionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCollectionDescriptionRequest;
    fromJSON(object: any): UpdateCollectionDescriptionRequest;
    toJSON(message: UpdateCollectionDescriptionRequest): unknown;
    create(base?: DeepPartial_81<UpdateCollectionDescriptionRequest>): UpdateCollectionDescriptionRequest;
    fromPartial(object: DeepPartial_81<UpdateCollectionDescriptionRequest>): UpdateCollectionDescriptionRequest;
};

declare interface UpdateCollectionDisplayLayoutRequest {
    /** The id of the collection to update. */
    collectionId?: string | undefined;
    /** One of: TIMELINE | GALLERY. This determines the layout of posts in the collection ui. */
    displayLayout?: string | undefined;
}

declare const UpdateCollectionDisplayLayoutRequest: {
    $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionDisplayLayoutRequest";
    encode(message: UpdateCollectionDisplayLayoutRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCollectionDisplayLayoutRequest;
    fromJSON(object: any): UpdateCollectionDisplayLayoutRequest;
    toJSON(message: UpdateCollectionDisplayLayoutRequest): unknown;
    create(base?: DeepPartial_81<UpdateCollectionDisplayLayoutRequest>): UpdateCollectionDisplayLayoutRequest;
    fromPartial(object: DeepPartial_81<UpdateCollectionDisplayLayoutRequest>): UpdateCollectionDisplayLayoutRequest;
};

declare interface UpdateCollectionTitleRequest {
    /** The id of the collection to update. */
    collectionId?: string | undefined;
    /** The new title of the collection */
    title?: string | undefined;
}

declare const UpdateCollectionTitleRequest: {
    $type: "devvit.plugin.redditapi.postcollections.UpdateCollectionTitleRequest";
    encode(message: UpdateCollectionTitleRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCollectionTitleRequest;
    fromJSON(object: any): UpdateCollectionTitleRequest;
    toJSON(message: UpdateCollectionTitleRequest): unknown;
    create(base?: DeepPartial_81<UpdateCollectionTitleRequest>): UpdateCollectionTitleRequest;
    fromPartial(object: DeepPartial_81<UpdateCollectionTitleRequest>): UpdateCollectionTitleRequest;
};

declare interface UpdateCommunityListWidgetRequest {
    subreddit: string;
    id: string;
    shortName: string;
    data: string[];
    styles?: WidgetStyles | undefined;
}

declare const UpdateCommunityListWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetRequest";
    encode(message: UpdateCommunityListWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCommunityListWidgetRequest;
    fromJSON(object: any): UpdateCommunityListWidgetRequest;
    toJSON(message: UpdateCommunityListWidgetRequest): unknown;
    create(base?: DeepPartial_4<UpdateCommunityListWidgetRequest>): UpdateCommunityListWidgetRequest;
    fromPartial(object: DeepPartial_4<UpdateCommunityListWidgetRequest>): UpdateCommunityListWidgetRequest;
};

declare interface UpdateCommunityListWidgetResponse {
    kind: string;
    shortName: string;
    data: string[];
    styles?: WidgetStyles | undefined;
}

declare const UpdateCommunityListWidgetResponse: {
    $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetResponse";
    encode(message: UpdateCommunityListWidgetResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCommunityListWidgetResponse;
    fromJSON(object: any): UpdateCommunityListWidgetResponse;
    toJSON(message: UpdateCommunityListWidgetResponse): unknown;
    create(base?: DeepPartial_4<UpdateCommunityListWidgetResponse>): UpdateCommunityListWidgetResponse;
    fromPartial(object: DeepPartial_4<UpdateCommunityListWidgetResponse>): UpdateCommunityListWidgetResponse;
};

declare interface UpdateCrowdControlLevelRequest {
    /** thing id (e.g t1_15bfi0) */
    id: string;
    /** an integer between 0 and 3 */
    level: number;
}

declare const UpdateCrowdControlLevelRequest: {
    $type: "devvit.plugin.redditapi.moderation.UpdateCrowdControlLevelRequest";
    encode(message: UpdateCrowdControlLevelRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCrowdControlLevelRequest;
    fromJSON(object: any): UpdateCrowdControlLevelRequest;
    toJSON(message: UpdateCrowdControlLevelRequest): unknown;
    create(base?: DeepPartial_2<UpdateCrowdControlLevelRequest>): UpdateCrowdControlLevelRequest;
    fromPartial(object: DeepPartial_2<UpdateCrowdControlLevelRequest>): UpdateCrowdControlLevelRequest;
};

declare interface UpdateCustomWidgetRequest {
    subreddit: string;
    id: string;
    shortName: string;
    text: string;
    height: number;
    css: string;
    imageData: WidgetImage[];
    styles?: WidgetStyles | undefined;
}

declare const UpdateCustomWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.UpdateCustomWidgetRequest";
    encode(message: UpdateCustomWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCustomWidgetRequest;
    fromJSON(object: any): UpdateCustomWidgetRequest;
    toJSON(message: UpdateCustomWidgetRequest): unknown;
    create(base?: DeepPartial_4<UpdateCustomWidgetRequest>): UpdateCustomWidgetRequest;
    fromPartial(object: DeepPartial_4<UpdateCustomWidgetRequest>): UpdateCustomWidgetRequest;
};

declare interface UpdateFriendRelationshipRequest {
    /** a valid, existing reddit username */
    name: string;
    note: string;
}

declare const UpdateFriendRelationshipRequest: {
    $type: "devvit.plugin.redditapi.users.UpdateFriendRelationshipRequest";
    encode(message: UpdateFriendRelationshipRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateFriendRelationshipRequest;
    fromJSON(object: any): UpdateFriendRelationshipRequest;
    toJSON(message: UpdateFriendRelationshipRequest): unknown;
    create(base?: DeepPartial_100<UpdateFriendRelationshipRequest>): UpdateFriendRelationshipRequest;
    fromPartial(object: DeepPartial_100<UpdateFriendRelationshipRequest>): UpdateFriendRelationshipRequest;
};

declare interface UpdateImageWidgetRequest {
    subreddit: string;
    id: string;
    data: WidgetImage[];
    shortName: string;
    styles?: WidgetStyles | undefined;
}

declare const UpdateImageWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.UpdateImageWidgetRequest";
    encode(message: UpdateImageWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateImageWidgetRequest;
    fromJSON(object: any): UpdateImageWidgetRequest;
    toJSON(message: UpdateImageWidgetRequest): unknown;
    create(base?: DeepPartial_4<UpdateImageWidgetRequest>): UpdateImageWidgetRequest;
    fromPartial(object: DeepPartial_4<UpdateImageWidgetRequest>): UpdateImageWidgetRequest;
};

export declare type UpdatePageSettingsOptions = {
    /** The name of the subreddit the page is in. */
    subredditName: string;
    /** The name of the page to update settings for. */
    page: string;
    /** Whether the page should be listed in the wiki index. */
    listed: boolean;
    /** The permission level for the page. */
    permLevel: WikiPagePermissionLevel;
};

declare interface UpdatePostFlairWidgetRequest {
    subreddit: string;
    id: string;
    display: string;
    order: string[];
    shortName: string;
    styles?: WidgetStyles | undefined;
}

declare const UpdatePostFlairWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.UpdatePostFlairWidgetRequest";
    encode(message: UpdatePostFlairWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdatePostFlairWidgetRequest;
    fromJSON(object: any): UpdatePostFlairWidgetRequest;
    toJSON(message: UpdatePostFlairWidgetRequest): unknown;
    create(base?: DeepPartial_4<UpdatePostFlairWidgetRequest>): UpdatePostFlairWidgetRequest;
    fromPartial(object: DeepPartial_4<UpdatePostFlairWidgetRequest>): UpdatePostFlairWidgetRequest;
};

declare interface UpdateTextAreaWidgetRequest {
    subreddit: string;
    id: string;
    shortName: string;
    text: string;
    styles?: WidgetStyles | undefined;
}

declare const UpdateTextAreaWidgetRequest: {
    $type: "devvit.plugin.redditapi.widgets.UpdateTextAreaWidgetRequest";
    encode(message: UpdateTextAreaWidgetRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateTextAreaWidgetRequest;
    fromJSON(object: any): UpdateTextAreaWidgetRequest;
    toJSON(message: UpdateTextAreaWidgetRequest): unknown;
    create(base?: DeepPartial_4<UpdateTextAreaWidgetRequest>): UpdateTextAreaWidgetRequest;
    fromPartial(object: DeepPartial_4<UpdateTextAreaWidgetRequest>): UpdateTextAreaWidgetRequest;
};

export declare type UpdateWikiPageOptions = {
    /** The name of the subreddit the page is in. */
    subredditName: string;
    /** The name of the page to update. */
    page: string;
    /** The new content of the page. */
    content: string;
    /** The reason for updating the page. */
    reason?: string;
};

declare interface UpdateWikiPageSettingsRequest {
    /** The subreddit omitting the r/ prefix. */
    subreddit: string;
    /** The name of the wiki page. */
    page: string;
    /**
     * The permission level required to edit the wiki page.
     * 0: Use subreddit wiki permissions
     * 1: Only approved wiki contributors for this page may edit
     * 2: Only mods may edit and view
     */
    permlevel: number;
    /** Whether the wiki page is listed. "on" to list, empty string to hide. */
    listed: string;
}

declare const UpdateWikiPageSettingsRequest: {
    $type: "devvit.plugin.redditapi.wiki.UpdateWikiPageSettingsRequest";
    encode(message: UpdateWikiPageSettingsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UpdateWikiPageSettingsRequest;
    fromJSON(object: any): UpdateWikiPageSettingsRequest;
    toJSON(message: UpdateWikiPageSettingsRequest): unknown;
    create(base?: DeepPartial_9<UpdateWikiPageSettingsRequest>): UpdateWikiPageSettingsRequest;
    fromPartial(object: DeepPartial_9<UpdateWikiPageSettingsRequest>): UpdateWikiPageSettingsRequest;
};

declare enum UpgradeStrategy {
    MANUAL = 0,
    AUTOMATIC = 1,
    UNRECOGNIZED = -1
}

export declare type UploadMediaOptions = {
    url: string;
    type: 'image' | 'gif' | 'video';
};

declare interface UploadSrImgRequest {
    /** file upload with maximum size of 500 KiB */
    file: string;
    /** (optional) can be ignored */
    header: number;
    /** an integer between 0 and 1 */
    imgType: string;
    /** a valid subreddit image name */
    name: string;
    /** one of png or jpg (default: png) */
    uploadType: string;
    /** the name of the subreddit */
    subreddit: string;
}

declare const UploadSrImgRequest: {
    $type: "devvit.plugin.redditapi.subreddits.UploadSrImgRequest";
    encode(message: UploadSrImgRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadSrImgRequest;
    fromJSON(object: any): UploadSrImgRequest;
    toJSON(message: UploadSrImgRequest): unknown;
    create(base?: DeepPartial_11<UploadSrImgRequest>): UploadSrImgRequest;
    fromPartial(object: DeepPartial_11<UploadSrImgRequest>): UploadSrImgRequest;
};

declare interface UploadSrImgResponse {
    errors: string[];
    imgSrc?: string | undefined;
    errorsValues: string[];
}

declare const UploadSrImgResponse: {
    $type: "devvit.plugin.redditapi.subreddits.UploadSrImgResponse";
    encode(message: UploadSrImgResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadSrImgResponse;
    fromJSON(object: any): UploadSrImgResponse;
    toJSON(message: UploadSrImgResponse): unknown;
    create(base?: DeepPartial_11<UploadSrImgResponse>): UploadSrImgResponse;
    fromPartial(object: DeepPartial_11<UploadSrImgResponse>): UploadSrImgResponse;
};

declare type UrlString = string;

/**
 * This is the preferred way to handle async state in Devvit.
 *
 * @param initializer -- any async function that returns a JSONValue
 * @returns UseAsyncResult<S>
 */
export declare function useAsync<S extends JSONValue>(initializer: AsyncUseStateInitializer<S>, options?: AsyncOptions): UseAsyncResult<S>;

export declare type UseAsyncResult<S> = {
    data: S | null;
    loading: boolean;
    error: AsyncError | null;
};

export declare function useAsyncState<S extends JSONValue>(initializer: AsyncUseStateInitializer<S>): UseStateResult<S>;

export declare type UseChannelHook = (options: ChannelOptions) => UseChannelResult;

export declare type UseChannelResult = {
    /** Subscribe to the channel */
    subscribe(): void;
    /** Unsubscribe from the channel */
    unsubscribe(): void;
    /** Publish a message to the channel */
    send(data: Data): Promise<void>;
    /** Current subscription status */
    status: ChannelStatus;
};

export declare function useForm(form: Form | FormFunction, onSubmit: (values: FormValues) => void | Promise<void>): FormKey;

/** A hook that returns a form key that can be used in the `ui.showForm` */
export declare type UseFormHook = (form: Form | FormFunction, onSubmit: (values: FormValues) => void | Promise<void>) => FormKey;

export declare function useInterval(callback: () => void | Promise<void>, requestedDelayMs: number): UseIntervalResult;

/** A hook that can used to run a callback on an interval between Block renders. Only one useInterval hook may be running at a time. */
export declare type UseIntervalHook = (
/** The callback to run on an interval */
callback: () => void | Promise<void>, 
/** The delay between each callback run in milliseconds. Delay must be at least 100ms. */
delay: number) => UseIntervalResult;

/** An object that contains functions to start and stop the interval created by the `useInterval` hook */
export declare type UseIntervalResult = {
    /** Start the interval */
    start: () => void;
    /** Stop the interval */
    stop: () => void;
};

/**
 * A class representing a user.
 */
export declare class User {
    #private;
    /**
     * The ID (starting with t2_) of the user to retrieve.
     * @example 't2_1w72'
     */
    get id(): T2ID;
    /**
     * The username of the user omitting the u/.
     * @example 'spez'
     */
    get username(): string;
    /**
     * The date the user was created.
     */
    get createdAt(): Date;
    /**
     * The amount of link karma the user has.
     */
    get linkKarma(): number;
    /**
     * The amount of comment karma the user has.
     */
    get commentKarma(): number;
    /**
     * Whether the user's profile is marked as NSFW (Not Safe For Work).
     */
    get nsfw(): boolean;
    /**
     * Whether the user is admin.
     */
    get isAdmin(): boolean;
    /**
     * The permissions the user has on the subreddit.
     */
    get modPermissions(): Map<string, ModeratorPermission[]>;
    /**
     * Returns the HTTP URL for the user
     */
    get url(): string;
    /**
     * Returns a permalink path relative to https://www.reddit.com
     */
    get permalink(): string;
    toJSON(): Pick<User, 'id' | 'username' | 'createdAt' | 'linkKarma' | 'commentKarma' | 'nsfw'> & {
        modPermissionsBySubreddit: Record<string, ModeratorPermission[]>;
    };
    /**
     * Get the mod permissions the user has on the subreddit if they are a moderator.
     *
     * @param subredditName - name of the subreddit
     * @returns the moderator permissions the user has on the subreddit
     */
    getModPermissionsForSubreddit(subredditName: string): Promise<ModeratorPermission[]>;
    /**
     * Get the user's comments.
     *
     * @param options - Options for the request
     * @param options.sort - The sort order of the comments. e.g. 'new'
     * @param options.timeframe - The timeframe of the comments. e.g. 'all'
     * @param options.limit - The maximum number of comments to return. e.g. 1000
     * @param options.pageSize - The number of comments to return per request. e.g. 100
     * @returns A Listing of Comment objects.
     */
    getComments(options: Omit<GetCommentsByUserOptions, 'username'>): Listing<Comment>;
    /**
     * Get the user's posts.
     *
     * @param options - Options for the request
     * @param options.sort - The sort order of the posts. e.g. 'new'
     * @param options.timeframe - The timeframe of the posts. e.g. 'all'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     */
    getPosts(options: Omit<GetPostsByUserOptions, 'username'>): Listing<Post>;
    /**
     * Retrieve the user's flair for the subreddit.
     *
     * @param subreddit - The name of the subreddit associated with the user's flair.
     *
     * @example
     * ```ts
     * const username = "badapple"
     * const subredditName = "mysubreddit"
     * const user = await reddit.getUserByUsername(username);
     * const userFlair = await user.getUserFlairBySubreddit(subredditName);
     * ```
     */
    getUserFlairBySubreddit(subreddit: string): Promise<UserFlair | undefined>;
    getSnoovatarUrl(): Promise<string | undefined>;
}

declare interface User_2 {
    acceptChats?: boolean | undefined;
    acceptFollowers?: boolean | undefined;
    acceptPms?: boolean | undefined;
    awardeeKarma?: number | undefined;
    awarderKarma?: number | undefined;
    canCreateSubreddit?: boolean | undefined;
    canEditName?: boolean | undefined;
    coins?: number | undefined;
    commentKarma?: number | undefined;
    created?: number | undefined;
    createdUtc?: number | undefined;
    features?: UserFeatures | undefined;
    forcePasswordReset?: boolean | undefined;
    goldCreddits?: number | undefined;
    goldExpiration?: string | undefined;
    hasAndroidSubscription?: boolean | undefined;
    hasExternalAccount?: boolean | undefined;
    hasGoldSubscription?: boolean | undefined;
    hasIosSubscription?: boolean | undefined;
    hasMail?: boolean | undefined;
    hasModMail?: boolean | undefined;
    hasPaypalSubscription?: boolean | undefined;
    hasStripeSubscription?: boolean | undefined;
    hasSubscribed?: boolean | undefined;
    hasSubscribedToPremium?: boolean | undefined;
    hasVerifiedEmail?: boolean | undefined;
    hasVisitedNewProfile?: boolean | undefined;
    hideFromRobots?: boolean | undefined;
    iconImg?: string | undefined;
    id?: string | undefined;
    inBeta?: boolean | undefined;
    inChat?: boolean | undefined;
    inRedesignBeta?: boolean | undefined;
    inboxCount?: number | undefined;
    isBlocked?: boolean | undefined;
    isEmployee?: boolean | undefined;
    isFriend?: boolean | undefined;
    isGold?: boolean | undefined;
    isMod?: boolean | undefined;
    isSponsor?: boolean | undefined;
    isSuspended?: boolean | undefined;
    linkKarma?: number | undefined;
    modhash?: string | undefined;
    name?: string | undefined;
    newModmailExists?: boolean | undefined;
    numFriends?: number | undefined;
    over18?: boolean | undefined;
    passwordSet?: boolean | undefined;
    prefAutoplay?: boolean | undefined;
    prefClickgadget?: number | undefined;
    prefGeopopular?: string | undefined;
    prefNightmode?: boolean | undefined;
    prefNoProfanity?: boolean | undefined;
    prefShowPresence?: boolean | undefined;
    prefShowSnoovatar?: boolean | undefined;
    prefShowTrending?: boolean | undefined;
    prefShowTwitter?: boolean | undefined;
    prefTopKarmaSubreddits?: boolean | undefined;
    prefVideoAutoplay?: boolean | undefined;
    snoovatarImg?: string | undefined;
    snoovatarSize: number[];
    subreddit?: Subreddit_2 | undefined;
    suspensionExpirationUtc?: string | undefined;
    totalKarma?: number | undefined;
    verified?: boolean | undefined;
    hasPhoneNumber?: boolean | undefined;
    /** user properties for automod invocation */
    subredditsModerated?: number | undefined;
    hasMetaSubscription?: boolean | undefined;
    metaSubscriptionAge?: number | undefined;
    metaPointsBalance?: string | undefined;
    metaLockedPointsBalance?: string | undefined;
    commentSubredditKarma?: number | undefined;
    postSubredditKarma?: number | undefined;
    /** PRIVATE - DO NOT SET FOR PUBLIC USE */
    markedSpam?: boolean | undefined;
    isSubredditProxyAccount?: boolean | undefined;
}

declare const User_2: {
    $type: "devvit.reddit.User";
    encode(message: User_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): User_2;
    fromJSON(object: any): User_2;
    toJSON(message: User_2): unknown;
    create(base?: DeepPartial_6<User_2>): User_2;
    fromPartial(object: DeepPartial_6<User_2>): User_2;
};

declare const USER_LINK_ELEMENT = "u/";

declare const USER_MENTION_ELEMENT = "@";

declare interface UserAboutRequest {
    /** a valid, existing reddit username */
    username: string;
}

declare const UserAboutRequest: {
    $type: "devvit.plugin.redditapi.users.UserAboutRequest";
    encode(message: UserAboutRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserAboutRequest;
    fromJSON(object: any): UserAboutRequest;
    toJSON(message: UserAboutRequest): unknown;
    create(base?: DeepPartial_100<UserAboutRequest>): UserAboutRequest;
    fromPartial(object: DeepPartial_100<UserAboutRequest>): UserAboutRequest;
};

declare interface UserAboutResponse {
    kind?: string | undefined;
    data?: User_2 | undefined;
}

declare const UserAboutResponse: {
    $type: "devvit.plugin.redditapi.users.UserAboutResponse";
    encode(message: UserAboutResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserAboutResponse;
    fromJSON(object: any): UserAboutResponse;
    toJSON(message: UserAboutResponse): unknown;
    create(base?: DeepPartial_100<UserAboutResponse>): UserAboutResponse;
    fromPartial(object: DeepPartial_100<UserAboutResponse>): UserAboutResponse;
};

declare interface UserAction {
    actionId: string;
    data?: {
        [key: string]: any;
    } | undefined;
}

declare const UserAction: {
    $type: "devvit.ui.events.v1alpha.UserAction";
    encode(message: UserAction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserAction;
    fromJSON(object: any): UserAction;
    toJSON(message: UserAction): unknown;
    create(base?: DeepPartial_49<UserAction>): UserAction;
    fromPartial(object: DeepPartial_49<UserAction>): UserAction;
};

/** Enables an actor to be configurable after installation */
declare interface UserConfigurable {
    /** Get a list of inputs to present to the user */
    RenderForm(request: Empty, metadata?: Metadata): Promise<ConfigForm>;
    /**
     * Parse the user input.
     * The original ConfigForm is provided with the response fields updated from the user's input.
     */
    HandleFormResponse(request: ConfigForm, metadata?: Metadata): Promise<FormResponse>;
}

declare class UserConfigurableClientImpl implements UserConfigurable {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_33, opts?: {
        service?: string;
    });
    RenderForm(request: Empty, metadata?: Metadata): Promise<ConfigForm>;
    HandleFormResponse(request: ConfigForm, metadata?: Metadata): Promise<FormResponse>;
}

/** Enables an actor to be configurable after installation */
declare type UserConfigurableDefinition = typeof UserConfigurableDefinition;

declare const UserConfigurableDefinition: {
    readonly name: "UserConfigurable";
    readonly fullName: "devvit.actor.user_configurable.UserConfigurable";
    readonly methods: {
        /** Get a list of inputs to present to the user */
        readonly renderForm: {
            readonly name: "RenderForm";
            readonly requestType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.user_configurable.ConfigForm";
                encode(message: ConfigForm, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ConfigForm;
                fromJSON(object: any): ConfigForm;
                toJSON(message: ConfigForm): unknown;
                create(base?: DeepPartial_29<ConfigForm>): ConfigForm;
                fromPartial(object: DeepPartial_29<ConfigForm>): ConfigForm;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /**
         * Parse the user input.
         * The original ConfigForm is provided with the response fields updated from the user's input.
         */
        readonly handleFormResponse: {
            readonly name: "HandleFormResponse";
            readonly requestType: {
                $type: "devvit.actor.user_configurable.ConfigForm";
                encode(message: ConfigForm, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): ConfigForm;
                fromJSON(object: any): ConfigForm;
                toJSON(message: ConfigForm): unknown;
                create(base?: DeepPartial_29<ConfigForm>): ConfigForm;
                fromPartial(object: DeepPartial_29<ConfigForm>): ConfigForm;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.actor.user_configurable.FormResponse";
                encode(message: FormResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): FormResponse;
                fromJSON(object: any): FormResponse;
                toJSON(message: FormResponse): unknown;
                create(base?: DeepPartial_29<FormResponse>): FormResponse;
                fromPartial(object: DeepPartial_29<FormResponse>): FormResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const UserConfigurableServiceName = "devvit.actor.user_configurable.UserConfigurable";

declare interface UserDataByAccountIdsRequest {
    /** a comma-separated list of account thing ids */
    ids: string;
}

declare const UserDataByAccountIdsRequest: {
    $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsRequest";
    encode(message: UserDataByAccountIdsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserDataByAccountIdsRequest;
    fromJSON(object: any): UserDataByAccountIdsRequest;
    toJSON(message: UserDataByAccountIdsRequest): unknown;
    create(base?: DeepPartial_100<UserDataByAccountIdsRequest>): UserDataByAccountIdsRequest;
    fromPartial(object: DeepPartial_100<UserDataByAccountIdsRequest>): UserDataByAccountIdsRequest;
};

declare interface UserDataByAccountIdsResponse {
    users: {
        [key: string]: UserDataByAccountIdsResponse_UserAccountData;
    };
}

declare const UserDataByAccountIdsResponse: {
    $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse";
    encode(message: UserDataByAccountIdsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserDataByAccountIdsResponse;
    fromJSON(object: any): UserDataByAccountIdsResponse;
    toJSON(message: UserDataByAccountIdsResponse): unknown;
    create(base?: DeepPartial_100<UserDataByAccountIdsResponse>): UserDataByAccountIdsResponse;
    fromPartial(object: DeepPartial_100<UserDataByAccountIdsResponse>): UserDataByAccountIdsResponse;
};

declare interface UserDataByAccountIdsResponse_UserAccountData {
    name?: string | undefined;
    createdUtc?: number | undefined;
    linkKarma?: number | undefined;
    commentKarma?: number | undefined;
    profileImg?: string | undefined;
    profileColor?: string | undefined;
    profileOver18?: boolean | undefined;
}

declare const UserDataByAccountIdsResponse_UserAccountData: {
    $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UserAccountData";
    encode(message: UserDataByAccountIdsResponse_UserAccountData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserDataByAccountIdsResponse_UserAccountData;
    fromJSON(object: any): UserDataByAccountIdsResponse_UserAccountData;
    toJSON(message: UserDataByAccountIdsResponse_UserAccountData): unknown;
    create(base?: DeepPartial_100<UserDataByAccountIdsResponse_UserAccountData>): UserDataByAccountIdsResponse_UserAccountData;
    fromPartial(object: DeepPartial_100<UserDataByAccountIdsResponse_UserAccountData>): UserDataByAccountIdsResponse_UserAccountData;
};

declare interface UserDataByAccountIdsResponse_UsersEntry {
    key: string;
    value?: UserDataByAccountIdsResponse_UserAccountData | undefined;
}

declare const UserDataByAccountIdsResponse_UsersEntry: {
    $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UsersEntry";
    encode(message: UserDataByAccountIdsResponse_UsersEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserDataByAccountIdsResponse_UsersEntry;
    fromJSON(object: any): UserDataByAccountIdsResponse_UsersEntry;
    toJSON(message: UserDataByAccountIdsResponse_UsersEntry): unknown;
    create(base?: DeepPartial_100<UserDataByAccountIdsResponse_UsersEntry>): UserDataByAccountIdsResponse_UsersEntry;
    fromPartial(object: DeepPartial_100<UserDataByAccountIdsResponse_UsersEntry>): UserDataByAccountIdsResponse_UsersEntry;
};

declare interface UserFeatures {
    awardsOnStreams?: boolean | undefined;
    canMakeMobileTestBuildPurchases?: boolean | undefined;
    chatGroupRollout?: boolean | undefined;
    chatSubreddit?: boolean | undefined;
    chatUserSettings?: boolean | undefined;
    chat?: boolean | undefined;
    cookieConsentBanner?: boolean | undefined;
    crosspostNotif?: boolean | undefined;
    crowdControlForPost?: boolean | undefined;
    customFeedImage?: boolean | undefined;
    doNotTrack?: boolean | undefined;
    expensiveCoinsPackage?: boolean | undefined;
    isEmailPermissionRequired?: boolean | undefined;
    liveComments?: boolean | undefined;
    liveOrangereds?: boolean | undefined;
    modAwards?: boolean | undefined;
    modServiceMuteReads?: boolean | undefined;
    modServiceMuteWrites?: boolean | undefined;
    modlogCopyrightRemoval?: boolean | undefined;
    mwebNsfwXpromo?: UserFeatures_Experiment | undefined;
    mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
    mwebXpromoInterstitialCommentsIos?: boolean | undefined;
    mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
    mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
    mwebXpromoRevampV2?: UserFeatures_Experiment | undefined;
    mwebXpromoRevampV3?: UserFeatures_Experiment | undefined;
    noreferrerToNoopener?: boolean | undefined;
    pollsMobile?: boolean | undefined;
    premiumSubscriptionsTable?: boolean | undefined;
    promotedTrendBlanks?: boolean | undefined;
    resizedStylesImages?: boolean | undefined;
    showAmpLink?: boolean | undefined;
    showNpsSurvey?: boolean | undefined;
    spezModal?: boolean | undefined;
    usePrefAccountDeployment?: boolean | undefined;
    userFlairMigrationTesting?: boolean | undefined;
    webhookConfig?: boolean | undefined;
}

declare const UserFeatures: {
    $type: "devvit.reddit.UserFeatures";
    encode(message: UserFeatures, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserFeatures;
    fromJSON(object: any): UserFeatures;
    toJSON(message: UserFeatures): unknown;
    create(base?: DeepPartial_6<UserFeatures>): UserFeatures;
    fromPartial(object: DeepPartial_6<UserFeatures>): UserFeatures;
};

declare interface UserFeatures_Experiment {
    experimentId?: number | undefined;
    owner?: string | undefined;
    variant?: string | undefined;
}

declare const UserFeatures_Experiment: {
    $type: "devvit.reddit.UserFeatures.Experiment";
    encode(message: UserFeatures_Experiment, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserFeatures_Experiment;
    fromJSON(object: any): UserFeatures_Experiment;
    toJSON(message: UserFeatures_Experiment): unknown;
    create(base?: DeepPartial_6<UserFeatures_Experiment>): UserFeatures_Experiment;
    fromPartial(object: DeepPartial_6<UserFeatures_Experiment>): UserFeatures_Experiment;
};

export declare type UserFlair = {
    /** The CSS class applied to this flair in the UI. */
    flairCssClass?: string;
    /** The username of the user to which this flair is assigned.*/
    user?: string;
    /** The text displayed in the UI for this flair. */
    flairText?: string;
};

declare interface UserFlair_2 {
    flairCssClass?: string | undefined;
    user?: string | undefined;
    flairText?: string | undefined;
}

declare const UserFlair_2: {
    $type: "devvit.plugin.redditapi.flair.UserFlair";
    encode(message: UserFlair_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserFlair_2;
    fromJSON(object: any): UserFlair_2;
    toJSON(message: UserFlair_2): unknown;
    create(base?: DeepPartial_56<UserFlair_2>): UserFlair_2;
    fromPartial(object: DeepPartial_56<UserFlair_2>): UserFlair_2;
};

export declare type UserFlairPageOptions = {
    /** A user id optionally provided which will result in a slice of user flairs, starting after this user, to be returned.  */
    after?: string;
    /** A user id optionally provided which will result in a slice of user flairs, starting before this user, to be returned.  */
    before?: string;
    /** A limit to the number of flairs that will be returned. Default: 25, Max: 1000  */
    limit?: number;
};

declare interface UserFlairRichtext {
    e?: string | undefined;
    t?: string | undefined;
}

declare const UserFlairRichtext: {
    $type: "devvit.reddit.UserFlairRichtext";
    encode(message: UserFlairRichtext, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserFlairRichtext;
    fromJSON(object: any): UserFlairRichtext;
    toJSON(message: UserFlairRichtext): unknown;
    create(base?: DeepPartial_5<UserFlairRichtext>): UserFlairRichtext;
    fromPartial(object: DeepPartial_5<UserFlairRichtext>): UserFlairRichtext;
};

declare interface UserFlairV2 {
    userId: string;
    subredditId: string;
    text: string;
    cssClass: string;
    templateId: string;
    textColor: string;
    backgroundColor: string;
    enabled: boolean;
}

declare const UserFlairV2: {
    $type: "devvit.reddit.v2alpha.UserFlairV2";
    encode(message: UserFlairV2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserFlairV2;
    fromJSON(object: any): UserFlairV2;
    toJSON(message: UserFlairV2): unknown;
    create(base?: DeepPartial_72<UserFlairV2>): UserFlairV2;
    fromPartial(object: DeepPartial_72<UserFlairV2>): UserFlairV2;
};

declare type UserLink = {
    e: typeof USER_LINK_ELEMENT;
    t: string;
    l: boolean;
};

/**
 * @borrows PrefixedRedditLinkOptions
 */
declare type UserLinkOptions = PrefixedRedditLinkOptions & {
    /**
     * Username the link should point to without "u/" prefix
     * @example { username: 'spez', showPrefix: true }
     */
    username: string;
};

declare type UserMention = {
    e: typeof USER_MENTION_ELEMENT;
    t: string;
    l: boolean;
};

/**
 * @borrows UserLinkOptions
 */
declare type UserMentionOptions = UserLinkOptions;

declare interface UsernameAvailableRequest {
    /** a valid, unused username */
    user: string;
}

declare const UsernameAvailableRequest: {
    $type: "devvit.plugin.redditapi.users.UsernameAvailableRequest";
    encode(message: UsernameAvailableRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UsernameAvailableRequest;
    fromJSON(object: any): UsernameAvailableRequest;
    toJSON(message: UsernameAvailableRequest): unknown;
    create(base?: DeepPartial_100<UsernameAvailableRequest>): UsernameAvailableRequest;
    fromPartial(object: DeepPartial_100<UsernameAvailableRequest>): UsernameAvailableRequest;
};

export declare type UserNote = {
    note?: string;
    redditId: T1ID | T3ID | T5ID;
    label?: UserNoteLabel;
};

export declare type UserNoteLabel = 'BOT_BAN' | 'PERMA_BAN' | 'BAN' | 'ABUSE_WARNING' | 'SPAM_WARNING' | 'SPAM_WATCH' | 'SOLID_CONTRIBUTOR' | 'HELPFUL_USER';

/**
 * USERS - https://www.reddit.com/dev/api#section_users
 * Note: all endpoints require oauth
 */
declare interface Users {
    /** https://www.reddit.com/dev/api#POST_api_block_user */
    BlockUser(request: BlockUserRequest, metadata?: Metadata): Promise<BlockUserResponse>;
    /** https://www.reddit.com/dev/api#POST_api_friend */
    Friend(request: FriendRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_report_user */
    ReportUser(request: ReportUserRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#POST_api_setpermissions */
    SetPermissions(request: SetPermissionsRequest, metadata?: Metadata): Promise<JsonStatus>;
    /** https://www.reddit.com/dev/api#POST_api_unfriend */
    Unfriend(request: UnfriendRequest, metadata?: Metadata): Promise<Empty>;
    /** https://www.reddit.com/dev/api#GET_api_user_data_by_account_ids */
    UserDataByAccountIds(request: UserDataByAccountIdsRequest, metadata?: Metadata): Promise<UserDataByAccountIdsResponse>;
    /** https://www.reddit.com/dev/api#GET_api_username_available */
    UsernameAvailable(request: UsernameAvailableRequest, metadata?: Metadata): Promise<BoolValue>;
    /** https://www.reddit.com/dev/api#DELETE_api_v1_me_friends_username */
    UnfriendUser(request: GenericUsersRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * https://www.reddit.com/dev/api#GET_api_v1_me_friends_username
     * TODO: this actually returns a WrappedRedditObject. Fix this up after the system worker is deleted.
     */
    GetFriendInformation(request: GenericUsersRequest, metadata?: Metadata): Promise<GeneralFriendResponse>;
    /** https://www.reddit.com/dev/api#PUT_api_v1_me_friends_username */
    UpdateFriendRelationship(request: UpdateFriendRelationshipRequest, metadata?: Metadata): Promise<GeneralFriendResponse>;
    /** https://www.reddit.com/dev/api#GET_api_v1_user_username_trophies */
    UserTrophies(request: GenericUsersRequest, metadata?: Metadata): Promise<UserTrophiesResponse>;
    /** https://www.reddit.com/dev/api#GET_user_username_about */
    UserAbout(request: UserAboutRequest, metadata?: Metadata): Promise<UserAboutResponse>;
    /** https://www.reddit.com/dev/api#GET_user_username_where */
    UserWhere(request: UserWhereRequest, metadata?: Metadata): Promise<Listing_2>;
}

declare class UsersClientImpl implements Users {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_50, opts?: {
        service?: string;
    });
    BlockUser(request: BlockUserRequest, metadata?: Metadata): Promise<BlockUserResponse>;
    Friend(request: FriendRequest, metadata?: Metadata): Promise<JsonStatus>;
    ReportUser(request: ReportUserRequest, metadata?: Metadata): Promise<Empty>;
    SetPermissions(request: SetPermissionsRequest, metadata?: Metadata): Promise<JsonStatus>;
    Unfriend(request: UnfriendRequest, metadata?: Metadata): Promise<Empty>;
    UserDataByAccountIds(request: UserDataByAccountIdsRequest, metadata?: Metadata): Promise<UserDataByAccountIdsResponse>;
    UsernameAvailable(request: UsernameAvailableRequest, metadata?: Metadata): Promise<BoolValue>;
    UnfriendUser(request: GenericUsersRequest, metadata?: Metadata): Promise<Empty>;
    GetFriendInformation(request: GenericUsersRequest, metadata?: Metadata): Promise<GeneralFriendResponse>;
    UpdateFriendRelationship(request: UpdateFriendRelationshipRequest, metadata?: Metadata): Promise<GeneralFriendResponse>;
    UserTrophies(request: GenericUsersRequest, metadata?: Metadata): Promise<UserTrophiesResponse>;
    UserAbout(request: UserAboutRequest, metadata?: Metadata): Promise<UserAboutResponse>;
    UserWhere(request: UserWhereRequest, metadata?: Metadata): Promise<Listing_2>;
}

/**
 * USERS - https://www.reddit.com/dev/api#section_users
 * Note: all endpoints require oauth
 */
declare type UsersDefinition = typeof UsersDefinition;

declare const UsersDefinition: {
    readonly name: "Users";
    readonly fullName: "devvit.plugin.redditapi.users.Users";
    readonly methods: {
        /** https://www.reddit.com/dev/api#POST_api_block_user */
        readonly blockUser: {
            readonly name: "BlockUser";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.BlockUserRequest";
                encode(message: BlockUserRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BlockUserRequest;
                fromJSON(object: any): BlockUserRequest;
                toJSON(message: BlockUserRequest): unknown;
                create(base?: {
                    accountId?: string | undefined;
                    name?: string | undefined;
                } | undefined): BlockUserRequest;
                fromPartial(object: {
                    accountId?: string | undefined;
                    name?: string | undefined;
                }): BlockUserRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.users.BlockUserResponse";
                encode(message: BlockUserResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BlockUserResponse;
                fromJSON(object: any): BlockUserResponse;
                toJSON(message: BlockUserResponse): unknown;
                create(base?: {
                    date?: number | undefined;
                    iconImg?: string | undefined;
                    id?: string | undefined;
                    name?: string | undefined;
                } | undefined): BlockUserResponse;
                fromPartial(object: {
                    date?: number | undefined;
                    iconImg?: string | undefined;
                    id?: string | undefined;
                    name?: string | undefined;
                }): BlockUserResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_friend */
        readonly friend: {
            readonly name: "Friend";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.FriendRequest";
                encode(message: FriendRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FriendRequest;
                fromJSON(object: any): FriendRequest;
                toJSON(message: FriendRequest): unknown;
                create(base?: {
                    banContext?: string | undefined;
                    banMessage?: string | undefined;
                    banReason?: string | undefined;
                    duration?: number | undefined;
                    name?: string;
                    note?: string | undefined;
                    permissions?: string | undefined;
                    type?: string;
                    subreddit?: string | undefined;
                } | undefined): FriendRequest;
                fromPartial(object: {
                    banContext?: string | undefined;
                    banMessage?: string | undefined;
                    banReason?: string | undefined;
                    duration?: number | undefined;
                    name?: string;
                    note?: string | undefined;
                    permissions?: string | undefined;
                    type?: string;
                    subreddit?: string | undefined;
                }): FriendRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_report_user */
        readonly reportUser: {
            readonly name: "ReportUser";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.ReportUserRequest";
                encode(message: ReportUserRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ReportUserRequest;
                fromJSON(object: any): ReportUserRequest;
                toJSON(message: ReportUserRequest): unknown;
                create(base?: {
                    details?: string;
                    reason?: string;
                    user?: string;
                } | undefined): ReportUserRequest;
                fromPartial(object: {
                    details?: string;
                    reason?: string;
                    user?: string;
                }): ReportUserRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_setpermissions */
        readonly setPermissions: {
            readonly name: "SetPermissions";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.SetPermissionsRequest";
                encode(message: SetPermissionsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SetPermissionsRequest;
                fromJSON(object: any): SetPermissionsRequest;
                toJSON(message: SetPermissionsRequest): unknown;
                create(base?: {
                    name?: string;
                    subreddit?: string;
                    permissions?: string;
                    type?: string;
                } | undefined): SetPermissionsRequest;
                fromPartial(object: {
                    name?: string;
                    subreddit?: string;
                    permissions?: string;
                    type?: string;
                }): SetPermissionsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.JsonStatus";
                encode(message: JsonStatus, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): JsonStatus;
                fromJSON(object: any): JsonStatus;
                toJSON(message: JsonStatus): unknown;
                create(base?: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                } | undefined): JsonStatus;
                fromPartial(object: {
                    json?: {
                        errors?: string[];
                    } | undefined;
                }): JsonStatus;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#POST_api_unfriend */
        readonly unfriend: {
            readonly name: "Unfriend";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.UnfriendRequest";
                encode(message: UnfriendRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UnfriendRequest;
                fromJSON(object: any): UnfriendRequest;
                toJSON(message: UnfriendRequest): unknown;
                create(base?: {
                    id?: string | undefined;
                    name?: string | undefined;
                    type?: string;
                    subreddit?: string | undefined;
                } | undefined): UnfriendRequest;
                fromPartial(object: {
                    id?: string | undefined;
                    name?: string | undefined;
                    type?: string;
                    subreddit?: string | undefined;
                }): UnfriendRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_user_data_by_account_ids */
        readonly userDataByAccountIds: {
            readonly name: "UserDataByAccountIds";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsRequest";
                encode(message: UserDataByAccountIdsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UserDataByAccountIdsRequest;
                fromJSON(object: any): UserDataByAccountIdsRequest;
                toJSON(message: UserDataByAccountIdsRequest): unknown;
                create(base?: {
                    ids?: string;
                } | undefined): UserDataByAccountIdsRequest;
                fromPartial(object: {
                    ids?: string;
                }): UserDataByAccountIdsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse";
                encode(message: UserDataByAccountIdsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UserDataByAccountIdsResponse;
                fromJSON(object: any): UserDataByAccountIdsResponse;
                toJSON(message: UserDataByAccountIdsResponse): unknown;
                create(base?: {
                    users?: {
                        [x: string]: {
                            name?: string | undefined;
                            createdUtc?: number | undefined;
                            linkKarma?: number | undefined;
                            commentKarma?: number | undefined;
                            profileImg?: string | undefined;
                            profileColor?: string | undefined;
                            profileOver18?: boolean | undefined;
                        } | undefined;
                    };
                } | undefined): UserDataByAccountIdsResponse;
                fromPartial(object: {
                    users?: {
                        [x: string]: {
                            name?: string | undefined;
                            createdUtc?: number | undefined;
                            linkKarma?: number | undefined;
                            commentKarma?: number | undefined;
                            profileImg?: string | undefined;
                            profileColor?: string | undefined;
                            profileOver18?: boolean | undefined;
                        } | undefined;
                    };
                }): UserDataByAccountIdsResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api#GET_api_username_available */
        readonly usernameAvailable: {
            readonly name: "UsernameAvailable";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.UsernameAvailableRequest";
                encode(message: UsernameAvailableRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UsernameAvailableRequest;
                fromJSON(object: any): UsernameAvailableRequest;
                toJSON(message: UsernameAvailableRequest): unknown;
                create(base?: {
                    user?: string;
                } | undefined): UsernameAvailableRequest;
                fromPartial(object: {
                    user?: string;
                }): UsernameAvailableRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.BoolValue";
                encode(message: BoolValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BoolValue;
                fromJSON(object: any): BoolValue;
                toJSON(message: BoolValue): unknown;
                create(base?: {
                    value?: boolean;
                } | undefined): BoolValue;
                fromPartial(object: {
                    value?: boolean;
                }): BoolValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        /** https://www.reddit.com/dev/api#DELETE_api_v1_me_friends_username */
        readonly unfriendUser: {
            readonly name: "UnfriendUser";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.GenericUsersRequest";
                encode(message: GenericUsersRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericUsersRequest;
                fromJSON(object: any): GenericUsersRequest;
                toJSON(message: GenericUsersRequest): unknown;
                create(base?: {
                    id?: string | undefined;
                    username?: string;
                } | undefined): GenericUsersRequest;
                fromPartial(object: {
                    id?: string | undefined;
                    username?: string;
                }): GenericUsersRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * https://www.reddit.com/dev/api#GET_api_v1_me_friends_username
         * TODO: this actually returns a WrappedRedditObject. Fix this up after the system worker is deleted.
         */
        readonly getFriendInformation: {
            readonly name: "GetFriendInformation";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.GenericUsersRequest";
                encode(message: GenericUsersRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericUsersRequest;
                fromJSON(object: any): GenericUsersRequest;
                toJSON(message: GenericUsersRequest): unknown;
                create(base?: {
                    id?: string | undefined;
                    username?: string;
                } | undefined): GenericUsersRequest;
                fromPartial(object: {
                    id?: string | undefined;
                    username?: string;
                }): GenericUsersRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.users.GeneralFriendResponse";
                encode(message: GeneralFriendResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GeneralFriendResponse;
                fromJSON(object: any): GeneralFriendResponse;
                toJSON(message: GeneralFriendResponse): unknown;
                create(base?: {
                    date?: number | undefined;
                    relId?: string | undefined;
                    name?: string | undefined;
                    id?: string | undefined;
                    fields?: string[];
                    explanation?: string | undefined;
                    message?: string | undefined;
                    reason?: string | undefined;
                } | undefined): GeneralFriendResponse;
                fromPartial(object: {
                    date?: number | undefined;
                    relId?: string | undefined;
                    name?: string | undefined;
                    id?: string | undefined;
                    fields?: string[];
                    explanation?: string | undefined;
                    message?: string | undefined;
                    reason?: string | undefined;
                }): GeneralFriendResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#PUT_api_v1_me_friends_username */
        readonly updateFriendRelationship: {
            readonly name: "UpdateFriendRelationship";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.UpdateFriendRelationshipRequest";
                encode(message: UpdateFriendRelationshipRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateFriendRelationshipRequest;
                fromJSON(object: any): UpdateFriendRelationshipRequest;
                toJSON(message: UpdateFriendRelationshipRequest): unknown;
                create(base?: {
                    name?: string;
                    note?: string;
                } | undefined): UpdateFriendRelationshipRequest;
                fromPartial(object: {
                    name?: string;
                    note?: string;
                }): UpdateFriendRelationshipRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.users.GeneralFriendResponse";
                encode(message: GeneralFriendResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GeneralFriendResponse;
                fromJSON(object: any): GeneralFriendResponse;
                toJSON(message: GeneralFriendResponse): unknown;
                create(base?: {
                    date?: number | undefined;
                    relId?: string | undefined;
                    name?: string | undefined;
                    id?: string | undefined;
                    fields?: string[];
                    explanation?: string | undefined;
                    message?: string | undefined;
                    reason?: string | undefined;
                } | undefined): GeneralFriendResponse;
                fromPartial(object: {
                    date?: number | undefined;
                    relId?: string | undefined;
                    name?: string | undefined;
                    id?: string | undefined;
                    fields?: string[];
                    explanation?: string | undefined;
                    message?: string | undefined;
                    reason?: string | undefined;
                }): GeneralFriendResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_api_v1_user_username_trophies */
        readonly userTrophies: {
            readonly name: "UserTrophies";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.GenericUsersRequest";
                encode(message: GenericUsersRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GenericUsersRequest;
                fromJSON(object: any): GenericUsersRequest;
                toJSON(message: GenericUsersRequest): unknown;
                create(base?: {
                    id?: string | undefined;
                    username?: string;
                } | undefined): GenericUsersRequest;
                fromPartial(object: {
                    id?: string | undefined;
                    username?: string;
                }): GenericUsersRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.users.UserTrophiesResponse";
                encode(message: UserTrophiesResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UserTrophiesResponse;
                fromJSON(object: any): UserTrophiesResponse;
                toJSON(message: UserTrophiesResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        trophies?: {
                            kind?: string | undefined;
                            data?: {
                                icon70?: string | undefined;
                                grantedAt?: number | undefined;
                                url?: string | undefined;
                                icon40?: string | undefined;
                                name?: string | undefined;
                                awardId?: string | undefined;
                                id?: string | undefined;
                                description?: string | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                } | undefined): UserTrophiesResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        trophies?: {
                            kind?: string | undefined;
                            data?: {
                                icon70?: string | undefined;
                                grantedAt?: number | undefined;
                                url?: string | undefined;
                                icon40?: string | undefined;
                                name?: string | undefined;
                                awardId?: string | undefined;
                                id?: string | undefined;
                                description?: string | undefined;
                            } | undefined;
                        }[];
                    } | undefined;
                }): UserTrophiesResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_user_username_about */
        readonly userAbout: {
            readonly name: "UserAbout";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.UserAboutRequest";
                encode(message: UserAboutRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UserAboutRequest;
                fromJSON(object: any): UserAboutRequest;
                toJSON(message: UserAboutRequest): unknown;
                create(base?: {
                    username?: string;
                } | undefined): UserAboutRequest;
                fromPartial(object: {
                    username?: string;
                }): UserAboutRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.users.UserAboutResponse";
                encode(message: UserAboutResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UserAboutResponse;
                fromJSON(object: any): UserAboutResponse;
                toJSON(message: UserAboutResponse): unknown;
                create(base?: {
                    kind?: string | undefined;
                    data?: {
                        acceptChats?: boolean | undefined;
                        acceptFollowers?: boolean | undefined;
                        acceptPms?: boolean | undefined;
                        awardeeKarma?: number | undefined;
                        awarderKarma?: number | undefined;
                        canCreateSubreddit?: boolean | undefined;
                        canEditName?: boolean | undefined;
                        coins?: number | undefined;
                        commentKarma?: number | undefined;
                        created?: number | undefined;
                        createdUtc?: number | undefined;
                        features?: {
                            awardsOnStreams?: boolean | undefined;
                            canMakeMobileTestBuildPurchases?: boolean | undefined;
                            chatGroupRollout?: boolean | undefined;
                            chatSubreddit?: boolean | undefined;
                            chatUserSettings?: boolean | undefined;
                            chat?: boolean | undefined;
                            cookieConsentBanner?: boolean | undefined;
                            crosspostNotif?: boolean | undefined;
                            crowdControlForPost?: boolean | undefined;
                            customFeedImage?: boolean | undefined;
                            doNotTrack?: boolean | undefined;
                            expensiveCoinsPackage?: boolean | undefined;
                            isEmailPermissionRequired?: boolean | undefined;
                            liveComments?: boolean | undefined;
                            liveOrangereds?: boolean | undefined;
                            modAwards?: boolean | undefined;
                            modServiceMuteReads?: boolean | undefined;
                            modServiceMuteWrites?: boolean | undefined;
                            modlogCopyrightRemoval?: boolean | undefined;
                            mwebNsfwXpromo?: {
                                experimentId?: number | undefined;
                                owner?: string | undefined;
                                variant?: string | undefined;
                            } | undefined;
                            mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                            mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                            mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                            mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                            mwebXpromoRevampV2?: {
                                experimentId?: number | undefined;
                                owner?: string | undefined;
                                variant?: string | undefined;
                            } | undefined;
                            mwebXpromoRevampV3?: {
                                experimentId?: number | undefined;
                                owner?: string | undefined;
                                variant?: string | undefined;
                            } | undefined;
                            noreferrerToNoopener?: boolean | undefined;
                            pollsMobile?: boolean | undefined;
                            premiumSubscriptionsTable?: boolean | undefined;
                            promotedTrendBlanks?: boolean | undefined;
                            resizedStylesImages?: boolean | undefined;
                            showAmpLink?: boolean | undefined;
                            showNpsSurvey?: boolean | undefined;
                            spezModal?: boolean | undefined;
                            usePrefAccountDeployment?: boolean | undefined;
                            userFlairMigrationTesting?: boolean | undefined;
                            webhookConfig?: boolean | undefined;
                        } | undefined;
                        forcePasswordReset?: boolean | undefined;
                        goldCreddits?: number | undefined;
                        goldExpiration?: string | undefined;
                        hasAndroidSubscription?: boolean | undefined;
                        hasExternalAccount?: boolean | undefined;
                        hasGoldSubscription?: boolean | undefined;
                        hasIosSubscription?: boolean | undefined;
                        hasMail?: boolean | undefined;
                        hasModMail?: boolean | undefined;
                        hasPaypalSubscription?: boolean | undefined;
                        hasStripeSubscription?: boolean | undefined;
                        hasSubscribed?: boolean | undefined;
                        hasSubscribedToPremium?: boolean | undefined;
                        hasVerifiedEmail?: boolean | undefined;
                        hasVisitedNewProfile?: boolean | undefined;
                        hideFromRobots?: boolean | undefined;
                        iconImg?: string | undefined;
                        id?: string | undefined;
                        inBeta?: boolean | undefined;
                        inChat?: boolean | undefined;
                        inRedesignBeta?: boolean | undefined;
                        inboxCount?: number | undefined;
                        isBlocked?: boolean | undefined;
                        isEmployee?: boolean | undefined;
                        isFriend?: boolean | undefined;
                        isGold?: boolean | undefined;
                        isMod?: boolean | undefined;
                        isSponsor?: boolean | undefined;
                        isSuspended?: boolean | undefined;
                        linkKarma?: number | undefined;
                        modhash?: string | undefined;
                        name?: string | undefined;
                        newModmailExists?: boolean | undefined;
                        numFriends?: number | undefined;
                        over18?: boolean | undefined;
                        passwordSet?: boolean | undefined;
                        prefAutoplay?: boolean | undefined;
                        prefClickgadget?: number | undefined;
                        prefGeopopular?: string | undefined;
                        prefNightmode?: boolean | undefined;
                        prefNoProfanity?: boolean | undefined;
                        prefShowPresence?: boolean | undefined;
                        prefShowSnoovatar?: boolean | undefined;
                        prefShowTrending?: boolean | undefined;
                        prefShowTwitter?: boolean | undefined;
                        prefTopKarmaSubreddits?: boolean | undefined;
                        prefVideoAutoplay?: boolean | undefined;
                        snoovatarImg?: string | undefined;
                        snoovatarSize?: number[];
                        subreddit?: {
                            acceptFollowers?: boolean | undefined;
                            accountsActiveIsFuzzed?: boolean | undefined;
                            accountsActive?: number | undefined;
                            activeUserCount?: number | undefined;
                            advertiserCategory?: string | undefined;
                            allOriginalContent?: boolean | undefined;
                            allowChatPostCreation?: boolean | undefined;
                            allowDiscovery?: boolean | undefined;
                            allowGalleries?: boolean | undefined;
                            allowImages?: boolean | undefined;
                            allowPolls?: boolean | undefined;
                            allowPredictionContributors?: boolean | undefined;
                            allowPredictionsTournament?: boolean | undefined;
                            allowPredictions?: boolean | undefined;
                            allowTalks?: boolean | undefined;
                            allowVideogifs?: boolean | undefined;
                            allowVideos?: boolean | undefined;
                            allowedMediaInComments?: string[];
                            bannerBackgroundColor?: string | undefined;
                            bannerBackgroundImage?: string | undefined;
                            bannerImg?: string | undefined;
                            bannerSize?: number[];
                            canAssignLinkFlair?: boolean | undefined;
                            canAssignUserFlair?: boolean | undefined;
                            coins?: number | undefined;
                            collapseDeletedComments?: boolean | undefined;
                            commentContributionSettings?: {
                                allowedMediaTypes?: string[];
                            } | undefined;
                            commentScoreHideMins?: number | undefined;
                            communityIcon?: string | undefined;
                            communityReviewed?: boolean | undefined;
                            contentCategory?: string | undefined;
                            createdUtc?: number | undefined;
                            created?: number | undefined;
                            defaultSet?: boolean | undefined;
                            description?: string | undefined;
                            descriptionHtml?: string | undefined;
                            disableContributorRequests?: boolean | undefined;
                            displayName?: string | undefined;
                            displayNamePrefixed?: string | undefined;
                            emojisCustomSize?: number[];
                            emojisEnabled?: boolean | undefined;
                            freeFormReports?: boolean | undefined;
                            hasMenuWidget?: boolean | undefined;
                            headerImg?: string | undefined;
                            headerSize?: number[];
                            headerTitle?: string | undefined;
                            hideAds?: boolean | undefined;
                            iconColor?: string | undefined;
                            iconImg?: string | undefined;
                            iconSize?: number[];
                            id?: string | undefined;
                            isChatPostFeatureEnabled?: boolean | undefined;
                            isCrosspostableSubreddit?: boolean | undefined;
                            isDefaultBanner?: boolean | undefined;
                            isDefaultIcon?: boolean | undefined;
                            isEnrolledInNewModmail?: boolean | undefined;
                            keyColor?: string | undefined;
                            lang?: string | undefined;
                            linkFlairEnabled?: boolean | undefined;
                            linkFlairPosition?: string | undefined;
                            mobileBannerImage?: string | undefined;
                            name?: string | undefined;
                            notificationLevel?: string | undefined;
                            originalContentTagEnabled?: string | undefined;
                            over18?: boolean | undefined;
                            predictionLeaderboardEntryType?: string | undefined;
                            previousNames?: string[];
                            primaryColor?: string | undefined;
                            publicDescription?: string | undefined;
                            publicDescriptionHtml?: string | undefined;
                            publicTraffic?: boolean | undefined;
                            quarantine?: boolean | undefined;
                            restrictCommenting?: boolean | undefined;
                            restrictPosting?: boolean | undefined;
                            shouldArchivePosts?: boolean | undefined;
                            shouldShowMediaInCommentsSetting?: boolean | undefined;
                            showMedia?: boolean | undefined;
                            showMediaPreview?: boolean | undefined;
                            spoilersEnabled?: boolean | undefined;
                            submissionType?: string | undefined;
                            submitLinkLabel?: string | undefined;
                            submitText?: string | undefined;
                            submitTextHtml?: string | undefined;
                            submitTextLabel?: string | undefined;
                            subredditType?: string | undefined;
                            subscribers?: number | undefined;
                            suggestedCommentSort?: string | undefined;
                            title?: string | undefined;
                            url?: string | undefined;
                            userCanFlairInSr?: boolean | undefined;
                            userFlairBackgroundColor?: string | undefined;
                            userFlairCssClass?: string | undefined;
                            userFlairEnabledInSr?: boolean | undefined;
                            userFlairPosition?: string | undefined;
                            userFlairRichtext?: {
                                e?: string | undefined;
                                t?: string | undefined;
                            }[];
                            userFlairTemplateId?: string | undefined;
                            userFlairText?: string | undefined;
                            userFlairTextColor?: string | undefined;
                            userFlairType?: string | undefined;
                            userHasFavorited?: boolean | undefined;
                            userIsBanned?: boolean | undefined;
                            userIsContributor?: boolean | undefined;
                            userIsModerator?: boolean | undefined;
                            userIsSubscriber?: boolean | undefined;
                            userSrFlairEnabled?: boolean | undefined;
                            userSrThemeEnabled?: boolean | undefined;
                            videostreamLinksCount?: number | undefined;
                            whitelistStatus?: string | undefined;
                            wikiEnabled?: boolean | undefined;
                            wls?: number | undefined;
                            markedSpam?: boolean | undefined;
                            postRequirements?: {
                                bodyRestrictionPolicy?: string | undefined;
                            } | undefined;
                            userIsMuted?: boolean;
                        } | undefined;
                        suspensionExpirationUtc?: string | undefined;
                        totalKarma?: number | undefined;
                        verified?: boolean | undefined;
                        hasPhoneNumber?: boolean | undefined;
                        subredditsModerated?: number | undefined;
                        hasMetaSubscription?: boolean | undefined;
                        metaSubscriptionAge?: number | undefined;
                        metaPointsBalance?: string | undefined;
                        metaLockedPointsBalance?: string | undefined;
                        commentSubredditKarma?: number | undefined;
                        postSubredditKarma?: number | undefined;
                        markedSpam?: boolean | undefined;
                        isSubredditProxyAccount?: boolean | undefined;
                    } | undefined;
                } | undefined): UserAboutResponse;
                fromPartial(object: {
                    kind?: string | undefined;
                    data?: {
                        acceptChats?: boolean | undefined;
                        acceptFollowers?: boolean | undefined;
                        acceptPms?: boolean | undefined;
                        awardeeKarma?: number | undefined;
                        awarderKarma?: number | undefined;
                        canCreateSubreddit?: boolean | undefined;
                        canEditName?: boolean | undefined;
                        coins?: number | undefined;
                        commentKarma?: number | undefined;
                        created?: number | undefined;
                        createdUtc?: number | undefined;
                        features?: {
                            awardsOnStreams?: boolean | undefined;
                            canMakeMobileTestBuildPurchases?: boolean | undefined;
                            chatGroupRollout?: boolean | undefined;
                            chatSubreddit?: boolean | undefined;
                            chatUserSettings?: boolean | undefined;
                            chat?: boolean | undefined;
                            cookieConsentBanner?: boolean | undefined;
                            crosspostNotif?: boolean | undefined;
                            crowdControlForPost?: boolean | undefined;
                            customFeedImage?: boolean | undefined;
                            doNotTrack?: boolean | undefined;
                            expensiveCoinsPackage?: boolean | undefined;
                            isEmailPermissionRequired?: boolean | undefined;
                            liveComments?: boolean | undefined;
                            liveOrangereds?: boolean | undefined;
                            modAwards?: boolean | undefined;
                            modServiceMuteReads?: boolean | undefined;
                            modServiceMuteWrites?: boolean | undefined;
                            modlogCopyrightRemoval?: boolean | undefined;
                            mwebNsfwXpromo?: {
                                experimentId?: number | undefined;
                                owner?: string | undefined;
                                variant?: string | undefined;
                            } | undefined;
                            mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                            mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                            mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                            mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                            mwebXpromoRevampV2?: {
                                experimentId?: number | undefined;
                                owner?: string | undefined;
                                variant?: string | undefined;
                            } | undefined;
                            mwebXpromoRevampV3?: {
                                experimentId?: number | undefined;
                                owner?: string | undefined;
                                variant?: string | undefined;
                            } | undefined;
                            noreferrerToNoopener?: boolean | undefined;
                            pollsMobile?: boolean | undefined;
                            premiumSubscriptionsTable?: boolean | undefined;
                            promotedTrendBlanks?: boolean | undefined;
                            resizedStylesImages?: boolean | undefined;
                            showAmpLink?: boolean | undefined;
                            showNpsSurvey?: boolean | undefined;
                            spezModal?: boolean | undefined;
                            usePrefAccountDeployment?: boolean | undefined;
                            userFlairMigrationTesting?: boolean | undefined;
                            webhookConfig?: boolean | undefined;
                        } | undefined;
                        forcePasswordReset?: boolean | undefined;
                        goldCreddits?: number | undefined;
                        goldExpiration?: string | undefined;
                        hasAndroidSubscription?: boolean | undefined;
                        hasExternalAccount?: boolean | undefined;
                        hasGoldSubscription?: boolean | undefined;
                        hasIosSubscription?: boolean | undefined;
                        hasMail?: boolean | undefined;
                        hasModMail?: boolean | undefined;
                        hasPaypalSubscription?: boolean | undefined;
                        hasStripeSubscription?: boolean | undefined;
                        hasSubscribed?: boolean | undefined;
                        hasSubscribedToPremium?: boolean | undefined;
                        hasVerifiedEmail?: boolean | undefined;
                        hasVisitedNewProfile?: boolean | undefined;
                        hideFromRobots?: boolean | undefined;
                        iconImg?: string | undefined;
                        id?: string | undefined;
                        inBeta?: boolean | undefined;
                        inChat?: boolean | undefined;
                        inRedesignBeta?: boolean | undefined;
                        inboxCount?: number | undefined;
                        isBlocked?: boolean | undefined;
                        isEmployee?: boolean | undefined;
                        isFriend?: boolean | undefined;
                        isGold?: boolean | undefined;
                        isMod?: boolean | undefined;
                        isSponsor?: boolean | undefined;
                        isSuspended?: boolean | undefined;
                        linkKarma?: number | undefined;
                        modhash?: string | undefined;
                        name?: string | undefined;
                        newModmailExists?: boolean | undefined;
                        numFriends?: number | undefined;
                        over18?: boolean | undefined;
                        passwordSet?: boolean | undefined;
                        prefAutoplay?: boolean | undefined;
                        prefClickgadget?: number | undefined;
                        prefGeopopular?: string | undefined;
                        prefNightmode?: boolean | undefined;
                        prefNoProfanity?: boolean | undefined;
                        prefShowPresence?: boolean | undefined;
                        prefShowSnoovatar?: boolean | undefined;
                        prefShowTrending?: boolean | undefined;
                        prefShowTwitter?: boolean | undefined;
                        prefTopKarmaSubreddits?: boolean | undefined;
                        prefVideoAutoplay?: boolean | undefined;
                        snoovatarImg?: string | undefined;
                        snoovatarSize?: number[];
                        subreddit?: {
                            acceptFollowers?: boolean | undefined;
                            accountsActiveIsFuzzed?: boolean | undefined;
                            accountsActive?: number | undefined;
                            activeUserCount?: number | undefined;
                            advertiserCategory?: string | undefined;
                            allOriginalContent?: boolean | undefined;
                            allowChatPostCreation?: boolean | undefined;
                            allowDiscovery?: boolean | undefined;
                            allowGalleries?: boolean | undefined;
                            allowImages?: boolean | undefined;
                            allowPolls?: boolean | undefined;
                            allowPredictionContributors?: boolean | undefined;
                            allowPredictionsTournament?: boolean | undefined;
                            allowPredictions?: boolean | undefined;
                            allowTalks?: boolean | undefined;
                            allowVideogifs?: boolean | undefined;
                            allowVideos?: boolean | undefined;
                            allowedMediaInComments?: string[];
                            bannerBackgroundColor?: string | undefined;
                            bannerBackgroundImage?: string | undefined;
                            bannerImg?: string | undefined;
                            bannerSize?: number[];
                            canAssignLinkFlair?: boolean | undefined;
                            canAssignUserFlair?: boolean | undefined;
                            coins?: number | undefined;
                            collapseDeletedComments?: boolean | undefined;
                            commentContributionSettings?: {
                                allowedMediaTypes?: string[];
                            } | undefined;
                            commentScoreHideMins?: number | undefined;
                            communityIcon?: string | undefined;
                            communityReviewed?: boolean | undefined;
                            contentCategory?: string | undefined;
                            createdUtc?: number | undefined;
                            created?: number | undefined;
                            defaultSet?: boolean | undefined;
                            description?: string | undefined;
                            descriptionHtml?: string | undefined;
                            disableContributorRequests?: boolean | undefined;
                            displayName?: string | undefined;
                            displayNamePrefixed?: string | undefined;
                            emojisCustomSize?: number[];
                            emojisEnabled?: boolean | undefined;
                            freeFormReports?: boolean | undefined;
                            hasMenuWidget?: boolean | undefined;
                            headerImg?: string | undefined;
                            headerSize?: number[];
                            headerTitle?: string | undefined;
                            hideAds?: boolean | undefined;
                            iconColor?: string | undefined;
                            iconImg?: string | undefined;
                            iconSize?: number[];
                            id?: string | undefined;
                            isChatPostFeatureEnabled?: boolean | undefined;
                            isCrosspostableSubreddit?: boolean | undefined;
                            isDefaultBanner?: boolean | undefined;
                            isDefaultIcon?: boolean | undefined;
                            isEnrolledInNewModmail?: boolean | undefined;
                            keyColor?: string | undefined;
                            lang?: string | undefined;
                            linkFlairEnabled?: boolean | undefined;
                            linkFlairPosition?: string | undefined;
                            mobileBannerImage?: string | undefined;
                            name?: string | undefined;
                            notificationLevel?: string | undefined;
                            originalContentTagEnabled?: string | undefined;
                            over18?: boolean | undefined;
                            predictionLeaderboardEntryType?: string | undefined;
                            previousNames?: string[];
                            primaryColor?: string | undefined;
                            publicDescription?: string | undefined;
                            publicDescriptionHtml?: string | undefined;
                            publicTraffic?: boolean | undefined;
                            quarantine?: boolean | undefined;
                            restrictCommenting?: boolean | undefined;
                            restrictPosting?: boolean | undefined;
                            shouldArchivePosts?: boolean | undefined;
                            shouldShowMediaInCommentsSetting?: boolean | undefined;
                            showMedia?: boolean | undefined;
                            showMediaPreview?: boolean | undefined;
                            spoilersEnabled?: boolean | undefined;
                            submissionType?: string | undefined;
                            submitLinkLabel?: string | undefined;
                            submitText?: string | undefined;
                            submitTextHtml?: string | undefined;
                            submitTextLabel?: string | undefined;
                            subredditType?: string | undefined;
                            subscribers?: number | undefined;
                            suggestedCommentSort?: string | undefined;
                            title?: string | undefined;
                            url?: string | undefined;
                            userCanFlairInSr?: boolean | undefined;
                            userFlairBackgroundColor?: string | undefined;
                            userFlairCssClass?: string | undefined;
                            userFlairEnabledInSr?: boolean | undefined;
                            userFlairPosition?: string | undefined;
                            userFlairRichtext?: {
                                e?: string | undefined;
                                t?: string | undefined;
                            }[];
                            userFlairTemplateId?: string | undefined;
                            userFlairText?: string | undefined;
                            userFlairTextColor?: string | undefined;
                            userFlairType?: string | undefined;
                            userHasFavorited?: boolean | undefined;
                            userIsBanned?: boolean | undefined;
                            userIsContributor?: boolean | undefined;
                            userIsModerator?: boolean | undefined;
                            userIsSubscriber?: boolean | undefined;
                            userSrFlairEnabled?: boolean | undefined;
                            userSrThemeEnabled?: boolean | undefined;
                            videostreamLinksCount?: number | undefined;
                            whitelistStatus?: string | undefined;
                            wikiEnabled?: boolean | undefined;
                            wls?: number | undefined;
                            markedSpam?: boolean | undefined;
                            postRequirements?: {
                                bodyRestrictionPolicy?: string | undefined;
                            } | undefined;
                            userIsMuted?: boolean;
                        } | undefined;
                        suspensionExpirationUtc?: string | undefined;
                        totalKarma?: number | undefined;
                        verified?: boolean | undefined;
                        hasPhoneNumber?: boolean | undefined;
                        subredditsModerated?: number | undefined;
                        hasMetaSubscription?: boolean | undefined;
                        metaSubscriptionAge?: number | undefined;
                        metaPointsBalance?: string | undefined;
                        metaLockedPointsBalance?: string | undefined;
                        commentSubredditKarma?: number | undefined;
                        postSubredditKarma?: number | undefined;
                        markedSpam?: boolean | undefined;
                        isSubredditProxyAccount?: boolean | undefined;
                    } | undefined;
                }): UserAboutResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /** https://www.reddit.com/dev/api#GET_user_username_where */
        readonly userWhere: {
            readonly name: "UserWhere";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.users.UserWhereRequest";
                encode(message: UserWhereRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UserWhereRequest;
                fromJSON(object: any): UserWhereRequest;
                toJSON(message: UserWhereRequest): unknown;
                create(base?: {
                    context?: number | undefined;
                    show?: string | undefined;
                    sort?: string | undefined;
                    t?: string | undefined;
                    type?: string | undefined;
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    username?: string | undefined;
                    where?: string;
                } | undefined): UserWhereRequest;
                fromPartial(object: {
                    context?: number | undefined;
                    show?: string | undefined;
                    sort?: string | undefined;
                    t?: string | undefined;
                    type?: string | undefined;
                    after?: string | undefined;
                    before?: string | undefined;
                    count?: number | undefined;
                    limit?: number | undefined;
                    username?: string | undefined;
                    where?: string;
                }): UserWhereRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.common.Listing";
                encode(message: Listing_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Listing_2;
                fromJSON(object: any): Listing_2;
                toJSON(message: Listing_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): Listing_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            kind?: string;
                            data?: {
                                allAwardings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                approved?: boolean | undefined;
                                approvedAtUtc?: number | undefined;
                                approvedBy?: string | undefined;
                                archived?: boolean | undefined;
                                associatedAward?: string | undefined;
                                author?: string | undefined;
                                authorFlairBackgroundColor?: string | undefined;
                                authorFlairCssClass?: string | undefined;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                authorFlairTemplateId?: string | undefined;
                                authorFlairText?: string | undefined;
                                authorFlairTextColor?: string | undefined;
                                authorFlairType?: string | undefined;
                                authorFullname?: string | undefined;
                                authorIsBlocked?: boolean | undefined;
                                authorPatreonFlair?: boolean | undefined;
                                authorPremium?: boolean | undefined;
                                awarders?: string[];
                                bannedAtUtc?: number | undefined;
                                bannedBy?: string | undefined;
                                body?: string | undefined;
                                bodyHtml?: string | undefined;
                                canGild?: boolean | undefined;
                                canModPost?: boolean | undefined;
                                collapsed?: boolean | undefined;
                                collapsedBecauseCrowdControl?: boolean | undefined;
                                collapsedReason?: string | undefined;
                                collapsedReasonCode?: string | undefined;
                                commentType?: string | undefined;
                                controversiality?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                distinguished?: string | undefined;
                                downs?: number | undefined;
                                edited?: boolean | undefined;
                                gilded?: number | undefined;
                                gildings?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                } | undefined;
                                id?: string | undefined;
                                ignoreReports?: boolean | undefined;
                                isSubmitter?: boolean | undefined;
                                likes?: boolean | undefined;
                                linkId?: string | undefined;
                                locked?: boolean | undefined;
                                modNote?: string | undefined;
                                modReasonBy?: string | undefined;
                                modReasonTitle?: string | undefined;
                                name?: string | undefined;
                                noFollow?: boolean | undefined;
                                numReports?: number | undefined;
                                parentId?: string | undefined;
                                permalink?: string | undefined;
                                removalReason?: string | undefined;
                                removed?: boolean | undefined;
                                replies?: string | undefined;
                                reportReasons?: any[] | undefined;
                                rteMode?: string | undefined;
                                saved?: boolean | undefined;
                                score?: number | undefined;
                                scoreHidden?: boolean | undefined;
                                sendReplies?: boolean | undefined;
                                spam?: boolean | undefined;
                                stickied?: boolean | undefined;
                                subreddit?: string | undefined;
                                subredditId?: string | undefined;
                                subredditNamePrefixed?: string | undefined;
                                subredditType?: string | undefined;
                                topAwardedType?: string | undefined;
                                totalAwardsReceived?: number | undefined;
                                treatmentTags?: {
                                    typeUrl?: string;
                                    value?: Uint8Array;
                                }[];
                                unrepliableReason?: string | undefined;
                                ups?: number | undefined;
                                depth?: number | undefined;
                                linkTitle?: string | undefined;
                                linkAuthor?: string | undefined;
                                numComments?: number | undefined;
                                over18?: boolean | undefined;
                                linkPermalink?: string | undefined;
                                quarantine?: boolean | undefined;
                                linkUrl?: string | undefined;
                                selftext?: string | undefined;
                                selftextHtml?: string | undefined;
                                thumbnail?: string | undefined;
                                thumbnailWidth?: number | undefined;
                                thumbnailHeight?: number | undefined;
                                title?: string | undefined;
                                url?: string | undefined;
                                displayName?: string | undefined;
                                modPermissions?: string[];
                                count?: number | undefined;
                                children?: any[] | undefined;
                                replyList?: any | undefined;
                                hidden?: boolean | undefined;
                                linkFlairBackgroundColor?: string | undefined;
                                linkFlairCssClass?: string | undefined;
                                linkFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                    a?: string | undefined;
                                    u?: string | undefined;
                                }[];
                                linkFlairTemplateId?: string | undefined;
                                linkFlairText?: string | undefined;
                                linkFlairTextColor?: string | undefined;
                                linkFlairType?: string | undefined;
                                secureMedia?: {
                                    type?: string;
                                    oembed?: {
                                        type?: string;
                                        title?: string | undefined;
                                        providerName?: string | undefined;
                                        providerUrl?: string | undefined;
                                        version?: string;
                                        thumbnailWidth?: number | undefined;
                                        thumbnailHeight?: number | undefined;
                                        thumbnailUrl?: string | undefined;
                                        html?: string;
                                        height?: number | undefined;
                                        width?: number | undefined;
                                        authorUrl?: string | undefined;
                                        authorName?: string | undefined;
                                    } | undefined;
                                    redditVideo?: {
                                        bitrateKbps?: number | undefined;
                                        dashUrl?: string | undefined;
                                        duration?: number | undefined;
                                        fallbackUrl?: string | undefined;
                                        height?: number | undefined;
                                        hlsUrl?: string | undefined;
                                        isGif?: boolean | undefined;
                                        scrubberMediaUrl?: string | undefined;
                                        transcodingStatus?: string | undefined;
                                        width?: number | undefined;
                                    } | undefined;
                                } | undefined;
                                spoiler?: boolean;
                                modReports?: any[][];
                                userReports?: any[][];
                                removedBy?: string | undefined;
                                removedByCategory?: string | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): Listing_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
    };
};

declare interface UserSearchResponse {
    kind?: string | undefined;
    data?: UserSearchResponse_AccData | undefined;
}

declare const UserSearchResponse: {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse";
    encode(message: UserSearchResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserSearchResponse;
    fromJSON(object: any): UserSearchResponse;
    toJSON(message: UserSearchResponse): unknown;
    create(base?: DeepPartial_11<UserSearchResponse>): UserSearchResponse;
    fromPartial(object: DeepPartial_11<UserSearchResponse>): UserSearchResponse;
};

declare interface UserSearchResponse_AccData {
    after?: string | undefined;
    dist?: number | undefined;
    modhash?: string | undefined;
    geoFilter?: string | undefined;
    children: UserSearchResponse_Account[];
    before?: string | undefined;
}

declare const UserSearchResponse_AccData: {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccData";
    encode(message: UserSearchResponse_AccData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserSearchResponse_AccData;
    fromJSON(object: any): UserSearchResponse_AccData;
    toJSON(message: UserSearchResponse_AccData): unknown;
    create(base?: DeepPartial_11<UserSearchResponse_AccData>): UserSearchResponse_AccData;
    fromPartial(object: DeepPartial_11<UserSearchResponse_AccData>): UserSearchResponse_AccData;
};

declare interface UserSearchResponse_Account {
    kind?: string | undefined;
    data?: UserSearchResponse_AccountData | undefined;
}

declare const UserSearchResponse_Account: {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.Account";
    encode(message: UserSearchResponse_Account, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserSearchResponse_Account;
    fromJSON(object: any): UserSearchResponse_Account;
    toJSON(message: UserSearchResponse_Account): unknown;
    create(base?: DeepPartial_11<UserSearchResponse_Account>): UserSearchResponse_Account;
    fromPartial(object: DeepPartial_11<UserSearchResponse_Account>): UserSearchResponse_Account;
};

declare interface UserSearchResponse_AccountData {
    isEmployee?: boolean | undefined;
    isFriend?: boolean | undefined;
    snoovatarSize: number[];
    id?: string | undefined;
    verified?: boolean | undefined;
    isGold?: boolean | undefined;
    isMod?: boolean | undefined;
    hasVerifiedEmail?: boolean | undefined;
    iconImg?: string | undefined;
    hideFromRobots?: boolean | undefined;
    linkKarma?: number | undefined;
    acceptChats?: boolean | undefined;
    isBlocked?: boolean | undefined;
    prefShowSnoovatar?: boolean | undefined;
    name?: string | undefined;
    created?: number | undefined;
    createdUtc?: number | undefined;
    snoovatarImg?: string | undefined;
    commentKarma?: number | undefined;
    acceptFollowers?: boolean | undefined;
    hasSubscribed?: boolean | undefined;
    acceptPms?: boolean | undefined;
    isSuspended?: boolean | undefined;
    subreddit?: UserSearchResponse_AccountData_Subreddit | undefined;
}

declare const UserSearchResponse_AccountData: {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData";
    encode(message: UserSearchResponse_AccountData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserSearchResponse_AccountData;
    fromJSON(object: any): UserSearchResponse_AccountData;
    toJSON(message: UserSearchResponse_AccountData): unknown;
    create(base?: DeepPartial_11<UserSearchResponse_AccountData>): UserSearchResponse_AccountData;
    fromPartial(object: DeepPartial_11<UserSearchResponse_AccountData>): UserSearchResponse_AccountData;
};

declare interface UserSearchResponse_AccountData_Subreddit {
    defaultSet?: boolean | undefined;
    userIsContributor?: boolean | undefined;
    bannerImg?: string | undefined;
    allowedMediaInComments: string[];
    userIsBanned?: boolean | undefined;
    freeFormReports?: boolean | undefined;
    communityIcon?: string | undefined;
    showMedia?: boolean | undefined;
    iconColor?: string | undefined;
    userIsMuted?: boolean | undefined;
    displayName?: string | undefined;
    headerImg?: string | undefined;
    title?: string | undefined;
    previousNames: string[];
    over18?: boolean | undefined;
    iconSize: number[];
    primaryColor?: string | undefined;
    iconImg?: string | undefined;
    description?: string | undefined;
    submitLinkLabel?: string | undefined;
    headerSize: number[];
    restrictPosting?: boolean | undefined;
    restrictCommenting?: boolean | undefined;
    subscribers?: number | undefined;
    submitTextLabel?: string | undefined;
    isDefaultIcon?: boolean | undefined;
    linkFlairPosition?: string | undefined;
    displayNamePrefixed?: string | undefined;
    keyColor?: string | undefined;
    name?: string | undefined;
    isDefaultBanner?: boolean | undefined;
    url?: string | undefined;
    quarantine?: boolean | undefined;
    bannerSize: number[];
    userIsModerator?: boolean | undefined;
    acceptFollowers?: boolean | undefined;
    publicDescription?: string | undefined;
    linkFlairEnabled?: boolean | undefined;
    disableContributorRequests?: boolean | undefined;
    subredditType?: string | undefined;
    userIsSubscriber?: boolean | undefined;
}

declare const UserSearchResponse_AccountData_Subreddit: {
    $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData.Subreddit";
    encode(message: UserSearchResponse_AccountData_Subreddit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserSearchResponse_AccountData_Subreddit;
    fromJSON(object: any): UserSearchResponse_AccountData_Subreddit;
    toJSON(message: UserSearchResponse_AccountData_Subreddit): unknown;
    create(base?: DeepPartial_11<UserSearchResponse_AccountData_Subreddit>): UserSearchResponse_AccountData_Subreddit;
    fromPartial(object: DeepPartial_11<UserSearchResponse_AccountData_Subreddit>): UserSearchResponse_AccountData_Subreddit;
};

declare interface UsersSearchRequest {
    /** fullname of a thing */
    after?: string | undefined;
    /** fullname of a thing */
    before?: string | undefined;
    /** a positive integer (default: 0) */
    count?: number | undefined;
    /** the maximum number of items desired (default: 25, maximum: 100) */
    limit?: number | undefined;
    /** a search query */
    q: string;
    /** a uuid */
    searchQueryId?: string | undefined;
    /** (optional) the string all */
    show?: string | undefined;
    /** one of (relevance, activity) */
    sort?: string | undefined;
    /** (optional) boolean value */
    typeaheadActive?: boolean | undefined;
}

declare const UsersSearchRequest: {
    $type: "devvit.plugin.redditapi.subreddits.UsersSearchRequest";
    encode(message: UsersSearchRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UsersSearchRequest;
    fromJSON(object: any): UsersSearchRequest;
    toJSON(message: UsersSearchRequest): unknown;
    create(base?: DeepPartial_11<UsersSearchRequest>): UsersSearchRequest;
    fromPartial(object: DeepPartial_11<UsersSearchRequest>): UsersSearchRequest;
};

declare const UsersServiceName = "devvit.plugin.redditapi.users.Users";

declare interface UserTrophiesResponse {
    kind?: string | undefined;
    data?: UserTrophiesResponse_UserTrophiesData | undefined;
}

declare const UserTrophiesResponse: {
    $type: "devvit.plugin.redditapi.users.UserTrophiesResponse";
    encode(message: UserTrophiesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserTrophiesResponse;
    fromJSON(object: any): UserTrophiesResponse;
    toJSON(message: UserTrophiesResponse): unknown;
    create(base?: DeepPartial_100<UserTrophiesResponse>): UserTrophiesResponse;
    fromPartial(object: DeepPartial_100<UserTrophiesResponse>): UserTrophiesResponse;
};

declare interface UserTrophiesResponse_TrophiesData {
    icon70?: string | undefined;
    grantedAt?: number | undefined;
    url?: string | undefined;
    icon40?: string | undefined;
    name?: string | undefined;
    awardId?: string | undefined;
    id?: string | undefined;
    description?: string | undefined;
}

declare const UserTrophiesResponse_TrophiesData: {
    $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesData";
    encode(message: UserTrophiesResponse_TrophiesData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserTrophiesResponse_TrophiesData;
    fromJSON(object: any): UserTrophiesResponse_TrophiesData;
    toJSON(message: UserTrophiesResponse_TrophiesData): unknown;
    create(base?: DeepPartial_100<UserTrophiesResponse_TrophiesData>): UserTrophiesResponse_TrophiesData;
    fromPartial(object: DeepPartial_100<UserTrophiesResponse_TrophiesData>): UserTrophiesResponse_TrophiesData;
};

declare interface UserTrophiesResponse_TrophiesType {
    kind?: string | undefined;
    data?: UserTrophiesResponse_TrophiesData | undefined;
}

declare const UserTrophiesResponse_TrophiesType: {
    $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesType";
    encode(message: UserTrophiesResponse_TrophiesType, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserTrophiesResponse_TrophiesType;
    fromJSON(object: any): UserTrophiesResponse_TrophiesType;
    toJSON(message: UserTrophiesResponse_TrophiesType): unknown;
    create(base?: DeepPartial_100<UserTrophiesResponse_TrophiesType>): UserTrophiesResponse_TrophiesType;
    fromPartial(object: DeepPartial_100<UserTrophiesResponse_TrophiesType>): UserTrophiesResponse_TrophiesType;
};

declare interface UserTrophiesResponse_UserTrophiesData {
    trophies: UserTrophiesResponse_TrophiesType[];
}

declare const UserTrophiesResponse_UserTrophiesData: {
    $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.UserTrophiesData";
    encode(message: UserTrophiesResponse_UserTrophiesData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserTrophiesResponse_UserTrophiesData;
    fromJSON(object: any): UserTrophiesResponse_UserTrophiesData;
    toJSON(message: UserTrophiesResponse_UserTrophiesData): unknown;
    create(base?: DeepPartial_100<UserTrophiesResponse_UserTrophiesData>): UserTrophiesResponse_UserTrophiesData;
    fromPartial(object: DeepPartial_100<UserTrophiesResponse_UserTrophiesData>): UserTrophiesResponse_UserTrophiesData;
};

declare interface UserV2 {
    id: string;
    name: string;
    isGold: boolean;
    snoovatarImage: string;
    url: string;
    spam: boolean;
    banned: boolean;
    flair?: UserFlairV2 | undefined;
    karma: number;
    iconImage: string;
}

declare const UserV2: {
    $type: "devvit.reddit.v2alpha.UserV2";
    encode(message: UserV2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserV2;
    fromJSON(object: any): UserV2;
    toJSON(message: UserV2): unknown;
    create(base?: DeepPartial_73<UserV2>): UserV2;
    fromPartial(object: DeepPartial_73<UserV2>): UserV2;
};

declare interface UserWhereRequest {
    context?: number | undefined;
    show?: string | undefined;
    sort?: string | undefined;
    t?: string | undefined;
    type?: string | undefined;
    after?: string | undefined;
    before?: string | undefined;
    count?: number | undefined;
    limit?: number | undefined;
    username?: string | undefined;
    where: string;
}

declare const UserWhereRequest: {
    $type: "devvit.plugin.redditapi.users.UserWhereRequest";
    encode(message: UserWhereRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserWhereRequest;
    fromJSON(object: any): UserWhereRequest;
    toJSON(message: UserWhereRequest): unknown;
    create(base?: DeepPartial_100<UserWhereRequest>): UserWhereRequest;
    fromPartial(object: DeepPartial_100<UserWhereRequest>): UserWhereRequest;
};

export declare function useState(initialState: UseStateInitializer<boolean>): UseStateResult<boolean>;

export declare function useState(initialState: UseStateInitializer<number>): UseStateResult<number>;

export declare function useState(initialState: UseStateInitializer<string>): UseStateResult<string>;

export declare function useState<S extends JSONValue>(initialState: UseStateInitializer<S>): UseStateResult<S>;

export declare type UseStateHook = Context['useState'];

export declare type UseStateInitializer<S> = S | (() => S);

/** A tuple containing the current state and a function to update it */
export declare type UseStateResult<S> = [S, StateSetter<S>];

/** Many RPCs take just a UUID as a parameter; declare a common message here to make life simpler */
declare interface UUID {
    id: string;
}

declare const UUID: {
    $type: "devvit.UUID";
    encode(message: UUID, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UUID;
    fromJSON(object: any): UUID;
    toJSON(message: UUID): unknown;
    create(base?: DeepPartial_102<UUID>): UUID;
    fromPartial(object: DeepPartial_102<UUID>): UUID;
};

/** The Events plugin allows an app to emit pre-defined v2 events */
declare interface V2Events {
    Publish(request: V2EventsPublishRequest, metadata?: Metadata): Promise<V2EventsPublishResponse>;
}

declare interface V2EventsActionInfo {
    pageType: string;
    paneName: string;
}

declare const V2EventsActionInfo: {
    $type: "devvit.plugin.v2events.V2EventsActionInfo";
    encode(message: V2EventsActionInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): V2EventsActionInfo;
    fromJSON(object: any): V2EventsActionInfo;
    toJSON(message: V2EventsActionInfo): unknown;
    create(base?: DeepPartial_101<V2EventsActionInfo>): V2EventsActionInfo;
    fromPartial(object: DeepPartial_101<V2EventsActionInfo>): V2EventsActionInfo;
};

declare class V2EventsClientImpl implements V2Events {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_11, opts?: {
        service?: string;
    });
    Publish(request: V2EventsPublishRequest, metadata?: Metadata): Promise<V2EventsPublishResponse>;
}

/** The Events plugin allows an app to emit pre-defined v2 events */
declare type V2EventsDefinition = typeof V2EventsDefinition;

declare const V2EventsDefinition: {
    readonly name: "V2Events";
    readonly fullName: "devvit.plugin.v2events.V2Events";
    readonly methods: {
        readonly publish: {
            readonly name: "Publish";
            readonly requestType: {
                $type: "devvit.plugin.v2events.V2EventsPublishRequest";
                encode(message: V2EventsPublishRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): V2EventsPublishRequest;
                fromJSON(object: any): V2EventsPublishRequest;
                toJSON(message: V2EventsPublishRequest): unknown;
                create(base?: DeepPartial_101<V2EventsPublishRequest>): V2EventsPublishRequest;
                fromPartial(object: DeepPartial_101<V2EventsPublishRequest>): V2EventsPublishRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.v2events.V2EventsPublishResponse";
                encode(_: V2EventsPublishResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): V2EventsPublishResponse;
                fromJSON(_: any): V2EventsPublishResponse;
                toJSON(_: V2EventsPublishResponse): unknown;
                create(base?: DeepPartial_101<V2EventsPublishResponse>): V2EventsPublishResponse;
                fromPartial(_: DeepPartial_101<V2EventsPublishResponse>): V2EventsPublishResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare interface V2EventsPostGuidanceCreate {
    actionInfo?: V2EventsActionInfo | undefined;
}

declare const V2EventsPostGuidanceCreate: {
    $type: "devvit.plugin.v2events.V2EventsPostGuidanceCreate";
    encode(message: V2EventsPostGuidanceCreate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): V2EventsPostGuidanceCreate;
    fromJSON(object: any): V2EventsPostGuidanceCreate;
    toJSON(message: V2EventsPostGuidanceCreate): unknown;
    create(base?: DeepPartial_101<V2EventsPostGuidanceCreate>): V2EventsPostGuidanceCreate;
    fromPartial(object: DeepPartial_101<V2EventsPostGuidanceCreate>): V2EventsPostGuidanceCreate;
};

declare interface V2EventsPostGuidanceUpdate {
    actionInfo?: V2EventsActionInfo | undefined;
}

declare const V2EventsPostGuidanceUpdate: {
    $type: "devvit.plugin.v2events.V2EventsPostGuidanceUpdate";
    encode(message: V2EventsPostGuidanceUpdate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): V2EventsPostGuidanceUpdate;
    fromJSON(object: any): V2EventsPostGuidanceUpdate;
    toJSON(message: V2EventsPostGuidanceUpdate): unknown;
    create(base?: DeepPartial_101<V2EventsPostGuidanceUpdate>): V2EventsPostGuidanceUpdate;
    fromPartial(object: DeepPartial_101<V2EventsPostGuidanceUpdate>): V2EventsPostGuidanceUpdate;
};

declare interface V2EventsPublishRequest {
    postGuidanceCreate?: V2EventsPostGuidanceCreate | undefined;
    postGuidanceUpdate?: V2EventsPostGuidanceUpdate | undefined;
}

declare const V2EventsPublishRequest: {
    $type: "devvit.plugin.v2events.V2EventsPublishRequest";
    encode(message: V2EventsPublishRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): V2EventsPublishRequest;
    fromJSON(object: any): V2EventsPublishRequest;
    toJSON(message: V2EventsPublishRequest): unknown;
    create(base?: DeepPartial_101<V2EventsPublishRequest>): V2EventsPublishRequest;
    fromPartial(object: DeepPartial_101<V2EventsPublishRequest>): V2EventsPublishRequest;
};

/** Generic response interface */
declare interface V2EventsPublishResponse {
}

declare const V2EventsPublishResponse: {
    $type: "devvit.plugin.v2events.V2EventsPublishResponse";
    encode(_: V2EventsPublishResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): V2EventsPublishResponse;
    fromJSON(_: any): V2EventsPublishResponse;
    toJSON(_: V2EventsPublishResponse): unknown;
    create(base?: DeepPartial_101<V2EventsPublishResponse>): V2EventsPublishResponse;
    fromPartial(_: DeepPartial_101<V2EventsPublishResponse>): V2EventsPublishResponse;
};

declare const V2EventsServiceName = "devvit.plugin.v2events.V2Events";

export declare type ValidatedBooleanField = Prettify<ValidatedFormField<BooleanField, boolean>>;

export declare type ValidatedFormField<Field, ValueType> = Omit<Field, 'required'> & {
    onValidate?: OnValidateHandler<ValueType>;
};

export declare type ValidatedNumberField = Prettify<ValidatedFormField<NumberField, number>>;

export declare type ValidatedParagraphField = Prettify<ValidatedFormField<ParagraphField, string>>;

export declare type ValidatedSelectField = Prettify<ValidatedFormField<SelectField, string[]>>;

export declare type ValidatedStringField = Prettify<ValidatedFormField<StringField, string>>;

declare interface ValidateFormRequest {
    /** If true, the form is editing existing settings */
    editing: boolean;
    /** Map of id:value pairs to validate */
    fieldValues: {
        [key: string]: FormFieldValue;
    };
}

declare const ValidateFormRequest: {
    $type: "devvit.actor.settings.v1alpha.ValidateFormRequest";
    encode(message: ValidateFormRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ValidateFormRequest;
    fromJSON(object: any): ValidateFormRequest;
    toJSON(message: ValidateFormRequest): unknown;
    create(base?: DeepPartial_16<ValidateFormRequest>): ValidateFormRequest;
    fromPartial(object: DeepPartial_16<ValidateFormRequest>): ValidateFormRequest;
};

declare interface ValidateFormRequest_FieldValuesEntry {
    key: string;
    value?: FormFieldValue | undefined;
}

declare const ValidateFormRequest_FieldValuesEntry: {
    $type: "devvit.actor.settings.v1alpha.ValidateFormRequest.FieldValuesEntry";
    encode(message: ValidateFormRequest_FieldValuesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ValidateFormRequest_FieldValuesEntry;
    fromJSON(object: any): ValidateFormRequest_FieldValuesEntry;
    toJSON(message: ValidateFormRequest_FieldValuesEntry): unknown;
    create(base?: DeepPartial_16<ValidateFormRequest_FieldValuesEntry>): ValidateFormRequest_FieldValuesEntry;
    fromPartial(object: DeepPartial_16<ValidateFormRequest_FieldValuesEntry>): ValidateFormRequest_FieldValuesEntry;
};

declare interface ValidateFormResponse {
    /** If false, prevent submission and display errors on the form */
    success: boolean;
    /** Map of id:error pairs to display on the form */
    errors: {
        [key: string]: string;
    };
}

declare const ValidateFormResponse: {
    $type: "devvit.actor.settings.v1alpha.ValidateFormResponse";
    encode(message: ValidateFormResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ValidateFormResponse;
    fromJSON(object: any): ValidateFormResponse;
    toJSON(message: ValidateFormResponse): unknown;
    create(base?: DeepPartial_16<ValidateFormResponse>): ValidateFormResponse;
    fromPartial(object: DeepPartial_16<ValidateFormResponse>): ValidateFormResponse;
};

declare interface ValidateFormResponse_ErrorsEntry {
    key: string;
    value: string;
}

declare const ValidateFormResponse_ErrorsEntry: {
    $type: "devvit.actor.settings.v1alpha.ValidateFormResponse.ErrorsEntry";
    encode(message: ValidateFormResponse_ErrorsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ValidateFormResponse_ErrorsEntry;
    fromJSON(object: any): ValidateFormResponse_ErrorsEntry;
    toJSON(message: ValidateFormResponse_ErrorsEntry): unknown;
    create(base?: DeepPartial_16<ValidateFormResponse_ErrorsEntry>): ValidateFormResponse_ErrorsEntry;
    fromPartial(object: DeepPartial_16<ValidateFormResponse_ErrorsEntry>): ValidateFormResponse_ErrorsEntry;
};

/**
 * `Value` represents a dynamically typed value which can be either
 * null, a number, a string, a boolean, a recursive struct value, or a
 * list of values. A producer of value is expected to set one of these
 * variants. Absence of any variant indicates an error.
 *
 * The JSON representation for `Value` is JSON value.
 */
declare interface Value {
    /** Represents a null value. */
    nullValue?: NullValue | undefined;
    /** Represents a double value. */
    numberValue?: number | undefined;
    /** Represents a string value. */
    stringValue?: string | undefined;
    /** Represents a boolean value. */
    boolValue?: boolean | undefined;
    /** Represents a structured value. */
    structValue?: {
        [key: string]: any;
    } | undefined;
    /** Represents a repeated `Value`. */
    listValue?: Array<any> | undefined;
}

declare const Value: {
    $type: "google.protobuf.Value";
    encode(message: Value, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Value;
    fromJSON(object: any): Value;
    toJSON(message: Value): unknown;
    create(base?: DeepPartial_103<Value>): Value;
    fromPartial(object: DeepPartial_103<Value>): Value;
    wrap(value: any): Value;
    unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined;
};

/**
 * A type representing a Vault (crypto wallet).
 */
export declare type Vault = {
    /**
     * The provider of the Vault address.
     * @example 'ethereum'
     */
    provider: string;
    /**
     * The ID (starting with t2_) of the user owning the Vault.
     * @example 't2_1w72'
     */
    userId: T2ID;
    /**
     * The address of the Vault.
     * @example '0x205ee28744456bDBf180A0Fa7De51e0F116d54Ed'
     */
    address: string;
    /**
     * The date the Vault was created.
     */
    createdAt: string;
    /**
     * Whether the Vault is active.
     */
    isActive: boolean;
};

/**
 * @mixin
 */
declare type VideoContainer<Context> = {
    /**
     * Append a Video
     * @param opts {@link VideoOptions}
     */
    video(opts: VideoOptions): Context;
};

/**
 * @borrows MediaOptions
 */
declare type VideoOptions = MediaOptions & {
    /**
     * An {@link Image} element to use as the thumbnail before the video has loaded
     * @see {@link Image}
     * @see {makeImage}
     */
    thumbnail?: Image;
    /** Whether the video should be converted to a looping GIF */
    convertToGif?: boolean;
};

declare interface Vote {
    updatedAt?: Date | undefined;
    comment?: CommentV2 | undefined;
    post?: PostV2 | undefined;
    subreddit?: SubredditV2 | undefined;
    upvoteRatio: number;
    score: number;
}

declare const Vote: {
    $type: "devvit.events.v1alpha.Vote";
    encode(message: Vote, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Vote;
    fromJSON(object: any): Vote;
    toJSON(message: Vote): unknown;
    create(base?: DeepPartial_74<Vote>): Vote;
    fromPartial(object: DeepPartial_74<Vote>): Vote;
};

declare interface VoteRequest {
    /**
     * One of: -1, 0, 1
     * Where:
     *   1 = Upvote
     *   0 = Cleared
     *  -1 = Downvote
     */
    dir: number;
    /**
     * Post or Comment thing ID
     * @example "t1_abc123"
     */
    id: string;
}

declare const VoteRequest: {
    $type: "devvit.plugin.redditapi.linksandcomments.VoteRequest";
    encode(message: VoteRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): VoteRequest;
    fromJSON(object: any): VoteRequest;
    toJSON(message: VoteRequest): unknown;
    create(base?: DeepPartial_64<VoteRequest>): VoteRequest;
    fromPartial(object: DeepPartial_64<VoteRequest>): VoteRequest;
};

declare interface WatchRequest {
    transactionId?: TransactionId | undefined;
    keys: string[];
}

declare const WatchRequest: {
    $type: "devvit.plugin.redis.WatchRequest";
    encode(message: WatchRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WatchRequest;
    fromJSON(object: any): WatchRequest;
    toJSON(message: WatchRequest): unknown;
    create(base?: DeepPartial_86<WatchRequest>): WatchRequest;
    fromPartial(object: DeepPartial_86<WatchRequest>): WatchRequest;
};

export declare class Widget {
    #private;
    constructor(widgetData: GetWidgetsResponse_WidgetItem, subredditName: string, metadata: Metadata | undefined);
    get id(): string;
    get name(): string;
    get subredditName(): string;
    toJSON(): Pick<Widget, 'id' | 'name' | 'subredditName'>;
    delete(): Promise<void>;
}

declare interface WidgetButton {
    kind: string;
    text: string;
    url?: string | undefined;
    imageUrl?: string | undefined;
    linkUrl?: string | undefined;
    color?: string | undefined;
    fillColor?: string | undefined;
    textColor?: string | undefined;
    height?: number | undefined;
    width?: number | undefined;
    hoverState?: WidgetButton_HoverState | undefined;
}

declare const WidgetButton: {
    $type: "devvit.plugin.redditapi.widgets.WidgetButton";
    encode(message: WidgetButton, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WidgetButton;
    fromJSON(object: any): WidgetButton;
    toJSON(message: WidgetButton): unknown;
    create(base?: DeepPartial_4<WidgetButton>): WidgetButton;
    fromPartial(object: DeepPartial_4<WidgetButton>): WidgetButton;
};

declare interface WidgetButton_HoverState {
    kind: string;
    color?: string | undefined;
    fillColor?: string | undefined;
    text?: string | undefined;
    textColor?: string | undefined;
    imageUrl?: string | undefined;
    height?: number | undefined;
    width?: number | undefined;
}

declare const WidgetButton_HoverState: {
    $type: "devvit.plugin.redditapi.widgets.WidgetButton.HoverState";
    encode(message: WidgetButton_HoverState, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WidgetButton_HoverState;
    fromJSON(object: any): WidgetButton_HoverState;
    toJSON(message: WidgetButton_HoverState): unknown;
    create(base?: DeepPartial_4<WidgetButton_HoverState>): WidgetButton_HoverState;
    fromPartial(object: DeepPartial_4<WidgetButton_HoverState>): WidgetButton_HoverState;
};

declare interface WidgetImage {
    url: string;
    /** required by can be an empty string */
    linkUrl: string;
    height: number;
    width: number;
}

declare const WidgetImage: {
    $type: "devvit.plugin.redditapi.widgets.WidgetImage";
    encode(message: WidgetImage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WidgetImage;
    fromJSON(object: any): WidgetImage;
    toJSON(message: WidgetImage): unknown;
    create(base?: DeepPartial_4<WidgetImage>): WidgetImage;
    fromPartial(object: DeepPartial_4<WidgetImage>): WidgetImage;
};

/** WIDGETS - https://www.reddit.com/dev/api#section_widgets */
declare interface Widgets {
    /**
     * Add a button widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    AddButtonWidget(request: AddButtonWidgetRequest, metadata?: Metadata): Promise<ButtonWidget_2>;
    /**
     * Add an image widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    AddImageWidget(request: AddImageWidgetRequest, metadata?: Metadata): Promise<ImageWidget_2>;
    /**
     * Add a calendar widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    AddCalendarWidget(request: AddCalendarWidgetRequest, metadata?: Metadata): Promise<CalendarWidget_2>;
    /**
     * Add a text widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    AddTextAreaWidget(request: AddTextAreaWidgetRequest, metadata?: Metadata): Promise<TextAreaWidget_2>;
    /**
     * Add a community list widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    AddCommunityListWidget(request: AddCommunityListWidgetRequest, metadata?: Metadata): Promise<CommunityListWidget_2>;
    /**
     * Add a post flair widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    AddPostFlairWidget(request: AddPostFlairWidgetRequest, metadata?: Metadata): Promise<PostFlairWidget_2>;
    /**
     * Add a custom widget to a subreddit. This is an experimental feature.
     * Custom widgets don't display on mobile devices. Customizations can break at any time
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    AddCustomWidget(request: AddCustomWidgetRequest, metadata?: Metadata): Promise<CustomWidget_2>;
    /**
     * Delete a widget from a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#DELETE_api_widget_\{widget_id\}}
     */
    DeleteWidget(request: DeleteWidgetRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Update a button widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    UpdateButtonWidget(request: UpdateButtonWidgetRequest, metadata?: Metadata): Promise<ButtonWidget_2>;
    /**
     * Update an image widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    UpdateImageWidget(request: UpdateImageWidgetRequest, metadata?: Metadata): Promise<ImageWidget_2>;
    /**
     * Update a calendar widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    UpdateCalendarWidget(request: UpdateCalendarWidgetRequest, metadata?: Metadata): Promise<CalendarWidget_2>;
    /**
     * Update a text widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    UpdateTextAreaWidget(request: UpdateTextAreaWidgetRequest, metadata?: Metadata): Promise<TextAreaWidget_2>;
    /**
     * Update a community list widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    UpdateCommunityListWidget(request: UpdateCommunityListWidgetRequest, metadata?: Metadata): Promise<UpdateCommunityListWidgetResponse>;
    /**
     * Update a post flair widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    UpdatePostFlairWidget(request: UpdatePostFlairWidgetRequest, metadata?: Metadata): Promise<PostFlairWidget_2>;
    /**
     * Update a custom widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    UpdateCustomWidget(request: UpdateCustomWidgetRequest, metadata?: Metadata): Promise<CustomWidget_2>;
    /**
     * Get an S3 upload lease for a widget image. This is used to upload images for image widgets.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget_image_upload_s3}
     */
    GetWidgetImageUploadLease(request: GetWidgetImageUploadLeaseRequest, metadata?: Metadata): Promise<GetWidgetImageUploadLeaseResponse>;
    /**
     * Update the order of widgets on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PATCH_api_widget_order_\{section\}}
     */
    OrderWidgets(request: OrderWidgetsRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Get a list of widgets on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#GET_api_widgets}
     */
    GetWidgets(request: GetWidgetsRequest, metadata?: Metadata): Promise<GetWidgetsResponse>;
}

declare class WidgetsClientImpl implements Widgets {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_49, opts?: {
        service?: string;
    });
    AddButtonWidget(request: AddButtonWidgetRequest, metadata?: Metadata): Promise<ButtonWidget_2>;
    AddImageWidget(request: AddImageWidgetRequest, metadata?: Metadata): Promise<ImageWidget_2>;
    AddCalendarWidget(request: AddCalendarWidgetRequest, metadata?: Metadata): Promise<CalendarWidget_2>;
    AddTextAreaWidget(request: AddTextAreaWidgetRequest, metadata?: Metadata): Promise<TextAreaWidget_2>;
    AddCommunityListWidget(request: AddCommunityListWidgetRequest, metadata?: Metadata): Promise<CommunityListWidget_2>;
    AddPostFlairWidget(request: AddPostFlairWidgetRequest, metadata?: Metadata): Promise<PostFlairWidget_2>;
    AddCustomWidget(request: AddCustomWidgetRequest, metadata?: Metadata): Promise<CustomWidget_2>;
    DeleteWidget(request: DeleteWidgetRequest, metadata?: Metadata): Promise<Empty>;
    UpdateButtonWidget(request: UpdateButtonWidgetRequest, metadata?: Metadata): Promise<ButtonWidget_2>;
    UpdateImageWidget(request: UpdateImageWidgetRequest, metadata?: Metadata): Promise<ImageWidget_2>;
    UpdateCalendarWidget(request: UpdateCalendarWidgetRequest, metadata?: Metadata): Promise<CalendarWidget_2>;
    UpdateTextAreaWidget(request: UpdateTextAreaWidgetRequest, metadata?: Metadata): Promise<TextAreaWidget_2>;
    UpdateCommunityListWidget(request: UpdateCommunityListWidgetRequest, metadata?: Metadata): Promise<UpdateCommunityListWidgetResponse>;
    UpdatePostFlairWidget(request: UpdatePostFlairWidgetRequest, metadata?: Metadata): Promise<PostFlairWidget_2>;
    UpdateCustomWidget(request: UpdateCustomWidgetRequest, metadata?: Metadata): Promise<CustomWidget_2>;
    GetWidgetImageUploadLease(request: GetWidgetImageUploadLeaseRequest, metadata?: Metadata): Promise<GetWidgetImageUploadLeaseResponse>;
    OrderWidgets(request: OrderWidgetsRequest, metadata?: Metadata): Promise<Empty>;
    GetWidgets(request: GetWidgetsRequest, metadata?: Metadata): Promise<GetWidgetsResponse>;
}

/** WIDGETS - https://www.reddit.com/dev/api#section_widgets */
declare type WidgetsDefinition = typeof WidgetsDefinition;

declare const WidgetsDefinition: {
    readonly name: "Widgets";
    readonly fullName: "devvit.plugin.redditapi.widgets.Widgets";
    readonly methods: {
        /**
         * Add a button widget to a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
         */
        readonly addButtonWidget: {
            readonly name: "AddButtonWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.AddButtonWidgetRequest";
                encode(message: AddButtonWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AddButtonWidgetRequest;
                fromJSON(object: any): AddButtonWidgetRequest;
                toJSON(message: AddButtonWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    shortName?: string;
                    description?: string;
                    buttons?: {
                        kind?: string;
                        text?: string;
                        url?: string | undefined;
                        imageUrl?: string | undefined;
                        linkUrl?: string | undefined;
                        color?: string | undefined;
                        fillColor?: string | undefined;
                        textColor?: string | undefined;
                        height?: number | undefined;
                        width?: number | undefined;
                        hoverState?: {
                            kind?: string;
                            color?: string | undefined;
                            fillColor?: string | undefined;
                            text?: string | undefined;
                            textColor?: string | undefined;
                            imageUrl?: string | undefined;
                            height?: number | undefined;
                            width?: number | undefined;
                        } | undefined;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): AddButtonWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    shortName?: string;
                    description?: string;
                    buttons?: {
                        kind?: string;
                        text?: string;
                        url?: string | undefined;
                        imageUrl?: string | undefined;
                        linkUrl?: string | undefined;
                        color?: string | undefined;
                        fillColor?: string | undefined;
                        textColor?: string | undefined;
                        height?: number | undefined;
                        width?: number | undefined;
                        hoverState?: {
                            kind?: string;
                            color?: string | undefined;
                            fillColor?: string | undefined;
                            text?: string | undefined;
                            textColor?: string | undefined;
                            imageUrl?: string | undefined;
                            height?: number | undefined;
                            width?: number | undefined;
                        } | undefined;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): AddButtonWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.ButtonWidget";
                encode(message: ButtonWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ButtonWidget_2;
                fromJSON(object: any): ButtonWidget_2;
                toJSON(message: ButtonWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    description?: string;
                    buttons?: {
                        kind?: string;
                        text?: string;
                        url?: string | undefined;
                        imageUrl?: string | undefined;
                        linkUrl?: string | undefined;
                        color?: string | undefined;
                        fillColor?: string | undefined;
                        textColor?: string | undefined;
                        height?: number | undefined;
                        width?: number | undefined;
                        hoverState?: {
                            kind?: string;
                            color?: string | undefined;
                            fillColor?: string | undefined;
                            text?: string | undefined;
                            textColor?: string | undefined;
                            imageUrl?: string | undefined;
                            height?: number | undefined;
                            width?: number | undefined;
                        } | undefined;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): ButtonWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    description?: string;
                    buttons?: {
                        kind?: string;
                        text?: string;
                        url?: string | undefined;
                        imageUrl?: string | undefined;
                        linkUrl?: string | undefined;
                        color?: string | undefined;
                        fillColor?: string | undefined;
                        textColor?: string | undefined;
                        height?: number | undefined;
                        width?: number | undefined;
                        hoverState?: {
                            kind?: string;
                            color?: string | undefined;
                            fillColor?: string | undefined;
                            text?: string | undefined;
                            textColor?: string | undefined;
                            imageUrl?: string | undefined;
                            height?: number | undefined;
                            width?: number | undefined;
                        } | undefined;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): ButtonWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Add an image widget to a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
         */
        readonly addImageWidget: {
            readonly name: "AddImageWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.AddImageWidgetRequest";
                encode(message: AddImageWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AddImageWidgetRequest;
                fromJSON(object: any): AddImageWidgetRequest;
                toJSON(message: AddImageWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    data?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): AddImageWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    data?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): AddImageWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.ImageWidget";
                encode(message: ImageWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ImageWidget_2;
                fromJSON(object: any): ImageWidget_2;
                toJSON(message: ImageWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    data?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                    subreddit?: string | undefined;
                } | undefined): ImageWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    data?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                    subreddit?: string | undefined;
                }): ImageWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Add a calendar widget to a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
         */
        readonly addCalendarWidget: {
            readonly name: "AddCalendarWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.AddCalendarWidgetRequest";
                encode(message: AddCalendarWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AddCalendarWidgetRequest;
                fromJSON(object: any): AddCalendarWidgetRequest;
                toJSON(message: AddCalendarWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    configuration?: {
                        numEvents?: number;
                        showDate?: boolean;
                        showDescription?: boolean;
                        showLocation?: boolean;
                        showTime?: boolean;
                        showTitle?: boolean;
                    } | undefined;
                    googleCalendarId?: string;
                    requiresSync?: boolean;
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): AddCalendarWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    configuration?: {
                        numEvents?: number;
                        showDate?: boolean;
                        showDescription?: boolean;
                        showLocation?: boolean;
                        showTime?: boolean;
                        showTitle?: boolean;
                    } | undefined;
                    googleCalendarId?: string;
                    requiresSync?: boolean;
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): AddCalendarWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.CalendarWidget";
                encode(message: CalendarWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CalendarWidget_2;
                fromJSON(object: any): CalendarWidget_2;
                toJSON(message: CalendarWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    configuration?: {
                        numEvents?: number;
                        showDate?: boolean;
                        showDescription?: boolean;
                        showLocation?: boolean;
                        showTime?: boolean;
                        showTitle?: boolean;
                    } | undefined;
                    googleCalendarId?: string;
                    requiresSync?: boolean;
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): CalendarWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    configuration?: {
                        numEvents?: number;
                        showDate?: boolean;
                        showDescription?: boolean;
                        showLocation?: boolean;
                        showTime?: boolean;
                        showTitle?: boolean;
                    } | undefined;
                    googleCalendarId?: string;
                    requiresSync?: boolean;
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): CalendarWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Add a text widget to a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
         */
        readonly addTextAreaWidget: {
            readonly name: "AddTextAreaWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.AddTextAreaWidgetRequest";
                encode(message: AddTextAreaWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AddTextAreaWidgetRequest;
                fromJSON(object: any): AddTextAreaWidgetRequest;
                toJSON(message: AddTextAreaWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    shortName?: string;
                    text?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): AddTextAreaWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    shortName?: string;
                    text?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): AddTextAreaWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.TextAreaWidget";
                encode(message: TextAreaWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): TextAreaWidget_2;
                fromJSON(object: any): TextAreaWidget_2;
                toJSON(message: TextAreaWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    text?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): TextAreaWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    text?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): TextAreaWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Add a community list widget to a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
         */
        readonly addCommunityListWidget: {
            readonly name: "AddCommunityListWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.AddCommunityListWidgetRequest";
                encode(message: AddCommunityListWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AddCommunityListWidgetRequest;
                fromJSON(object: any): AddCommunityListWidgetRequest;
                toJSON(message: AddCommunityListWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    shortName?: string;
                    data?: string[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): AddCommunityListWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    shortName?: string;
                    data?: string[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): AddCommunityListWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.CommunityListWidget";
                encode(message: CommunityListWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CommunityListWidget_2;
                fromJSON(object: any): CommunityListWidget_2;
                toJSON(message: CommunityListWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    data?: {
                        communityIcon?: string;
                        iconUrl?: string;
                        isNsfw?: boolean;
                        isSubscribed?: boolean;
                        name?: string;
                        prefixedName?: string;
                        primaryColor?: string;
                        subscribers?: number;
                        type?: string;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): CommunityListWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    data?: {
                        communityIcon?: string;
                        iconUrl?: string;
                        isNsfw?: boolean;
                        isSubscribed?: boolean;
                        name?: string;
                        prefixedName?: string;
                        primaryColor?: string;
                        subscribers?: number;
                        type?: string;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): CommunityListWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Add a post flair widget to a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
         */
        readonly addPostFlairWidget: {
            readonly name: "AddPostFlairWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.AddPostFlairWidgetRequest";
                encode(message: AddPostFlairWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AddPostFlairWidgetRequest;
                fromJSON(object: any): AddPostFlairWidgetRequest;
                toJSON(message: AddPostFlairWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    display?: string;
                    order?: string[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): AddPostFlairWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    display?: string;
                    order?: string[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): AddPostFlairWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.PostFlairWidget";
                encode(message: PostFlairWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostFlairWidget_2;
                fromJSON(object: any): PostFlairWidget_2;
                toJSON(message: PostFlairWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    display?: string;
                    order?: string[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                    subreddit?: string | undefined;
                } | undefined): PostFlairWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    display?: string;
                    order?: string[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                    subreddit?: string | undefined;
                }): PostFlairWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Add a custom widget to a subreddit. This is an experimental feature.
         * Custom widgets don't display on mobile devices. Customizations can break at any time
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
         */
        readonly addCustomWidget: {
            readonly name: "AddCustomWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.AddCustomWidgetRequest";
                encode(message: AddCustomWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AddCustomWidgetRequest;
                fromJSON(object: any): AddCustomWidgetRequest;
                toJSON(message: AddCustomWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    shortName?: string;
                    text?: string;
                    height?: number;
                    css?: string;
                    imageData?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): AddCustomWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    shortName?: string;
                    text?: string;
                    height?: number;
                    css?: string;
                    imageData?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): AddCustomWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.CustomWidget";
                encode(message: CustomWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CustomWidget_2;
                fromJSON(object: any): CustomWidget_2;
                toJSON(message: CustomWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    text?: string;
                    height?: number;
                    css?: string;
                    imageData?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): CustomWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    text?: string;
                    height?: number;
                    css?: string;
                    imageData?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): CustomWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Delete a widget from a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#DELETE_api_widget_\{widget_id\}}
         */
        readonly deleteWidget: {
            readonly name: "DeleteWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.DeleteWidgetRequest";
                encode(message: DeleteWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DeleteWidgetRequest;
                fromJSON(object: any): DeleteWidgetRequest;
                toJSON(message: DeleteWidgetRequest): unknown;
                create(base?: {
                    id?: string;
                    subreddit?: string;
                } | undefined): DeleteWidgetRequest;
                fromPartial(object: {
                    id?: string;
                    subreddit?: string;
                }): DeleteWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Update a button widget on a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
         */
        readonly updateButtonWidget: {
            readonly name: "UpdateButtonWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.UpdateButtonWidgetRequest";
                encode(message: UpdateButtonWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateButtonWidgetRequest;
                fromJSON(object: any): UpdateButtonWidgetRequest;
                toJSON(message: UpdateButtonWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    id?: string;
                    shortName?: string;
                    description?: string;
                    buttons?: {
                        kind?: string;
                        text?: string;
                        url?: string | undefined;
                        imageUrl?: string | undefined;
                        linkUrl?: string | undefined;
                        color?: string | undefined;
                        fillColor?: string | undefined;
                        textColor?: string | undefined;
                        height?: number | undefined;
                        width?: number | undefined;
                        hoverState?: {
                            kind?: string;
                            color?: string | undefined;
                            fillColor?: string | undefined;
                            text?: string | undefined;
                            textColor?: string | undefined;
                            imageUrl?: string | undefined;
                            height?: number | undefined;
                            width?: number | undefined;
                        } | undefined;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): UpdateButtonWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    id?: string;
                    shortName?: string;
                    description?: string;
                    buttons?: {
                        kind?: string;
                        text?: string;
                        url?: string | undefined;
                        imageUrl?: string | undefined;
                        linkUrl?: string | undefined;
                        color?: string | undefined;
                        fillColor?: string | undefined;
                        textColor?: string | undefined;
                        height?: number | undefined;
                        width?: number | undefined;
                        hoverState?: {
                            kind?: string;
                            color?: string | undefined;
                            fillColor?: string | undefined;
                            text?: string | undefined;
                            textColor?: string | undefined;
                            imageUrl?: string | undefined;
                            height?: number | undefined;
                            width?: number | undefined;
                        } | undefined;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): UpdateButtonWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.ButtonWidget";
                encode(message: ButtonWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ButtonWidget_2;
                fromJSON(object: any): ButtonWidget_2;
                toJSON(message: ButtonWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    description?: string;
                    buttons?: {
                        kind?: string;
                        text?: string;
                        url?: string | undefined;
                        imageUrl?: string | undefined;
                        linkUrl?: string | undefined;
                        color?: string | undefined;
                        fillColor?: string | undefined;
                        textColor?: string | undefined;
                        height?: number | undefined;
                        width?: number | undefined;
                        hoverState?: {
                            kind?: string;
                            color?: string | undefined;
                            fillColor?: string | undefined;
                            text?: string | undefined;
                            textColor?: string | undefined;
                            imageUrl?: string | undefined;
                            height?: number | undefined;
                            width?: number | undefined;
                        } | undefined;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): ButtonWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    description?: string;
                    buttons?: {
                        kind?: string;
                        text?: string;
                        url?: string | undefined;
                        imageUrl?: string | undefined;
                        linkUrl?: string | undefined;
                        color?: string | undefined;
                        fillColor?: string | undefined;
                        textColor?: string | undefined;
                        height?: number | undefined;
                        width?: number | undefined;
                        hoverState?: {
                            kind?: string;
                            color?: string | undefined;
                            fillColor?: string | undefined;
                            text?: string | undefined;
                            textColor?: string | undefined;
                            imageUrl?: string | undefined;
                            height?: number | undefined;
                            width?: number | undefined;
                        } | undefined;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): ButtonWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Update an image widget on a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
         */
        readonly updateImageWidget: {
            readonly name: "UpdateImageWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.UpdateImageWidgetRequest";
                encode(message: UpdateImageWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateImageWidgetRequest;
                fromJSON(object: any): UpdateImageWidgetRequest;
                toJSON(message: UpdateImageWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    id?: string;
                    data?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): UpdateImageWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    id?: string;
                    data?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): UpdateImageWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.ImageWidget";
                encode(message: ImageWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ImageWidget_2;
                fromJSON(object: any): ImageWidget_2;
                toJSON(message: ImageWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    data?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                    subreddit?: string | undefined;
                } | undefined): ImageWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    data?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                    subreddit?: string | undefined;
                }): ImageWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Update a calendar widget on a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
         */
        readonly updateCalendarWidget: {
            readonly name: "UpdateCalendarWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.UpdateCalendarWidgetRequest";
                encode(message: UpdateCalendarWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateCalendarWidgetRequest;
                fromJSON(object: any): UpdateCalendarWidgetRequest;
                toJSON(message: UpdateCalendarWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    id?: string;
                    configuration?: {
                        numEvents?: number;
                        showDate?: boolean;
                        showDescription?: boolean;
                        showLocation?: boolean;
                        showTime?: boolean;
                        showTitle?: boolean;
                    } | undefined;
                    googleCalendarId?: string;
                    requiresSync?: boolean;
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): UpdateCalendarWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    id?: string;
                    configuration?: {
                        numEvents?: number;
                        showDate?: boolean;
                        showDescription?: boolean;
                        showLocation?: boolean;
                        showTime?: boolean;
                        showTitle?: boolean;
                    } | undefined;
                    googleCalendarId?: string;
                    requiresSync?: boolean;
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): UpdateCalendarWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.CalendarWidget";
                encode(message: CalendarWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CalendarWidget_2;
                fromJSON(object: any): CalendarWidget_2;
                toJSON(message: CalendarWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    configuration?: {
                        numEvents?: number;
                        showDate?: boolean;
                        showDescription?: boolean;
                        showLocation?: boolean;
                        showTime?: boolean;
                        showTitle?: boolean;
                    } | undefined;
                    googleCalendarId?: string;
                    requiresSync?: boolean;
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): CalendarWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    configuration?: {
                        numEvents?: number;
                        showDate?: boolean;
                        showDescription?: boolean;
                        showLocation?: boolean;
                        showTime?: boolean;
                        showTitle?: boolean;
                    } | undefined;
                    googleCalendarId?: string;
                    requiresSync?: boolean;
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): CalendarWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Update a text widget on a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
         */
        readonly updateTextAreaWidget: {
            readonly name: "UpdateTextAreaWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.UpdateTextAreaWidgetRequest";
                encode(message: UpdateTextAreaWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateTextAreaWidgetRequest;
                fromJSON(object: any): UpdateTextAreaWidgetRequest;
                toJSON(message: UpdateTextAreaWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    id?: string;
                    shortName?: string;
                    text?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): UpdateTextAreaWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    id?: string;
                    shortName?: string;
                    text?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): UpdateTextAreaWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.TextAreaWidget";
                encode(message: TextAreaWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): TextAreaWidget_2;
                fromJSON(object: any): TextAreaWidget_2;
                toJSON(message: TextAreaWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    text?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): TextAreaWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    text?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): TextAreaWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Update a community list widget on a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
         */
        readonly updateCommunityListWidget: {
            readonly name: "UpdateCommunityListWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetRequest";
                encode(message: UpdateCommunityListWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateCommunityListWidgetRequest;
                fromJSON(object: any): UpdateCommunityListWidgetRequest;
                toJSON(message: UpdateCommunityListWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    id?: string;
                    shortName?: string;
                    data?: string[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): UpdateCommunityListWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    id?: string;
                    shortName?: string;
                    data?: string[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): UpdateCommunityListWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetResponse";
                encode(message: UpdateCommunityListWidgetResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateCommunityListWidgetResponse;
                fromJSON(object: any): UpdateCommunityListWidgetResponse;
                toJSON(message: UpdateCommunityListWidgetResponse): unknown;
                create(base?: {
                    kind?: string;
                    shortName?: string;
                    data?: string[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): UpdateCommunityListWidgetResponse;
                fromPartial(object: {
                    kind?: string;
                    shortName?: string;
                    data?: string[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): UpdateCommunityListWidgetResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Update a post flair widget on a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
         */
        readonly updatePostFlairWidget: {
            readonly name: "UpdatePostFlairWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.UpdatePostFlairWidgetRequest";
                encode(message: UpdatePostFlairWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdatePostFlairWidgetRequest;
                fromJSON(object: any): UpdatePostFlairWidgetRequest;
                toJSON(message: UpdatePostFlairWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    id?: string;
                    display?: string;
                    order?: string[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): UpdatePostFlairWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    id?: string;
                    display?: string;
                    order?: string[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): UpdatePostFlairWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.PostFlairWidget";
                encode(message: PostFlairWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PostFlairWidget_2;
                fromJSON(object: any): PostFlairWidget_2;
                toJSON(message: PostFlairWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    display?: string;
                    order?: string[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                    subreddit?: string | undefined;
                } | undefined): PostFlairWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    display?: string;
                    order?: string[];
                    shortName?: string;
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                    subreddit?: string | undefined;
                }): PostFlairWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Update a custom widget on a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
         */
        readonly updateCustomWidget: {
            readonly name: "UpdateCustomWidget";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.UpdateCustomWidgetRequest";
                encode(message: UpdateCustomWidgetRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateCustomWidgetRequest;
                fromJSON(object: any): UpdateCustomWidgetRequest;
                toJSON(message: UpdateCustomWidgetRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    id?: string;
                    shortName?: string;
                    text?: string;
                    height?: number;
                    css?: string;
                    imageData?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): UpdateCustomWidgetRequest;
                fromPartial(object: {
                    subreddit?: string;
                    id?: string;
                    shortName?: string;
                    text?: string;
                    height?: number;
                    css?: string;
                    imageData?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): UpdateCustomWidgetRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.CustomWidget";
                encode(message: CustomWidget_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): CustomWidget_2;
                fromJSON(object: any): CustomWidget_2;
                toJSON(message: CustomWidget_2): unknown;
                create(base?: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    text?: string;
                    height?: number;
                    css?: string;
                    imageData?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                } | undefined): CustomWidget_2;
                fromPartial(object: {
                    id?: string;
                    kind?: string;
                    shortName?: string;
                    text?: string;
                    height?: number;
                    css?: string;
                    imageData?: {
                        url?: string;
                        linkUrl?: string;
                        height?: number;
                        width?: number;
                    }[];
                    styles?: {
                        backgroundColor?: string | undefined;
                        headerColor?: string | undefined;
                    } | undefined;
                }): CustomWidget_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Get an S3 upload lease for a widget image. This is used to upload images for image widgets.
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_widget_image_upload_s3}
         */
        readonly getWidgetImageUploadLease: {
            readonly name: "GetWidgetImageUploadLease";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseRequest";
                encode(message: GetWidgetImageUploadLeaseRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWidgetImageUploadLeaseRequest;
                fromJSON(object: any): GetWidgetImageUploadLeaseRequest;
                toJSON(message: GetWidgetImageUploadLeaseRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    filepath?: string;
                    mimetype?: string;
                } | undefined): GetWidgetImageUploadLeaseRequest;
                fromPartial(object: {
                    subreddit?: string;
                    filepath?: string;
                    mimetype?: string;
                }): GetWidgetImageUploadLeaseRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse";
                encode(message: GetWidgetImageUploadLeaseResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWidgetImageUploadLeaseResponse;
                fromJSON(object: any): GetWidgetImageUploadLeaseResponse;
                toJSON(message: GetWidgetImageUploadLeaseResponse): unknown;
                create(base?: {
                    s3UploadLease?: {
                        action?: string;
                        fields?: {
                            name?: string;
                            value?: string;
                        }[];
                    } | undefined;
                    websocketUrl?: string;
                } | undefined): GetWidgetImageUploadLeaseResponse;
                fromPartial(object: {
                    s3UploadLease?: {
                        action?: string;
                        fields?: {
                            name?: string;
                            value?: string;
                        }[];
                    } | undefined;
                    websocketUrl?: string;
                }): GetWidgetImageUploadLeaseResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Update the order of widgets on a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#PATCH_api_widget_order_\{section\}}
         */
        readonly orderWidgets: {
            readonly name: "OrderWidgets";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.OrderWidgetsRequest";
                encode(message: OrderWidgetsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): OrderWidgetsRequest;
                fromJSON(object: any): OrderWidgetsRequest;
                toJSON(message: OrderWidgetsRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    order?: string[];
                } | undefined): OrderWidgetsRequest;
                fromPartial(object: {
                    subreddit?: string;
                    order?: string[];
                }): OrderWidgetsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Get a list of widgets on a subreddit.
         *
         * @see {@link https://www.reddit.com/dev/api#GET_api_widgets}
         */
        readonly getWidgets: {
            readonly name: "GetWidgets";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.widgets.GetWidgetsRequest";
                encode(message: GetWidgetsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWidgetsRequest;
                fromJSON(object: any): GetWidgetsRequest;
                toJSON(message: GetWidgetsRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    progressiveImages?: boolean | undefined;
                } | undefined): GetWidgetsRequest;
                fromPartial(object: {
                    subreddit?: string;
                    progressiveImages?: boolean | undefined;
                }): GetWidgetsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse";
                encode(message: GetWidgetsResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWidgetsResponse;
                fromJSON(object: any): GetWidgetsResponse;
                toJSON(message: GetWidgetsResponse): unknown;
                create(base?: {
                    layout?: {
                        idCardWidget?: string;
                        topbar?: {
                            order?: string[];
                        } | undefined;
                        sidebar?: {
                            order?: string[];
                        } | undefined;
                        moderatorWidget?: string;
                    } | undefined;
                    items?: {
                        [x: string]: {
                            id?: string;
                            kind?: string;
                            styles?: {
                                backgroundColor?: string | undefined;
                                headerColor?: string | undefined;
                            } | undefined;
                            shortName?: string;
                            description?: string | undefined;
                            data?: {
                                url?: string | undefined;
                                linkUrl?: string | undefined;
                                height?: number | undefined;
                                width?: number | undefined;
                                iconUrl?: string | undefined;
                                name?: string | undefined;
                                prefixedName?: string | undefined;
                                isSubscribed?: boolean | undefined;
                                type?: string | undefined;
                                subscribers?: number | undefined;
                                communityIcon?: string | undefined;
                                isNsfw?: boolean | undefined;
                                text?: string | undefined;
                                children?: {
                                    text?: string | undefined;
                                    url?: string | undefined;
                                    children?: any[];
                                }[];
                            }[];
                            buttons?: {
                                kind?: string;
                                text?: string;
                                url?: string | undefined;
                                imageUrl?: string | undefined;
                                linkUrl?: string | undefined;
                                color?: string | undefined;
                                fillColor?: string | undefined;
                                textColor?: string | undefined;
                                height?: number | undefined;
                                width?: number | undefined;
                                hoverState?: {
                                    kind?: string;
                                    color?: string | undefined;
                                    fillColor?: string | undefined;
                                    text?: string | undefined;
                                    textColor?: string | undefined;
                                    imageUrl?: string | undefined;
                                    height?: number | undefined;
                                    width?: number | undefined;
                                } | undefined;
                            }[];
                            subscribersCount?: number | undefined;
                            currentlyViewingText?: string | undefined;
                            currentlyViewingCount?: number | undefined;
                            subscribersText?: string | undefined;
                            showWiki?: boolean | undefined;
                            templates?: {
                                [x: string]: {
                                    text?: string;
                                    richtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    backgroundColor?: string;
                                    templateId?: string;
                                    textColor?: string;
                                    type?: string;
                                } | undefined;
                            };
                            display?: string | undefined;
                            order?: string[];
                            mods?: {
                                name?: string;
                                authorFlairType?: string;
                                authorFlairTextColor?: string;
                                authorFlairBackgroundColor?: string;
                                authorFalirText?: string;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                }[];
                            }[];
                            totalMods?: number | undefined;
                            googleCalendarId?: string | undefined;
                            requiresSync?: boolean | undefined;
                            configuration?: {
                                numEvents?: number;
                                showDate?: boolean;
                                showDescription?: boolean;
                                showLocation?: boolean;
                                showTime?: boolean;
                                showTitle?: boolean;
                            } | undefined;
                            text?: string | undefined;
                            css?: string | undefined;
                            stylesheetUrl?: string | undefined;
                            height?: number | undefined;
                            imageData?: {
                                url?: string;
                                linkUrl?: string;
                                height?: number;
                                width?: number;
                            }[];
                        } | undefined;
                    };
                } | undefined): GetWidgetsResponse;
                fromPartial(object: {
                    layout?: {
                        idCardWidget?: string;
                        topbar?: {
                            order?: string[];
                        } | undefined;
                        sidebar?: {
                            order?: string[];
                        } | undefined;
                        moderatorWidget?: string;
                    } | undefined;
                    items?: {
                        [x: string]: {
                            id?: string;
                            kind?: string;
                            styles?: {
                                backgroundColor?: string | undefined;
                                headerColor?: string | undefined;
                            } | undefined;
                            shortName?: string;
                            description?: string | undefined;
                            data?: {
                                url?: string | undefined;
                                linkUrl?: string | undefined;
                                height?: number | undefined;
                                width?: number | undefined;
                                iconUrl?: string | undefined;
                                name?: string | undefined;
                                prefixedName?: string | undefined;
                                isSubscribed?: boolean | undefined;
                                type?: string | undefined;
                                subscribers?: number | undefined;
                                communityIcon?: string | undefined;
                                isNsfw?: boolean | undefined;
                                text?: string | undefined;
                                children?: {
                                    text?: string | undefined;
                                    url?: string | undefined;
                                    children?: any[];
                                }[];
                            }[];
                            buttons?: {
                                kind?: string;
                                text?: string;
                                url?: string | undefined;
                                imageUrl?: string | undefined;
                                linkUrl?: string | undefined;
                                color?: string | undefined;
                                fillColor?: string | undefined;
                                textColor?: string | undefined;
                                height?: number | undefined;
                                width?: number | undefined;
                                hoverState?: {
                                    kind?: string;
                                    color?: string | undefined;
                                    fillColor?: string | undefined;
                                    text?: string | undefined;
                                    textColor?: string | undefined;
                                    imageUrl?: string | undefined;
                                    height?: number | undefined;
                                    width?: number | undefined;
                                } | undefined;
                            }[];
                            subscribersCount?: number | undefined;
                            currentlyViewingText?: string | undefined;
                            currentlyViewingCount?: number | undefined;
                            subscribersText?: string | undefined;
                            showWiki?: boolean | undefined;
                            templates?: {
                                [x: string]: {
                                    text?: string;
                                    richtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    backgroundColor?: string;
                                    templateId?: string;
                                    textColor?: string;
                                    type?: string;
                                } | undefined;
                            };
                            display?: string | undefined;
                            order?: string[];
                            mods?: {
                                name?: string;
                                authorFlairType?: string;
                                authorFlairTextColor?: string;
                                authorFlairBackgroundColor?: string;
                                authorFalirText?: string;
                                authorFlairRichtext?: {
                                    e?: string | undefined;
                                    t?: string | undefined;
                                }[];
                            }[];
                            totalMods?: number | undefined;
                            googleCalendarId?: string | undefined;
                            requiresSync?: boolean | undefined;
                            configuration?: {
                                numEvents?: number;
                                showDate?: boolean;
                                showDescription?: boolean;
                                showLocation?: boolean;
                                showTime?: boolean;
                                showTitle?: boolean;
                            } | undefined;
                            text?: string | undefined;
                            css?: string | undefined;
                            stylesheetUrl?: string | undefined;
                            height?: number | undefined;
                            imageData?: {
                                url?: string;
                                linkUrl?: string;
                                height?: number;
                                width?: number;
                            }[];
                        } | undefined;
                    };
                }): GetWidgetsResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
    };
};

declare const WidgetsServiceName = "devvit.plugin.redditapi.widgets.Widgets";

declare interface WidgetStyles {
    backgroundColor?: string | undefined;
    headerColor?: string | undefined;
}

declare const WidgetStyles: {
    $type: "devvit.plugin.redditapi.widgets.WidgetStyles";
    encode(message: WidgetStyles, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WidgetStyles;
    fromJSON(object: any): WidgetStyles;
    toJSON(message: WidgetStyles): unknown;
    create(base?: DeepPartial_4<WidgetStyles>): WidgetStyles;
    fromPartial(object: DeepPartial_4<WidgetStyles>): WidgetStyles;
};

/** WIKI - https://www.reddit.com/dev/api#section_wiki */
declare interface Wiki {
    /**
     * Get a list of wiki pages for a subreddit
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_pages}
     */
    GetWikiPages(request: GetWikiPagesRequest, metadata?: Metadata): Promise<GetWikiPagesResponse>;
    /**
     * Get a wiki page
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_\{page\}}
     */
    GetWikiPage(request: GetWikiPageRequest, metadata?: Metadata): Promise<GetWikiPageResponse>;
    /**
     * Edit wiki page
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_edit}
     */
    EditWikiPage(request: EditWikiPageRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Hide a wiki page revision
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_hide}
     */
    HideWikiPageRevision(request: HideWikiPageRevisionRequest, metadata?: Metadata): Promise<HideWikiPageRevisionResponse>;
    /**
     * Get a list of revisions of a wiki page
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_revisions_\{page\}}
     */
    GetWikiPageRevisions(request: GetWikiPageRevisionsRequest, metadata?: Metadata): Promise<WikiPageRevisionListing>;
    /**
     * Retrieve a list of recently changed wiki pages in this subreddit
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_revisions}
     */
    GetWikiRevisions(request: GetWikiRevisionsRequest, metadata?: Metadata): Promise<WikiPageRevisionListing>;
    /**
     * Revert a wiki page to revision
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_revert}
     */
    RevertWikiPage(request: RevertWikiPageRequest, metadata?: Metadata): Promise<Empty>;
    /**
     * Retrieve the current permission settings for page
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_settings_\{page\}}
     */
    GetWikiPageSettings(request: GetWikiPageSettingsRequest, metadata?: Metadata): Promise<WikiPageSettings_2>;
    /**
     * Update the permissions and visibility of wiki page
     *
     * @see {@link https://www.reddit.com/dev/api#POST_wiki_settings_\{page\}}
     */
    UpdateWikiPageSettings(request: UpdateWikiPageSettingsRequest, metadata?: Metadata): Promise<WikiPageSettings_2>;
    /**
     * Allow/deny username to edit this wiki page
     * Note act must be either "add" or "del"
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_alloweditor_\{act\}}
     */
    AllowEditor(request: AllowEditorRequest, metadata?: Metadata): Promise<Empty>;
}

declare class WikiClientImpl implements Wiki {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_48, opts?: {
        service?: string;
    });
    GetWikiPages(request: GetWikiPagesRequest, metadata?: Metadata): Promise<GetWikiPagesResponse>;
    GetWikiPage(request: GetWikiPageRequest, metadata?: Metadata): Promise<GetWikiPageResponse>;
    EditWikiPage(request: EditWikiPageRequest, metadata?: Metadata): Promise<Empty>;
    HideWikiPageRevision(request: HideWikiPageRevisionRequest, metadata?: Metadata): Promise<HideWikiPageRevisionResponse>;
    GetWikiPageRevisions(request: GetWikiPageRevisionsRequest, metadata?: Metadata): Promise<WikiPageRevisionListing>;
    GetWikiRevisions(request: GetWikiRevisionsRequest, metadata?: Metadata): Promise<WikiPageRevisionListing>;
    RevertWikiPage(request: RevertWikiPageRequest, metadata?: Metadata): Promise<Empty>;
    GetWikiPageSettings(request: GetWikiPageSettingsRequest, metadata?: Metadata): Promise<WikiPageSettings_2>;
    UpdateWikiPageSettings(request: UpdateWikiPageSettingsRequest, metadata?: Metadata): Promise<WikiPageSettings_2>;
    AllowEditor(request: AllowEditorRequest, metadata?: Metadata): Promise<Empty>;
}

/** WIKI - https://www.reddit.com/dev/api#section_wiki */
declare type WikiDefinition = typeof WikiDefinition;

declare const WikiDefinition: {
    readonly name: "Wiki";
    readonly fullName: "devvit.plugin.redditapi.wiki.Wiki";
    readonly methods: {
        /**
         * Get a list of wiki pages for a subreddit
         *
         * @see {@link https://www.reddit.com/dev/api#GET_wiki_pages}
         */
        readonly getWikiPages: {
            readonly name: "GetWikiPages";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.GetWikiPagesRequest";
                encode(message: GetWikiPagesRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWikiPagesRequest;
                fromJSON(object: any): GetWikiPagesRequest;
                toJSON(message: GetWikiPagesRequest): unknown;
                create(base?: {
                    subreddit?: string;
                } | undefined): GetWikiPagesRequest;
                fromPartial(object: {
                    subreddit?: string;
                }): GetWikiPagesRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.wiki.GetWikiPagesResponse";
                encode(message: GetWikiPagesResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWikiPagesResponse;
                fromJSON(object: any): GetWikiPagesResponse;
                toJSON(message: GetWikiPagesResponse): unknown;
                create(base?: {
                    kind?: string;
                    data?: string[];
                } | undefined): GetWikiPagesResponse;
                fromPartial(object: {
                    kind?: string;
                    data?: string[];
                }): GetWikiPagesResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Get a wiki page
         *
         * @see {@link https://www.reddit.com/dev/api#GET_wiki_\{page\}}
         */
        readonly getWikiPage: {
            readonly name: "GetWikiPage";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.GetWikiPageRequest";
                encode(message: GetWikiPageRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWikiPageRequest;
                fromJSON(object: any): GetWikiPageRequest;
                toJSON(message: GetWikiPageRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    page?: string;
                } | undefined): GetWikiPageRequest;
                fromPartial(object: {
                    subreddit?: string;
                    page?: string;
                }): GetWikiPageRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.wiki.GetWikiPageResponse";
                encode(message: GetWikiPageResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWikiPageResponse;
                /**
                 * Retrieve the current permission settings for page
                 *
                 * @see {@link https://www.reddit.com/dev/api#GET_wiki_settings_\{page\}}
                 */
                fromJSON(object: any): GetWikiPageResponse;
                toJSON(message: GetWikiPageResponse): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        contentMd?: string;
                        contentHtml?: string;
                        revisionId?: string;
                        revisionDate?: number;
                        mayRevise?: boolean;
                        reason?: string | undefined;
                        revisionBy?: {
                            id?: string | undefined;
                            data?: {
                                acceptChats?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                                awardeeKarma?: number | undefined;
                                awarderKarma?: number | undefined;
                                canCreateSubreddit?: boolean | undefined;
                                canEditName?: boolean | undefined;
                                coins?: number | undefined;
                                commentKarma?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                features?: {
                                    awardsOnStreams?: boolean | undefined;
                                    canMakeMobileTestBuildPurchases?: boolean | undefined;
                                    chatGroupRollout?: boolean | undefined;
                                    chatSubreddit?: boolean | undefined;
                                    chatUserSettings?: boolean | undefined;
                                    chat?: boolean | undefined;
                                    cookieConsentBanner?: boolean | undefined;
                                    crosspostNotif?: boolean | undefined;
                                    crowdControlForPost?: boolean | undefined;
                                    customFeedImage?: boolean | undefined;
                                    doNotTrack?: boolean | undefined;
                                    expensiveCoinsPackage?: boolean | undefined;
                                    isEmailPermissionRequired?: boolean | undefined;
                                    liveComments?: boolean | undefined;
                                    liveOrangereds?: boolean | undefined;
                                    modAwards?: boolean | undefined;
                                    modServiceMuteReads?: boolean | undefined;
                                    modServiceMuteWrites?: boolean | undefined;
                                    modlogCopyrightRemoval?: boolean | undefined;
                                    mwebNsfwXpromo?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                    mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                    mwebXpromoRevampV2?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoRevampV3?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    noreferrerToNoopener?: boolean | undefined;
                                    pollsMobile?: boolean | undefined;
                                    premiumSubscriptionsTable?: boolean | undefined;
                                    promotedTrendBlanks?: boolean | undefined;
                                    resizedStylesImages?: boolean | undefined;
                                    showAmpLink?: boolean | undefined;
                                    showNpsSurvey?: boolean | undefined;
                                    spezModal?: boolean | undefined;
                                    usePrefAccountDeployment?: boolean | undefined;
                                    userFlairMigrationTesting?: boolean | undefined;
                                    webhookConfig?: boolean | undefined;
                                } | undefined;
                                forcePasswordReset?: boolean | undefined;
                                goldCreddits?: number | undefined;
                                goldExpiration?: string | undefined;
                                hasAndroidSubscription?: boolean | undefined;
                                hasExternalAccount?: boolean | undefined;
                                hasGoldSubscription?: boolean | undefined;
                                hasIosSubscription?: boolean | undefined;
                                hasMail?: boolean | undefined;
                                hasModMail?: boolean | undefined;
                                hasPaypalSubscription?: boolean | undefined;
                                hasStripeSubscription?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                hasSubscribedToPremium?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                hasVisitedNewProfile?: boolean | undefined;
                                hideFromRobots?: boolean | undefined;
                                iconImg?: string | undefined;
                                id?: string | undefined;
                                inBeta?: boolean | undefined;
                                inChat?: boolean | undefined;
                                inRedesignBeta?: boolean | undefined;
                                inboxCount?: number | undefined;
                                isBlocked?: boolean | undefined;
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                isSponsor?: boolean | undefined;
                                isSuspended?: boolean | undefined;
                                linkKarma?: number | undefined;
                                modhash?: string | undefined;
                                name?: string | undefined;
                                newModmailExists?: boolean | undefined;
                                numFriends?: number | undefined;
                                over18?: boolean | undefined;
                                passwordSet?: boolean | undefined;
                                prefAutoplay?: boolean | undefined;
                                prefClickgadget?: number | undefined;
                                prefGeopopular?: string | undefined;
                                prefNightmode?: boolean | undefined;
                                prefNoProfanity?: boolean | undefined;
                                prefShowPresence?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                prefShowTrending?: boolean | undefined;
                                prefShowTwitter?: boolean | undefined;
                                prefTopKarmaSubreddits?: boolean | undefined;
                                prefVideoAutoplay?: boolean | undefined;
                                snoovatarImg?: string | undefined;
                                snoovatarSize?: number[];
                                subreddit?: {
                                    acceptFollowers?: boolean | undefined;
                                    accountsActiveIsFuzzed?: boolean | undefined;
                                    accountsActive?: number | undefined;
                                    activeUserCount?: number | undefined;
                                    advertiserCategory?: string | undefined;
                                    allOriginalContent?: boolean | undefined;
                                    allowChatPostCreation?: boolean | undefined;
                                    allowDiscovery?: boolean | undefined;
                                    allowGalleries?: boolean | undefined;
                                    allowImages?: boolean | undefined;
                                    allowPolls?: boolean | undefined;
                                    allowPredictionContributors?: boolean | undefined;
                                    allowPredictionsTournament?: boolean | undefined;
                                    allowPredictions?: boolean | undefined;
                                    allowTalks?: boolean | undefined;
                                    allowVideogifs?: boolean | undefined;
                                    allowVideos?: boolean | undefined;
                                    allowedMediaInComments?: string[];
                                    bannerBackgroundColor?: string | undefined;
                                    bannerBackgroundImage?: string | undefined;
                                    bannerImg?: string | undefined;
                                    bannerSize?: number[];
                                    canAssignLinkFlair?: boolean | undefined;
                                    canAssignUserFlair?: boolean | undefined;
                                    coins?: number | undefined;
                                    collapseDeletedComments?: boolean | undefined;
                                    commentContributionSettings?: {
                                        allowedMediaTypes?: string[];
                                    } | undefined;
                                    commentScoreHideMins?: number | undefined;
                                    communityIcon?: string | undefined;
                                    communityReviewed?: boolean | undefined;
                                    contentCategory?: string | undefined;
                                    createdUtc?: number | undefined;
                                    created?: number | undefined;
                                    defaultSet?: boolean | undefined;
                                    description?: string | undefined;
                                    descriptionHtml?: string | undefined;
                                    disableContributorRequests?: boolean | undefined;
                                    displayName?: string | undefined;
                                    displayNamePrefixed?: string | undefined;
                                    emojisCustomSize?: number[];
                                    emojisEnabled?: boolean | undefined;
                                    freeFormReports?: boolean | undefined;
                                    hasMenuWidget?: boolean | undefined;
                                    headerImg?: string | undefined;
                                    headerSize?: number[];
                                    headerTitle?: string | undefined;
                                    hideAds?: boolean | undefined;
                                    iconColor?: string | undefined;
                                    iconImg?: string | undefined;
                                    iconSize?: number[];
                                    id?: string | undefined;
                                    isChatPostFeatureEnabled?: boolean | undefined;
                                    isCrosspostableSubreddit?: boolean | undefined;
                                    isDefaultBanner?: boolean | undefined;
                                    isDefaultIcon?: boolean | undefined;
                                    isEnrolledInNewModmail?: boolean | undefined;
                                    keyColor?: string | undefined;
                                    lang?: string | undefined;
                                    linkFlairEnabled?: boolean | undefined;
                                    linkFlairPosition?: string | undefined;
                                    mobileBannerImage?: string | undefined;
                                    name?: string | undefined;
                                    notificationLevel?: string | undefined;
                                    originalContentTagEnabled?: string | undefined;
                                    over18?: boolean | undefined;
                                    predictionLeaderboardEntryType?: string | undefined;
                                    previousNames?: string[];
                                    primaryColor?: string | undefined;
                                    publicDescription?: string | undefined;
                                    publicDescriptionHtml?: string | undefined;
                                    publicTraffic?: boolean | undefined;
                                    quarantine?: boolean | undefined;
                                    restrictCommenting?: boolean | undefined;
                                    restrictPosting?: boolean | undefined;
                                    shouldArchivePosts?: boolean | undefined;
                                    shouldShowMediaInCommentsSetting?: boolean | undefined;
                                    showMedia?: boolean | undefined;
                                    showMediaPreview?: boolean | undefined;
                                    spoilersEnabled?: boolean | undefined;
                                    submissionType?: string | undefined;
                                    submitLinkLabel?: string | undefined;
                                    submitText?: string | undefined;
                                    submitTextHtml?: string | undefined;
                                    submitTextLabel?: string | undefined;
                                    subredditType?: string | undefined;
                                    subscribers?: number | undefined;
                                    suggestedCommentSort?: string | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    userCanFlairInSr?: boolean | undefined;
                                    userFlairBackgroundColor?: string | undefined;
                                    userFlairCssClass?: string | undefined;
                                    userFlairEnabledInSr?: boolean | undefined;
                                    userFlairPosition?: string | undefined;
                                    userFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    userFlairTemplateId?: string | undefined;
                                    userFlairText?: string | undefined;
                                    userFlairTextColor?: string | undefined;
                                    userFlairType?: string | undefined;
                                    userHasFavorited?: boolean | undefined;
                                    userIsBanned?: boolean | undefined;
                                    userIsContributor?: boolean | undefined;
                                    userIsModerator?: boolean | undefined;
                                    userIsSubscriber?: boolean | undefined;
                                    userSrFlairEnabled?: boolean | undefined;
                                    userSrThemeEnabled?: boolean | undefined;
                                    videostreamLinksCount?: number | undefined;
                                    whitelistStatus?: string | undefined;
                                    wikiEnabled?: boolean | undefined;
                                    wls?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    postRequirements?: {
                                        bodyRestrictionPolicy?: string | undefined;
                                    } | undefined;
                                    userIsMuted?: boolean;
                                } | undefined;
                                suspensionExpirationUtc?: string | undefined;
                                totalKarma?: number | undefined;
                                verified?: boolean | undefined;
                                hasPhoneNumber?: boolean | undefined;
                                subredditsModerated?: number | undefined;
                                hasMetaSubscription?: boolean | undefined;
                                metaSubscriptionAge?: number | undefined;
                                metaPointsBalance?: string | undefined;
                                metaLockedPointsBalance?: string | undefined;
                                commentSubredditKarma?: number | undefined;
                                postSubredditKarma?: number | undefined;
                                markedSpam?: boolean | undefined;
                                isSubredditProxyAccount?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    } | undefined;
                } | undefined): GetWikiPageResponse;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        contentMd?: string;
                        contentHtml?: string;
                        revisionId?: string;
                        revisionDate?: number;
                        mayRevise?: boolean;
                        reason?: string | undefined;
                        revisionBy?: {
                            id?: string | undefined;
                            data?: {
                                acceptChats?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                                awardeeKarma?: number | undefined;
                                awarderKarma?: number | undefined;
                                canCreateSubreddit?: boolean | undefined;
                                canEditName?: boolean | undefined;
                                coins?: number | undefined;
                                commentKarma?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                features?: {
                                    awardsOnStreams?: boolean | undefined;
                                    canMakeMobileTestBuildPurchases?: boolean | undefined;
                                    chatGroupRollout?: boolean | undefined;
                                    chatSubreddit?: boolean | undefined;
                                    chatUserSettings?: boolean | undefined;
                                    chat?: boolean | undefined;
                                    cookieConsentBanner?: boolean | undefined;
                                    crosspostNotif?: boolean | undefined;
                                    crowdControlForPost?: boolean | undefined;
                                    customFeedImage?: boolean | undefined;
                                    doNotTrack?: boolean | undefined;
                                    expensiveCoinsPackage?: boolean | undefined;
                                    isEmailPermissionRequired?: boolean | undefined;
                                    liveComments?: boolean | undefined;
                                    liveOrangereds?: boolean | undefined;
                                    modAwards?: boolean | undefined;
                                    modServiceMuteReads?: boolean | undefined;
                                    modServiceMuteWrites?: boolean | undefined;
                                    modlogCopyrightRemoval?: boolean | undefined;
                                    mwebNsfwXpromo?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                    mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                    mwebXpromoRevampV2?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoRevampV3?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    noreferrerToNoopener?: boolean | undefined;
                                    pollsMobile?: boolean | undefined;
                                    premiumSubscriptionsTable?: boolean | undefined;
                                    promotedTrendBlanks?: boolean | undefined;
                                    resizedStylesImages?: boolean | undefined;
                                    showAmpLink?: boolean | undefined;
                                    showNpsSurvey?: boolean | undefined;
                                    spezModal?: boolean | undefined;
                                    usePrefAccountDeployment?: boolean | undefined;
                                    userFlairMigrationTesting?: boolean | undefined;
                                    webhookConfig?: boolean | undefined;
                                } | undefined;
                                forcePasswordReset?: boolean | undefined;
                                goldCreddits?: number | undefined;
                                goldExpiration?: string | undefined;
                                hasAndroidSubscription?: boolean | undefined;
                                hasExternalAccount?: boolean | undefined;
                                hasGoldSubscription?: boolean | undefined;
                                hasIosSubscription?: boolean | undefined;
                                hasMail?: boolean | undefined;
                                hasModMail?: boolean | undefined;
                                hasPaypalSubscription?: boolean | undefined;
                                hasStripeSubscription?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                hasSubscribedToPremium?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                hasVisitedNewProfile?: boolean | undefined;
                                hideFromRobots?: boolean | undefined;
                                iconImg?: string | undefined;
                                id?: string | undefined;
                                inBeta?: boolean | undefined;
                                inChat?: boolean | undefined;
                                inRedesignBeta?: boolean | undefined;
                                inboxCount?: number | undefined;
                                isBlocked?: boolean | undefined;
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                isSponsor?: boolean | undefined;
                                isSuspended?: boolean | undefined;
                                linkKarma?: number | undefined;
                                modhash?: string | undefined;
                                name?: string | undefined;
                                newModmailExists?: boolean | undefined;
                                numFriends?: number | undefined;
                                over18?: boolean | undefined;
                                passwordSet?: boolean | undefined;
                                prefAutoplay?: boolean | undefined;
                                prefClickgadget?: number | undefined;
                                prefGeopopular?: string | undefined;
                                prefNightmode?: boolean | undefined;
                                prefNoProfanity?: boolean | undefined;
                                prefShowPresence?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                prefShowTrending?: boolean | undefined;
                                prefShowTwitter?: boolean | undefined;
                                prefTopKarmaSubreddits?: boolean | undefined;
                                prefVideoAutoplay?: boolean | undefined;
                                snoovatarImg?: string | undefined;
                                snoovatarSize?: number[];
                                subreddit?: {
                                    acceptFollowers?: boolean | undefined;
                                    accountsActiveIsFuzzed?: boolean | undefined;
                                    accountsActive?: number | undefined;
                                    activeUserCount?: number | undefined;
                                    advertiserCategory?: string | undefined;
                                    allOriginalContent?: boolean | undefined;
                                    allowChatPostCreation?: boolean | undefined;
                                    allowDiscovery?: boolean | undefined;
                                    allowGalleries?: boolean | undefined;
                                    allowImages?: boolean | undefined;
                                    allowPolls?: boolean | undefined;
                                    allowPredictionContributors?: boolean | undefined;
                                    allowPredictionsTournament?: boolean | undefined;
                                    allowPredictions?: boolean | undefined;
                                    allowTalks?: boolean | undefined;
                                    allowVideogifs?: boolean | undefined;
                                    allowVideos?: boolean | undefined;
                                    allowedMediaInComments?: string[];
                                    bannerBackgroundColor?: string | undefined;
                                    bannerBackgroundImage?: string | undefined;
                                    bannerImg?: string | undefined;
                                    bannerSize?: number[];
                                    canAssignLinkFlair?: boolean | undefined;
                                    canAssignUserFlair?: boolean | undefined;
                                    coins?: number | undefined;
                                    collapseDeletedComments?: boolean | undefined;
                                    commentContributionSettings?: {
                                        allowedMediaTypes?: string[];
                                    } | undefined;
                                    commentScoreHideMins?: number | undefined;
                                    communityIcon?: string | undefined;
                                    communityReviewed?: boolean | undefined;
                                    contentCategory?: string | undefined;
                                    createdUtc?: number | undefined;
                                    created?: number | undefined;
                                    defaultSet?: boolean | undefined;
                                    description?: string | undefined;
                                    descriptionHtml?: string | undefined;
                                    disableContributorRequests?: boolean | undefined;
                                    displayName?: string | undefined;
                                    displayNamePrefixed?: string | undefined;
                                    emojisCustomSize?: number[];
                                    emojisEnabled?: boolean | undefined;
                                    freeFormReports?: boolean | undefined;
                                    hasMenuWidget?: boolean | undefined;
                                    headerImg?: string | undefined;
                                    headerSize?: number[];
                                    headerTitle?: string | undefined;
                                    hideAds?: boolean | undefined;
                                    iconColor?: string | undefined;
                                    iconImg?: string | undefined;
                                    iconSize?: number[];
                                    id?: string | undefined;
                                    isChatPostFeatureEnabled?: boolean | undefined;
                                    isCrosspostableSubreddit?: boolean | undefined;
                                    isDefaultBanner?: boolean | undefined;
                                    isDefaultIcon?: boolean | undefined;
                                    isEnrolledInNewModmail?: boolean | undefined;
                                    keyColor?: string | undefined;
                                    lang?: string | undefined;
                                    linkFlairEnabled?: boolean | undefined;
                                    linkFlairPosition?: string | undefined;
                                    mobileBannerImage?: string | undefined;
                                    name?: string | undefined;
                                    notificationLevel?: string | undefined;
                                    originalContentTagEnabled?: string | undefined;
                                    over18?: boolean | undefined;
                                    predictionLeaderboardEntryType?: string | undefined;
                                    previousNames?: string[];
                                    primaryColor?: string | undefined;
                                    publicDescription?: string | undefined;
                                    publicDescriptionHtml?: string | undefined;
                                    publicTraffic?: boolean | undefined;
                                    quarantine?: boolean | undefined;
                                    restrictCommenting?: boolean | undefined;
                                    restrictPosting?: boolean | undefined;
                                    shouldArchivePosts?: boolean | undefined;
                                    shouldShowMediaInCommentsSetting?: boolean | undefined;
                                    showMedia?: boolean | undefined;
                                    showMediaPreview?: boolean | undefined;
                                    spoilersEnabled?: boolean | undefined;
                                    submissionType?: string | undefined;
                                    submitLinkLabel?: string | undefined;
                                    submitText?: string | undefined;
                                    submitTextHtml?: string | undefined;
                                    submitTextLabel?: string | undefined;
                                    subredditType?: string | undefined;
                                    subscribers?: number | undefined;
                                    suggestedCommentSort?: string | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    userCanFlairInSr?: boolean | undefined;
                                    userFlairBackgroundColor?: string | undefined;
                                    userFlairCssClass?: string | undefined;
                                    userFlairEnabledInSr?: boolean | undefined;
                                    userFlairPosition?: string | undefined;
                                    userFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    userFlairTemplateId?: string | undefined;
                                    userFlairText?: string | undefined;
                                    userFlairTextColor?: string | undefined;
                                    userFlairType?: string | undefined;
                                    userHasFavorited?: boolean | undefined;
                                    userIsBanned?: boolean | undefined;
                                    userIsContributor?: boolean | undefined;
                                    userIsModerator?: boolean | undefined;
                                    userIsSubscriber?: boolean | undefined;
                                    userSrFlairEnabled?: boolean | undefined;
                                    userSrThemeEnabled?: boolean | undefined;
                                    videostreamLinksCount?: number | undefined;
                                    whitelistStatus?: string | undefined;
                                    wikiEnabled?: boolean | undefined;
                                    wls?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    postRequirements?: {
                                        bodyRestrictionPolicy?: string | undefined;
                                    } | undefined;
                                    userIsMuted?: boolean;
                                } | undefined;
                                suspensionExpirationUtc?: string | undefined;
                                totalKarma?: number | undefined;
                                verified?: boolean | undefined;
                                hasPhoneNumber?: boolean | undefined;
                                subredditsModerated?: number | undefined;
                                hasMetaSubscription?: boolean | undefined;
                                metaSubscriptionAge?: number | undefined;
                                metaPointsBalance?: string | undefined;
                                metaLockedPointsBalance?: string | undefined;
                                commentSubredditKarma?: number | undefined;
                                postSubredditKarma?: number | undefined;
                                markedSpam?: boolean | undefined;
                                isSubredditProxyAccount?: boolean | undefined;
                            } | undefined;
                        } | undefined;
                    } | undefined;
                }): GetWikiPageResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Edit wiki page
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_edit}
         */
        readonly editWikiPage: {
            readonly name: "EditWikiPage";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.EditWikiPageRequest";
                encode(message: EditWikiPageRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): EditWikiPageRequest;
                fromJSON(object: any): EditWikiPageRequest;
                toJSON(message: EditWikiPageRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    page?: string;
                    content?: string;
                    reason?: string;
                } | undefined): EditWikiPageRequest;
                fromPartial(object: {
                    subreddit?: string;
                    page?: string;
                    content?: string;
                    reason?: string;
                }): EditWikiPageRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer; /**
                * Get a list of wiki pages for a subreddit
                *
                * @see {@link https://www.reddit.com/dev/api#GET_wiki_pages}
                */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Hide a wiki page revision
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_hide}
         */
        readonly hideWikiPageRevision: {
            readonly name: "HideWikiPageRevision";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionRequest";
                encode(message: HideWikiPageRevisionRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): HideWikiPageRevisionRequest;
                fromJSON(object: any): HideWikiPageRevisionRequest;
                toJSON(message: HideWikiPageRevisionRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    page?: string;
                    revision?: string;
                } | undefined): HideWikiPageRevisionRequest;
                fromPartial(object: {
                    subreddit?: string;
                    page?: string;
                    revision?: string;
                }): HideWikiPageRevisionRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionResponse";
                encode(message: HideWikiPageRevisionResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): HideWikiPageRevisionResponse;
                fromJSON(object: any): HideWikiPageRevisionResponse;
                toJSON(message: HideWikiPageRevisionResponse): unknown;
                create(base?: {
                    status?: boolean;
                } | undefined): HideWikiPageRevisionResponse;
                fromPartial(object: {
                    status?: boolean;
                }): HideWikiPageRevisionResponse;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Get a list of revisions of a wiki page
         *
         * @see {@link https://www.reddit.com/dev/api#GET_wiki_revisions_\{page\}}
         */
        readonly getWikiPageRevisions: {
            readonly name: "GetWikiPageRevisions";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.GetWikiPageRevisionsRequest";
                encode(message: GetWikiPageRevisionsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWikiPageRevisionsRequest;
                fromJSON(object: any): GetWikiPageRevisionsRequest;
                toJSON(message: GetWikiPageRevisionsRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    page?: string;
                    after?: string | undefined;
                    before?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: boolean | undefined;
                    srDetail?: boolean | undefined;
                } | undefined): GetWikiPageRevisionsRequest;
                fromPartial(object: {
                    subreddit?: string;
                    page?: string;
                    after?: string | undefined;
                    before?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: boolean | undefined;
                    srDetail?: boolean | undefined;
                }): GetWikiPageRevisionsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing";
                encode(message: WikiPageRevisionListing, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): WikiPageRevisionListing;
                fromJSON(object: any): WikiPageRevisionListing;
                toJSON(message: WikiPageRevisionListing): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            id?: string;
                            page?: string;
                            timestamp?: number;
                            reason?: string;
                            revisionHidden?: boolean;
                            author?: {
                                id?: string | undefined;
                                data?: {
                                    acceptChats?: boolean | undefined;
                                    acceptFollowers?: boolean | undefined;
                                    acceptPms?: boolean | undefined;
                                    awardeeKarma?: number | undefined;
                                    awarderKarma?: number | undefined;
                                    canCreateSubreddit?: boolean | undefined;
                                    canEditName?: boolean | undefined;
                                    coins?: number | undefined;
                                    commentKarma?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    features?: {
                                        awardsOnStreams?: boolean | undefined;
                                        canMakeMobileTestBuildPurchases?: boolean | undefined;
                                        chatGroupRollout?: boolean | undefined;
                                        chatSubreddit?: boolean | undefined;
                                        chatUserSettings?: boolean | undefined;
                                        chat?: boolean | undefined;
                                        cookieConsentBanner?: boolean | undefined;
                                        crosspostNotif?: boolean | undefined;
                                        crowdControlForPost?: boolean | undefined;
                                        customFeedImage?: boolean | undefined;
                                        doNotTrack?: boolean | undefined;
                                        expensiveCoinsPackage?: boolean | undefined;
                                        isEmailPermissionRequired?: boolean | undefined;
                                        liveComments?: boolean | undefined;
                                        liveOrangereds?: boolean | undefined;
                                        modAwards?: boolean | undefined;
                                        modServiceMuteReads?: boolean | undefined;
                                        modServiceMuteWrites?: boolean | undefined;
                                        modlogCopyrightRemoval?: boolean | undefined;
                                        mwebNsfwXpromo?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                        mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                        mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                        mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                        mwebXpromoRevampV2?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        mwebXpromoRevampV3?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        noreferrerToNoopener?: boolean | undefined;
                                        pollsMobile?: boolean | undefined;
                                        premiumSubscriptionsTable?: boolean | undefined;
                                        promotedTrendBlanks?: boolean | undefined;
                                        resizedStylesImages?: boolean | undefined;
                                        showAmpLink?: boolean | undefined;
                                        showNpsSurvey?: boolean | undefined;
                                        spezModal?: boolean | undefined;
                                        usePrefAccountDeployment?: boolean | undefined;
                                        userFlairMigrationTesting?: boolean | undefined;
                                        webhookConfig?: boolean | undefined;
                                    } | undefined;
                                    forcePasswordReset?: boolean | undefined;
                                    goldCreddits?: number | undefined;
                                    goldExpiration?: string | undefined;
                                    hasAndroidSubscription?: boolean | undefined;
                                    hasExternalAccount?: boolean | undefined;
                                    hasGoldSubscription?: boolean | undefined;
                                    hasIosSubscription?: boolean | undefined;
                                    hasMail?: boolean | undefined;
                                    hasModMail?: boolean | undefined;
                                    hasPaypalSubscription?: boolean | undefined;
                                    hasStripeSubscription?: boolean | undefined;
                                    hasSubscribed?: boolean | undefined;
                                    hasSubscribedToPremium?: boolean | undefined;
                                    hasVerifiedEmail?: boolean | undefined;
                                    hasVisitedNewProfile?: boolean | undefined;
                                    hideFromRobots?: boolean | undefined;
                                    iconImg?: string | undefined;
                                    id?: string | undefined;
                                    inBeta?: boolean | undefined;
                                    inChat?: boolean | undefined;
                                    inRedesignBeta?: boolean | undefined;
                                    inboxCount?: number | undefined;
                                    isBlocked?: boolean | undefined;
                                    isEmployee?: boolean | undefined;
                                    isFriend?: boolean | undefined;
                                    isGold?: boolean | undefined;
                                    isMod?: boolean | undefined;
                                    isSponsor?: boolean | undefined;
                                    isSuspended?: boolean | undefined;
                                    linkKarma?: number | undefined;
                                    modhash?: string | undefined;
                                    name?: string | undefined;
                                    newModmailExists?: boolean | undefined;
                                    numFriends?: number | undefined;
                                    over18?: boolean | undefined;
                                    passwordSet?: boolean | undefined;
                                    prefAutoplay?: boolean | undefined;
                                    prefClickgadget?: number | undefined;
                                    prefGeopopular?: string | undefined;
                                    prefNightmode?: boolean | undefined;
                                    prefNoProfanity?: boolean | undefined;
                                    prefShowPresence?: boolean | undefined;
                                    prefShowSnoovatar?: boolean | undefined;
                                    prefShowTrending?: boolean | undefined;
                                    prefShowTwitter?: boolean | undefined;
                                    prefTopKarmaSubreddits?: boolean | undefined;
                                    prefVideoAutoplay?: boolean | undefined;
                                    snoovatarImg?: string | undefined;
                                    snoovatarSize?: number[];
                                    subreddit?: {
                                        acceptFollowers?: boolean | undefined;
                                        accountsActiveIsFuzzed?: boolean | undefined;
                                        accountsActive?: number | undefined;
                                        activeUserCount?: number | undefined;
                                        advertiserCategory?: string | undefined;
                                        allOriginalContent?: boolean | undefined;
                                        allowChatPostCreation?: boolean | undefined;
                                        allowDiscovery?: boolean | undefined;
                                        allowGalleries?: boolean | undefined;
                                        allowImages?: boolean | undefined;
                                        allowPolls?: boolean | undefined;
                                        allowPredictionContributors?: boolean | undefined;
                                        allowPredictionsTournament?: boolean | undefined;
                                        allowPredictions?: boolean | undefined;
                                        allowTalks?: boolean | undefined;
                                        allowVideogifs?: boolean | undefined;
                                        allowVideos?: boolean | undefined;
                                        allowedMediaInComments?: string[];
                                        bannerBackgroundColor?: string | undefined;
                                        bannerBackgroundImage?: string | undefined;
                                        bannerImg?: string | undefined;
                                        bannerSize?: number[];
                                        canAssignLinkFlair?: boolean | undefined;
                                        canAssignUserFlair?: boolean | undefined;
                                        coins?: number | undefined;
                                        collapseDeletedComments?: boolean | undefined;
                                        commentContributionSettings?: {
                                            allowedMediaTypes?: string[];
                                        } | undefined;
                                        commentScoreHideMins?: number | undefined;
                                        communityIcon?: string | undefined;
                                        communityReviewed?: boolean | undefined;
                                        contentCategory?: string | undefined;
                                        createdUtc?: number | undefined;
                                        created?: number | undefined;
                                        defaultSet?: boolean | undefined;
                                        description?: string | undefined;
                                        descriptionHtml?: string | undefined;
                                        disableContributorRequests?: boolean | undefined;
                                        displayName?: string | undefined;
                                        displayNamePrefixed?: string | undefined;
                                        emojisCustomSize?: number[];
                                        emojisEnabled?: boolean | undefined;
                                        freeFormReports?: boolean | undefined;
                                        hasMenuWidget?: boolean | undefined;
                                        headerImg?: string | undefined;
                                        headerSize?: number[];
                                        headerTitle?: string | undefined;
                                        hideAds?: boolean | undefined;
                                        iconColor?: string | undefined;
                                        iconImg?: string | undefined;
                                        iconSize?: number[];
                                        id?: string | undefined;
                                        isChatPostFeatureEnabled?: boolean | undefined;
                                        isCrosspostableSubreddit?: boolean | undefined;
                                        isDefaultBanner?: boolean | undefined;
                                        isDefaultIcon?: boolean | undefined;
                                        isEnrolledInNewModmail?: boolean | undefined;
                                        keyColor?: string | undefined;
                                        lang?: string | undefined;
                                        linkFlairEnabled?: boolean | undefined;
                                        linkFlairPosition?: string | undefined;
                                        mobileBannerImage?: string | undefined;
                                        name?: string | undefined;
                                        notificationLevel?: string | undefined;
                                        originalContentTagEnabled?: string | undefined;
                                        over18?: boolean | undefined;
                                        predictionLeaderboardEntryType?: string | undefined;
                                        previousNames?: string[];
                                        primaryColor?: string | undefined;
                                        publicDescription?: string | undefined;
                                        publicDescriptionHtml?: string | undefined;
                                        publicTraffic?: boolean | undefined;
                                        quarantine?: boolean | undefined;
                                        restrictCommenting?: boolean | undefined;
                                        restrictPosting?: boolean | undefined;
                                        shouldArchivePosts?: boolean | undefined;
                                        shouldShowMediaInCommentsSetting?: boolean | undefined;
                                        showMedia?: boolean | undefined;
                                        showMediaPreview?: boolean | undefined;
                                        spoilersEnabled?: boolean | undefined;
                                        submissionType?: string | undefined;
                                        submitLinkLabel?: string | undefined;
                                        submitText?: string | undefined;
                                        submitTextHtml?: string | undefined;
                                        submitTextLabel?: string | undefined;
                                        subredditType?: string | undefined;
                                        subscribers?: number | undefined;
                                        suggestedCommentSort?: string | undefined;
                                        title?: string | undefined;
                                        url?: string | undefined;
                                        userCanFlairInSr?: boolean | undefined;
                                        userFlairBackgroundColor?: string | undefined;
                                        userFlairCssClass?: string | undefined;
                                        userFlairEnabledInSr?: boolean | undefined;
                                        userFlairPosition?: string | undefined;
                                        userFlairRichtext?: {
                                            e?: string | undefined;
                                            t?: string | undefined;
                                        }[];
                                        userFlairTemplateId?: string | undefined;
                                        userFlairText?: string | undefined;
                                        userFlairTextColor?: string | undefined;
                                        userFlairType?: string | undefined;
                                        userHasFavorited?: boolean | undefined;
                                        userIsBanned?: boolean | undefined;
                                        userIsContributor?: boolean | undefined;
                                        userIsModerator?: boolean | undefined;
                                        userIsSubscriber?: boolean | undefined;
                                        userSrFlairEnabled?: boolean | undefined;
                                        userSrThemeEnabled?: boolean | undefined;
                                        videostreamLinksCount?: number | undefined;
                                        whitelistStatus?: string | undefined;
                                        wikiEnabled?: boolean | undefined;
                                        wls?: number | undefined;
                                        markedSpam?: boolean | undefined;
                                        postRequirements?: {
                                            bodyRestrictionPolicy?: string | undefined;
                                        } | undefined;
                                        userIsMuted?: boolean;
                                    } | undefined;
                                    suspensionExpirationUtc?: string | undefined;
                                    totalKarma?: number | undefined;
                                    verified?: boolean | undefined;
                                    hasPhoneNumber?: boolean | undefined;
                                    subredditsModerated?: number | undefined;
                                    hasMetaSubscription?: boolean | undefined;
                                    metaSubscriptionAge?: number | undefined;
                                    metaPointsBalance?: string | undefined;
                                    metaLockedPointsBalance?: string | undefined;
                                    commentSubredditKarma?: number | undefined;
                                    postSubredditKarma?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    isSubredditProxyAccount?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): WikiPageRevisionListing;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            id?: string;
                            page?: string;
                            timestamp?: number;
                            reason?: string;
                            revisionHidden?: boolean;
                            author?: {
                                id?: string | undefined;
                                data?: {
                                    acceptChats?: boolean | undefined;
                                    acceptFollowers?: boolean | undefined;
                                    acceptPms?: boolean | undefined;
                                    awardeeKarma?: number | undefined;
                                    awarderKarma?: number | undefined;
                                    canCreateSubreddit?: boolean | undefined;
                                    canEditName?: boolean | undefined;
                                    coins?: number | undefined;
                                    commentKarma?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    features?: {
                                        awardsOnStreams?: boolean | undefined;
                                        canMakeMobileTestBuildPurchases?: boolean | undefined;
                                        chatGroupRollout?: boolean | undefined;
                                        chatSubreddit?: boolean | undefined;
                                        chatUserSettings?: boolean | undefined;
                                        chat?: boolean | undefined;
                                        cookieConsentBanner?: boolean | undefined;
                                        crosspostNotif?: boolean | undefined;
                                        crowdControlForPost?: boolean | undefined;
                                        customFeedImage?: boolean | undefined;
                                        doNotTrack?: boolean | undefined;
                                        expensiveCoinsPackage?: boolean | undefined;
                                        isEmailPermissionRequired?: boolean | undefined;
                                        liveComments?: boolean | undefined;
                                        liveOrangereds?: boolean | undefined;
                                        modAwards?: boolean | undefined;
                                        modServiceMuteReads?: boolean | undefined;
                                        modServiceMuteWrites?: boolean | undefined;
                                        modlogCopyrightRemoval?: boolean | undefined;
                                        mwebNsfwXpromo?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                        mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                        mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                        mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                        mwebXpromoRevampV2?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        mwebXpromoRevampV3?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        noreferrerToNoopener?: boolean | undefined;
                                        pollsMobile?: boolean | undefined;
                                        premiumSubscriptionsTable?: boolean | undefined;
                                        promotedTrendBlanks?: boolean | undefined;
                                        resizedStylesImages?: boolean | undefined;
                                        showAmpLink?: boolean | undefined;
                                        showNpsSurvey?: boolean | undefined;
                                        spezModal?: boolean | undefined;
                                        usePrefAccountDeployment?: boolean | undefined;
                                        userFlairMigrationTesting?: boolean | undefined;
                                        webhookConfig?: boolean | undefined;
                                    } | undefined;
                                    forcePasswordReset?: boolean | undefined;
                                    goldCreddits?: number | undefined;
                                    goldExpiration?: string | undefined;
                                    hasAndroidSubscription?: boolean | undefined;
                                    hasExternalAccount?: boolean | undefined;
                                    hasGoldSubscription?: boolean | undefined;
                                    hasIosSubscription?: boolean | undefined;
                                    hasMail?: boolean | undefined;
                                    hasModMail?: boolean | undefined;
                                    hasPaypalSubscription?: boolean | undefined;
                                    hasStripeSubscription?: boolean | undefined;
                                    hasSubscribed?: boolean | undefined;
                                    hasSubscribedToPremium?: boolean | undefined;
                                    hasVerifiedEmail?: boolean | undefined;
                                    hasVisitedNewProfile?: boolean | undefined;
                                    hideFromRobots?: boolean | undefined;
                                    iconImg?: string | undefined;
                                    id?: string | undefined;
                                    inBeta?: boolean | undefined;
                                    inChat?: boolean | undefined;
                                    inRedesignBeta?: boolean | undefined;
                                    inboxCount?: number | undefined;
                                    isBlocked?: boolean | undefined;
                                    isEmployee?: boolean | undefined;
                                    isFriend?: boolean | undefined;
                                    isGold?: boolean | undefined;
                                    isMod?: boolean | undefined;
                                    isSponsor?: boolean | undefined;
                                    isSuspended?: boolean | undefined;
                                    linkKarma?: number | undefined;
                                    modhash?: string | undefined;
                                    name?: string | undefined;
                                    newModmailExists?: boolean | undefined;
                                    numFriends?: number | undefined;
                                    over18?: boolean | undefined;
                                    passwordSet?: boolean | undefined;
                                    prefAutoplay?: boolean | undefined;
                                    prefClickgadget?: number | undefined;
                                    prefGeopopular?: string | undefined;
                                    prefNightmode?: boolean | undefined;
                                    prefNoProfanity?: boolean | undefined;
                                    prefShowPresence?: boolean | undefined;
                                    prefShowSnoovatar?: boolean | undefined;
                                    prefShowTrending?: boolean | undefined;
                                    prefShowTwitter?: boolean | undefined;
                                    prefTopKarmaSubreddits?: boolean | undefined;
                                    prefVideoAutoplay?: boolean | undefined;
                                    snoovatarImg?: string | undefined;
                                    snoovatarSize?: number[];
                                    subreddit?: {
                                        acceptFollowers?: boolean | undefined;
                                        accountsActiveIsFuzzed?: boolean | undefined;
                                        accountsActive?: number | undefined;
                                        activeUserCount?: number | undefined;
                                        advertiserCategory?: string | undefined;
                                        allOriginalContent?: boolean | undefined;
                                        allowChatPostCreation?: boolean | undefined;
                                        allowDiscovery?: boolean | undefined;
                                        allowGalleries?: boolean | undefined;
                                        allowImages?: boolean | undefined;
                                        allowPolls?: boolean | undefined;
                                        allowPredictionContributors?: boolean | undefined;
                                        allowPredictionsTournament?: boolean | undefined;
                                        allowPredictions?: boolean | undefined;
                                        allowTalks?: boolean | undefined;
                                        allowVideogifs?: boolean | undefined;
                                        allowVideos?: boolean | undefined;
                                        allowedMediaInComments?: string[];
                                        bannerBackgroundColor?: string | undefined;
                                        bannerBackgroundImage?: string | undefined;
                                        bannerImg?: string | undefined;
                                        bannerSize?: number[];
                                        canAssignLinkFlair?: boolean | undefined;
                                        canAssignUserFlair?: boolean | undefined;
                                        coins?: number | undefined;
                                        collapseDeletedComments?: boolean | undefined;
                                        commentContributionSettings?: {
                                            allowedMediaTypes?: string[];
                                        } | undefined;
                                        commentScoreHideMins?: number | undefined;
                                        communityIcon?: string | undefined;
                                        communityReviewed?: boolean | undefined;
                                        contentCategory?: string | undefined;
                                        createdUtc?: number | undefined;
                                        created?: number | undefined;
                                        defaultSet?: boolean | undefined;
                                        description?: string | undefined;
                                        descriptionHtml?: string | undefined;
                                        disableContributorRequests?: boolean | undefined;
                                        displayName?: string | undefined;
                                        displayNamePrefixed?: string | undefined;
                                        emojisCustomSize?: number[];
                                        emojisEnabled?: boolean | undefined;
                                        freeFormReports?: boolean | undefined;
                                        hasMenuWidget?: boolean | undefined;
                                        headerImg?: string | undefined;
                                        headerSize?: number[];
                                        headerTitle?: string | undefined;
                                        hideAds?: boolean | undefined;
                                        iconColor?: string | undefined;
                                        iconImg?: string | undefined;
                                        iconSize?: number[];
                                        id?: string | undefined;
                                        isChatPostFeatureEnabled?: boolean | undefined;
                                        isCrosspostableSubreddit?: boolean | undefined;
                                        isDefaultBanner?: boolean | undefined;
                                        isDefaultIcon?: boolean | undefined;
                                        isEnrolledInNewModmail?: boolean | undefined;
                                        keyColor?: string | undefined;
                                        lang?: string | undefined;
                                        linkFlairEnabled?: boolean | undefined;
                                        linkFlairPosition?: string | undefined;
                                        mobileBannerImage?: string | undefined;
                                        name?: string | undefined;
                                        notificationLevel?: string | undefined;
                                        originalContentTagEnabled?: string | undefined;
                                        over18?: boolean | undefined;
                                        predictionLeaderboardEntryType?: string | undefined;
                                        previousNames?: string[];
                                        primaryColor?: string | undefined;
                                        publicDescription?: string | undefined;
                                        publicDescriptionHtml?: string | undefined;
                                        publicTraffic?: boolean | undefined;
                                        quarantine?: boolean | undefined;
                                        restrictCommenting?: boolean | undefined;
                                        restrictPosting?: boolean | undefined;
                                        shouldArchivePosts?: boolean | undefined;
                                        shouldShowMediaInCommentsSetting?: boolean | undefined;
                                        showMedia?: boolean | undefined;
                                        showMediaPreview?: boolean | undefined;
                                        spoilersEnabled?: boolean | undefined;
                                        submissionType?: string | undefined;
                                        submitLinkLabel?: string | undefined;
                                        submitText?: string | undefined;
                                        submitTextHtml?: string | undefined;
                                        submitTextLabel?: string | undefined;
                                        subredditType?: string | undefined;
                                        subscribers?: number | undefined;
                                        suggestedCommentSort?: string | undefined;
                                        title?: string | undefined;
                                        url?: string | undefined;
                                        userCanFlairInSr?: boolean | undefined;
                                        userFlairBackgroundColor?: string | undefined;
                                        userFlairCssClass?: string | undefined;
                                        userFlairEnabledInSr?: boolean | undefined;
                                        userFlairPosition?: string | undefined;
                                        userFlairRichtext?: {
                                            e?: string | undefined;
                                            t?: string | undefined;
                                        }[];
                                        userFlairTemplateId?: string | undefined;
                                        userFlairText?: string | undefined;
                                        userFlairTextColor?: string | undefined;
                                        userFlairType?: string | undefined;
                                        userHasFavorited?: boolean | undefined;
                                        userIsBanned?: boolean | undefined;
                                        userIsContributor?: boolean | undefined;
                                        userIsModerator?: boolean | undefined;
                                        userIsSubscriber?: boolean | undefined;
                                        userSrFlairEnabled?: boolean | undefined;
                                        userSrThemeEnabled?: boolean | undefined;
                                        videostreamLinksCount?: number | undefined;
                                        whitelistStatus?: string | undefined;
                                        wikiEnabled?: boolean | undefined;
                                        wls?: number | undefined;
                                        markedSpam?: boolean | undefined;
                                        postRequirements?: {
                                            bodyRestrictionPolicy?: string | undefined;
                                        } | undefined;
                                        userIsMuted?: boolean;
                                    } | undefined;
                                    suspensionExpirationUtc?: string | undefined;
                                    totalKarma?: number | undefined;
                                    verified?: boolean | undefined;
                                    hasPhoneNumber?: boolean | undefined;
                                    subredditsModerated?: number | undefined;
                                    hasMetaSubscription?: boolean | undefined;
                                    metaSubscriptionAge?: number | undefined;
                                    metaPointsBalance?: string | undefined;
                                    metaLockedPointsBalance?: string | undefined;
                                    commentSubredditKarma?: number | undefined;
                                    postSubredditKarma?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    isSubredditProxyAccount?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): WikiPageRevisionListing;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Retrieve a list of recently changed wiki pages in this subreddit
         *
         * @see {@link https://www.reddit.com/dev/api#GET_wiki_revisions}
         */
        readonly getWikiRevisions: {
            readonly name: "GetWikiRevisions";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.GetWikiRevisionsRequest";
                encode(message: GetWikiRevisionsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWikiRevisionsRequest;
                fromJSON(object: any): GetWikiRevisionsRequest;
                toJSON(message: GetWikiRevisionsRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    after?: string | undefined;
                    before?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: boolean | undefined;
                    srDetail?: boolean | undefined;
                } | undefined): GetWikiRevisionsRequest;
                fromPartial(object: {
                    subreddit?: string;
                    after?: string | undefined;
                    before?: string | undefined;
                    limit?: number | undefined;
                    count?: number | undefined;
                    show?: boolean | undefined;
                    srDetail?: boolean | undefined;
                }): GetWikiRevisionsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing";
                encode(message: WikiPageRevisionListing, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): WikiPageRevisionListing;
                fromJSON(object: any): WikiPageRevisionListing;
                toJSON(message: WikiPageRevisionListing): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            id?: string;
                            page?: string;
                            timestamp?: number;
                            reason?: string;
                            revisionHidden?: boolean;
                            author?: {
                                id?: string | undefined;
                                data?: {
                                    acceptChats?: boolean | undefined;
                                    acceptFollowers?: boolean | undefined;
                                    acceptPms?: boolean | undefined;
                                    awardeeKarma?: number | undefined;
                                    awarderKarma?: number | undefined;
                                    canCreateSubreddit?: boolean | undefined;
                                    canEditName?: boolean | undefined;
                                    coins?: number | undefined;
                                    commentKarma?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    features?: {
                                        awardsOnStreams?: boolean | undefined;
                                        canMakeMobileTestBuildPurchases?: boolean | undefined;
                                        chatGroupRollout?: boolean | undefined;
                                        chatSubreddit?: boolean | undefined;
                                        chatUserSettings?: boolean | undefined;
                                        chat?: boolean | undefined;
                                        cookieConsentBanner?: boolean | undefined;
                                        crosspostNotif?: boolean | undefined;
                                        crowdControlForPost?: boolean | undefined;
                                        customFeedImage?: boolean | undefined;
                                        doNotTrack?: boolean | undefined;
                                        expensiveCoinsPackage?: boolean | undefined;
                                        isEmailPermissionRequired?: boolean | undefined;
                                        liveComments?: boolean | undefined;
                                        liveOrangereds?: boolean | undefined;
                                        modAwards?: boolean | undefined;
                                        modServiceMuteReads?: boolean | undefined;
                                        modServiceMuteWrites?: boolean | undefined;
                                        modlogCopyrightRemoval?: boolean | undefined;
                                        mwebNsfwXpromo?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                        mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                        mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                        mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                        mwebXpromoRevampV2?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        mwebXpromoRevampV3?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        noreferrerToNoopener?: boolean | undefined;
                                        pollsMobile?: boolean | undefined;
                                        premiumSubscriptionsTable?: boolean | undefined;
                                        promotedTrendBlanks?: boolean | undefined;
                                        resizedStylesImages?: boolean | undefined;
                                        showAmpLink?: boolean | undefined;
                                        showNpsSurvey?: boolean | undefined;
                                        spezModal?: boolean | undefined;
                                        usePrefAccountDeployment?: boolean | undefined;
                                        userFlairMigrationTesting?: boolean | undefined;
                                        webhookConfig?: boolean | undefined;
                                    } | undefined;
                                    forcePasswordReset?: boolean | undefined;
                                    goldCreddits?: number | undefined;
                                    goldExpiration?: string | undefined;
                                    hasAndroidSubscription?: boolean | undefined;
                                    hasExternalAccount?: boolean | undefined;
                                    hasGoldSubscription?: boolean | undefined;
                                    hasIosSubscription?: boolean | undefined;
                                    hasMail?: boolean | undefined;
                                    hasModMail?: boolean | undefined;
                                    hasPaypalSubscription?: boolean | undefined;
                                    hasStripeSubscription?: boolean | undefined;
                                    hasSubscribed?: boolean | undefined;
                                    hasSubscribedToPremium?: boolean | undefined;
                                    hasVerifiedEmail?: boolean | undefined;
                                    hasVisitedNewProfile?: boolean | undefined;
                                    hideFromRobots?: boolean | undefined;
                                    iconImg?: string | undefined;
                                    id?: string | undefined;
                                    inBeta?: boolean | undefined;
                                    inChat?: boolean | undefined;
                                    inRedesignBeta?: boolean | undefined;
                                    inboxCount?: number | undefined;
                                    isBlocked?: boolean | undefined;
                                    isEmployee?: boolean | undefined;
                                    isFriend?: boolean | undefined;
                                    isGold?: boolean | undefined;
                                    isMod?: boolean | undefined;
                                    isSponsor?: boolean | undefined;
                                    isSuspended?: boolean | undefined;
                                    linkKarma?: number | undefined;
                                    modhash?: string | undefined;
                                    name?: string | undefined;
                                    newModmailExists?: boolean | undefined;
                                    numFriends?: number | undefined;
                                    over18?: boolean | undefined;
                                    passwordSet?: boolean | undefined;
                                    prefAutoplay?: boolean | undefined;
                                    prefClickgadget?: number | undefined;
                                    prefGeopopular?: string | undefined;
                                    prefNightmode?: boolean | undefined;
                                    prefNoProfanity?: boolean | undefined;
                                    prefShowPresence?: boolean | undefined;
                                    prefShowSnoovatar?: boolean | undefined;
                                    prefShowTrending?: boolean | undefined;
                                    prefShowTwitter?: boolean | undefined;
                                    prefTopKarmaSubreddits?: boolean | undefined;
                                    prefVideoAutoplay?: boolean | undefined;
                                    snoovatarImg?: string | undefined;
                                    snoovatarSize?: number[];
                                    subreddit?: {
                                        acceptFollowers?: boolean | undefined;
                                        accountsActiveIsFuzzed?: boolean | undefined;
                                        accountsActive?: number | undefined;
                                        activeUserCount?: number | undefined;
                                        advertiserCategory?: string | undefined;
                                        allOriginalContent?: boolean | undefined;
                                        allowChatPostCreation?: boolean | undefined;
                                        allowDiscovery?: boolean | undefined;
                                        allowGalleries?: boolean | undefined;
                                        allowImages?: boolean | undefined;
                                        allowPolls?: boolean | undefined;
                                        allowPredictionContributors?: boolean | undefined;
                                        allowPredictionsTournament?: boolean | undefined;
                                        allowPredictions?: boolean | undefined;
                                        allowTalks?: boolean | undefined;
                                        allowVideogifs?: boolean | undefined;
                                        allowVideos?: boolean | undefined;
                                        allowedMediaInComments?: string[];
                                        bannerBackgroundColor?: string | undefined;
                                        bannerBackgroundImage?: string | undefined;
                                        bannerImg?: string | undefined;
                                        bannerSize?: number[];
                                        canAssignLinkFlair?: boolean | undefined;
                                        canAssignUserFlair?: boolean | undefined;
                                        coins?: number | undefined;
                                        collapseDeletedComments?: boolean | undefined;
                                        commentContributionSettings?: {
                                            allowedMediaTypes?: string[];
                                        } | undefined;
                                        commentScoreHideMins?: number | undefined;
                                        communityIcon?: string | undefined;
                                        communityReviewed?: boolean | undefined;
                                        contentCategory?: string | undefined;
                                        createdUtc?: number | undefined;
                                        created?: number | undefined;
                                        defaultSet?: boolean | undefined;
                                        description?: string | undefined;
                                        descriptionHtml?: string | undefined;
                                        disableContributorRequests?: boolean | undefined;
                                        displayName?: string | undefined;
                                        displayNamePrefixed?: string | undefined;
                                        emojisCustomSize?: number[];
                                        emojisEnabled?: boolean | undefined;
                                        freeFormReports?: boolean | undefined;
                                        hasMenuWidget?: boolean | undefined;
                                        headerImg?: string | undefined;
                                        headerSize?: number[];
                                        headerTitle?: string | undefined;
                                        hideAds?: boolean | undefined;
                                        iconColor?: string | undefined;
                                        iconImg?: string | undefined;
                                        iconSize?: number[];
                                        id?: string | undefined;
                                        isChatPostFeatureEnabled?: boolean | undefined;
                                        isCrosspostableSubreddit?: boolean | undefined;
                                        isDefaultBanner?: boolean | undefined;
                                        isDefaultIcon?: boolean | undefined;
                                        isEnrolledInNewModmail?: boolean | undefined;
                                        keyColor?: string | undefined;
                                        lang?: string | undefined;
                                        linkFlairEnabled?: boolean | undefined;
                                        linkFlairPosition?: string | undefined;
                                        mobileBannerImage?: string | undefined;
                                        name?: string | undefined;
                                        notificationLevel?: string | undefined;
                                        originalContentTagEnabled?: string | undefined;
                                        over18?: boolean | undefined;
                                        predictionLeaderboardEntryType?: string | undefined;
                                        previousNames?: string[];
                                        primaryColor?: string | undefined;
                                        publicDescription?: string | undefined;
                                        publicDescriptionHtml?: string | undefined;
                                        publicTraffic?: boolean | undefined;
                                        quarantine?: boolean | undefined;
                                        restrictCommenting?: boolean | undefined;
                                        restrictPosting?: boolean | undefined;
                                        shouldArchivePosts?: boolean | undefined;
                                        shouldShowMediaInCommentsSetting?: boolean | undefined;
                                        showMedia?: boolean | undefined;
                                        showMediaPreview?: boolean | undefined;
                                        spoilersEnabled?: boolean | undefined;
                                        submissionType?: string | undefined;
                                        submitLinkLabel?: string | undefined;
                                        submitText?: string | undefined;
                                        submitTextHtml?: string | undefined;
                                        submitTextLabel?: string | undefined;
                                        subredditType?: string | undefined;
                                        subscribers?: number | undefined;
                                        suggestedCommentSort?: string | undefined;
                                        title?: string | undefined;
                                        url?: string | undefined;
                                        userCanFlairInSr?: boolean | undefined;
                                        userFlairBackgroundColor?: string | undefined;
                                        userFlairCssClass?: string | undefined;
                                        userFlairEnabledInSr?: boolean | undefined;
                                        userFlairPosition?: string | undefined;
                                        userFlairRichtext?: {
                                            e?: string | undefined;
                                            t?: string | undefined;
                                        }[];
                                        userFlairTemplateId?: string | undefined;
                                        userFlairText?: string | undefined;
                                        userFlairTextColor?: string | undefined;
                                        userFlairType?: string | undefined;
                                        userHasFavorited?: boolean | undefined;
                                        userIsBanned?: boolean | undefined;
                                        userIsContributor?: boolean | undefined;
                                        userIsModerator?: boolean | undefined;
                                        userIsSubscriber?: boolean | undefined;
                                        userSrFlairEnabled?: boolean | undefined;
                                        userSrThemeEnabled?: boolean | undefined;
                                        videostreamLinksCount?: number | undefined;
                                        whitelistStatus?: string | undefined;
                                        wikiEnabled?: boolean | undefined;
                                        wls?: number | undefined;
                                        markedSpam?: boolean | undefined;
                                        postRequirements?: {
                                            bodyRestrictionPolicy?: string | undefined;
                                        } | undefined;
                                        userIsMuted?: boolean;
                                    } | undefined;
                                    suspensionExpirationUtc?: string | undefined;
                                    totalKarma?: number | undefined;
                                    verified?: boolean | undefined;
                                    hasPhoneNumber?: boolean | undefined;
                                    subredditsModerated?: number | undefined;
                                    hasMetaSubscription?: boolean | undefined;
                                    metaSubscriptionAge?: number | undefined;
                                    metaPointsBalance?: string | undefined;
                                    metaLockedPointsBalance?: string | undefined;
                                    commentSubredditKarma?: number | undefined;
                                    postSubredditKarma?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    isSubredditProxyAccount?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                } | undefined): WikiPageRevisionListing;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        after?: string | undefined;
                        before?: string | undefined;
                        children?: {
                            id?: string;
                            page?: string;
                            timestamp?: number;
                            reason?: string;
                            revisionHidden?: boolean;
                            author?: {
                                id?: string | undefined;
                                data?: {
                                    acceptChats?: boolean | undefined;
                                    acceptFollowers?: boolean | undefined;
                                    acceptPms?: boolean | undefined;
                                    awardeeKarma?: number | undefined;
                                    awarderKarma?: number | undefined;
                                    canCreateSubreddit?: boolean | undefined;
                                    canEditName?: boolean | undefined;
                                    coins?: number | undefined;
                                    commentKarma?: number | undefined;
                                    created?: number | undefined;
                                    createdUtc?: number | undefined;
                                    features?: {
                                        awardsOnStreams?: boolean | undefined;
                                        canMakeMobileTestBuildPurchases?: boolean | undefined;
                                        chatGroupRollout?: boolean | undefined;
                                        chatSubreddit?: boolean | undefined;
                                        chatUserSettings?: boolean | undefined;
                                        chat?: boolean | undefined;
                                        cookieConsentBanner?: boolean | undefined;
                                        crosspostNotif?: boolean | undefined;
                                        crowdControlForPost?: boolean | undefined;
                                        customFeedImage?: boolean | undefined;
                                        doNotTrack?: boolean | undefined;
                                        expensiveCoinsPackage?: boolean | undefined;
                                        isEmailPermissionRequired?: boolean | undefined;
                                        liveComments?: boolean | undefined;
                                        liveOrangereds?: boolean | undefined;
                                        modAwards?: boolean | undefined;
                                        modServiceMuteReads?: boolean | undefined;
                                        modServiceMuteWrites?: boolean | undefined;
                                        modlogCopyrightRemoval?: boolean | undefined;
                                        mwebNsfwXpromo?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                        mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                        mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                        mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                        mwebXpromoRevampV2?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        mwebXpromoRevampV3?: {
                                            experimentId?: number | undefined;
                                            owner?: string | undefined;
                                            variant?: string | undefined;
                                        } | undefined;
                                        noreferrerToNoopener?: boolean | undefined;
                                        pollsMobile?: boolean | undefined;
                                        premiumSubscriptionsTable?: boolean | undefined;
                                        promotedTrendBlanks?: boolean | undefined;
                                        resizedStylesImages?: boolean | undefined;
                                        showAmpLink?: boolean | undefined;
                                        showNpsSurvey?: boolean | undefined;
                                        spezModal?: boolean | undefined;
                                        usePrefAccountDeployment?: boolean | undefined;
                                        userFlairMigrationTesting?: boolean | undefined;
                                        webhookConfig?: boolean | undefined;
                                    } | undefined;
                                    forcePasswordReset?: boolean | undefined;
                                    goldCreddits?: number | undefined;
                                    goldExpiration?: string | undefined;
                                    hasAndroidSubscription?: boolean | undefined;
                                    hasExternalAccount?: boolean | undefined;
                                    hasGoldSubscription?: boolean | undefined;
                                    hasIosSubscription?: boolean | undefined;
                                    hasMail?: boolean | undefined;
                                    hasModMail?: boolean | undefined;
                                    hasPaypalSubscription?: boolean | undefined;
                                    hasStripeSubscription?: boolean | undefined;
                                    hasSubscribed?: boolean | undefined;
                                    hasSubscribedToPremium?: boolean | undefined;
                                    hasVerifiedEmail?: boolean | undefined;
                                    hasVisitedNewProfile?: boolean | undefined;
                                    hideFromRobots?: boolean | undefined;
                                    iconImg?: string | undefined;
                                    id?: string | undefined;
                                    inBeta?: boolean | undefined;
                                    inChat?: boolean | undefined;
                                    inRedesignBeta?: boolean | undefined;
                                    inboxCount?: number | undefined;
                                    isBlocked?: boolean | undefined;
                                    isEmployee?: boolean | undefined;
                                    isFriend?: boolean | undefined;
                                    isGold?: boolean | undefined;
                                    isMod?: boolean | undefined;
                                    isSponsor?: boolean | undefined;
                                    isSuspended?: boolean | undefined;
                                    linkKarma?: number | undefined;
                                    modhash?: string | undefined;
                                    name?: string | undefined;
                                    newModmailExists?: boolean | undefined;
                                    numFriends?: number | undefined;
                                    over18?: boolean | undefined;
                                    passwordSet?: boolean | undefined;
                                    prefAutoplay?: boolean | undefined;
                                    prefClickgadget?: number | undefined;
                                    prefGeopopular?: string | undefined;
                                    prefNightmode?: boolean | undefined;
                                    prefNoProfanity?: boolean | undefined;
                                    prefShowPresence?: boolean | undefined;
                                    prefShowSnoovatar?: boolean | undefined;
                                    prefShowTrending?: boolean | undefined;
                                    prefShowTwitter?: boolean | undefined;
                                    prefTopKarmaSubreddits?: boolean | undefined;
                                    prefVideoAutoplay?: boolean | undefined;
                                    snoovatarImg?: string | undefined;
                                    snoovatarSize?: number[];
                                    subreddit?: {
                                        acceptFollowers?: boolean | undefined;
                                        accountsActiveIsFuzzed?: boolean | undefined;
                                        accountsActive?: number | undefined;
                                        activeUserCount?: number | undefined;
                                        advertiserCategory?: string | undefined;
                                        allOriginalContent?: boolean | undefined;
                                        allowChatPostCreation?: boolean | undefined;
                                        allowDiscovery?: boolean | undefined;
                                        allowGalleries?: boolean | undefined;
                                        allowImages?: boolean | undefined;
                                        allowPolls?: boolean | undefined;
                                        allowPredictionContributors?: boolean | undefined;
                                        allowPredictionsTournament?: boolean | undefined;
                                        allowPredictions?: boolean | undefined;
                                        allowTalks?: boolean | undefined;
                                        allowVideogifs?: boolean | undefined;
                                        allowVideos?: boolean | undefined;
                                        allowedMediaInComments?: string[];
                                        bannerBackgroundColor?: string | undefined;
                                        bannerBackgroundImage?: string | undefined;
                                        bannerImg?: string | undefined;
                                        bannerSize?: number[];
                                        canAssignLinkFlair?: boolean | undefined;
                                        canAssignUserFlair?: boolean | undefined;
                                        coins?: number | undefined;
                                        collapseDeletedComments?: boolean | undefined;
                                        commentContributionSettings?: {
                                            allowedMediaTypes?: string[];
                                        } | undefined;
                                        commentScoreHideMins?: number | undefined;
                                        communityIcon?: string | undefined;
                                        communityReviewed?: boolean | undefined;
                                        contentCategory?: string | undefined;
                                        createdUtc?: number | undefined;
                                        created?: number | undefined;
                                        defaultSet?: boolean | undefined;
                                        description?: string | undefined;
                                        descriptionHtml?: string | undefined;
                                        disableContributorRequests?: boolean | undefined;
                                        displayName?: string | undefined;
                                        displayNamePrefixed?: string | undefined;
                                        emojisCustomSize?: number[];
                                        emojisEnabled?: boolean | undefined;
                                        freeFormReports?: boolean | undefined;
                                        hasMenuWidget?: boolean | undefined;
                                        headerImg?: string | undefined;
                                        headerSize?: number[];
                                        headerTitle?: string | undefined;
                                        hideAds?: boolean | undefined;
                                        iconColor?: string | undefined;
                                        iconImg?: string | undefined;
                                        iconSize?: number[];
                                        id?: string | undefined;
                                        isChatPostFeatureEnabled?: boolean | undefined;
                                        isCrosspostableSubreddit?: boolean | undefined;
                                        isDefaultBanner?: boolean | undefined;
                                        isDefaultIcon?: boolean | undefined;
                                        isEnrolledInNewModmail?: boolean | undefined;
                                        keyColor?: string | undefined;
                                        lang?: string | undefined;
                                        linkFlairEnabled?: boolean | undefined;
                                        linkFlairPosition?: string | undefined;
                                        mobileBannerImage?: string | undefined;
                                        name?: string | undefined;
                                        notificationLevel?: string | undefined;
                                        originalContentTagEnabled?: string | undefined;
                                        over18?: boolean | undefined;
                                        predictionLeaderboardEntryType?: string | undefined;
                                        previousNames?: string[];
                                        primaryColor?: string | undefined;
                                        publicDescription?: string | undefined;
                                        publicDescriptionHtml?: string | undefined;
                                        publicTraffic?: boolean | undefined;
                                        quarantine?: boolean | undefined;
                                        restrictCommenting?: boolean | undefined;
                                        restrictPosting?: boolean | undefined;
                                        shouldArchivePosts?: boolean | undefined;
                                        shouldShowMediaInCommentsSetting?: boolean | undefined;
                                        showMedia?: boolean | undefined;
                                        showMediaPreview?: boolean | undefined;
                                        spoilersEnabled?: boolean | undefined;
                                        submissionType?: string | undefined;
                                        submitLinkLabel?: string | undefined;
                                        submitText?: string | undefined;
                                        submitTextHtml?: string | undefined;
                                        submitTextLabel?: string | undefined;
                                        subredditType?: string | undefined;
                                        subscribers?: number | undefined;
                                        suggestedCommentSort?: string | undefined;
                                        title?: string | undefined;
                                        url?: string | undefined;
                                        userCanFlairInSr?: boolean | undefined;
                                        userFlairBackgroundColor?: string | undefined;
                                        userFlairCssClass?: string | undefined;
                                        userFlairEnabledInSr?: boolean | undefined;
                                        userFlairPosition?: string | undefined;
                                        userFlairRichtext?: {
                                            e?: string | undefined;
                                            t?: string | undefined;
                                        }[];
                                        userFlairTemplateId?: string | undefined;
                                        userFlairText?: string | undefined;
                                        userFlairTextColor?: string | undefined;
                                        userFlairType?: string | undefined;
                                        userHasFavorited?: boolean | undefined;
                                        userIsBanned?: boolean | undefined;
                                        userIsContributor?: boolean | undefined;
                                        userIsModerator?: boolean | undefined;
                                        userIsSubscriber?: boolean | undefined;
                                        userSrFlairEnabled?: boolean | undefined;
                                        userSrThemeEnabled?: boolean | undefined;
                                        videostreamLinksCount?: number | undefined;
                                        whitelistStatus?: string | undefined;
                                        wikiEnabled?: boolean | undefined;
                                        wls?: number | undefined;
                                        markedSpam?: boolean | undefined;
                                        postRequirements?: {
                                            bodyRestrictionPolicy?: string | undefined;
                                        } | undefined;
                                        userIsMuted?: boolean;
                                    } | undefined;
                                    suspensionExpirationUtc?: string | undefined;
                                    totalKarma?: number | undefined;
                                    verified?: boolean | undefined;
                                    hasPhoneNumber?: boolean | undefined;
                                    subredditsModerated?: number | undefined;
                                    hasMetaSubscription?: boolean | undefined;
                                    metaSubscriptionAge?: number | undefined;
                                    metaPointsBalance?: string | undefined;
                                    metaLockedPointsBalance?: string | undefined;
                                    commentSubredditKarma?: number | undefined;
                                    postSubredditKarma?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    isSubredditProxyAccount?: boolean | undefined;
                                } | undefined;
                            } | undefined;
                        }[];
                        dist?: number | undefined;
                    } | undefined;
                }): WikiPageRevisionListing;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Revert a wiki page to revision
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_revert}
         */
        readonly revertWikiPage: {
            readonly name: "RevertWikiPage";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.RevertWikiPageRequest";
                encode(message: RevertWikiPageRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): RevertWikiPageRequest;
                fromJSON(object: any): RevertWikiPageRequest;
                toJSON(message: RevertWikiPageRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    page?: string;
                    revision?: string;
                } | undefined): RevertWikiPageRequest;
                fromPartial(object: {
                    subreddit?: string;
                    page?: string;
                    revision?: string;
                }): RevertWikiPageRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer; /**
                * Get a list of wiki pages for a subreddit
                *
                * @see {@link https://www.reddit.com/dev/api#GET_wiki_pages}
                */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Retrieve the current permission settings for page
         *
         * @see {@link https://www.reddit.com/dev/api#GET_wiki_settings_\{page\}}
         */
        readonly getWikiPageSettings: {
            readonly name: "GetWikiPageSettings";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.GetWikiPageSettingsRequest";
                encode(message: GetWikiPageSettingsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): GetWikiPageSettingsRequest;
                fromJSON(object: any): GetWikiPageSettingsRequest;
                toJSON(message: GetWikiPageSettingsRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    page?: string;
                } | undefined): GetWikiPageSettingsRequest;
                fromPartial(object: {
                    subreddit?: string;
                    page?: string;
                }): GetWikiPageSettingsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.wiki.WikiPageSettings";
                encode(message: WikiPageSettings_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): WikiPageSettings_2;
                fromJSON(object: any): WikiPageSettings_2;
                toJSON(message: WikiPageSettings_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        permLevel?: number;
                        editors?: {
                            id?: string | undefined;
                            data?: {
                                acceptChats?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                                awardeeKarma?: number | undefined;
                                awarderKarma?: number | undefined;
                                canCreateSubreddit?: boolean | undefined;
                                canEditName?: boolean | undefined;
                                coins?: number | undefined;
                                commentKarma?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                features?: {
                                    awardsOnStreams?: boolean | undefined;
                                    canMakeMobileTestBuildPurchases?: boolean | undefined;
                                    chatGroupRollout?: boolean | undefined;
                                    chatSubreddit?: boolean | undefined;
                                    chatUserSettings?: boolean | undefined;
                                    chat?: boolean | undefined;
                                    cookieConsentBanner?: boolean | undefined;
                                    crosspostNotif?: boolean | undefined;
                                    crowdControlForPost?: boolean | undefined;
                                    customFeedImage?: boolean | undefined;
                                    doNotTrack?: boolean | undefined;
                                    expensiveCoinsPackage?: boolean | undefined;
                                    isEmailPermissionRequired?: boolean | undefined;
                                    liveComments?: boolean | undefined;
                                    liveOrangereds?: boolean | undefined;
                                    modAwards?: boolean | undefined;
                                    modServiceMuteReads?: boolean | undefined;
                                    modServiceMuteWrites?: boolean | undefined;
                                    modlogCopyrightRemoval?: boolean | undefined;
                                    mwebNsfwXpromo?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                    mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                    mwebXpromoRevampV2?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoRevampV3?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    noreferrerToNoopener?: boolean | undefined;
                                    pollsMobile?: boolean | undefined;
                                    premiumSubscriptionsTable?: boolean | undefined;
                                    promotedTrendBlanks?: boolean | undefined;
                                    resizedStylesImages?: boolean | undefined;
                                    showAmpLink?: boolean | undefined;
                                    showNpsSurvey?: boolean | undefined;
                                    spezModal?: boolean | undefined;
                                    usePrefAccountDeployment?: boolean | undefined;
                                    userFlairMigrationTesting?: boolean | undefined;
                                    webhookConfig?: boolean | undefined;
                                } | undefined;
                                forcePasswordReset?: boolean | undefined;
                                goldCreddits?: number | undefined;
                                goldExpiration?: string | undefined;
                                hasAndroidSubscription?: boolean | undefined;
                                hasExternalAccount?: boolean | undefined;
                                hasGoldSubscription?: boolean | undefined;
                                hasIosSubscription?: boolean | undefined;
                                hasMail?: boolean | undefined;
                                hasModMail?: boolean | undefined;
                                hasPaypalSubscription?: boolean | undefined;
                                hasStripeSubscription?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                hasSubscribedToPremium?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                hasVisitedNewProfile?: boolean | undefined;
                                hideFromRobots?: boolean | undefined;
                                iconImg?: string | undefined;
                                id?: string | undefined;
                                inBeta?: boolean | undefined;
                                inChat?: boolean | undefined;
                                inRedesignBeta?: boolean | undefined;
                                inboxCount?: number | undefined;
                                isBlocked?: boolean | undefined;
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                isSponsor?: boolean | undefined;
                                isSuspended?: boolean | undefined;
                                linkKarma?: number | undefined;
                                modhash?: string | undefined;
                                name?: string | undefined;
                                newModmailExists?: boolean | undefined;
                                numFriends?: number | undefined;
                                over18?: boolean | undefined;
                                passwordSet?: boolean | undefined;
                                prefAutoplay?: boolean | undefined;
                                prefClickgadget?: number | undefined;
                                prefGeopopular?: string | undefined;
                                prefNightmode?: boolean | undefined;
                                prefNoProfanity?: boolean | undefined;
                                prefShowPresence?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                prefShowTrending?: boolean | undefined;
                                prefShowTwitter?: boolean | undefined;
                                prefTopKarmaSubreddits?: boolean | undefined;
                                prefVideoAutoplay?: boolean | undefined;
                                snoovatarImg?: string | undefined;
                                snoovatarSize?: number[];
                                subreddit?: {
                                    acceptFollowers?: boolean | undefined;
                                    accountsActiveIsFuzzed?: boolean | undefined;
                                    accountsActive?: number | undefined;
                                    activeUserCount?: number | undefined;
                                    advertiserCategory?: string | undefined;
                                    allOriginalContent?: boolean | undefined;
                                    allowChatPostCreation?: boolean | undefined;
                                    allowDiscovery?: boolean | undefined;
                                    allowGalleries?: boolean | undefined;
                                    allowImages?: boolean | undefined;
                                    allowPolls?: boolean | undefined;
                                    allowPredictionContributors?: boolean | undefined;
                                    allowPredictionsTournament?: boolean | undefined;
                                    allowPredictions?: boolean | undefined;
                                    allowTalks?: boolean | undefined;
                                    allowVideogifs?: boolean | undefined;
                                    allowVideos?: boolean | undefined;
                                    allowedMediaInComments?: string[];
                                    bannerBackgroundColor?: string | undefined;
                                    bannerBackgroundImage?: string | undefined;
                                    bannerImg?: string | undefined;
                                    bannerSize?: number[];
                                    canAssignLinkFlair?: boolean | undefined;
                                    canAssignUserFlair?: boolean | undefined;
                                    coins?: number | undefined;
                                    collapseDeletedComments?: boolean | undefined;
                                    commentContributionSettings?: {
                                        allowedMediaTypes?: string[];
                                    } | undefined;
                                    commentScoreHideMins?: number | undefined;
                                    communityIcon?: string | undefined;
                                    communityReviewed?: boolean | undefined;
                                    contentCategory?: string | undefined;
                                    createdUtc?: number | undefined;
                                    created?: number | undefined;
                                    defaultSet?: boolean | undefined;
                                    description?: string | undefined;
                                    descriptionHtml?: string | undefined;
                                    disableContributorRequests?: boolean | undefined;
                                    displayName?: string | undefined;
                                    displayNamePrefixed?: string | undefined;
                                    emojisCustomSize?: number[];
                                    emojisEnabled?: boolean | undefined;
                                    freeFormReports?: boolean | undefined;
                                    hasMenuWidget?: boolean | undefined;
                                    headerImg?: string | undefined;
                                    headerSize?: number[];
                                    headerTitle?: string | undefined;
                                    hideAds?: boolean | undefined;
                                    iconColor?: string | undefined;
                                    iconImg?: string | undefined;
                                    iconSize?: number[];
                                    id?: string | undefined;
                                    isChatPostFeatureEnabled?: boolean | undefined;
                                    isCrosspostableSubreddit?: boolean | undefined;
                                    isDefaultBanner?: boolean | undefined;
                                    isDefaultIcon?: boolean | undefined;
                                    isEnrolledInNewModmail?: boolean | undefined;
                                    keyColor?: string | undefined;
                                    lang?: string | undefined;
                                    linkFlairEnabled?: boolean | undefined;
                                    linkFlairPosition?: string | undefined;
                                    mobileBannerImage?: string | undefined;
                                    name?: string | undefined;
                                    notificationLevel?: string | undefined;
                                    originalContentTagEnabled?: string | undefined;
                                    over18?: boolean | undefined;
                                    predictionLeaderboardEntryType?: string | undefined;
                                    previousNames?: string[];
                                    primaryColor?: string | undefined;
                                    publicDescription?: string | undefined;
                                    publicDescriptionHtml?: string | undefined;
                                    publicTraffic?: boolean | undefined;
                                    quarantine?: boolean | undefined;
                                    restrictCommenting?: boolean | undefined;
                                    restrictPosting?: boolean | undefined;
                                    shouldArchivePosts?: boolean | undefined;
                                    shouldShowMediaInCommentsSetting?: boolean | undefined;
                                    showMedia?: boolean | undefined;
                                    showMediaPreview?: boolean | undefined;
                                    spoilersEnabled?: boolean | undefined;
                                    submissionType?: string | undefined;
                                    submitLinkLabel?: string | undefined;
                                    submitText?: string | undefined;
                                    submitTextHtml?: string | undefined;
                                    submitTextLabel?: string | undefined;
                                    subredditType?: string | undefined;
                                    subscribers?: number | undefined;
                                    suggestedCommentSort?: string | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    userCanFlairInSr?: boolean | undefined;
                                    userFlairBackgroundColor?: string | undefined;
                                    userFlairCssClass?: string | undefined;
                                    userFlairEnabledInSr?: boolean | undefined;
                                    userFlairPosition?: string | undefined;
                                    userFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    userFlairTemplateId?: string | undefined;
                                    userFlairText?: string | undefined;
                                    userFlairTextColor?: string | undefined;
                                    userFlairType?: string | undefined;
                                    userHasFavorited?: boolean | undefined;
                                    userIsBanned?: boolean | undefined;
                                    userIsContributor?: boolean | undefined;
                                    userIsModerator?: boolean | undefined;
                                    userIsSubscriber?: boolean | undefined;
                                    userSrFlairEnabled?: boolean | undefined;
                                    userSrThemeEnabled?: boolean | undefined;
                                    videostreamLinksCount?: number | undefined;
                                    whitelistStatus?: string | undefined;
                                    wikiEnabled?: boolean | undefined;
                                    wls?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    postRequirements?: {
                                        bodyRestrictionPolicy?: string | undefined;
                                    } | undefined;
                                    userIsMuted?: boolean;
                                } | undefined;
                                suspensionExpirationUtc?: string | undefined;
                                totalKarma?: number | undefined;
                                verified?: boolean | undefined;
                                hasPhoneNumber?: boolean | undefined;
                                subredditsModerated?: number | undefined;
                                hasMetaSubscription?: boolean | undefined;
                                metaSubscriptionAge?: number | undefined;
                                metaPointsBalance?: string | undefined;
                                metaLockedPointsBalance?: string | undefined;
                                commentSubredditKarma?: number | undefined;
                                postSubredditKarma?: number | undefined;
                                markedSpam?: boolean | undefined;
                                isSubredditProxyAccount?: boolean | undefined;
                            } | undefined;
                        }[];
                        listed?: boolean;
                    } | undefined;
                } | undefined): WikiPageSettings_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        permLevel?: number;
                        editors?: {
                            id?: string | undefined;
                            data?: {
                                acceptChats?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                                awardeeKarma?: number | undefined;
                                awarderKarma?: number | undefined;
                                canCreateSubreddit?: boolean | undefined;
                                canEditName?: boolean | undefined;
                                coins?: number | undefined;
                                commentKarma?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                features?: {
                                    awardsOnStreams?: boolean | undefined;
                                    canMakeMobileTestBuildPurchases?: boolean | undefined;
                                    chatGroupRollout?: boolean | undefined;
                                    chatSubreddit?: boolean | undefined;
                                    chatUserSettings?: boolean | undefined;
                                    chat?: boolean | undefined;
                                    cookieConsentBanner?: boolean | undefined;
                                    crosspostNotif?: boolean | undefined;
                                    crowdControlForPost?: boolean | undefined;
                                    customFeedImage?: boolean | undefined;
                                    doNotTrack?: boolean | undefined;
                                    expensiveCoinsPackage?: boolean | undefined;
                                    isEmailPermissionRequired?: boolean | undefined;
                                    liveComments?: boolean | undefined;
                                    liveOrangereds?: boolean | undefined;
                                    modAwards?: boolean | undefined;
                                    modServiceMuteReads?: boolean | undefined;
                                    modServiceMuteWrites?: boolean | undefined;
                                    modlogCopyrightRemoval?: boolean | undefined;
                                    mwebNsfwXpromo?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                    mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                    mwebXpromoRevampV2?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoRevampV3?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    noreferrerToNoopener?: boolean | undefined;
                                    pollsMobile?: boolean | undefined;
                                    premiumSubscriptionsTable?: boolean | undefined;
                                    promotedTrendBlanks?: boolean | undefined;
                                    resizedStylesImages?: boolean | undefined;
                                    showAmpLink?: boolean | undefined;
                                    showNpsSurvey?: boolean | undefined;
                                    spezModal?: boolean | undefined;
                                    usePrefAccountDeployment?: boolean | undefined;
                                    userFlairMigrationTesting?: boolean | undefined;
                                    webhookConfig?: boolean | undefined;
                                } | undefined;
                                forcePasswordReset?: boolean | undefined;
                                goldCreddits?: number | undefined;
                                goldExpiration?: string | undefined;
                                hasAndroidSubscription?: boolean | undefined;
                                hasExternalAccount?: boolean | undefined;
                                hasGoldSubscription?: boolean | undefined;
                                hasIosSubscription?: boolean | undefined;
                                hasMail?: boolean | undefined;
                                hasModMail?: boolean | undefined;
                                hasPaypalSubscription?: boolean | undefined;
                                hasStripeSubscription?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                hasSubscribedToPremium?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                hasVisitedNewProfile?: boolean | undefined;
                                hideFromRobots?: boolean | undefined;
                                iconImg?: string | undefined;
                                id?: string | undefined;
                                inBeta?: boolean | undefined;
                                inChat?: boolean | undefined;
                                inRedesignBeta?: boolean | undefined;
                                inboxCount?: number | undefined;
                                isBlocked?: boolean | undefined;
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                isSponsor?: boolean | undefined;
                                isSuspended?: boolean | undefined;
                                linkKarma?: number | undefined;
                                modhash?: string | undefined;
                                name?: string | undefined;
                                newModmailExists?: boolean | undefined;
                                numFriends?: number | undefined;
                                over18?: boolean | undefined;
                                passwordSet?: boolean | undefined;
                                prefAutoplay?: boolean | undefined;
                                prefClickgadget?: number | undefined;
                                prefGeopopular?: string | undefined;
                                prefNightmode?: boolean | undefined;
                                prefNoProfanity?: boolean | undefined;
                                prefShowPresence?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                prefShowTrending?: boolean | undefined;
                                prefShowTwitter?: boolean | undefined;
                                prefTopKarmaSubreddits?: boolean | undefined;
                                prefVideoAutoplay?: boolean | undefined;
                                snoovatarImg?: string | undefined;
                                snoovatarSize?: number[];
                                subreddit?: {
                                    acceptFollowers?: boolean | undefined;
                                    accountsActiveIsFuzzed?: boolean | undefined;
                                    accountsActive?: number | undefined;
                                    activeUserCount?: number | undefined;
                                    advertiserCategory?: string | undefined;
                                    allOriginalContent?: boolean | undefined;
                                    allowChatPostCreation?: boolean | undefined;
                                    allowDiscovery?: boolean | undefined;
                                    allowGalleries?: boolean | undefined;
                                    allowImages?: boolean | undefined;
                                    allowPolls?: boolean | undefined;
                                    allowPredictionContributors?: boolean | undefined;
                                    allowPredictionsTournament?: boolean | undefined;
                                    allowPredictions?: boolean | undefined;
                                    allowTalks?: boolean | undefined;
                                    allowVideogifs?: boolean | undefined;
                                    allowVideos?: boolean | undefined;
                                    allowedMediaInComments?: string[];
                                    bannerBackgroundColor?: string | undefined;
                                    bannerBackgroundImage?: string | undefined;
                                    bannerImg?: string | undefined;
                                    bannerSize?: number[];
                                    canAssignLinkFlair?: boolean | undefined;
                                    canAssignUserFlair?: boolean | undefined;
                                    coins?: number | undefined;
                                    collapseDeletedComments?: boolean | undefined;
                                    commentContributionSettings?: {
                                        allowedMediaTypes?: string[];
                                    } | undefined;
                                    commentScoreHideMins?: number | undefined;
                                    communityIcon?: string | undefined;
                                    communityReviewed?: boolean | undefined;
                                    contentCategory?: string | undefined;
                                    createdUtc?: number | undefined;
                                    created?: number | undefined;
                                    defaultSet?: boolean | undefined;
                                    description?: string | undefined;
                                    descriptionHtml?: string | undefined;
                                    disableContributorRequests?: boolean | undefined;
                                    displayName?: string | undefined;
                                    displayNamePrefixed?: string | undefined;
                                    emojisCustomSize?: number[];
                                    emojisEnabled?: boolean | undefined;
                                    freeFormReports?: boolean | undefined;
                                    hasMenuWidget?: boolean | undefined;
                                    headerImg?: string | undefined;
                                    headerSize?: number[];
                                    headerTitle?: string | undefined;
                                    hideAds?: boolean | undefined;
                                    iconColor?: string | undefined;
                                    iconImg?: string | undefined;
                                    iconSize?: number[];
                                    id?: string | undefined;
                                    isChatPostFeatureEnabled?: boolean | undefined;
                                    isCrosspostableSubreddit?: boolean | undefined;
                                    isDefaultBanner?: boolean | undefined;
                                    isDefaultIcon?: boolean | undefined;
                                    isEnrolledInNewModmail?: boolean | undefined;
                                    keyColor?: string | undefined;
                                    lang?: string | undefined;
                                    linkFlairEnabled?: boolean | undefined;
                                    linkFlairPosition?: string | undefined;
                                    mobileBannerImage?: string | undefined;
                                    name?: string | undefined;
                                    notificationLevel?: string | undefined;
                                    originalContentTagEnabled?: string | undefined;
                                    over18?: boolean | undefined;
                                    predictionLeaderboardEntryType?: string | undefined;
                                    previousNames?: string[];
                                    primaryColor?: string | undefined;
                                    publicDescription?: string | undefined;
                                    publicDescriptionHtml?: string | undefined;
                                    publicTraffic?: boolean | undefined;
                                    quarantine?: boolean | undefined;
                                    restrictCommenting?: boolean | undefined;
                                    restrictPosting?: boolean | undefined;
                                    shouldArchivePosts?: boolean | undefined;
                                    shouldShowMediaInCommentsSetting?: boolean | undefined;
                                    showMedia?: boolean | undefined;
                                    showMediaPreview?: boolean | undefined;
                                    spoilersEnabled?: boolean | undefined;
                                    submissionType?: string | undefined;
                                    submitLinkLabel?: string | undefined;
                                    submitText?: string | undefined;
                                    submitTextHtml?: string | undefined;
                                    submitTextLabel?: string | undefined;
                                    subredditType?: string | undefined;
                                    subscribers?: number | undefined;
                                    suggestedCommentSort?: string | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    userCanFlairInSr?: boolean | undefined;
                                    userFlairBackgroundColor?: string | undefined;
                                    userFlairCssClass?: string | undefined;
                                    userFlairEnabledInSr?: boolean | undefined;
                                    userFlairPosition?: string | undefined;
                                    userFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    userFlairTemplateId?: string | undefined;
                                    userFlairText?: string | undefined;
                                    userFlairTextColor?: string | undefined;
                                    userFlairType?: string | undefined;
                                    userHasFavorited?: boolean | undefined;
                                    userIsBanned?: boolean | undefined;
                                    userIsContributor?: boolean | undefined;
                                    userIsModerator?: boolean | undefined;
                                    userIsSubscriber?: boolean | undefined;
                                    userSrFlairEnabled?: boolean | undefined;
                                    userSrThemeEnabled?: boolean | undefined;
                                    videostreamLinksCount?: number | undefined;
                                    whitelistStatus?: string | undefined;
                                    wikiEnabled?: boolean | undefined;
                                    wls?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    postRequirements?: {
                                        bodyRestrictionPolicy?: string | undefined;
                                    } | undefined;
                                    userIsMuted?: boolean;
                                } | undefined;
                                suspensionExpirationUtc?: string | undefined;
                                totalKarma?: number | undefined;
                                verified?: boolean | undefined;
                                hasPhoneNumber?: boolean | undefined;
                                subredditsModerated?: number | undefined;
                                hasMetaSubscription?: boolean | undefined;
                                metaSubscriptionAge?: number | undefined;
                                metaPointsBalance?: string | undefined;
                                metaLockedPointsBalance?: string | undefined;
                                commentSubredditKarma?: number | undefined;
                                postSubredditKarma?: number | undefined;
                                markedSpam?: boolean | undefined;
                                isSubredditProxyAccount?: boolean | undefined;
                            } | undefined;
                        }[];
                        listed?: boolean;
                    } | undefined;
                }): WikiPageSettings_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Update the permissions and visibility of wiki page
         *
         * @see {@link https://www.reddit.com/dev/api#POST_wiki_settings_\{page\}}
         */
        readonly updateWikiPageSettings: {
            readonly name: "UpdateWikiPageSettings";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.UpdateWikiPageSettingsRequest";
                encode(message: UpdateWikiPageSettingsRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UpdateWikiPageSettingsRequest;
                fromJSON(object: any): UpdateWikiPageSettingsRequest;
                toJSON(message: UpdateWikiPageSettingsRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    page?: string;
                    permlevel?: number;
                    listed?: string;
                } | undefined): UpdateWikiPageSettingsRequest;
                fromPartial(object: {
                    subreddit?: string;
                    page?: string;
                    permlevel?: number;
                    listed?: string;
                }): UpdateWikiPageSettingsRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "devvit.plugin.redditapi.wiki.WikiPageSettings";
                encode(message: WikiPageSettings_2, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): WikiPageSettings_2;
                fromJSON(object: any): WikiPageSettings_2;
                toJSON(message: WikiPageSettings_2): unknown;
                create(base?: {
                    kind?: string;
                    data?: {
                        permLevel?: number;
                        editors?: {
                            id?: string | undefined;
                            data?: {
                                acceptChats?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                                awardeeKarma?: number | undefined;
                                awarderKarma?: number | undefined;
                                canCreateSubreddit?: boolean | undefined;
                                canEditName?: boolean | undefined;
                                coins?: number | undefined;
                                commentKarma?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                features?: {
                                    awardsOnStreams?: boolean | undefined;
                                    canMakeMobileTestBuildPurchases?: boolean | undefined;
                                    chatGroupRollout?: boolean | undefined;
                                    chatSubreddit?: boolean | undefined;
                                    chatUserSettings?: boolean | undefined;
                                    chat?: boolean | undefined;
                                    cookieConsentBanner?: boolean | undefined;
                                    crosspostNotif?: boolean | undefined;
                                    crowdControlForPost?: boolean | undefined;
                                    customFeedImage?: boolean | undefined;
                                    doNotTrack?: boolean | undefined;
                                    expensiveCoinsPackage?: boolean | undefined;
                                    isEmailPermissionRequired?: boolean | undefined;
                                    liveComments?: boolean | undefined;
                                    liveOrangereds?: boolean | undefined;
                                    modAwards?: boolean | undefined;
                                    modServiceMuteReads?: boolean | undefined;
                                    modServiceMuteWrites?: boolean | undefined;
                                    modlogCopyrightRemoval?: boolean | undefined;
                                    mwebNsfwXpromo?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                    mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                    mwebXpromoRevampV2?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoRevampV3?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    noreferrerToNoopener?: boolean | undefined;
                                    pollsMobile?: boolean | undefined;
                                    premiumSubscriptionsTable?: boolean | undefined;
                                    promotedTrendBlanks?: boolean | undefined;
                                    resizedStylesImages?: boolean | undefined;
                                    showAmpLink?: boolean | undefined;
                                    showNpsSurvey?: boolean | undefined;
                                    spezModal?: boolean | undefined;
                                    usePrefAccountDeployment?: boolean | undefined;
                                    userFlairMigrationTesting?: boolean | undefined;
                                    webhookConfig?: boolean | undefined;
                                } | undefined;
                                forcePasswordReset?: boolean | undefined;
                                goldCreddits?: number | undefined;
                                goldExpiration?: string | undefined;
                                hasAndroidSubscription?: boolean | undefined;
                                hasExternalAccount?: boolean | undefined;
                                hasGoldSubscription?: boolean | undefined;
                                hasIosSubscription?: boolean | undefined;
                                hasMail?: boolean | undefined;
                                hasModMail?: boolean | undefined;
                                hasPaypalSubscription?: boolean | undefined;
                                hasStripeSubscription?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                hasSubscribedToPremium?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                hasVisitedNewProfile?: boolean | undefined;
                                hideFromRobots?: boolean | undefined;
                                iconImg?: string | undefined;
                                id?: string | undefined;
                                inBeta?: boolean | undefined;
                                inChat?: boolean | undefined;
                                inRedesignBeta?: boolean | undefined;
                                inboxCount?: number | undefined;
                                isBlocked?: boolean | undefined;
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                isSponsor?: boolean | undefined;
                                isSuspended?: boolean | undefined;
                                linkKarma?: number | undefined;
                                modhash?: string | undefined;
                                name?: string | undefined;
                                newModmailExists?: boolean | undefined;
                                numFriends?: number | undefined;
                                over18?: boolean | undefined;
                                passwordSet?: boolean | undefined;
                                prefAutoplay?: boolean | undefined;
                                prefClickgadget?: number | undefined;
                                prefGeopopular?: string | undefined;
                                prefNightmode?: boolean | undefined;
                                prefNoProfanity?: boolean | undefined;
                                prefShowPresence?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                prefShowTrending?: boolean | undefined;
                                prefShowTwitter?: boolean | undefined;
                                prefTopKarmaSubreddits?: boolean | undefined;
                                prefVideoAutoplay?: boolean | undefined;
                                snoovatarImg?: string | undefined;
                                snoovatarSize?: number[];
                                subreddit?: {
                                    acceptFollowers?: boolean | undefined;
                                    accountsActiveIsFuzzed?: boolean | undefined;
                                    accountsActive?: number | undefined;
                                    activeUserCount?: number | undefined;
                                    advertiserCategory?: string | undefined;
                                    allOriginalContent?: boolean | undefined;
                                    allowChatPostCreation?: boolean | undefined;
                                    allowDiscovery?: boolean | undefined;
                                    allowGalleries?: boolean | undefined;
                                    allowImages?: boolean | undefined;
                                    allowPolls?: boolean | undefined;
                                    allowPredictionContributors?: boolean | undefined;
                                    allowPredictionsTournament?: boolean | undefined;
                                    allowPredictions?: boolean | undefined;
                                    allowTalks?: boolean | undefined;
                                    allowVideogifs?: boolean | undefined;
                                    allowVideos?: boolean | undefined;
                                    allowedMediaInComments?: string[];
                                    bannerBackgroundColor?: string | undefined;
                                    bannerBackgroundImage?: string | undefined;
                                    bannerImg?: string | undefined;
                                    bannerSize?: number[];
                                    canAssignLinkFlair?: boolean | undefined;
                                    canAssignUserFlair?: boolean | undefined;
                                    coins?: number | undefined;
                                    collapseDeletedComments?: boolean | undefined;
                                    commentContributionSettings?: {
                                        allowedMediaTypes?: string[];
                                    } | undefined;
                                    commentScoreHideMins?: number | undefined;
                                    communityIcon?: string | undefined;
                                    communityReviewed?: boolean | undefined;
                                    contentCategory?: string | undefined;
                                    createdUtc?: number | undefined;
                                    created?: number | undefined;
                                    defaultSet?: boolean | undefined;
                                    description?: string | undefined;
                                    descriptionHtml?: string | undefined;
                                    disableContributorRequests?: boolean | undefined;
                                    displayName?: string | undefined;
                                    displayNamePrefixed?: string | undefined;
                                    emojisCustomSize?: number[];
                                    emojisEnabled?: boolean | undefined;
                                    freeFormReports?: boolean | undefined;
                                    hasMenuWidget?: boolean | undefined;
                                    headerImg?: string | undefined;
                                    headerSize?: number[];
                                    headerTitle?: string | undefined;
                                    hideAds?: boolean | undefined;
                                    iconColor?: string | undefined;
                                    iconImg?: string | undefined;
                                    iconSize?: number[];
                                    id?: string | undefined;
                                    isChatPostFeatureEnabled?: boolean | undefined;
                                    isCrosspostableSubreddit?: boolean | undefined;
                                    isDefaultBanner?: boolean | undefined;
                                    isDefaultIcon?: boolean | undefined;
                                    isEnrolledInNewModmail?: boolean | undefined;
                                    keyColor?: string | undefined;
                                    lang?: string | undefined;
                                    linkFlairEnabled?: boolean | undefined;
                                    linkFlairPosition?: string | undefined;
                                    mobileBannerImage?: string | undefined;
                                    name?: string | undefined;
                                    notificationLevel?: string | undefined;
                                    originalContentTagEnabled?: string | undefined;
                                    over18?: boolean | undefined;
                                    predictionLeaderboardEntryType?: string | undefined;
                                    previousNames?: string[];
                                    primaryColor?: string | undefined;
                                    publicDescription?: string | undefined;
                                    publicDescriptionHtml?: string | undefined;
                                    publicTraffic?: boolean | undefined;
                                    quarantine?: boolean | undefined;
                                    restrictCommenting?: boolean | undefined;
                                    restrictPosting?: boolean | undefined;
                                    shouldArchivePosts?: boolean | undefined;
                                    shouldShowMediaInCommentsSetting?: boolean | undefined;
                                    showMedia?: boolean | undefined;
                                    showMediaPreview?: boolean | undefined;
                                    spoilersEnabled?: boolean | undefined;
                                    submissionType?: string | undefined;
                                    submitLinkLabel?: string | undefined;
                                    submitText?: string | undefined;
                                    submitTextHtml?: string | undefined;
                                    submitTextLabel?: string | undefined;
                                    subredditType?: string | undefined;
                                    subscribers?: number | undefined;
                                    suggestedCommentSort?: string | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    userCanFlairInSr?: boolean | undefined;
                                    userFlairBackgroundColor?: string | undefined;
                                    userFlairCssClass?: string | undefined;
                                    userFlairEnabledInSr?: boolean | undefined;
                                    userFlairPosition?: string | undefined;
                                    userFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    userFlairTemplateId?: string | undefined;
                                    userFlairText?: string | undefined;
                                    userFlairTextColor?: string | undefined;
                                    userFlairType?: string | undefined;
                                    userHasFavorited?: boolean | undefined;
                                    userIsBanned?: boolean | undefined;
                                    userIsContributor?: boolean | undefined;
                                    userIsModerator?: boolean | undefined;
                                    userIsSubscriber?: boolean | undefined;
                                    userSrFlairEnabled?: boolean | undefined;
                                    userSrThemeEnabled?: boolean | undefined;
                                    videostreamLinksCount?: number | undefined;
                                    whitelistStatus?: string | undefined;
                                    wikiEnabled?: boolean | undefined;
                                    wls?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    postRequirements?: {
                                        bodyRestrictionPolicy?: string | undefined;
                                    } | undefined;
                                    userIsMuted?: boolean;
                                } | undefined;
                                suspensionExpirationUtc?: string | undefined;
                                totalKarma?: number | undefined;
                                verified?: boolean | undefined;
                                hasPhoneNumber?: boolean | undefined;
                                subredditsModerated?: number | undefined;
                                hasMetaSubscription?: boolean | undefined;
                                metaSubscriptionAge?: number | undefined;
                                metaPointsBalance?: string | undefined;
                                metaLockedPointsBalance?: string | undefined;
                                commentSubredditKarma?: number | undefined;
                                postSubredditKarma?: number | undefined;
                                markedSpam?: boolean | undefined;
                                isSubredditProxyAccount?: boolean | undefined;
                            } | undefined;
                        }[];
                        listed?: boolean;
                    } | undefined;
                } | undefined): WikiPageSettings_2;
                fromPartial(object: {
                    kind?: string;
                    data?: {
                        permLevel?: number;
                        editors?: {
                            id?: string | undefined;
                            data?: {
                                acceptChats?: boolean | undefined;
                                acceptFollowers?: boolean | undefined;
                                acceptPms?: boolean | undefined;
                                awardeeKarma?: number | undefined;
                                awarderKarma?: number | undefined;
                                canCreateSubreddit?: boolean | undefined;
                                canEditName?: boolean | undefined;
                                coins?: number | undefined;
                                commentKarma?: number | undefined;
                                created?: number | undefined;
                                createdUtc?: number | undefined;
                                features?: {
                                    awardsOnStreams?: boolean | undefined;
                                    canMakeMobileTestBuildPurchases?: boolean | undefined;
                                    chatGroupRollout?: boolean | undefined;
                                    chatSubreddit?: boolean | undefined;
                                    chatUserSettings?: boolean | undefined;
                                    chat?: boolean | undefined;
                                    cookieConsentBanner?: boolean | undefined;
                                    crosspostNotif?: boolean | undefined;
                                    crowdControlForPost?: boolean | undefined;
                                    customFeedImage?: boolean | undefined;
                                    doNotTrack?: boolean | undefined;
                                    expensiveCoinsPackage?: boolean | undefined;
                                    isEmailPermissionRequired?: boolean | undefined;
                                    liveComments?: boolean | undefined;
                                    liveOrangereds?: boolean | undefined;
                                    modAwards?: boolean | undefined;
                                    modServiceMuteReads?: boolean | undefined;
                                    modServiceMuteWrites?: boolean | undefined;
                                    modlogCopyrightRemoval?: boolean | undefined;
                                    mwebNsfwXpromo?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoInterstitialCommentsAndroid?: boolean | undefined;
                                    mwebXpromoInterstitialCommentsIos?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleAndroid?: boolean | undefined;
                                    mwebXpromoModalListingClickDailyDismissibleIos?: boolean | undefined;
                                    mwebXpromoRevampV2?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    mwebXpromoRevampV3?: {
                                        experimentId?: number | undefined;
                                        owner?: string | undefined;
                                        variant?: string | undefined;
                                    } | undefined;
                                    noreferrerToNoopener?: boolean | undefined;
                                    pollsMobile?: boolean | undefined;
                                    premiumSubscriptionsTable?: boolean | undefined;
                                    promotedTrendBlanks?: boolean | undefined;
                                    resizedStylesImages?: boolean | undefined;
                                    showAmpLink?: boolean | undefined;
                                    showNpsSurvey?: boolean | undefined;
                                    spezModal?: boolean | undefined;
                                    usePrefAccountDeployment?: boolean | undefined;
                                    userFlairMigrationTesting?: boolean | undefined;
                                    webhookConfig?: boolean | undefined;
                                } | undefined;
                                forcePasswordReset?: boolean | undefined;
                                goldCreddits?: number | undefined;
                                goldExpiration?: string | undefined;
                                hasAndroidSubscription?: boolean | undefined;
                                hasExternalAccount?: boolean | undefined;
                                hasGoldSubscription?: boolean | undefined;
                                hasIosSubscription?: boolean | undefined;
                                hasMail?: boolean | undefined;
                                hasModMail?: boolean | undefined;
                                hasPaypalSubscription?: boolean | undefined;
                                hasStripeSubscription?: boolean | undefined;
                                hasSubscribed?: boolean | undefined;
                                hasSubscribedToPremium?: boolean | undefined;
                                hasVerifiedEmail?: boolean | undefined;
                                hasVisitedNewProfile?: boolean | undefined;
                                hideFromRobots?: boolean | undefined;
                                iconImg?: string | undefined;
                                id?: string | undefined;
                                inBeta?: boolean | undefined;
                                inChat?: boolean | undefined;
                                inRedesignBeta?: boolean | undefined;
                                inboxCount?: number | undefined;
                                isBlocked?: boolean | undefined;
                                isEmployee?: boolean | undefined;
                                isFriend?: boolean | undefined;
                                isGold?: boolean | undefined;
                                isMod?: boolean | undefined;
                                isSponsor?: boolean | undefined;
                                isSuspended?: boolean | undefined;
                                linkKarma?: number | undefined;
                                modhash?: string | undefined;
                                name?: string | undefined;
                                newModmailExists?: boolean | undefined;
                                numFriends?: number | undefined;
                                over18?: boolean | undefined;
                                passwordSet?: boolean | undefined;
                                prefAutoplay?: boolean | undefined;
                                prefClickgadget?: number | undefined;
                                prefGeopopular?: string | undefined;
                                prefNightmode?: boolean | undefined;
                                prefNoProfanity?: boolean | undefined;
                                prefShowPresence?: boolean | undefined;
                                prefShowSnoovatar?: boolean | undefined;
                                prefShowTrending?: boolean | undefined;
                                prefShowTwitter?: boolean | undefined;
                                prefTopKarmaSubreddits?: boolean | undefined;
                                prefVideoAutoplay?: boolean | undefined;
                                snoovatarImg?: string | undefined;
                                snoovatarSize?: number[];
                                subreddit?: {
                                    acceptFollowers?: boolean | undefined;
                                    accountsActiveIsFuzzed?: boolean | undefined;
                                    accountsActive?: number | undefined;
                                    activeUserCount?: number | undefined;
                                    advertiserCategory?: string | undefined;
                                    allOriginalContent?: boolean | undefined;
                                    allowChatPostCreation?: boolean | undefined;
                                    allowDiscovery?: boolean | undefined;
                                    allowGalleries?: boolean | undefined;
                                    allowImages?: boolean | undefined;
                                    allowPolls?: boolean | undefined;
                                    allowPredictionContributors?: boolean | undefined;
                                    allowPredictionsTournament?: boolean | undefined;
                                    allowPredictions?: boolean | undefined;
                                    allowTalks?: boolean | undefined;
                                    allowVideogifs?: boolean | undefined;
                                    allowVideos?: boolean | undefined;
                                    allowedMediaInComments?: string[];
                                    bannerBackgroundColor?: string | undefined;
                                    bannerBackgroundImage?: string | undefined;
                                    bannerImg?: string | undefined;
                                    bannerSize?: number[];
                                    canAssignLinkFlair?: boolean | undefined;
                                    canAssignUserFlair?: boolean | undefined;
                                    coins?: number | undefined;
                                    collapseDeletedComments?: boolean | undefined;
                                    commentContributionSettings?: {
                                        allowedMediaTypes?: string[];
                                    } | undefined;
                                    commentScoreHideMins?: number | undefined;
                                    communityIcon?: string | undefined;
                                    communityReviewed?: boolean | undefined;
                                    contentCategory?: string | undefined;
                                    createdUtc?: number | undefined;
                                    created?: number | undefined;
                                    defaultSet?: boolean | undefined;
                                    description?: string | undefined;
                                    descriptionHtml?: string | undefined;
                                    disableContributorRequests?: boolean | undefined;
                                    displayName?: string | undefined;
                                    displayNamePrefixed?: string | undefined;
                                    emojisCustomSize?: number[];
                                    emojisEnabled?: boolean | undefined;
                                    freeFormReports?: boolean | undefined;
                                    hasMenuWidget?: boolean | undefined;
                                    headerImg?: string | undefined;
                                    headerSize?: number[];
                                    headerTitle?: string | undefined;
                                    hideAds?: boolean | undefined;
                                    iconColor?: string | undefined;
                                    iconImg?: string | undefined;
                                    iconSize?: number[];
                                    id?: string | undefined;
                                    isChatPostFeatureEnabled?: boolean | undefined;
                                    isCrosspostableSubreddit?: boolean | undefined;
                                    isDefaultBanner?: boolean | undefined;
                                    isDefaultIcon?: boolean | undefined;
                                    isEnrolledInNewModmail?: boolean | undefined;
                                    keyColor?: string | undefined;
                                    lang?: string | undefined;
                                    linkFlairEnabled?: boolean | undefined;
                                    linkFlairPosition?: string | undefined;
                                    mobileBannerImage?: string | undefined;
                                    name?: string | undefined;
                                    notificationLevel?: string | undefined;
                                    originalContentTagEnabled?: string | undefined;
                                    over18?: boolean | undefined;
                                    predictionLeaderboardEntryType?: string | undefined;
                                    previousNames?: string[];
                                    primaryColor?: string | undefined;
                                    publicDescription?: string | undefined;
                                    publicDescriptionHtml?: string | undefined;
                                    publicTraffic?: boolean | undefined;
                                    quarantine?: boolean | undefined;
                                    restrictCommenting?: boolean | undefined;
                                    restrictPosting?: boolean | undefined;
                                    shouldArchivePosts?: boolean | undefined;
                                    shouldShowMediaInCommentsSetting?: boolean | undefined;
                                    showMedia?: boolean | undefined;
                                    showMediaPreview?: boolean | undefined;
                                    spoilersEnabled?: boolean | undefined;
                                    submissionType?: string | undefined;
                                    submitLinkLabel?: string | undefined;
                                    submitText?: string | undefined;
                                    submitTextHtml?: string | undefined;
                                    submitTextLabel?: string | undefined;
                                    subredditType?: string | undefined;
                                    subscribers?: number | undefined;
                                    suggestedCommentSort?: string | undefined;
                                    title?: string | undefined;
                                    url?: string | undefined;
                                    userCanFlairInSr?: boolean | undefined;
                                    userFlairBackgroundColor?: string | undefined;
                                    userFlairCssClass?: string | undefined;
                                    userFlairEnabledInSr?: boolean | undefined;
                                    userFlairPosition?: string | undefined;
                                    userFlairRichtext?: {
                                        e?: string | undefined;
                                        t?: string | undefined;
                                    }[];
                                    userFlairTemplateId?: string | undefined;
                                    userFlairText?: string | undefined;
                                    userFlairTextColor?: string | undefined;
                                    userFlairType?: string | undefined;
                                    userHasFavorited?: boolean | undefined;
                                    userIsBanned?: boolean | undefined;
                                    userIsContributor?: boolean | undefined;
                                    userIsModerator?: boolean | undefined;
                                    userIsSubscriber?: boolean | undefined;
                                    userSrFlairEnabled?: boolean | undefined;
                                    userSrThemeEnabled?: boolean | undefined;
                                    videostreamLinksCount?: number | undefined;
                                    whitelistStatus?: string | undefined;
                                    wikiEnabled?: boolean | undefined;
                                    wls?: number | undefined;
                                    markedSpam?: boolean | undefined;
                                    postRequirements?: {
                                        bodyRestrictionPolicy?: string | undefined;
                                    } | undefined;
                                    userIsMuted?: boolean;
                                } | undefined;
                                suspensionExpirationUtc?: string | undefined;
                                totalKarma?: number | undefined;
                                verified?: boolean | undefined;
                                hasPhoneNumber?: boolean | undefined;
                                subredditsModerated?: number | undefined;
                                hasMetaSubscription?: boolean | undefined;
                                metaSubscriptionAge?: number | undefined;
                                metaPointsBalance?: string | undefined;
                                metaLockedPointsBalance?: string | undefined;
                                commentSubredditKarma?: number | undefined;
                                postSubredditKarma?: number | undefined;
                                markedSpam?: boolean | undefined;
                                isSubredditProxyAccount?: boolean | undefined;
                            } | undefined;
                        }[];
                        listed?: boolean;
                    } | undefined;
                }): WikiPageSettings_2;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
        /**
         * Allow/deny username to edit this wiki page
         * Note act must be either "add" or "del"
         *
         * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_alloweditor_\{act\}}
         */
        readonly allowEditor: {
            readonly name: "AllowEditor";
            readonly requestType: {
                $type: "devvit.plugin.redditapi.wiki.AllowEditorRequest";
                encode(message: AllowEditorRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AllowEditorRequest;
                fromJSON(object: any): AllowEditorRequest;
                toJSON(message: AllowEditorRequest): unknown;
                create(base?: {
                    subreddit?: string;
                    page?: string;
                    act?: string;
                    username?: string;
                } | undefined): AllowEditorRequest;
                fromPartial(object: {
                    subreddit?: string;
                    page?: string;
                    act?: string;
                    username?: string;
                }): AllowEditorRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Empty";
                encode(_: Empty, writer?: _m0.Writer): _m0.Writer; /**
                * Get a list of wiki pages for a subreddit
                *
                * @see {@link https://www.reddit.com/dev/api#GET_wiki_pages}
                */
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Empty;
                fromJSON(_: any): Empty;
                toJSON(_: Empty): unknown;
                create(base?: {} | undefined): Empty;
                fromPartial(_: {}): Empty;
            };
            readonly responseStream: false;
            readonly options: {
                readonly _unknownFields: {
                    readonly 480010: readonly [Uint8Array];
                };
            };
        };
    };
};

export declare class WikiPage {
    #private;
    /** The name of the page. */
    get name(): string;
    /** The name of the subreddit the page is in. */
    get subredditName(): string;
    /** The Markdown content of the page. */
    get content(): string;
    /** The ID of the revision. */
    get revisionId(): string;
    /** The date of the revision. */
    get revisionDate(): Date;
    /** The reason for the revision. */
    get revisionReason(): string;
    /** The author of this revision. */
    get revisionAuthor(): User;
    toJSON(): Pick<WikiPage, 'name' | 'subredditName' | 'content' | 'revisionId' | 'revisionDate' | 'revisionReason'> & {
        revisionAuthor: ReturnType<User['toJSON']>;
    };
    /** Update this page. */
    update(content: string, reason?: string): Promise<WikiPage>;
    /** Get the revisions for this page. */
    getRevisions(options: Omit<GetPageRevisionsOptions, 'subredditName' | 'page'>): Promise<Listing<WikiPageRevision>>;
    /** Revert this page to a previous revision. */
    revertTo(revisionId: string): Promise<void>;
    /** Get the settings for this page. */
    getSettings(): Promise<WikiPageSettings>;
    /** Update the settings for this page. */
    updateSettings(options: Omit<UpdatePageSettingsOptions, 'subredditName' | 'page'>): Promise<WikiPageSettings>;
    /** Add an editor to this page. */
    addEditor(username: string): Promise<void>;
    /** Remove an editor from this page. */
    removeEditor(username: string): Promise<void>;
}

declare interface WikiPage_2 {
    /** The markdown content of the wiki page. */
    contentMd: string;
    /** The HTML content of the wiki page. */
    contentHtml: string;
    /** The revision ID of the wiki page. */
    revisionId: string;
    /** The date of the wiki page's last revision. */
    revisionDate: number;
    /** Whether the wiki page can be revised. */
    mayRevise: boolean;
    /** The reason for the wiki page's last revision. */
    reason?: string | undefined;
    /** The user who last edited the wiki page. */
    revisionBy?: WrappedUserObject | undefined;
}

declare const WikiPage_2: {
    $type: "devvit.plugin.redditapi.wiki.WikiPage";
    encode(message: WikiPage_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WikiPage_2;
    fromJSON(object: any): WikiPage_2;
    toJSON(message: WikiPage_2): unknown;
    create(base?: DeepPartial_9<WikiPage_2>): WikiPage_2;
    fromPartial(object: DeepPartial_9<WikiPage_2>): WikiPage_2;
};

export declare enum WikiPagePermissionLevel {
    /** Use subreddit wiki permissions */
    SUBREDDIT_PERMISSIONS = 0,
    /** Only approved wiki contributors for this page may edit */
    APPROVED_CONTRIBUTORS_ONLY = 1,
    /** Only mods may edit and view */
    MODS_ONLY = 2
}

export declare class WikiPageRevision {
    #private;
    constructor(data: WikiPageRevision_2, metadata: Metadata | undefined);
    get id(): string;
    get page(): string;
    get date(): Date;
    get author(): User;
    get reason(): string;
    get hidden(): boolean;
    toJSON(): Pick<WikiPageRevision, 'id' | 'page' | 'date' | 'reason' | 'hidden'> & {
        author: ReturnType<User['toJSON']>;
    };
}

declare interface WikiPageRevision_2 {
    /** ID of the revision. */
    id: string;
    /** The name of the wiki page. */
    page: string;
    /** The date of the revision. */
    timestamp: number;
    /** The reason for the revision. */
    reason: string;
    /** Whether the revision is hidden. */
    revisionHidden: boolean;
    /** The user who made the revision. */
    author?: WrappedUserObject | undefined;
}

declare const WikiPageRevision_2: {
    $type: "devvit.plugin.redditapi.wiki.WikiPageRevision";
    encode(message: WikiPageRevision_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WikiPageRevision_2;
    fromJSON(object: any): WikiPageRevision_2;
    toJSON(message: WikiPageRevision_2): unknown;
    create(base?: DeepPartial_9<WikiPageRevision_2>): WikiPageRevision_2;
    fromPartial(object: DeepPartial_9<WikiPageRevision_2>): WikiPageRevision_2;
};

declare interface WikiPageRevisionListing {
    /** String value: "Listing" */
    kind: string;
    /** The data of the wiki page revision listing. */
    data?: WikiPageRevisionListing_Data | undefined;
}

declare const WikiPageRevisionListing: {
    $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing";
    encode(message: WikiPageRevisionListing, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WikiPageRevisionListing;
    fromJSON(object: any): WikiPageRevisionListing;
    toJSON(message: WikiPageRevisionListing): unknown;
    create(base?: DeepPartial_9<WikiPageRevisionListing>): WikiPageRevisionListing;
    fromPartial(object: DeepPartial_9<WikiPageRevisionListing>): WikiPageRevisionListing;
};

declare interface WikiPageRevisionListing_Data {
    /**
     * If present, use this as the `after` parameter when calling the same
     * API again to fetch the next page
     */
    after?: string | undefined;
    /**
     * If present, use this as the `before` parameter when calling the same
     * API again to fetch the previous page
     */
    before?: string | undefined;
    /** Contents of the current page of the listing */
    children: WikiPageRevision_2[];
    /**
     * Number of objects in `children`
     * Note: Only counts immediate entries in `children` and does not count
     *       nested objects such as comment trees
     */
    dist?: number | undefined;
}

declare const WikiPageRevisionListing_Data: {
    $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing.Data";
    encode(message: WikiPageRevisionListing_Data, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WikiPageRevisionListing_Data;
    fromJSON(object: any): WikiPageRevisionListing_Data;
    toJSON(message: WikiPageRevisionListing_Data): unknown;
    create(base?: DeepPartial_9<WikiPageRevisionListing_Data>): WikiPageRevisionListing_Data;
    fromPartial(object: DeepPartial_9<WikiPageRevisionListing_Data>): WikiPageRevisionListing_Data;
};

export declare class WikiPageSettings {
    #private;
    constructor(data: WikiPageSettings_Data, metadata: Metadata | undefined);
    get listed(): boolean;
    get permLevel(): WikiPagePermissionLevel;
    get editors(): User[];
    toJSON(): Pick<WikiPageSettings, 'listed' | 'permLevel'> & {
        editors: ReturnType<User['toJSON']>[];
    };
}

declare interface WikiPageSettings_2 {
    /** String value: "wikipagesettings" */
    kind: string;
    /** The data of the wiki page settings. */
    data?: WikiPageSettings_Data | undefined;
}

declare const WikiPageSettings_2: {
    $type: "devvit.plugin.redditapi.wiki.WikiPageSettings";
    encode(message: WikiPageSettings_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WikiPageSettings_2;
    fromJSON(object: any): WikiPageSettings_2;
    toJSON(message: WikiPageSettings_2): unknown;
    create(base?: DeepPartial_9<WikiPageSettings_2>): WikiPageSettings_2;
    fromPartial(object: DeepPartial_9<WikiPageSettings_2>): WikiPageSettings_2;
};

declare interface WikiPageSettings_Data {
    /** The permission level required to edit the wiki page. */
    permLevel: number;
    /** The users who can edit the wiki page. */
    editors: WrappedUserObject[];
    /** Whether the wiki page is listed. */
    listed: boolean;
}

declare const WikiPageSettings_Data: {
    $type: "devvit.plugin.redditapi.wiki.WikiPageSettings.Data";
    encode(message: WikiPageSettings_Data, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WikiPageSettings_Data;
    fromJSON(object: any): WikiPageSettings_Data;
    toJSON(message: WikiPageSettings_Data): unknown;
    create(base?: DeepPartial_9<WikiPageSettings_Data>): WikiPageSettings_Data;
    fromPartial(object: DeepPartial_9<WikiPageSettings_Data>): WikiPageSettings_Data;
};

declare const WikiServiceName = "devvit.plugin.redditapi.wiki.Wiki";

export declare type WithUserData = {
    user?: ConversationUserData;
};

declare interface WorkerQuery {
    hostname: string;
}

declare const WorkerQuery: {
    $type: "devvit.runtime.actor.WorkerQuery";
    encode(message: WorkerQuery, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WorkerQuery;
    fromJSON(object: any): WorkerQuery;
    toJSON(message: WorkerQuery): unknown;
    create(base?: DeepPartial_108<WorkerQuery>): WorkerQuery;
    fromPartial(object: DeepPartial_108<WorkerQuery>): WorkerQuery;
};

declare interface WqCleanup {
    cursor: number;
}

declare const WqCleanup: {
    $type: "devvit.events.v1alpha.WqCleanup";
    encode(message: WqCleanup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WqCleanup;
    fromJSON(object: any): WqCleanup;
    toJSON(message: WqCleanup): unknown;
    create(base?: DeepPartial_109<WqCleanup>): WqCleanup;
    fromPartial(object: DeepPartial_109<WqCleanup>): WqCleanup;
};

/** A WrappedRedditObject couples a RedditObject with a type identifier */
declare interface WrappedRedditObject {
    /** Thing ID prefix to identify what kind of object this is */
    kind: string;
    /** Object data of type `kind` */
    data?: RedditObject | undefined;
}

declare const WrappedRedditObject: {
    $type: "devvit.plugin.redditapi.common.WrappedRedditObject";
    encode(message: WrappedRedditObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WrappedRedditObject;
    fromJSON(object: any): WrappedRedditObject;
    toJSON(message: WrappedRedditObject): unknown;
    create(base?: DeepPartial_8<WrappedRedditObject>): WrappedRedditObject;
    fromPartial(object: DeepPartial_8<WrappedRedditObject>): WrappedRedditObject;
};

declare interface WrappedUserObject {
    id?: string | undefined;
    data?: User_2 | undefined;
}

declare const WrappedUserObject: {
    $type: "devvit.plugin.redditapi.common.WrappedUserObject";
    encode(message: WrappedUserObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WrappedUserObject;
    fromJSON(object: any): WrappedUserObject;
    toJSON(message: WrappedUserObject): unknown;
    create(base?: DeepPartial_8<WrappedUserObject>): WrappedUserObject;
    fromPartial(object: DeepPartial_8<WrappedUserObject>): WrappedUserObject;
};

declare interface WrapperTypes {
    StringRequest(request: StringValue, metadata?: Metadata): Promise<StringValue>;
    BoolRequest(request: BoolValue, metadata?: Metadata): Promise<BoolValue>;
    Int32Request(request: Int32Value, metadata?: Metadata): Promise<Int32Value>;
    UInt32Request(request: UInt32Value, metadata?: Metadata): Promise<UInt32Value>;
    Int64Request(request: Int64Value, metadata?: Metadata): Promise<Int64Value>;
    UInt64Request(request: UInt64Value, metadata?: Metadata): Promise<UInt64Value>;
    FloatRequest(request: FloatValue, metadata?: Metadata): Promise<FloatValue>;
    DoubleRequest(request: DoubleValue, metadata?: Metadata): Promise<DoubleValue>;
}

declare class WrapperTypesClientImpl implements WrapperTypes {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc_34, opts?: {
        service?: string;
    });
    StringRequest(request: StringValue, metadata?: Metadata): Promise<StringValue>;
    BoolRequest(request: BoolValue, metadata?: Metadata): Promise<BoolValue>;
    Int32Request(request: Int32Value, metadata?: Metadata): Promise<Int32Value>;
    UInt32Request(request: UInt32Value, metadata?: Metadata): Promise<UInt32Value>;
    Int64Request(request: Int64Value, metadata?: Metadata): Promise<Int64Value>;
    UInt64Request(request: UInt64Value, metadata?: Metadata): Promise<UInt64Value>;
    FloatRequest(request: FloatValue, metadata?: Metadata): Promise<FloatValue>;
    DoubleRequest(request: DoubleValue, metadata?: Metadata): Promise<DoubleValue>;
}

declare type WrapperTypesDefinition = typeof WrapperTypesDefinition;

declare const WrapperTypesDefinition: {
    readonly name: "WrapperTypes";
    readonly fullName: "devvit.actor.test.WrapperTypes";
    readonly methods: {
        readonly stringRequest: {
            readonly name: "StringRequest";
            readonly requestType: {
                $type: "google.protobuf.StringValue";
                encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StringValue;
                fromJSON(object: any): StringValue;
                toJSON(message: StringValue): unknown;
                create(base?: {
                    value?: string;
                } | undefined): StringValue;
                fromPartial(object: {
                    value?: string;
                }): StringValue;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.StringValue";
                encode(message: StringValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): StringValue;
                fromJSON(object: any): StringValue;
                toJSON(message: StringValue): unknown;
                create(base?: {
                    value?: string;
                } | undefined): StringValue;
                fromPartial(object: {
                    value?: string;
                }): StringValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly boolRequest: {
            readonly name: "BoolRequest";
            readonly requestType: {
                $type: "google.protobuf.BoolValue";
                encode(message: BoolValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BoolValue;
                fromJSON(object: any): BoolValue;
                toJSON(message: BoolValue): unknown;
                create(base?: {
                    value?: boolean;
                } | undefined): BoolValue;
                fromPartial(object: {
                    value?: boolean;
                }): BoolValue;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.BoolValue";
                encode(message: BoolValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): BoolValue;
                fromJSON(object: any): BoolValue;
                toJSON(message: BoolValue): unknown;
                create(base?: {
                    value?: boolean;
                } | undefined): BoolValue;
                fromPartial(object: {
                    value?: boolean;
                }): BoolValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly int32Request: {
            readonly name: "Int32Request";
            readonly requestType: {
                $type: "google.protobuf.Int32Value";
                encode(message: Int32Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int32Value;
                fromJSON(object: any): Int32Value;
                toJSON(message: Int32Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int32Value;
                fromPartial(object: {
                    value?: number;
                }): Int32Value;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int32Value";
                encode(message: Int32Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int32Value;
                fromJSON(object: any): Int32Value;
                toJSON(message: Int32Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int32Value;
                fromPartial(object: {
                    value?: number;
                }): Int32Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly uInt32Request: {
            readonly name: "UInt32Request";
            readonly requestType: {
                $type: "google.protobuf.UInt32Value";
                encode(message: UInt32Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UInt32Value;
                fromJSON(object: any): UInt32Value;
                toJSON(message: UInt32Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): UInt32Value;
                fromPartial(object: {
                    value?: number;
                }): UInt32Value;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.UInt32Value";
                encode(message: UInt32Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UInt32Value;
                fromJSON(object: any): UInt32Value;
                toJSON(message: UInt32Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): UInt32Value;
                fromPartial(object: {
                    value?: number;
                }): UInt32Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly int64Request: {
            readonly name: "Int64Request";
            readonly requestType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.Int64Value";
                encode(message: Int64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Int64Value;
                fromJSON(object: any): Int64Value;
                toJSON(message: Int64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): Int64Value;
                fromPartial(object: {
                    value?: number;
                }): Int64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly uInt64Request: {
            readonly name: "UInt64Request";
            readonly requestType: {
                $type: "google.protobuf.UInt64Value";
                encode(message: UInt64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UInt64Value;
                fromJSON(object: any): UInt64Value;
                toJSON(message: UInt64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): UInt64Value;
                fromPartial(object: {
                    value?: number;
                }): UInt64Value;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.UInt64Value";
                encode(message: UInt64Value, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): UInt64Value;
                fromJSON(object: any): UInt64Value;
                toJSON(message: UInt64Value): unknown;
                create(base?: {
                    value?: number;
                } | undefined): UInt64Value;
                fromPartial(object: {
                    value?: number;
                }): UInt64Value;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly floatRequest: {
            readonly name: "FloatRequest";
            readonly requestType: {
                $type: "google.protobuf.FloatValue";
                encode(message: FloatValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FloatValue;
                fromJSON(object: any): FloatValue;
                toJSON(message: FloatValue): unknown;
                create(base?: {
                    value?: number;
                } | undefined): FloatValue;
                fromPartial(object: {
                    value?: number;
                }): FloatValue;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.FloatValue";
                encode(message: FloatValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): FloatValue;
                fromJSON(object: any): FloatValue;
                toJSON(message: FloatValue): unknown;
                create(base?: {
                    value?: number;
                } | undefined): FloatValue;
                fromPartial(object: {
                    value?: number;
                }): FloatValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
        readonly doubleRequest: {
            readonly name: "DoubleRequest";
            readonly requestType: {
                $type: "google.protobuf.DoubleValue";
                encode(message: DoubleValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DoubleValue;
                fromJSON(object: any): DoubleValue;
                toJSON(message: DoubleValue): unknown;
                create(base?: {
                    value?: number;
                } | undefined): DoubleValue;
                fromPartial(object: {
                    value?: number;
                }): DoubleValue;
            };
            readonly requestStream: false;
            readonly responseType: {
                $type: "google.protobuf.DoubleValue";
                encode(message: DoubleValue, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DoubleValue;
                fromJSON(object: any): DoubleValue;
                toJSON(message: DoubleValue): unknown;
                create(base?: {
                    value?: number;
                } | undefined): DoubleValue;
                fromPartial(object: {
                    value?: number;
                }): DoubleValue;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};

declare const WrapperTypesServiceName = "devvit.actor.test.WrapperTypes";

declare interface ZAddRequest {
    key: string;
    members: ZMember_2[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const ZAddRequest: {
    $type: "devvit.plugin.redis.ZAddRequest";
    encode(message: ZAddRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZAddRequest;
    fromJSON(object: any): ZAddRequest;
    toJSON(message: ZAddRequest): unknown;
    create(base?: DeepPartial_86<ZAddRequest>): ZAddRequest;
    fromPartial(object: DeepPartial_86<ZAddRequest>): ZAddRequest;
};

declare interface ZIncrByRequest {
    key: string;
    member: string;
    value: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const ZIncrByRequest: {
    $type: "devvit.plugin.redis.ZIncrByRequest";
    encode(message: ZIncrByRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZIncrByRequest;
    fromJSON(object: any): ZIncrByRequest;
    toJSON(message: ZIncrByRequest): unknown;
    create(base?: DeepPartial_86<ZIncrByRequest>): ZIncrByRequest;
    fromPartial(object: DeepPartial_86<ZIncrByRequest>): ZIncrByRequest;
};

export declare type ZMember = {
    score: number;
    member: string;
};

declare interface ZMember_2 {
    score: number;
    member: string;
}

declare const ZMember_2: {
    $type: "devvit.plugin.redis.ZMember";
    encode(message: ZMember_2, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZMember_2;
    fromJSON(object: any): ZMember_2;
    toJSON(message: ZMember_2): unknown;
    create(base?: DeepPartial_86<ZMember_2>): ZMember_2;
    fromPartial(object: DeepPartial_86<ZMember_2>): ZMember_2;
};

declare interface ZMembers {
    members: ZMember_2[];
}

declare const ZMembers: {
    $type: "devvit.plugin.redis.ZMembers";
    encode(message: ZMembers, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZMembers;
    fromJSON(object: any): ZMembers;
    toJSON(message: ZMembers): unknown;
    create(base?: DeepPartial_86<ZMembers>): ZMembers;
    fromPartial(object: DeepPartial_86<ZMembers>): ZMembers;
};

declare interface ZRangeByLexRequest {
    key?: KeyRequest | undefined;
    min: string;
    max: string;
    scope?: RedisKeyScope | undefined;
}

declare const ZRangeByLexRequest: {
    $type: "devvit.plugin.redis.ZRangeByLexRequest";
    encode(message: ZRangeByLexRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZRangeByLexRequest;
    fromJSON(object: any): ZRangeByLexRequest;
    toJSON(message: ZRangeByLexRequest): unknown;
    create(base?: DeepPartial_86<ZRangeByLexRequest>): ZRangeByLexRequest;
    fromPartial(object: DeepPartial_86<ZRangeByLexRequest>): ZRangeByLexRequest;
};

export declare type ZRangeByScoreOptions = {
    withScores?: boolean;
    limit?: {
        offset: number;
        count: number;
    };
};

declare interface ZRangeByScoreRequest {
    key?: KeyRequest | undefined;
    min: number;
    max: number;
    withScores: boolean;
    scope?: RedisKeyScope | undefined;
}

declare const ZRangeByScoreRequest: {
    $type: "devvit.plugin.redis.ZRangeByScoreRequest";
    encode(message: ZRangeByScoreRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZRangeByScoreRequest;
    fromJSON(object: any): ZRangeByScoreRequest;
    toJSON(message: ZRangeByScoreRequest): unknown;
    create(base?: DeepPartial_86<ZRangeByScoreRequest>): ZRangeByScoreRequest;
    fromPartial(object: DeepPartial_86<ZRangeByScoreRequest>): ZRangeByScoreRequest;
};

export declare type ZRangeOptions = {
    /**
     * Reverses the sorted set, with index 0 as the element with the highest
     * score.
     */
    reverse?: boolean;
    by: 'score' | 'lex' | 'rank';
};

declare interface ZRangeRequest {
    key?: KeyRequest | undefined;
    start: string;
    stop: string;
    byScore: boolean;
    byLex: boolean;
    rev: boolean;
    offset: number;
    count: number;
    scope?: RedisKeyScope | undefined;
}

declare const ZRangeRequest: {
    $type: "devvit.plugin.redis.ZRangeRequest";
    encode(message: ZRangeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZRangeRequest;
    fromJSON(object: any): ZRangeRequest;
    toJSON(message: ZRangeRequest): unknown;
    create(base?: DeepPartial_86<ZRangeRequest>): ZRangeRequest;
    fromPartial(object: DeepPartial_86<ZRangeRequest>): ZRangeRequest;
};

declare interface ZRankRequest {
    key?: KeyRequest | undefined;
    member: string;
    scope?: RedisKeyScope | undefined;
}

declare const ZRankRequest: {
    $type: "devvit.plugin.redis.ZRankRequest";
    encode(message: ZRankRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZRankRequest;
    fromJSON(object: any): ZRankRequest;
    toJSON(message: ZRankRequest): unknown;
    create(base?: DeepPartial_86<ZRankRequest>): ZRankRequest;
    fromPartial(object: DeepPartial_86<ZRankRequest>): ZRankRequest;
};

declare interface ZRemRangeByLexRequest {
    key?: KeyRequest | undefined;
    min: string;
    max: string;
    scope?: RedisKeyScope | undefined;
}

declare const ZRemRangeByLexRequest: {
    $type: "devvit.plugin.redis.ZRemRangeByLexRequest";
    encode(message: ZRemRangeByLexRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZRemRangeByLexRequest;
    fromJSON(object: any): ZRemRangeByLexRequest;
    toJSON(message: ZRemRangeByLexRequest): unknown;
    create(base?: DeepPartial_86<ZRemRangeByLexRequest>): ZRemRangeByLexRequest;
    fromPartial(object: DeepPartial_86<ZRemRangeByLexRequest>): ZRemRangeByLexRequest;
};

declare interface ZRemRangeByRankRequest {
    key?: KeyRequest | undefined;
    start: number;
    stop: number;
    scope?: RedisKeyScope | undefined;
}

declare const ZRemRangeByRankRequest: {
    $type: "devvit.plugin.redis.ZRemRangeByRankRequest";
    encode(message: ZRemRangeByRankRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZRemRangeByRankRequest;
    fromJSON(object: any): ZRemRangeByRankRequest;
    toJSON(message: ZRemRangeByRankRequest): unknown;
    create(base?: DeepPartial_86<ZRemRangeByRankRequest>): ZRemRangeByRankRequest;
    fromPartial(object: DeepPartial_86<ZRemRangeByRankRequest>): ZRemRangeByRankRequest;
};

declare interface ZRemRangeByScoreRequest {
    key?: KeyRequest | undefined;
    min: number;
    max: number;
    scope?: RedisKeyScope | undefined;
}

declare const ZRemRangeByScoreRequest: {
    $type: "devvit.plugin.redis.ZRemRangeByScoreRequest";
    encode(message: ZRemRangeByScoreRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZRemRangeByScoreRequest;
    fromJSON(object: any): ZRemRangeByScoreRequest;
    toJSON(message: ZRemRangeByScoreRequest): unknown;
    create(base?: DeepPartial_86<ZRemRangeByScoreRequest>): ZRemRangeByScoreRequest;
    fromPartial(object: DeepPartial_86<ZRemRangeByScoreRequest>): ZRemRangeByScoreRequest;
};

declare interface ZRemRequest {
    key?: KeyRequest | undefined;
    members: string[];
    scope?: RedisKeyScope | undefined;
}

declare const ZRemRequest: {
    $type: "devvit.plugin.redis.ZRemRequest";
    encode(message: ZRemRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZRemRequest;
    fromJSON(object: any): ZRemRequest;
    toJSON(message: ZRemRequest): unknown;
    create(base?: DeepPartial_86<ZRemRequest>): ZRemRequest;
    fromPartial(object: DeepPartial_86<ZRemRequest>): ZRemRequest;
};

declare interface ZScanRequest {
    key: string;
    cursor: number;
    pattern?: string | undefined;
    count?: number | undefined;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
}

declare const ZScanRequest: {
    $type: "devvit.plugin.redis.ZScanRequest";
    encode(message: ZScanRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZScanRequest;
    fromJSON(object: any): ZScanRequest;
    toJSON(message: ZScanRequest): unknown;
    create(base?: DeepPartial_86<ZScanRequest>): ZScanRequest;
    fromPartial(object: DeepPartial_86<ZScanRequest>): ZScanRequest;
};

declare interface ZScanResponse {
    cursor: number;
    members: ZMember_2[];
}

declare const ZScanResponse: {
    $type: "devvit.plugin.redis.ZScanResponse";
    encode(message: ZScanResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZScanResponse;
    fromJSON(object: any): ZScanResponse;
    toJSON(message: ZScanResponse): unknown;
    create(base?: DeepPartial_86<ZScanResponse>): ZScanResponse;
    fromPartial(object: DeepPartial_86<ZScanResponse>): ZScanResponse;
};

declare interface ZScoreRequest {
    key?: KeyRequest | undefined;
    member: string;
    scope?: RedisKeyScope | undefined;
}

declare const ZScoreRequest: {
    $type: "devvit.plugin.redis.ZScoreRequest";
    encode(message: ZScoreRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZScoreRequest;
    fromJSON(object: any): ZScoreRequest;
    toJSON(message: ZScoreRequest): unknown;
    create(base?: DeepPartial_86<ZScoreRequest>): ZScoreRequest;
    fromPartial(object: DeepPartial_86<ZScoreRequest>): ZScoreRequest;
};

export { }
declare global {
  namespace JSX {
    interface IntrinsicElements extends Devvit.Blocks.IntrinsicElements {}

    type Fragment = Iterable<JSX.Element>;
    type SyncElement = BlockElement | JSX.Fragment | string | number | boolean | null;
    type Element = SyncElement | Promise<SyncElement>;
    type ElementChildrenAttribute = { children: {} };
    type Children = JSX.Element | JSX.Element[];
    type Props<T extends {} = {}> = T & { children?: Devvit.ElementChildren };

    type ComponentFunction = (props: JSX.Props, context: Devvit.Context) => JSX.Element;
  }
}
