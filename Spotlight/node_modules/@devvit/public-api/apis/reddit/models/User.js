var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _User_id, _User_username, _User_createdAt, _User_linkKarma, _User_commentKarma, _User_nsfw, _User_isAdmin, _User_modPermissionsBySubreddit, _User_url, _User_permalink, _User_metadata;
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { asT2ID, isT2ID } from '@devvit/shared-types/tid.js';
import { Devvit } from '../../../devvit/Devvit.js';
import { GraphQL } from '../graphql/GraphQL.js';
import { makeGettersEnumerable } from '../helpers/makeGettersEnumerable.js';
import { formatModeratorPermissions, validModPermissions } from '../helpers/permissions.js';
import { Comment } from './Comment.js';
import { Flair, convertUserFlairProtoToAPI } from './Flair.js';
import { Listing } from './Listing.js';
import { Post } from './Post.js';
/**
 * A class representing a user.
 */
export class User {
    /**
     * @internal
     */
    constructor(data, metadata) {
        _User_id.set(this, void 0);
        _User_username.set(this, void 0);
        _User_createdAt.set(this, void 0);
        _User_linkKarma.set(this, void 0);
        _User_commentKarma.set(this, void 0);
        _User_nsfw.set(this, void 0);
        _User_isAdmin.set(this, void 0);
        _User_modPermissionsBySubreddit.set(this, new Map());
        // R2 bug: user.url is a permalink path
        _User_url.set(this, void 0);
        // R2 bug: user object does not contain a permalink field
        _User_permalink.set(this, void 0);
        _User_metadata.set(this, void 0);
        makeGettersEnumerable(this);
        assertNonNull(data.id, 'User ID is missing or undefined');
        assertNonNull(data.name, 'Username is missing or undefined');
        assertNonNull(data.createdUtc, 'User is missing created date');
        // UserDataByAccountIds returns the ID without the t2_ prefix
        __classPrivateFieldSet(this, _User_id, asT2ID(isT2ID(data.id) ? data.id : `t2_${data.id}`), "f");
        __classPrivateFieldSet(this, _User_username, data.name, "f");
        __classPrivateFieldSet(this, _User_nsfw, data.over18 ?? false, "f");
        __classPrivateFieldSet(this, _User_isAdmin, data.isEmployee ?? false, "f");
        const createdAt = new Date(0);
        createdAt.setUTCSeconds(data.createdUtc);
        __classPrivateFieldSet(this, _User_createdAt, createdAt, "f");
        __classPrivateFieldSet(this, _User_linkKarma, data.linkKarma ?? 0, "f");
        __classPrivateFieldSet(this, _User_commentKarma, data.commentKarma ?? 0, "f");
        if (data.modPermissions) {
            for (const [subredditName, permissions] of Object.entries(data.modPermissions)) {
                __classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f").set(subredditName, validModPermissions(permissions));
            }
        }
        __classPrivateFieldSet(this, _User_url, new URL(data.subreddit?.url ?? '', 'https://www.reddit.com').toString(), "f");
        __classPrivateFieldSet(this, _User_permalink, data.subreddit?.url ?? '', "f");
        __classPrivateFieldSet(this, _User_metadata, metadata, "f");
    }
    /**
     * The ID (starting with t2_) of the user to retrieve.
     * @example 't2_1w72'
     */
    get id() {
        return __classPrivateFieldGet(this, _User_id, "f");
    }
    /**
     * The username of the user omitting the u/.
     * @example 'spez'
     */
    get username() {
        return __classPrivateFieldGet(this, _User_username, "f");
    }
    /**
     * The date the user was created.
     */
    get createdAt() {
        return __classPrivateFieldGet(this, _User_createdAt, "f");
    }
    /**
     * The amount of link karma the user has.
     */
    get linkKarma() {
        return __classPrivateFieldGet(this, _User_linkKarma, "f");
    }
    /**
     * The amount of comment karma the user has.
     */
    get commentKarma() {
        return __classPrivateFieldGet(this, _User_commentKarma, "f");
    }
    /**
     * Whether the user's profile is marked as NSFW (Not Safe For Work).
     */
    get nsfw() {
        return __classPrivateFieldGet(this, _User_nsfw, "f");
    }
    /**
     * Whether the user is admin.
     */
    get isAdmin() {
        return __classPrivateFieldGet(this, _User_isAdmin, "f");
    }
    /**
     * The permissions the user has on the subreddit.
     */
    get modPermissions() {
        return __classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f");
    }
    /**
     * Returns the HTTP URL for the user
     */
    get url() {
        return __classPrivateFieldGet(this, _User_url, "f");
    }
    /**
     * Returns a permalink path relative to https://www.reddit.com
     */
    get permalink() {
        return __classPrivateFieldGet(this, _User_permalink, "f");
    }
    toJSON() {
        return {
            id: this.id,
            username: this.username,
            createdAt: this.createdAt,
            linkKarma: this.linkKarma,
            commentKarma: this.commentKarma,
            nsfw: this.nsfw,
            modPermissionsBySubreddit: Object.fromEntries(this.modPermissions),
        };
    }
    /**
     * Get the mod permissions the user has on the subreddit if they are a moderator.
     *
     * @param subredditName - name of the subreddit
     * @returns the moderator permissions the user has on the subreddit
     */
    async getModPermissionsForSubreddit(subredditName) {
        if (__classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f").has(subredditName)) {
            return __classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f").get(subredditName);
        }
        const mods = await User.getSubredditUsersByType({
            subredditName,
            type: 'moderators',
            username: this.username,
        }, __classPrivateFieldGet(this, _User_metadata, "f")).all();
        if (mods.length === 0) {
            return [];
        }
        const permissions = mods[0].modPermissions.get(subredditName) ?? [];
        if (permissions.length > 0) {
            __classPrivateFieldGet(this, _User_modPermissionsBySubreddit, "f").set(subredditName, permissions);
        }
        return permissions;
    }
    /**
     * Get the user's comments.
     *
     * @param options - Options for the request
     * @param options.sort - The sort order of the comments. e.g. 'new'
     * @param options.timeframe - The timeframe of the comments. e.g. 'all'
     * @param options.limit - The maximum number of comments to return. e.g. 1000
     * @param options.pageSize - The number of comments to return per request. e.g. 100
     * @returns A Listing of Comment objects.
     */
    getComments(options) {
        return Comment.getCommentsByUser({
            username: this.username,
            ...options,
        }, __classPrivateFieldGet(this, _User_metadata, "f"));
    }
    /**
     * Get the user's posts.
     *
     * @param options - Options for the request
     * @param options.sort - The sort order of the posts. e.g. 'new'
     * @param options.timeframe - The timeframe of the posts. e.g. 'all'
     * @param options.limit - The maximum number of posts to return. e.g. 1000
     * @param options.pageSize - The number of posts to return per request. e.g. 100
     * @returns A Listing of Post objects.
     */
    getPosts(options) {
        return Post.getPostsByUser({
            username: this.username,
            ...options,
        }, __classPrivateFieldGet(this, _User_metadata, "f"));
    }
    /**
     * Retrieve the user's flair for the subreddit.
     *
     * @param subreddit - The name of the subreddit associated with the user's flair.
     *
     * @example
     * ```ts
     * const username = "badapple"
     * const subredditName = "mysubreddit"
     * const user = await reddit.getUserByUsername(username);
     * const userFlair = await user.getUserFlairBySubreddit(subredditName);
     * ```
     */
    async getUserFlairBySubreddit(subreddit) {
        const userFlairs = await Flair.getUserFlairBySubreddit({
            subreddit,
            name: __classPrivateFieldGet(this, _User_username, "f"),
        }, __classPrivateFieldGet(this, _User_metadata, "f"));
        return userFlairs.users[0] ? convertUserFlairProtoToAPI(userFlairs.users[0]) : undefined;
    }
    getSnoovatarUrl() {
        return User.getSnoovatarUrl(this.username, __classPrivateFieldGet(this, _User_metadata, "f"));
    }
    /** @internal */
    static async getById(id, metadata) {
        const client = Devvit.redditAPIPlugins.Users;
        const response = await client.UserDataByAccountIds({ ids: id }, metadata);
        const username = response?.users?.[id]?.name;
        assertNonNull(username, 'Expected the username in response to be not null');
        return User.getByUsername(username, metadata);
    }
    /** @internal */
    static async getByUsername(username, metadata) {
        const client = Devvit.redditAPIPlugins.Users;
        const response = await client.UserAbout({
            username,
        }, metadata);
        if (!response.data?.id) {
            throw new Error('failed to get user');
        }
        return new User(response.data, metadata);
    }
    /** @internal */
    static async getFromMetadata(key, metadata) {
        assertNonNull(metadata);
        const userId = metadata?.[key]?.values[0];
        return userId ? User.getById(asT2ID(userId), metadata) : Promise.resolve(undefined);
    }
    /** @internal */
    static getSubredditUsersByType(options, metadata) {
        const client = Devvit.redditAPIPlugins.Subreddits;
        return new Listing({
            hasMore: true,
            pageSize: options.pageSize,
            limit: options.limit,
            after: options.after,
            before: options.before,
            fetch: async (fetchOptions) => {
                const response = await client.AboutWhere({
                    where: options.type,
                    user: options.username,
                    subreddit: options.subredditName,
                    show: 'all',
                    ...fetchOptions,
                }, metadata);
                return listingProtosToUsers(response, options.subredditName, metadata);
            },
        });
    }
    /** @internal */
    static async createRelationship(options, metadata) {
        const client = Devvit.redditAPIPlugins.Users;
        const { type, subredditName, username, permissions, ...optionalFields } = options;
        const response = await client.Friend({
            type,
            subreddit: subredditName,
            name: username,
            permissions: permissions ? formatModeratorPermissions(permissions) : undefined,
            ...optionalFields,
        }, metadata);
        if (response.json?.errors?.length) {
            throw new Error(response.json.errors.join('\n'));
        }
    }
    /** @internal */
    static async removeRelationship(options, metadata) {
        const client = Devvit.redditAPIPlugins.Users;
        await client.Unfriend({
            type: options.type,
            subreddit: options.subredditName,
            name: options.username,
        }, metadata);
    }
    /** @internal */
    static async setModeratorPermissions(username, subredditName, permissions, metadata) {
        const client = Devvit.redditAPIPlugins.Users;
        const response = await client.SetPermissions({
            subreddit: subredditName,
            name: username,
            type: 'moderator',
            permissions: formatModeratorPermissions(permissions),
        }, metadata);
        if (response.json?.errors?.length) {
            throw new Error(response.json.errors.join('\n'));
        }
    }
    /** @internal */
    static async getSnoovatarUrl(username, metadata) {
        const operationName = 'GetSnoovatarUrlByName';
        const persistedQueryHash = 'c47fd42345af268616d2d8904b56856acdc05cf61d3650380f539ad7d596ac0c';
        const response = await GraphQL.query(operationName, persistedQueryHash, { username }, metadata);
        return response.data?.redditorInfoByName?.snoovatarIcon?.url;
    }
    /** @internal */
    static getOverview(options, metadata) {
        const client = Devvit.redditAPIPlugins.Users;
        return new Listing({
            hasMore: true,
            before: options.before,
            after: options.after,
            pageSize: options.pageSize,
            limit: options.limit,
            async fetch(fetchOptions) {
                const response = await client.UserWhere({
                    username: options.username,
                    where: 'overview',
                    ...fetchOptions,
                }, metadata);
                return listingProtosToPostsOrComments(response, metadata);
            },
        });
    }
}
_User_id = new WeakMap(), _User_username = new WeakMap(), _User_createdAt = new WeakMap(), _User_linkKarma = new WeakMap(), _User_commentKarma = new WeakMap(), _User_nsfw = new WeakMap(), _User_isAdmin = new WeakMap(), _User_modPermissionsBySubreddit = new WeakMap(), _User_url = new WeakMap(), _User_permalink = new WeakMap(), _User_metadata = new WeakMap();
function listingProtosToPostsOrComments(listingProto, metadata) {
    if (!listingProto.data?.children) {
        throw new Error('Listing response is missing children');
    }
    const children = listingProto.data.children.map((child) => {
        if (child.kind === 't3') {
            return new Post(child.data, metadata);
        }
        else if (child.kind === 't1') {
            return new Comment(child.data, metadata);
        }
        throw new Error(`Type ${child.kind} is not supported`);
    });
    return {
        children: children,
        before: listingProto.data.before,
        after: listingProto.data.after,
    };
}
async function listingProtosToUsers(listingProto, subredditName, metadata) {
    const client = Devvit.redditAPIPlugins.Users;
    if (!listingProto.data?.children) {
        throw new Error('Listing response is missing children');
    }
    const userIds = listingProto.data.children.map((child) => {
        assertNonNull(child.data?.id, 'User id is still from listing data');
        return child.data.id;
    });
    // break the ids into chunks since they're passed over a query parameter
    const chunkSize = 100;
    const userIdChunks = [];
    for (let i = 0; i < userIds.length; i += chunkSize) {
        userIdChunks.push(userIds.slice(i, i + chunkSize));
    }
    // perform the requests
    const usersMapResponses = await Promise.all(userIdChunks.map((userIds) => client.UserDataByAccountIds({
        ids: userIds.join(','),
    }, metadata)));
    // join the responses back into a single map of user data
    const userDataById = usersMapResponses.reduce((allUsers, response) => ({ ...allUsers, ...response.users }), {});
    const children = listingProto.data.children.map((child) => {
        const id = child.data?.id;
        assertNonNull(id, 'User id is missing from listing');
        const userData = userDataById[id];
        // Casting to unknown because Typescript assumes that userData is always defined
        // because of how we defined the UserDataByAccountIdsResponse_UserAccountData protobuf.
        assertNonNull(userData, 'User data is missing from response');
        return new User({
            id,
            name: userData.name,
            linkKarma: userData.linkKarma,
            commentKarma: userData.commentKarma,
            createdUtc: userData.createdUtc,
            over18: userData.profileOver18,
            snoovatarSize: [],
            modPermissions: {
                [subredditName]: child.data?.modPermissions ?? [],
            },
        }, metadata);
    });
    return {
        children,
        before: listingProto.data.before,
        after: listingProto.data.after,
    };
}
