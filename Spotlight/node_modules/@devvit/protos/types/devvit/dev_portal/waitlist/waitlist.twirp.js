import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { Empty } from '../../../google/protobuf/empty.js';
import { IsCurrentUserRegisteredResponse, WaitlistRegisterUserRequest, WaitlistRegisterUserResponse, GetCurrentUserStatusResponse, } from './waitlist.js';
export var WaitlistMethod;
(function (WaitlistMethod) {
    WaitlistMethod["IsCurrentUserRegistered"] = "IsCurrentUserRegistered";
    WaitlistMethod["RegisterUser"] = "RegisterUser";
    WaitlistMethod["GetCurrentUserStatus"] = "GetCurrentUserStatus";
    WaitlistMethod["AcceptTermsAndConditions"] = "AcceptTermsAndConditions";
    WaitlistMethod["EnsureDeveloperAccountExists"] = "EnsureDeveloperAccountExists";
})(WaitlistMethod || (WaitlistMethod = {}));
export const WaitlistMethodList = [
    WaitlistMethod.IsCurrentUserRegistered,
    WaitlistMethod.RegisterUser,
    WaitlistMethod.GetCurrentUserStatus,
    WaitlistMethod.AcceptTermsAndConditions,
    WaitlistMethod.EnsureDeveloperAccountExists,
];
export function createWaitlistServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal.waitlist',
        serviceName: 'Waitlist',
        methodList: WaitlistMethodList,
        matchRoute: matchWaitlistRoute,
    });
}
function matchWaitlistRoute(method, events) {
    switch (method) {
        case 'IsCurrentUserRegistered':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'IsCurrentUserRegistered' };
                await events.onMatch(ctx);
                return handleWaitlistIsCurrentUserRegisteredRequest(ctx, service, data, interceptors);
            };
        case 'RegisterUser':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'RegisterUser' };
                await events.onMatch(ctx);
                return handleWaitlistRegisterUserRequest(ctx, service, data, interceptors);
            };
        case 'GetCurrentUserStatus':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetCurrentUserStatus' };
                await events.onMatch(ctx);
                return handleWaitlistGetCurrentUserStatusRequest(ctx, service, data, interceptors);
            };
        case 'AcceptTermsAndConditions':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AcceptTermsAndConditions' };
                await events.onMatch(ctx);
                return handleWaitlistAcceptTermsAndConditionsRequest(ctx, service, data, interceptors);
            };
        case 'EnsureDeveloperAccountExists':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'EnsureDeveloperAccountExists' };
                await events.onMatch(ctx);
                return handleWaitlistEnsureDeveloperAccountExistsRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWaitlistIsCurrentUserRegisteredRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWaitlistIsCurrentUserRegisteredJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWaitlistIsCurrentUserRegisteredProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWaitlistRegisterUserRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWaitlistRegisterUserJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWaitlistRegisterUserProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWaitlistGetCurrentUserStatusRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWaitlistGetCurrentUserStatusJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWaitlistGetCurrentUserStatusProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWaitlistAcceptTermsAndConditionsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWaitlistAcceptTermsAndConditionsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWaitlistAcceptTermsAndConditionsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWaitlistEnsureDeveloperAccountExistsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWaitlistEnsureDeveloperAccountExistsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWaitlistEnsureDeveloperAccountExistsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleWaitlistIsCurrentUserRegisteredJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.IsCurrentUserRegistered(ctx, inputReq);
        });
    }
    else {
        response = await service.IsCurrentUserRegistered(ctx, request);
    }
    return JSON.stringify(IsCurrentUserRegisteredResponse.toJSON(response));
}
async function handleWaitlistRegisterUserJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = WaitlistRegisterUserRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RegisterUser(ctx, inputReq);
        });
    }
    else {
        response = await service.RegisterUser(ctx, request);
    }
    return JSON.stringify(WaitlistRegisterUserResponse.toJSON(response));
}
async function handleWaitlistGetCurrentUserStatusJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetCurrentUserStatus(ctx, inputReq);
        });
    }
    else {
        response = await service.GetCurrentUserStatus(ctx, request);
    }
    return JSON.stringify(GetCurrentUserStatusResponse.toJSON(response));
}
async function handleWaitlistAcceptTermsAndConditionsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AcceptTermsAndConditions(ctx, inputReq);
        });
    }
    else {
        response = await service.AcceptTermsAndConditions(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleWaitlistEnsureDeveloperAccountExistsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.EnsureDeveloperAccountExists(ctx, inputReq);
        });
    }
    else {
        response = await service.EnsureDeveloperAccountExists(ctx, request);
    }
    return JSON.stringify(WaitlistRegisterUserResponse.toJSON(response));
}
async function handleWaitlistIsCurrentUserRegisteredProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.IsCurrentUserRegistered(ctx, inputReq);
        });
    }
    else {
        response = await service.IsCurrentUserRegistered(ctx, request);
    }
    return Buffer.from(IsCurrentUserRegisteredResponse.encode(response).finish());
}
async function handleWaitlistRegisterUserProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = WaitlistRegisterUserRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RegisterUser(ctx, inputReq);
        });
    }
    else {
        response = await service.RegisterUser(ctx, request);
    }
    return Buffer.from(WaitlistRegisterUserResponse.encode(response).finish());
}
async function handleWaitlistGetCurrentUserStatusProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetCurrentUserStatus(ctx, inputReq);
        });
    }
    else {
        response = await service.GetCurrentUserStatus(ctx, request);
    }
    return Buffer.from(GetCurrentUserStatusResponse.encode(response).finish());
}
async function handleWaitlistAcceptTermsAndConditionsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AcceptTermsAndConditions(ctx, inputReq);
        });
    }
    else {
        response = await service.AcceptTermsAndConditions(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleWaitlistEnsureDeveloperAccountExistsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.EnsureDeveloperAccountExists(ctx, inputReq);
        });
    }
    else {
        response = await service.EnsureDeveloperAccountExists(ctx, request);
    }
    return Buffer.from(WaitlistRegisterUserResponse.encode(response).finish());
}
