/**
 * #effect.ts
 *
 * @packageDocumentation
 */
import _m0 from 'protobufjs/minimal.js';
import { SetIntervalsEffect } from './interval.js';
import { NavigateToUrlEffect } from './navigate_to_url.js';
import { RealtimeSubscriptionsEffect } from './realtime_subscriptions.js';
import { ReloadPartEffect } from './reload_part.js';
import { RerenderEffect } from './rerender_ui.js';
import { ShowFormEffect } from './show_form.js';
import { ShowToastEffect } from './show_toast.js';
export declare enum EffectType {
    /** EFFECT_REALTIME_SUB - Notify client to synchronize its realtime subscriptions */
    EFFECT_REALTIME_SUB = 0,
    /** EFFECT_RERENDER_UI - Trigger a re-render for apps that have visible UI */
    EFFECT_RERENDER_UI = 1,
    /** EFFECT_RELOAD_PART - Notify the client that parts of a subreddit, post, or comment should be reloaded */
    EFFECT_RELOAD_PART = 2,
    /** EFFECT_SHOW_FORM - Display a user input form */
    EFFECT_SHOW_FORM = 3,
    /** EFFECT_SHOW_TOAST - Display a transient toast message */
    EFFECT_SHOW_TOAST = 4,
    /** EFFECT_NAVIGATE_TO_URL - Notify the client to navigate to a URL */
    EFFECT_NAVIGATE_TO_URL = 5,
    /** EFFECT_SET_INTERVALS - This updates the list of active timers. */
    EFFECT_SET_INTERVALS = 7,
    UNRECOGNIZED = -1
}
export declare function effectTypeFromJSON(object: any): EffectType;
export declare function effectTypeToJSON(object: EffectType): number;
export interface Effect {
    realtimeSubscriptions?: RealtimeSubscriptionsEffect | undefined;
    rerenderUi?: RerenderEffect | undefined;
    reloadPart?: ReloadPartEffect | undefined;
    showForm?: ShowFormEffect | undefined;
    showToast?: ShowToastEffect | undefined;
    navigateToUrl?: NavigateToUrlEffect | undefined;
    interval?: SetIntervalsEffect | undefined;
    /** TODO: remove this field once all clients are updated.  Redundant with effect_type */
    type: EffectType;
}
export declare const Effect: {
    $type: "devvit.ui.effects.v1alpha.Effect";
    encode(message: Effect, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Effect;
    fromJSON(object: any): Effect;
    toJSON(message: Effect): unknown;
    create(base?: DeepPartial<Effect>): Effect;
    fromPartial(object: DeepPartial<Effect>): Effect;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=effect.d.ts.map